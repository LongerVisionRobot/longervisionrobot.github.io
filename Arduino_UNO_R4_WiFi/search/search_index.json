{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Longer Vision Robot's Smart Vehicle Based on Arduino UNO R4 WiFi The full documentation is hosted at https://longervisionrobot.github.io/Arduino_UNO_R4_WiFi .","title":"Home"},{"location":"#welcome-to-longer-vision-robots-smart-vehicle-based-on-arduino-uno-r4-wifi","text":"The full documentation is hosted at https://longervisionrobot.github.io/Arduino_UNO_R4_WiFi .","title":"Welcome to Longer Vision Robot's Smart Vehicle Based on Arduino UNO R4 WiFi"},{"location":"01_introduction/","text":"Chapter 1: Arduino UNO R4 WiFi Section 1.1: Arduino UNO R4 Arduino UNO R4 comes into the market in late May 2023. Arduino UNO R4 has two types of boards: Arduino UNO R4 Minima Arduino UNO R4 WiFi This tutorial will focus on Arduino UNO R4 WiFi . Section 1.2: Arduino UNO R4 WiFi Specs The following spec table is directly cited from official page of Arduino UNO R4 WiFi . As we can see, the most important components of Arduino UNO R4 WiFi are: microcontroller Renesas RA4M1 wifi module ESP32-S3 Note This project is under active development.","title":"Chapter 1 - Intruduction"},{"location":"01_introduction/#chapter-1-arduino-uno-r4-wifi","text":"","title":"Chapter 1: Arduino UNO R4 WiFi"},{"location":"01_introduction/#section-11-arduino-uno-r4","text":"Arduino UNO R4 comes into the market in late May 2023. Arduino UNO R4 has two types of boards: Arduino UNO R4 Minima Arduino UNO R4 WiFi This tutorial will focus on Arduino UNO R4 WiFi .","title":"Section 1.1: Arduino UNO R4"},{"location":"01_introduction/#section-12-arduino-uno-r4-wifi-specs","text":"The following spec table is directly cited from official page of Arduino UNO R4 WiFi . As we can see, the most important components of Arduino UNO R4 WiFi are: microcontroller Renesas RA4M1 wifi module ESP32-S3 Note This project is under active development.","title":"Section 1.2: Arduino UNO R4 WiFi Specs"},{"location":"02_components/","text":"Chapter 2: Components - 2 MCUs Section 2.1: Microcontroller - Renesas RA4M1 Renesas RA4M1 is a 32-bit Arm Cortex-M4 Core of 48 MHz. Its block diagram is directly cited from official page of Renesas RA4M1 as follows. A lot more details can be found in RA4M1 Datasheet . Renesas RA4M1 is the core chip of Arduino UNO R4 WiFi , which corresponds to Arduino UNO R4 WiFi board from inside Arduino IDE . Section 2.2: WiFi Module - ESP32-S3 ESP32-S3 itself is a dual-core XTensa LX7 MCU, capable of running at 240 MHz. Apart from its 512 KB of internal SRAM, it also comes with integrated 2.4 GHz, 802.11 b/g/n Wi-Fi and Bluetooth 5 (LE) connectivity that provides long-range support. It has 45 programmable GPIOs and supports a rich set of peripherals. ESP32-S3 supports larger, high-speed octal SPI flash, and PSRAM with configurable data and instruction cache. (Cited from ESP32-S3 official doc ) A lot more details can be found in ESP32-S3 Datasheet . ESP32-S3 is the wireless communication chip (including both WiFi and Bluetooth 5) of Arduino UNO R4 WiFi , which corresponds to ESP32S3 Dev Module board from inside Arduino IDE , when shorting the download pin and GND . Section 2.3: Let's Do a Comparison I know this thought is a kind of weird, but let's just do a comparison of Renesas RA4M1 and ESP32-S3 . Components Renesas RA4M1 ESP32-S3 Number of Cores 1 2 Running Frequency (MHz) 48 240 SRAM (kB) 16+16 512 Flash (kB) 256+8 0 WiFi No 2.4 GHz 802.11 b/g/n, 40 MHz bandwidth Bluetooth No 5 (LE) Others - -","title":"Chapter 2 - Components"},{"location":"02_components/#chapter-2-components-2-mcus","text":"","title":"Chapter 2: Components - 2 MCUs"},{"location":"02_components/#section-21-microcontroller-renesas-ra4m1","text":"Renesas RA4M1 is a 32-bit Arm Cortex-M4 Core of 48 MHz. Its block diagram is directly cited from official page of Renesas RA4M1 as follows. A lot more details can be found in RA4M1 Datasheet . Renesas RA4M1 is the core chip of Arduino UNO R4 WiFi , which corresponds to Arduino UNO R4 WiFi board from inside Arduino IDE .","title":"Section 2.1: Microcontroller - Renesas RA4M1"},{"location":"02_components/#section-22-wifi-module-esp32-s3","text":"ESP32-S3 itself is a dual-core XTensa LX7 MCU, capable of running at 240 MHz. Apart from its 512 KB of internal SRAM, it also comes with integrated 2.4 GHz, 802.11 b/g/n Wi-Fi and Bluetooth 5 (LE) connectivity that provides long-range support. It has 45 programmable GPIOs and supports a rich set of peripherals. ESP32-S3 supports larger, high-speed octal SPI flash, and PSRAM with configurable data and instruction cache. (Cited from ESP32-S3 official doc ) A lot more details can be found in ESP32-S3 Datasheet . ESP32-S3 is the wireless communication chip (including both WiFi and Bluetooth 5) of Arduino UNO R4 WiFi , which corresponds to ESP32S3 Dev Module board from inside Arduino IDE , when shorting the download pin and GND .","title":"Section 2.2: WiFi Module - ESP32-S3"},{"location":"02_components/#section-23-lets-do-a-comparison","text":"I know this thought is a kind of weird, but let's just do a comparison of Renesas RA4M1 and ESP32-S3 . Components Renesas RA4M1 ESP32-S3 Number of Cores 1 2 Running Frequency (MHz) 48 240 SRAM (kB) 16+16 512 Flash (kB) 256+8 0 WiFi No 2.4 GHz 802.11 b/g/n, 40 MHz bandwidth Bluetooth No 5 (LE) Others - -","title":"Section 2.3: Let's Do a Comparison"},{"location":"03_arduinoide_fritzing_kicad/","text":"Chapter 3: Arduino IDE , Fritzing and KiCad Section 3.1: Arduino UNO R4 WiFi Without shorting the download pin and GND on Arduino UNO R4 WiFi , Subsection 3.1.1 lsusb lsusb will detect Arduino UNO R4 WiFi as: \u279c lsusb ...... Bus 011 Device 043: ID 2341:1002 Arduino SA UNO WiFi R4 CMSIS-DAP ...... Subsection 3.1.2 Arduino IDE From within Arduino IDE , Arduino UNO R4 WiFi is now detected as Arduino UNO R4 WiFi . In addition, please have the following 2 boards packages installed. Arduino AVR Boards Arduino UNO R4 Boards Section 3.2: ESP32S3 Dev Module By shorting the download pin and GND on Arduino UNO R4 WiFi as (Cited from official Arduino tutorial UNO R4 WiFi Custom Firmware Upload to ESP32 (Advanced) ): Subsection 3.2.1 lsusb lsusb will detect Arduino UNO R4 WiFi as: \u279c lsusb ...... Bus 011 Device 044: ID 303a:1001 Espressif USB JTAG/serial debug unit ...... Subsection 3.2.2 Arduino IDE From within Arduino IDE , Arduino UNO R4 WiFi is now detected as ESP32S3 Dev Module . In addition, please have the following 2 boards packages installed. Arduino ESP32 Boards esp32 Section 3.3: Fritzing vs. KiCad As of today, December 22, 2023, Section 3.3.1: Fritzing has NO official support for Arduino UNO R4 , but a community support in its forum issue 20145 . The following picture from within Fritzing IDE demonstrates its feasibility. Section 3.3.2: KiCad A third-party open source arduino-kicad-library provides a decent support for Arduino UNO R4 as KiCad 's plugin. Note For this open source book Arduino UNO R4 WiFi , we are going to use Fritzing for circuit s and KiCad for schematic s.","title":"Chapter 3 - Arduino IDE, Fritzing and KiCad"},{"location":"03_arduinoide_fritzing_kicad/#chapter-3-arduino-ide-fritzing-and-kicad","text":"","title":"Chapter 3: Arduino IDE, Fritzing and KiCad"},{"location":"03_arduinoide_fritzing_kicad/#section-31-arduino-uno-r4-wifi","text":"Without shorting the download pin and GND on Arduino UNO R4 WiFi ,","title":"Section 3.1: Arduino UNO R4 WiFi"},{"location":"03_arduinoide_fritzing_kicad/#subsection-311-lsusb","text":"lsusb will detect Arduino UNO R4 WiFi as: \u279c lsusb ...... Bus 011 Device 043: ID 2341:1002 Arduino SA UNO WiFi R4 CMSIS-DAP ......","title":"Subsection 3.1.1 lsusb"},{"location":"03_arduinoide_fritzing_kicad/#subsection-312-arduino-ide","text":"From within Arduino IDE , Arduino UNO R4 WiFi is now detected as Arduino UNO R4 WiFi . In addition, please have the following 2 boards packages installed. Arduino AVR Boards Arduino UNO R4 Boards","title":"Subsection 3.1.2 Arduino IDE"},{"location":"03_arduinoide_fritzing_kicad/#section-32-esp32s3-dev-module","text":"By shorting the download pin and GND on Arduino UNO R4 WiFi as (Cited from official Arduino tutorial UNO R4 WiFi Custom Firmware Upload to ESP32 (Advanced) ):","title":"Section 3.2: ESP32S3 Dev Module"},{"location":"03_arduinoide_fritzing_kicad/#subsection-321-lsusb","text":"lsusb will detect Arduino UNO R4 WiFi as: \u279c lsusb ...... Bus 011 Device 044: ID 303a:1001 Espressif USB JTAG/serial debug unit ......","title":"Subsection 3.2.1 lsusb"},{"location":"03_arduinoide_fritzing_kicad/#subsection-322-arduino-ide","text":"From within Arduino IDE , Arduino UNO R4 WiFi is now detected as ESP32S3 Dev Module . In addition, please have the following 2 boards packages installed. Arduino ESP32 Boards esp32","title":"Subsection 3.2.2 Arduino IDE"},{"location":"03_arduinoide_fritzing_kicad/#section-33-fritzing-vs-kicad","text":"As of today, December 22, 2023,","title":"Section 3.3: Fritzing vs. KiCad"},{"location":"03_arduinoide_fritzing_kicad/#section-331-fritzing","text":"has NO official support for Arduino UNO R4 , but a community support in its forum issue 20145 . The following picture from within Fritzing IDE demonstrates its feasibility.","title":"Section 3.3.1: Fritzing"},{"location":"03_arduinoide_fritzing_kicad/#section-332-kicad","text":"A third-party open source arduino-kicad-library provides a decent support for Arduino UNO R4 as KiCad 's plugin. Note For this open source book Arduino UNO R4 WiFi , we are going to use Fritzing for circuit s and KiCad for schematic s.","title":"Section 3.3.2: KiCad"},{"location":"04_builtin_examples/","text":"Chapter 4: Arduino Build-in Examples Note In this chapter, all snippets of sketch codes are from the official Arduino Examples . Section 4.1: 01.Basics Examples 4.1.1 AnalogReadSerial Sketch Code /* AnalogReadSerial Reads an analog input on pin 0, prints the result to the Serial Monitor. Graphical representation is available using Serial Plotter (Tools > Serial Plotter menu). Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogReadSerial */ // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); } // the loop routine runs over and over again forever: void loop() { // read the input on analog pin 0: int sensorValue = analogRead(A0); // print out the value you read: Serial.println(sensorValue); delay(1); // delay in between reads for stability } Fritzing Circuit KiCad Schematic Video Demonstration 4.1.2 BareMinimum Sketch Code void setup() { // put your setup code here, to run once: } void loop() { // put your main code here, to run repeatedly: } This sketch simply shows the standard template when coding for any Arduino boards. As you can see, there are typically only 2 functions : setup(): for initialization loop(): normally, a forever loop that runs infinitely From this bare minimum template, we can easily tell Arduino is a Microcontroller with a single thread , and of course for a single user . Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration N/A 4.1.3 Blink Sketch Code /* Blink Turns an LED on for one second, then off for one second, repeatedly. Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products modified 8 May 2014 by Scott Fitzgerald modified 2 Sep 2016 by Arturo Guadalupi modified 8 Sep 2016 by Colby Newman This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Blink */ // the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.1.4 DigitalReadSerial Sketch Code /* DigitalReadSerial Reads a digital input on pin 2, prints the result to the Serial Monitor This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/DigitalReadSerial */ // digital pin 2 has a pushbutton attached to it. Give it a name: int pushButton = 2; // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); // make the pushbutton's pin an input: pinMode(pushButton, INPUT); } // the loop routine runs over and over again forever: void loop() { // read the input pin: int buttonState = digitalRead(pushButton); // print out the state of the button: Serial.println(buttonState); delay(1); // delay in between reads for stability } Fritzing Circuit KiCad Schematic Video Demonstration 4.1.5 Fade Sketch Code /* Fade This example shows how to fade an LED on pin 9 using the analogWrite() function. The analogWrite() function uses PWM, so if you want to change the pin you're using, be sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with a \"~\" sign, like ~3, ~5, ~6, ~9, ~10 and ~11. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Fade */ int led = 9; // the PWM pin the LED is attached to int brightness = 0; // how bright the LED is int fadeAmount = 5; // how many points to fade the LED by // the setup routine runs once when you press reset: void setup() { // declare pin 9 to be an output: pinMode(led, OUTPUT); } // the loop routine runs over and over again forever: void loop() { // set the brightness of pin 9: analogWrite(led, brightness); // change the brightness for next time through the loop: brightness = brightness + fadeAmount; // reverse the direction of the fading at the ends of the fade: if (brightness <= 0 || brightness >= 255) { fadeAmount = -fadeAmount; } // wait for 30 milliseconds to see the dimming effect delay(30); } Fritzing Circuit KiCad Schematic Video Demonstration 4.1.6 ReadAnalogVoltage Sketch Code /* ReadAnalogVoltage Reads an analog input on pin 0, converts it to voltage, and prints the result to the Serial Monitor. Graphical representation is available using Serial Plotter (Tools > Serial Plotter menu). Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ReadAnalogVoltage */ // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); } // the loop routine runs over and over again forever: void loop() { // read the input on analog pin 0: int sensorValue = analogRead(A0); // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V): float voltage = sensorValue * (5.0 / 1023.0); // print out the value you read: Serial.println(voltage); } Fritzing Circuit Same as Example AnalogReadSerial KiCad Schematic Same as Example AnalogReadSerial Video Demonstration Section 4.2: 02.Digital Examples 4.2.1 BlinkWithoutDelay Sketch Code /* Blink without Delay Turns on and off a light emitting diode (LED) connected to a digital pin, without using the delay() function. This means that other code can run at the same time without being interrupted by the LED code. The circuit: - Use the onboard LED. - Note: Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products created 2005 by David A. Mellis modified 8 Feb 2010 by Paul Stoffregen modified 11 Nov 2013 by Scott Fitzgerald modified 9 Jan 2017 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/BlinkWithoutDelay */ // constants won't change. Used here to set a pin number: const int ledPin = LED_BUILTIN; // the number of the LED pin // Variables will change: int ledState = LOW; // ledState used to set the LED // Generally, you should use \"unsigned long\" for variables that hold time // The value will quickly become too large for an int to store unsigned long previousMillis = 0; // will store last time LED was updated // constants won't change: const long interval = 1000; // interval at which to blink (milliseconds) void setup() { // set the digital pin as output: pinMode(ledPin, OUTPUT); } void loop() { // here is where you'd put code that needs to be running all the time. // check to see if it's time to blink the LED; that is, if the difference // between the current time and last time you blinked the LED is bigger than // the interval at which you want to blink the LED. unsigned long currentMillis = millis(); if (currentMillis - previousMillis >= interval) { // save the last time you blinked the LED previousMillis = currentMillis; // if the LED is off turn it on and vice-versa: if (ledState == LOW) { ledState = HIGH; } else { ledState = LOW; } // set the LED with the ledState of the variable: digitalWrite(ledPin, ledState); } } Fritzing Circuit KiCad Schematic Video Demonstration 4.2.2 Button Sketch Code /* Button Turns on and off a light emitting diode(LED) connected to digital pin 13, when pressing a pushbutton attached to pin 2. The circuit: - LED attached from pin 13 to ground through 220 ohm resistor - pushbutton attached to pin 2 from +5V - 10K resistor attached to pin 2 from ground - Note: on most Arduinos there is already an LED on the board attached to pin 13. created 2005 by DojoDave <http://www.0j0.org> modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Button */ // constants won't change. They're used here to set pin numbers: const int buttonPin = 2; // the number of the pushbutton pin const int ledPin = 13; // the number of the LED pin // variables will change: int buttonState = 0; // variable for reading the pushbutton status void setup() { // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); // initialize the pushbutton pin as an input: pinMode(buttonPin, INPUT); } void loop() { // read the state of the pushbutton value: buttonState = digitalRead(buttonPin); // check if the pushbutton is pressed. If it is, the buttonState is HIGH: if (buttonState == HIGH) { // turn LED on: digitalWrite(ledPin, HIGH); } else { // turn LED off: digitalWrite(ledPin, LOW); } } Fritzing Circuit Same as Example DigitalReadSerial KiCad Schematic Roughly the same as Example DigitalReadSerial Video Demonstration Same as Example DigitalReadSerial 4.2.3 Debounce Sketch Code /* Debounce Each time the input pin goes from LOW to HIGH (e.g. because of a push-button press), the output pin is toggled from LOW to HIGH or HIGH to LOW. There's a minimum delay between toggles to debounce the circuit (i.e. to ignore noise). The circuit: - LED attached from pin 13 to ground through 220 ohm resistor - pushbutton attached from pin 2 to +5V - 10 kilohm resistor attached from pin 2 to ground - Note: On most Arduino boards, there is already an LED on the board connected to pin 13, so you don't need any extra components for this example. created 21 Nov 2006 by David A. Mellis modified 30 Aug 2011 by Limor Fried modified 28 Dec 2012 by Mike Walters modified 30 Aug 2016 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Debounce */ // constants won't change. They're used here to set pin numbers: const int buttonPin = 2; // the number of the pushbutton pin const int ledPin = 13; // the number of the LED pin // Variables will change: int ledState = HIGH; // the current state of the output pin int buttonState; // the current reading from the input pin int lastButtonState = LOW; // the previous reading from the input pin // the following variables are unsigned longs because the time, measured in // milliseconds, will quickly become a bigger number than can be stored in an int. unsigned long lastDebounceTime = 0; // the last time the output pin was toggled unsigned long debounceDelay = 50; // the debounce time; increase if the output flickers void setup() { pinMode(buttonPin, INPUT); pinMode(ledPin, OUTPUT); // set initial LED state digitalWrite(ledPin, ledState); } void loop() { // read the state of the switch into a local variable: int reading = digitalRead(buttonPin); // check to see if you just pressed the button // (i.e. the input went from LOW to HIGH), and you've waited long enough // since the last press to ignore any noise: // If the switch changed, due to noise or pressing: if (reading != lastButtonState) { // reset the debouncing timer lastDebounceTime = millis(); } if ((millis() - lastDebounceTime) > debounceDelay) { // whatever the reading is at, it's been there for longer than the debounce // delay, so take it as the actual current state: // if the button state has changed: if (reading != buttonState) { buttonState = reading; // only toggle the LED if the new button state is HIGH if (buttonState == HIGH) { ledState = !ledState; } } } // set the LED: digitalWrite(ledPin, ledState); // save the reading. Next time through the loop, it'll be the lastButtonState: lastButtonState = reading; } Fritzing Circuit Same as Example DigitalReadSerial KiCad Schematic Same as Example DigitalReadSerial Video Demonstration 4.2.4 DigitalInputPullup Sketch Code /* Input Pull-up Serial This example demonstrates the use of pinMode(INPUT_PULLUP). It reads a digital input on pin 2 and prints the results to the Serial Monitor. The circuit: - momentary switch attached from pin 2 to ground - built-in LED on pin 13 Unlike pinMode(INPUT), there is no pull-down resistor necessary. An internal 20K-ohm resistor is pulled to 5V. This configuration causes the input to read HIGH when the switch is open, and LOW when it is closed. created 14 Mar 2012 by Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/InputPullupSerial */ void setup() { //start serial connection Serial.begin(9600); //configure pin 2 as an input and enable the internal pull-up resistor pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); } void loop() { //read the pushbutton value into a variable int sensorVal = digitalRead(2); //print out the value of the pushbutton Serial.println(sensorVal); // Keep in mind the pull-up means the pushbutton's logic is inverted. It goes // HIGH when it's open, and LOW when it's pressed. Turn on pin 13 when the // button's pressed, and off when it's not: if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } } Fritzing Circuit KiCad Schematic Video Demonstration 4.2.5 StateChangeDetection Sketch Code /* State change detection (edge detection) Often, you don't need to know the state of a digital input all the time, but you just need to know when the input changes from one state to another. For example, you want to know when a button goes from OFF to ON. This is called state change detection, or edge detection. This example shows how to detect when a button or button changes from off to on and on to off. The circuit: - pushbutton attached to pin 2 from +5V - 10 kilohm resistor attached to pin 2 from ground - LED attached from pin 13 to ground through 220 ohm resistor (or use the built-in LED on most Arduino boards) created 27 Sep 2005 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StateChangeDetection */ // this constant won't change: const int buttonPin = 2; // the pin that the pushbutton is attached to const int ledPin = 13; // the pin that the LED is attached to // Variables will change: int buttonPushCounter = 0; // counter for the number of button presses int buttonState = 0; // current state of the button int lastButtonState = 0; // previous state of the button void setup() { // initialize the button pin as a input: pinMode(buttonPin, INPUT); // initialize the LED as an output: pinMode(ledPin, OUTPUT); // initialize serial communication: Serial.begin(9600); } void loop() { // read the pushbutton input pin: buttonState = digitalRead(buttonPin); // compare the buttonState to its previous state if (buttonState != lastButtonState) { // if the state has changed, increment the counter if (buttonState == HIGH) { // if the current state is HIGH then the button went from off to on: buttonPushCounter++; Serial.println(\"on\"); Serial.print(\"number of button pushes: \"); Serial.println(buttonPushCounter); } else { // if the current state is LOW then the button went from on to off: Serial.println(\"off\"); } // Delay a little bit to avoid bouncing delay(50); } // save the current state as the last state, for next time through the loop lastButtonState = buttonState; // turns on the LED every four button pushes by checking the modulo of the // button push counter. the modulo function gives you the remainder of the // division of two numbers: if (buttonPushCounter % 4 == 0) { digitalWrite(ledPin, HIGH); } else { digitalWrite(ledPin, LOW); } } Fritzing Circuit Same as Example DigitalReadSerial KiCad Schematic Same as Example DigitalReadSerial Video Demonstration 4.2.6 toneKeyboard Sketch Code /* Keyboard Plays a pitch that changes based on a changing analog input circuit: - three force-sensing resistors from +5V to analog in 0 through 5 - three 10 kilohm resistors from analog in 0 through 5 to ground - 8 ohm speaker on digital pin 8 created 21 Jan 2010 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneKeyboard */ #include \"pitches.h\" const int threshold = 10; // minimum reading of the sensors that generates a note // notes to play, corresponding to the 3 sensors: int notes[] = { NOTE_A4, NOTE_B4, NOTE_C3 }; void setup() { } void loop() { for (int thisSensor = 0; thisSensor < 3; thisSensor++) { // get a sensor reading: int sensorReading = analogRead(thisSensor); // if the sensor is pressed hard enough: if (sensorReading > threshold) { // play the note corresponding to this sensor: tone(8, notes[thisSensor], 20); } } } Fritzing Circuit KiCad Schematic Video Demonstration N/A 4.2.7 toneMelody Sketch Code /* Melody Plays a melody circuit: - 8 ohm speaker on digital pin 8 created 21 Jan 2010 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneMelody */ #include \"pitches.h\" // notes in the melody: int melody[] = { NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4 }; // note durations: 4 = quarter note, 8 = eighth note, etc.: int noteDurations[] = { 4, 8, 8, 4, 4, 4, 4, 4 }; void setup() { // iterate over the notes of the melody: for (int thisNote = 0; thisNote < 8; thisNote++) { // to calculate the note duration, take one second divided by the note type. //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc. int noteDuration = 1000 / noteDurations[thisNote]; tone(8, melody[thisNote], noteDuration); // to distinguish the notes, set a minimum time between them. // the note's duration + 30% seems to work well: int pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); // stop the tone playing: noTone(8); } } void loop() { // no need to repeat the melody. } Fritzing Circuit KiCad Schematic Video Demonstration 4.2.8 toneMultiple Sketch Code /* Multiple tone player Plays multiple tones on multiple pins in sequence circuit: - three 8 ohm speakers on digital pins 6, 7, and 8 created 8 Mar 2010 by Tom Igoe based on a snippet from Greg Borenstein This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneMultiple */ void setup() { } void loop() { // turn off tone function for pin 8: noTone(8); // play a note on pin 6 for 200 ms: tone(6, 440, 200); delay(200); // turn off tone function for pin 6: noTone(6); // play a note on pin 7 for 500 ms: tone(7, 494, 500); delay(500); // turn off tone function for pin 7: noTone(7); // play a note on pin 8 for 300 ms: tone(8, 523, 300); delay(300); } Fritzing Circuit KiCad Schematic Video Demonstration N/A 4.2.9 tonePitchFollower Sketch Code /* Pitch follower Plays a pitch that changes based on a changing analog input circuit: - 8 ohm speaker on digital pin 9 - photoresistor on analog 0 to 5V - 4.7 kilohm resistor on analog 0 to ground created 21 Jan 2010 modified 31 May 2012 by Tom Igoe, with suggestion from Michael Flynn This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/tonePitchFollower */ void setup() { // initialize serial communications (for debugging only): Serial.begin(9600); } void loop() { // read the sensor: int sensorReading = analogRead(A0); // print the sensor reading so you know its range Serial.println(sensorReading); // map the analog input range (in this case, 400 - 1000 from the photoresistor) // to the output pitch range (120 - 1500Hz) // change the minimum and maximum input numbers below depending on the range // your sensor's giving: int thisPitch = map(sensorReading, 400, 1000, 120, 1500); // play the pitch: tone(9, thisPitch, 10); delay(1); // delay in between reads for stability } Fritzing Circuit KiCad Schematic Video Demonstration N/A Section 4.3: 03.Analog Examples 4.3.1 AnalogInOutSerial Sketch Code /* Analog input, analog output, serial output Reads an analog input pin, maps the result to a range from 0 to 255 and uses the result to set the pulse width modulation (PWM) of an output pin. Also prints the results to the Serial Monitor. The circuit: - potentiometer connected to analog pin 0. Center pin of the potentiometer goes to the analog pin. side pins of the potentiometer go to +5V and ground - LED connected from digital pin 9 to ground through 220 ohm resistor created 29 Dec. 2008 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogInOutSerial */ // These constants won't change. They're used to give names to the pins used: const int analogInPin = A0; // Analog input pin that the potentiometer is attached to const int analogOutPin = 9; // Analog output pin that the LED is attached to int sensorValue = 0; // value read from the pot int outputValue = 0; // value output to the PWM (analog out) void setup() { // initialize serial communications at 9600 bps: Serial.begin(9600); } void loop() { // read the analog in value: sensorValue = analogRead(analogInPin); // map it to the range of the analog out: outputValue = map(sensorValue, 0, 1023, 0, 255); // change the analog out value: analogWrite(analogOutPin, outputValue); // print the results to the Serial Monitor: Serial.print(\"sensor = \"); Serial.print(sensorValue); Serial.print(\"\\t output = \"); Serial.println(outputValue); // wait 2 milliseconds before the next loop for the analog-to-digital // converter to settle after the last reading: delay(2); } Fritzing Circuit Same as Example AnalogReadSerial KiCad Schematic Same as Example AnalogReadSerial Video Demonstration 4.3.2 AnalogInput Sketch Code /* Analog Input Demonstrates analog input by reading an analog sensor on analog pin 0 and turning on and off a light emitting diode(LED) connected to digital pin 13. The amount of time the LED will be on and off depends on the value obtained by analogRead(). The circuit: - potentiometer center pin of the potentiometer to the analog input 0 one side pin (either one) to ground the other side pin to +5V - LED anode (long leg) attached to digital output 13 through 220 ohm resistor cathode (short leg) attached to ground - Note: because most Arduinos have a built-in LED attached to pin 13 on the board, the LED is optional. created by David Cuartielles modified 30 Aug 2011 By Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogInput */ int sensorPin = A0; // select the input pin for the potentiometer int ledPin = 13; // select the pin for the LED int sensorValue = 0; // variable to store the value coming from the sensor void setup() { // declare the ledPin as an OUTPUT: pinMode(ledPin, OUTPUT); } void loop() { // read the value from the sensor: sensorValue = analogRead(sensorPin); // turn the ledPin on digitalWrite(ledPin, HIGH); // stop the program for <sensorValue> milliseconds: delay(sensorValue); // turn the ledPin off: digitalWrite(ledPin, LOW); // stop the program for for <sensorValue> milliseconds: delay(sensorValue); } Fritzing Circuit With Potentiometer Same as Example AnalogReadSerial With Photoresistor KiCad Schematic With Potentiometer Same as Example AnalogReadSerial With Photoresistor Video Demonstration 4.3.3 AnalogWriteMega Sketch Code /* Mega analogWrite() test This sketch fades LEDs up and down one at a time on digital pins 2 through 13. This sketch was written for the Arduino Mega, and will not work on other boards. The circuit: - LEDs attached from pins 2 through 13 to ground. created 8 Feb 2009 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogWriteMega */ // These constants won't change. They're used to give names to the pins used: const int lowestPin = 2; const int highestPin = 13; void setup() { // set pins 2 through 13 as outputs: for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // iterate over the pins: for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) { // fade the LED on thisPin from off to brightest: for (int brightness = 0; brightness < 255; brightness++) { analogWrite(thisPin, brightness); delay(2); } // fade the LED on thisPin from brightest to off: for (int brightness = 255; brightness >= 0; brightness--) { analogWrite(thisPin, brightness); delay(2); } // pause between LEDs: delay(100); } } Fritzing Circuit KiCad Schematic Video Demonstration 4.3.4 Calibration Sketch Code /* Calibration Demonstrates one technique for calibrating sensor input. The sensor readings during the first five seconds of the sketch execution define the minimum and maximum of expected values attached to the sensor pin. The sensor minimum and maximum initial values may seem backwards. Initially, you set the minimum high and listen for anything lower, saving it as the new minimum. Likewise, you set the maximum low and listen for anything higher as the new maximum. The circuit: - analog sensor (potentiometer will do) attached to analog input 0 - LED attached from digital pin 9 to ground through 220 ohm resistor created 29 Oct 2008 by David A Mellis modified 30 Aug 2011 by Tom Igoe modified 07 Apr 2017 by Zachary J. Fields This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Calibration */ // These constants won't change: const int sensorPin = A0; // pin that the sensor is attached to const int ledPin = 9; // pin that the LED is attached to // variables: int sensorValue = 0; // the sensor value int sensorMin = 1023; // minimum sensor value int sensorMax = 0; // maximum sensor value void setup() { // turn on LED to signal the start of the calibration period: pinMode(13, OUTPUT); digitalWrite(13, HIGH); // calibrate during the first five seconds while (millis() < 5000) { sensorValue = analogRead(sensorPin); // record the maximum sensor value if (sensorValue > sensorMax) { sensorMax = sensorValue; } // record the minimum sensor value if (sensorValue < sensorMin) { sensorMin = sensorValue; } } // signal the end of the calibration period digitalWrite(13, LOW); } void loop() { // read the sensor: sensorValue = analogRead(sensorPin); // in case the sensor value is outside the range seen during calibration sensorValue = constrain(sensorValue, sensorMin, sensorMax); // apply the calibration to the sensor reading sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255); // fade the LED using the calibrated value: analogWrite(ledPin, sensorValue); } Fritzing Circuit Note There is an error from the official Arduino built-in example Calibration . Please refer to my issue asked at Is the sketch for Calibration wrong? KiCad Schematic Video Demonstration 4.3.5 Fading Sketch Code /* Fading This example shows how to fade an LED using the analogWrite() function. The circuit: - LED attached from digital pin 9 to ground through 220 ohm resistor. created 1 Nov 2008 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Fading */ int ledPin = 9; // LED connected to digital pin 9 void setup() { // nothing happens in setup } void loop() { // fade in from min to max in increments of 5 points: for (int fadeValue = 0; fadeValue <= 255; fadeValue += 5) { // sets the value (range from 0 to 255): analogWrite(ledPin, fadeValue); // wait for 30 milliseconds to see the dimming effect delay(30); } // fade out from max to min in increments of 5 points: for (int fadeValue = 255; fadeValue >= 0; fadeValue -= 5) { // sets the value (range from 0 to 255): analogWrite(ledPin, fadeValue); // wait for 30 milliseconds to see the dimming effect delay(30); } } Fritzing Circuit Same as Example Fade KiCad Schematic Same as Example Fade Video Demonstration 4.3.6 Smotthing Sketch Code /* Smoothing Reads repeatedly from an analog input, calculating a running average and printing it to the computer. Keeps ten readings in an array and continually averages them. The circuit: - analog sensor (potentiometer will do) attached to analog input 0 created 22 Apr 2007 by David A. Mellis <dam@mellis.org> modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Smoothing */ // Define the number of samples to keep track of. The higher the number, the // more the readings will be smoothed, but the slower the output will respond to // the input. Using a constant rather than a normal variable lets us use this // value to determine the size of the readings array. const int numReadings = 10; int readings[numReadings]; // the readings from the analog input int readIndex = 0; // the index of the current reading int total = 0; // the running total int average = 0; // the average int inputPin = A0; void setup() { // initialize serial communication with computer: Serial.begin(9600); // initialize all the readings to 0: for (int thisReading = 0; thisReading < numReadings; thisReading++) { readings[thisReading] = 0; } } void loop() { // subtract the last reading: total = total - readings[readIndex]; // read from the sensor: readings[readIndex] = analogRead(inputPin); // add the reading to the total: total = total + readings[readIndex]; // advance to the next position in the array: readIndex = readIndex + 1; // if we're at the end of the array... if (readIndex >= numReadings) { // ...wrap around to the beginning: readIndex = 0; } // calculate the average: average = total / numReadings; // send it to the computer as ASCII digits Serial.println(average); delay(1); // delay in between reads for stability } Fritzing Circuit Same as Example AnalogReadSerial KiCad Schematic Same as Example AnalogReadSerial Video Demonstration Section 4.4: 04.Communication Examples 4.4.1 ASCIITable Sketch Code /* ASCII table Prints out byte values in all possible formats: - as raw binary values - as ASCII-encoded decimal, hex, octal, and binary values For more on ASCII, see http://www.asciitable.com and http://en.wikipedia.org/wiki/ASCII The circuit: No external hardware needed. created 2006 by Nicholas Zambetti <http://www.zambetti.com> modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ASCIITable */ void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // prints title with ending line break Serial.println(\"ASCII Table ~ Character Map\"); } // first visible ASCIIcharacter '!' is number 33: int thisByte = 33; // you can also write ASCII characters in single quotes. // for example, '!' is the same as 33, so you could also use this: // int thisByte = '!'; void loop() { // prints value unaltered, i.e. the raw binary version of the byte. // The Serial Monitor interprets all bytes as ASCII, so 33, the first number, // will show up as '!' Serial.write(thisByte); Serial.print(\", dec: \"); // prints value as string as an ASCII-encoded decimal (base 10). // Decimal is the default format for Serial.print() and Serial.println(), // so no modifier is needed: Serial.print(thisByte); // But you can declare the modifier for decimal if you want to. // this also works if you uncomment it: // Serial.print(thisByte, DEC); Serial.print(\", hex: \"); // prints value as string in hexadecimal (base 16): Serial.print(thisByte, HEX); Serial.print(\", oct: \"); // prints value as string in octal (base 8); Serial.print(thisByte, OCT); Serial.print(\", bin: \"); // prints value as string in binary (base 2) also prints ending line break: Serial.println(thisByte, BIN); // if printed last visible character '~' or 126, stop: if (thisByte == 126) { // you could also use if (thisByte == '~') { // This loop loops forever and does nothing while (true) { continue; } } // go on to the next character thisByte++; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.4.2 Dimmer Sketch Code /* Dimmer Demonstrates sending data from the computer to the Arduino board, in this case to control the brightness of an LED. The data is sent in individual bytes, each of which ranges from 0 to 255. Arduino reads these bytes and uses them to set the brightness of the LED. The circuit: - LED attached from digital pin 9 to ground through 220 ohm resistor. - Serial connection to Processing, Max/MSP, or another serial application created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Dimmer */ const int ledPin = 9; // the pin that the LED is attached to void setup() { // initialize the serial communication: Serial.begin(9600); // initialize the ledPin as an output: pinMode(ledPin, OUTPUT); } void loop() { byte brightness; // check if data has been sent from the computer: if (Serial.available()) { // read the most recent byte (which will be from 0 to 255): brightness = Serial.read(); // set the brightness of the LED: analogWrite(ledPin, brightness); } } /* Processing code for this example // Dimmer - sends bytes over a serial port // by David A. Mellis // This example code is in the public domain. import processing.serial.*; Serial port; void setup() { size(256, 150); println(\"Available serial ports:\"); // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // Uses the first port in this list (number 0). Change this to select the port // corresponding to your Arduino board. The last parameter (e.g. 9600) is the // speed of the communication. It has to correspond to the value passed to // Serial.begin() in your Arduino sketch. port = new Serial(this, Serial.list()[0], 9600); // If you know the name of the port used by the Arduino board, you can specify // it directly like this. //port = new Serial(this, \"COM1\", 9600); } void draw() { // draw a gradient from black to white for (int i = 0; i < 256; i++) { stroke(i); line(i, 0, i, 150); } // write the current X-position of the mouse to the serial port as // a single byte port.write(mouseX); } */ /* Max/MSP v5 patch for this example ----------begin_max5_patcher---------- 1008.3ocuXszaiaCD9r8uhA5rqAeHIa0aAMaAVf1S6hdoYQAsDiL6JQZHQ2M YWr+2KeX4vjnjXKKkKhhiGQ9MeyCNz+X9rnMp63sQvuB+MLa1OlOalSjUvrC ymEUytKuh05TKJWUWyk5nE9eSyuS6jesvHu4F4MxOuUzB6X57sPKWVzBLXiP xZtGj6q2vafaaT0.BzJfjj.p8ZPukazsQvpfcpFs8mXR3plh8BoBxURIOWyK rxspZ0YI.eTCEh5Vqp+wGtFXZMKe6CZc3yWZwTdCmYW.BBkdiby8v0r+ST.W sD9SdUkn8FYspPbqvnBNFtZWiUyLmleJWo0vuKzeuj2vpJLaWA7YiE7wREui FpDFDp1KcbAFcP5sJoVxp4NB5Jq40ougIDxJt1wo3GDZHiNocKhiIExx+owv AdOEAksDs.RRrOoww1Arc.9RvN2J9tamwjkcqknvAE0l+8WnjHqreNet8whK z6mukIK4d+Xknv3jstvJs8EirMMhxsZIusET25jXbX8xczIl5xPVxhPcTGFu xNDu9rXtUCg37g9Q8Yc+EuofIYmg8QdkPCrOnXsaHwYs3rWx9PGsO+pqueG2 uNQBqWFh1X7qQG+3.VHcHrfO1nyR2TlqpTM9MDsLKNCQVz6KO.+Sfc5j1Ykj jzkn2jwNDRP7LVb3d9LtoWBAOnvB92Le6yRmZ4UF7YpQhiFi7A5Ka8zXhKdA 4r9TRGG7V4COiSbAJKdXrWNhhF0hNUh7uBa4Mba0l7JUK+omjDMwkSn95Izr TOwkdp7W.oPRmNRQsiKeu4j3CkfVgt.NYPEYqMGvvJ48vIlPiyzrIuZskWIS xGJPcmPiWOfLodybH3wjPbMYwlbFIMNHPHFOtLBNaLSa9sGk1TxMzCX5KTa6 WIH2ocxSdngM0QPqFRxyPHFsprrhGc9Gy9xoBjz0NWdR2yW9DUa2F85jG2v9 FgTO4Q8qiC7fzzQNpmNpsY3BrYPVJBMJQ1uVmoItRhw9NrVGO3NMNzYZ+zS7 3WTvTOnUydG5kHMKLqAOjTe7fN2bGSxOZDkMrBrGQ9J1gONBEy0k4gVo8qHc cxmfxVihWz6a3yqY9NazzUYkua9UnynadOtogW.JfsVGRVNEbWF8I+eHtcwJ +wLXqZeSdWLo+FQF6731Tva0BISKTx.cLwmgJsUTTvkg1YsnXmxDge.CDR7x D6YmX6fMznaF7kdczmJXwm.XSOOrdoHhNA7GMiZYLZZR.+4lconMaJP6JOZ8 ftCs1YWHZI3o.sIXezX5ihMSuXzZtk3ai1mXRSczoCS32hAydeyXNEu5SHyS xqZqbd3ZLdera1iPqYxOm++v7SUSz -----------end_max5_patcher----------- */ Fritzing Circuit Same as Example Fade KiCad Schematic Same as Example Fade Video Demonstration 4.4.3 Graph Sketch Code /* Graph A simple example of communication from the Arduino board to the computer: The value of analog input 0 is sent out the serial port. We call this \"serial\" communication because the connection appears to both the Arduino and the computer as a serial port, even though it may actually use a USB cable. Bytes are sent one after another (serially) from the Arduino to the computer. You can use the Arduino Serial Monitor to view the sent data, or it can be read by Processing, PD, Max/MSP, or any other program capable of reading data from a serial port. The Processing code below graphs the data received so you can see the value of the analog input changing over time. The circuit: - any analog input sensor attached to analog in pin 0 created 2006 by David A. Mellis modified 9 Apr 2012 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Graph */ void setup() { // initialize the serial communication: Serial.begin(9600); } void loop() { // send the value of analog input 0: Serial.println(analogRead(A0)); // wait a bit for the analog-to-digital converter to stabilize after the last // reading: delay(2); } /* Processing code for this example // Graphing sketch // This program takes ASCII-encoded strings from the serial port at 9600 baud // and graphs them. It expects values in the range 0 to 1023, followed by a // newline, or newline and carriage return // created 20 Apr 2005 // updated 24 Nov 2015 // by Tom Igoe // This example code is in the public domain. import processing.serial.*; Serial myPort; // The serial port int xPos = 1; // horizontal position of the graph float inByte = 0; void setup () { // set the window size: size(400, 300); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino, so I open Serial.list()[0]. // Open whatever port is the one you're using. myPort = new Serial(this, Serial.list()[0], 9600); // don't generate a serialEvent() unless you get a newline character: myPort.bufferUntil('\\n'); // set initial background: background(0); } void draw () { // draw the line: stroke(127, 34, 255); line(xPos, height, xPos, height - inByte); // at the edge of the screen, go back to the beginning: if (xPos >= width) { xPos = 0; background(0); } else { // increment the horizontal position: xPos++; } } void serialEvent (Serial myPort) { // get the ASCII string: String inString = myPort.readStringUntil('\\n'); if (inString != null) { // trim off any whitespace: inString = trim(inString); // convert to an int and map to the screen height: inByte = float(inString); println(inByte); inByte = map(inByte, 0, 1023, 0, height); } } */ /* Max/MSP v5 patch for this example ----------begin_max5_patcher---------- 1591.3oc0YszbaaCD9r7uBL5RalQUAO3CvdyS5zVenWZxs5NcfHgjPCIfJIT RTxj+6AOHkoTDooroUs0AQPR73a+1cwtK3WtZxzEpOwqlB9YveAlL4KWMYh6 Q1GLo99ISKXeJMmU451zTUQAWpmNy+NM+SZ2y+sR1l02JuU9t0hJvFlNcMPy dOuBv.U5Rgb0LPpRpYBooM3529latArTUVvzZdFPtsXAuDrrTU.f.sBffXxL vGE50lIHkUVJXq3fRtdaoDvjYfbgjujaFJSCzq4.tLaN.bi1tJefWpqbO0uz 1IjIABoluxrJ1guxh2JfPO2B5zRNyBCLDFcqbwNvuv9fHCb8bvevyyEU2JKT YhkBSWPAfq2TZ6YhqmuMUo0feUn+rYpY4YtY+cFw3lUJdCMYAapZqzwUHX8S crjAd+SIOU6UBAwIygy.Q1+HAA1KH6EveWOFQlitUK92ehfal9kFhUxJ3tWc sgpxadigWExbt1o7Ps5dk3yttivyg20W0VcSmg1G90qtx92rAZbH4ez.ruy1 nhmaDPidE07J+5n2sg6E6oKXxUSmc20o6E3SPRDbrkXnPGUYE.i5nCNB9TxQ jG.G0kCTZtH88f07Rt0ZMMWUw8VvbKVAaTk6GyoraPdZff7rQTejBN54lgyv HE0Ft7AvIvvgvIwO23jBdUkYOuSvIFSiNcjFhiSsUBwsUCh1AgfNSBAeNDBZ DIDqY.f8.YjfjV1HAn9XDTxyNFYatVTkKx3kcK9GraZpI5jv7GOx+Z37Xh82 LSKHIDmDXaESoXRngIZQDKVkpxUkMCyXCQhcCK1z.G457gi3TzMz4RFD515F G3bIQQwcP3SOF0zlkGhiCBQ1kOHHFFlXaEBQIQnCwv9QF1LxPZ.A4jR5cyQs vbvHMJsLll01We+rE2LazX6zYmCraRrsPFwKg1ANBZFY.IAihr8Ox.aH0oAL hB8nQVw0FSJiZeunOykbT6t3r.NP8.iL+bnwNiXuVMNJH9H9YCm89CFXPBER bz422p8.O4dg6kRxdyjDqRwMIHTbT3QFLskxJ8tbmQK4tm0XGeZWF7wKKtYY aTAF.XPNFaaQBinQMJ4QLF0aNHF0JtYuHSxoUZfZY6.UU2ejJTb8lQw8Fo5k Rv6e2PI+fOM71o2ecY1VgTYdCSxxUqLokuYq9jYJi6lxPgD2NIPePLB0mwbG YA9Rgxdiu1k5xiLlSU6JVnx6wzg3sYHwTesB8Z5D7RiGZpXyvDNJY.DQX3.H hvmcUN4bP1yCkhpTle2P37jtBsKrLWcMScEmltOPv22ZfAqQAdKr9HzATQwZ q18PrUGt6Tst2XMCRUfGuhXs6ccn23YloomMqcTiC5iMGPsHsHRWhWFlaenV XcqwgCQiGGJzptyS2ZMODBz6fGza0bzmXBj7+DA94bvpR01MffAlueO7HwcI pWCwmzJdvi9ILgflLAFmyXB6O7ML0YbD26lenmcGxjVsZUN+A6pUK7AtTrPg M+eRYG0qD9j4I7eEbco8Xh6WcO.or9XDC6UCiewbXHkh6xm5LiPEkzpJDRTu mEB44Fgz4NCtJvX.SM1vo2SlTCZGAe7GZu6ahdRyzFOhYZ+mbVVSYptBw.K1 tboIkatIA7c1cTKD1u.honLYV04VkluHsXe0szv9pQCE9Ro3jaVB1o15pz2X zYoBvO5KXCAe0LCYJybE8ZODf4fV8t9qW0zYxq.YJfTosj1bv0xc.SaC0+AV 9V9L.KKyV3SyTcRtmzi6rO.O16USvts4B5xe9EymDvebK0eMfW6+NIsNlE2m eqRyJ0utRq13+RjmqYKN1e.4d61jjdsauXe3.2p6jgi9hsNIv97CoyJ01xzl c3ZhUCtSHx3UZgjoEJYqNY+hYs5zZQVFW19L3JDYaTlMLqAAt1G2yXlnFg9a 53L1FJVcv.cOX0dh7mCVGCLce7GFcQwDdH5Ta3nyAS0pQbHxegr+tGIZORgM RnMj5vGl1Fs16drnk7Tf1XOLgv1n0d2iEsCxR.eQsNOZ4FGF7whofgfI3kES 1kCeOX5L2rifbdu0A9ae2X.V33B1Z+.Bj1FrP5iFrCYCG5EUWSG.hhunHJd. HJ5hhnng3h9HPj4lud02.1bxGw. -----------end_max5_patcher----------- */ Fritzing Circuit Same as Example AnalogReadSerial KiCad Schematic Same as Example AnalogReadSerial Video Demonstration 4.4.4 Midi Sketch Code /* MIDI note player This sketch shows how to use the serial transmit pin (pin 1) to send MIDI note data. If this circuit is connected to a MIDI synth, it will play the notes F#-0 (0x1E) to F#-5 (0x5A) in sequence. The circuit: - digital in 1 connected to MIDI jack pin 5 - MIDI jack pin 2 connected to ground - MIDI jack pin 4 connected to +5V through 220 ohm resistor - Attach a MIDI cable to the jack, then to a MIDI synth, and play music. created 13 Jun 2006 modified 13 Aug 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Midi */ void setup() { // Set MIDI baud rate: Serial.begin(31250); } void loop() { // play notes from F#-0 (0x1E) to F#-5 (0x5A): for (int note = 0x1E; note < 0x5A; note++) { //Note on channel 1 (0x90), some note value (note), middle velocity (0x45): noteOn(0x90, note, 0x45); delay(100); //Note on channel 1 (0x90), some note value (note), silent velocity (0x00): noteOn(0x90, note, 0x00); delay(100); } } // plays a MIDI note. Doesn't check to see that cmd is greater than 127, or that // data values are less than 127: void noteOn(int cmd, int pitch, int velocity) { Serial.write(cmd); Serial.write(pitch); Serial.write(velocity); } Fritzing Circuit KiCad Schematic Video Demonstration 4.4.5 MultiSerial Sketch Code /* Multiple Serial test Receives from the main serial port, sends to the others. Receives from serial port 1, sends to the main serial (Serial 0). This example works only with boards with more than one serial like Arduino Mega, Due, Zero etc. The circuit: - any serial device attached to Serial port 1 - Serial Monitor open on Serial port 0 created 30 Dec 2008 modified 20 May 2012 by Tom Igoe & Jed Roach modified 27 Nov 2015 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/MultiSerialMega */ void setup() { // initialize both serial ports: Serial.begin(9600); Serial1.begin(9600); } void loop() { // read from port 1, send to port 0: if (Serial1.available()) { int inByte = Serial1.read(); Serial.write(inByte); } // read from port 0, send to port 1: if (Serial.available()) { int inByte = Serial.read(); Serial1.write(inByte); } } Fritzing Circuit Note There is ONLY 1 pair of RX and TX on Arduino UNO R4 WiFi . KiCad Schematic Note There is an error from the official Arduino built-in example Use Multiple Serial Ports on the Arduino Mega . Please refer to my issue asked at RX to TX, and TX to RX? Video Demonstration 4.4.6 PhysicalPixel Sketch Code /* Physical Pixel An example of using the Arduino board to receive data from the computer. In this case, the Arduino boards turns on an LED when it receives the character 'H', and turns off the LED when it receives the character 'L'. The data can be sent from the Arduino Serial Monitor, or another program like Processing (see code below), Flash (via a serial-net proxy), PD, or Max/MSP. The circuit: - LED connected from digital pin 13 to ground through 220 ohm resistor created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/PhysicalPixel */ const int ledPin = 13; // the pin that the LED is attached to int incomingByte; // a variable to read incoming serial data into void setup() { // initialize serial communication: Serial.begin(9600); // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); } void loop() { // see if there's incoming serial data: if (Serial.available() > 0) { // read the oldest byte in the serial buffer: incomingByte = Serial.read(); // if it's a capital H (ASCII 72), turn on the LED: if (incomingByte == 'H') { digitalWrite(ledPin, HIGH); } // if it's an L (ASCII 76) turn off the LED: if (incomingByte == 'L') { digitalWrite(ledPin, LOW); } } } /* Processing code for this example // Mouse over serial // Demonstrates how to send data to the Arduino I/O board, in order to turn ON // a light if the mouse is over a square and turn it off if the mouse is not. // created 2003-4 // based on examples by Casey Reas and Hernando Barragan // modified 30 Aug 2011 // by Tom Igoe // This example code is in the public domain. import processing.serial.*; float boxX; float boxY; int boxSize = 20; boolean mouseOverBox = false; Serial port; void setup() { size(200, 200); boxX = width / 2.0; boxY = height / 2.0; rectMode(RADIUS); // List all the available serial ports in the output pane. // You will need to choose the port that the Arduino board is connected to // from this list. The first port in the list is port #0 and the third port // in the list is port #2. // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // Open the port that the Arduino board is connected to (in this case #0) // Make sure to open the port at the same speed Arduino is using (9600bps) port = new Serial(this, Serial.list()[0], 9600); } void draw() { background(0); // Test if the cursor is over the box if (mouseX > boxX - boxSize && mouseX < boxX + boxSize && mouseY > boxY - boxSize && mouseY < boxY + boxSize) { mouseOverBox = true; // draw a line around the box and change its color: stroke(255); fill(153); // send an 'H' to indicate mouse is over square: port.write('H'); } else { // return the box to its inactive state: stroke(153); fill(153); // send an 'L' to turn the LED off: port.write('L'); mouseOverBox = false; } // Draw the box rect(boxX, boxY, boxSize, boxSize); } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 1672.3oc2ZszaaiCD9ryuBBebQVCQRYao8xhf1cQCPVfBzh8RRQ.sDsM2HSZ HQmlzh9eu7gjsjsEk7y0oWjiHoHm4aluYHGlueUmtiDuPy5B9Cv8fNc99Uc5 XZR2Pm726zcF4knDRlYXciDylQ4xtWa6SReQZZ+iSeMiEQR.ej8BM4A9C7OO kkAlSjQSAYTdbFfvA27o2c6sfO.Doqd6NfXgDHmRUCKkolg4hT06BfbQJGH3 5Qd2e8d.QJIQSow5tzebZ7BFW.FIHow8.2JAQpVIIYByxo9KIMkSjL9D0BRT sbGHZJIkDoZOSMuQT.8YZ5qpgGI3locF4IpQRzq2nDF+odZMIJkRjpEF44M3 A9nWAum7LKFbSOv+PSRXYOvmIhYiYpg.8A2LOUOxPyH+TjPJA+MS9sIzTRRr QP9rXF31IBZAHpVHkHrfaPRHLuUCzoj9GSoQRqIB52y6Z.tu8o4EX+fddfuj +MrXiwPL5+9cXwrOVvkbxLpomazHbQO7EyX7DpzXYgkFdF6algCQpkX4XUlo hA6oa7GWck9w0Gnmy6RXQOoQeCfWwlzsdnHLTq8n9PCHLv7Cxa6PAN3RCKjh ISRVZ+sSl704Tqt0kocE9R8J+P+RJOZ4ysp6gN0vppBbOTEN8qp0YCq5bq47 PUwfA5e766z7NbGMuncw7VgNRSyQhbnPMGrDsGaFSvKM5NcWoIVdZn44.eOi 9DTRUT.7jDQzSTiF4UzXLc7tLGh4T9pwaFQkGUGIiOOkpBSJUwGsBd40krHQ 9XEvwq2V6eLIhV6GuzP7uzzXBmzsXPSRYwBtVLp7s5lKVv6UN2VW7xRtYDbx 7s7wRgHYDI8YVFaTBshkP49R3rYpH3RlUhTQmK5jMadJyF3cYaTNQMGSyhRE IIUlJaOOukdhoOyhnekEKmZlqU3UkLrk7bpPrpztKBVUR1uorLddk6xIOqNt lBOroRrNVFJGLrDxudpET4kzkstNp2lzuUHVMgk5TDZx9GWumnoQTbhXsEtF tzCcM+z0QKXsngCUtTOEIN0SX2iHTTIIz968.Kf.uhfzUCUuAd3UKd.OKt.N HTynxTQyjpQD9jlwEXeKQxfHCBahUge6RprSa2V4m3aYOMyaP6gah2Yf1zbD jVwZVGFZHHxINFxpjr5CiTS9JiZn6e6nTlXQZTAFj6QCppQwzL0AxVtoi6WE QXsANkEGWMEuwNvhmKTnat7A9RqLq6pXuEwY6xM5xRraoTiurj51J1vKLzFs CvM7HI14Mpje6YRxHOSieTsJpvJORjxT1nERK6s7YTN7sr6rylNwf5zMiHI4 meZ4rTYt2PpVettZERbjJ6PjfqN2loPSrUcusH01CegsGEE5467rnCdqT1ES QxtCvFq.cvGz+BaAHXKzRSfP+2Jf.KCvj5ZLJRAhwi+SWHvPyN3vXiaPn6JR 3eoA.0TkFhTvpsDMIrL20nAkCI4EoYfSHAuiPBdmJRyd.IynYYjIzMvjOTKf 3DLvnvRLDLpWeEOYXMfAZqfQ0.qsnlUdmA33t8CNJ7MZEb.u7fiZHLYzDkJp R7CqEVLGN75U+1JXxFUY.xEEBcRCqhOEkz2bENEWnh4pbh0wY25EefbD6EmW UA6Ip8wFLyuFXx+Wrp8m6iff1B86W7bqJO9+mx8er4E3.abCLrYdA16sBuHx vKT6BlpIGQIhL55W7oicf3ayv3ixQCm4aQuY1HZUPQWY+cASx2WZ3f1fICuz vj5R5ZbM1y8gXYN4dIXaYGq4NhQvS5MmcDADy+S.j8CQ78vk7Q7gtPDX3kFh 3NGaAsYBUAO.8N1U4WKycxbQdrWxJdXd10gNIO+hkUMmm.CZwknu7JbNUYUq 0sOsTsI1QudDtjw0t+xZ85wWZd80tMCiiMADNX4UzrcSeK23su87IANqmA7j tiRzoXi2YRh67ldAk79gPmTe3YKuoY0qdEDV3X8xylCJMTN45JIakB7uY8XW uVr3PO8wWwEoTW8lsfraX7ZqzZDDXCRqNkztHsGCYpIDDAOqxDpMVUMKcOrp 942acPvx2NPocMC1wQZ8glRn3myTykVaEUNLoEeJjVaAevA4EAZnsNgkeyO+ 3rEZB7f0DTazDcQTNmdt8aACGi1QOWnMmd+.6YjMHH19OB5gKsMF877x8wsJ hN97JSnSfLUXGUoj6ujWXd6Pk1SAC+Pkogm.tZ.1lX1qL.pe6PE11DPeMMZ2 .P0K+3peBt3NskC -----------end_max5_patcher----------- */ Fritzing Circuit Same as Example Blink KiCad Schematic Same as Example Blink Video Demonstration 4.4.7 ReadASCIIString Sketch Code /* Reading a serial ASCII-encoded string. This sketch demonstrates the Serial parseInt() function. It looks for an ASCII string of comma-separated values. It parses them into ints, and uses those to fade an RGB LED. Circuit: Common-Cathode RGB LED wired like so: - red anode: digital pin 3 through 220 ohm resistor - green anode: digital pin 5 through 220 ohm resistor - blue anode: digital pin 6 through 220 ohm resistor - cathode: GND created 13 Apr 2012 by Tom Igoe modified 14 Mar 2016 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ReadASCIIString */ // pins for the LEDs: const int redPin = 3; const int greenPin = 5; const int bluePin = 6; void setup() { // initialize serial: Serial.begin(9600); // make the pins outputs: pinMode(redPin, OUTPUT); pinMode(greenPin, OUTPUT); pinMode(bluePin, OUTPUT); } void loop() { // if there's any serial available, read it: while (Serial.available() > 0) { // look for the next valid integer in the incoming serial stream: int red = Serial.parseInt(); // do it again: int green = Serial.parseInt(); // do it again: int blue = Serial.parseInt(); // look for the newline. That's the end of your sentence: if (Serial.read() == '\\n') { // constrain the values to 0 - 255 and invert // if you're using a common-cathode LED, just use \"constrain(color, 0, 255);\" red = 255 - constrain(red, 0, 255); green = 255 - constrain(green, 0, 255); blue = 255 - constrain(blue, 0, 255); // fade the red, green, and blue legs of the LED: analogWrite(redPin, red); analogWrite(greenPin, green); analogWrite(bluePin, blue); // print the three numbers in one string as hexadecimal: Serial.print(red, HEX); Serial.print(green, HEX); Serial.println(blue, HEX); } } } Fritzing Circuit KiCad Schematic Note There is an error from the official Arduino built-in example Read ASCII String . Video Demonstration 4.4.8 SerialCallResponse Sketch Code /* Serial Call and Response Language: Wiring/Arduino This program sends an ASCII A (byte of value 65) on startup and repeats that until it gets some data in. Then it waits for a byte in the serial port, and sends three sensor values whenever it gets a byte in. The circuit: - potentiometers attached to analog inputs 0 and 1 - pushbutton attached to digital I/O 2 created 26 Sep 2005 by Tom Igoe modified 24 Apr 2012 by Tom Igoe and Scott Fitzgerald Thanks to Greg Shakar and Scott Fitzgerald for the improvements This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialCallResponse */ int firstSensor = 0; // first analog sensor int secondSensor = 0; // second analog sensor int thirdSensor = 0; // digital sensor int inByte = 0; // incoming serial byte void setup() { // start serial port at 9600 bps: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } pinMode(2, INPUT); // digital sensor is on digital pin 2 establishContact(); // send a byte to establish contact until receiver responds } void loop() { // if we get a valid byte, read analog ins: if (Serial.available() > 0) { // get incoming byte: inByte = Serial.read(); // read first analog input, divide by 4 to make the range 0-255: firstSensor = analogRead(A0) / 4; // delay 10ms to let the ADC recover: delay(10); // read second analog input, divide by 4 to make the range 0-255: secondSensor = analogRead(1) / 4; // read switch, map it to 0 or 255L thirdSensor = map(digitalRead(2), 0, 1, 0, 255); // send sensor values: Serial.write(firstSensor); Serial.write(secondSensor); Serial.write(thirdSensor); } } void establishContact() { while (Serial.available() <= 0) { Serial.print('A'); // send a capital A delay(300); } } /* Processing sketch to run with this example: // This example code is in the public domain. import processing.serial.*; int bgcolor; // Background color int fgcolor; // Fill color Serial myPort; // The serial port int[] serialInArray = new int[3]; // Where we'll put what we receive int serialCount = 0; // A count of how many bytes we receive int xpos, ypos; // Starting position of the ball boolean firstContact = false; // Whether we've heard from the microcontroller void setup() { size(256, 256); // Stage size noStroke(); // No border on the next thing drawn // Set the starting position of the ball (middle of the stage) xpos = width / 2; ypos = height / 2; // Print a list of the serial ports for debugging purposes // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my FTDI // adaptor, so I open Serial.list()[0]. // On Windows machines, this generally opens COM1. // Open whatever port is the one you're using. String portName = Serial.list()[0]; myPort = new Serial(this, portName, 9600); } void draw() { background(bgcolor); fill(fgcolor); // Draw the shape ellipse(xpos, ypos, 20, 20); } void serialEvent(Serial myPort) { // read a byte from the serial port: int inByte = myPort.read(); // if this is the first byte received, and it's an A, clear the serial // buffer and note that you've had first contact from the microcontroller. // Otherwise, add the incoming byte to the array: if (firstContact == false) { if (inByte == 'A') { myPort.clear(); // clear the serial port buffer firstContact = true; // you've had first contact from the microcontroller myPort.write('A'); // ask for more } } else { // Add the latest byte from the serial port to array: serialInArray[serialCount] = inByte; serialCount++; // If we have 3 bytes: if (serialCount > 2 ) { xpos = serialInArray[0]; ypos = serialInArray[1]; fgcolor = serialInArray[2]; // print the values (for debugging purposes only): println(xpos + \"\\t\" + ypos + \"\\t\" + fgcolor); // Send a capital A to request new sensor readings: myPort.write('A'); // Reset serialCount: serialCount = 0; } } } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 3908.3oc6ckziiaiE9b0+J3XjCIXpp.WzZNMURv.jCInQ5fYNjNngrDssRKK 4nkp6JA4+973hrkrsjncKu0SRiXasQ83G+dKj7QV+4qtaxzrOxKlf9Zzuft6 t+7U2cm7ThSbm936lrL3igIAExaaRJ+CYS+sI2qtTI+ikxSuBMKNojm+N3D4 Aua5KkPwpuoUAkgKhSm+tbdXo5cQXVOhuGwrohuHD4WT7iXzupen3HY4BuqG rH0kzrrzxzfkb4kdJONHo9JoUKiSS3kRgjt4jYUk0mkznPJh+CYgHewpSqty xWVwUh3jIqkEYEfmqQEMr.ETbB+YddQbVZix+tIAqV03z203QDX4ukIKHm6W ep3T0ovqOUN+435m2Rcx+5U0E+FTzVBh9xOsHXIh5YuADg1x4IYgumG0r3mj shmFmtJmWvSKCJ0um0WNhOKnJo7c6GmZe8YAg7Ne381Rc2j44wQYoBgn0SJN c8qCHH1RhQqJi7NRCVsmGt.pGUESCxE31zDdCV.PRyxRZeo0MU.WOHMdYPIu LVIrT75BMd4p73zxVuHdZ.TFKJByyRRZUTpq77dtRDzZFx+PbT4BYY0DJgaO dUcSvj0XTT7bdQY6yUFLun8YZo71jl0TIt042RYNLa4RfCTWfsznKWDWfJpl tJHrbgV6t.AZInfzWP.4INpJHA8za91u+6QN1nk7hh.PpQwonxEbTAWzpilV MimilkmsDtPbo3TPiUdY0pGa9ZShS4gYUJz1pwE1iwCpxbAgJI9DGGwWNzFT ksLf3z7M0MybG6Hj1WngsD7VEXS8j5q7Wu5U0+39ir8QJJS5GMHdtRimL4m1 0e1EVX0YsE2YssINriYRoFRyWVMoRRUGQvnkmms3pnXDYHbBKMPpIOL5i1s8 3rMPwFcRCsGRyPH780.8HBnpWz.vlEQBWJ+0CSunehJSmJxiIZRtNGhhDYrU jt3ZQyA2fHJhZDifXIQHUHH8oGYgOREI5nqHIzhFWUndPyBdB3VzHJGwUhkV rgvRl2UCVNMHcd234lf1DN16HFEIdHt99A5hrp7v5WWMSBQZgMP.Tkwoqig8 W1.Sn1f3h3nn1wLpBypPDzlJ7XinEGkLiMPloWOhrgR7dpZWJQV1faDy35Qj MThMFkWFGsJChQPqrQp8iorV6Q28HBVF4nMVDJj7f1xyYACFScisg.ruLHOW uMUS4Am4pI4PTnHi.6bi02HNzSYnDBe4cgAgKzRk1jc8PJLoH3Ydz6.Q.7K8 tfxx73oUkJq1MGuCy5TpAi.POWZ3AenidLOOIaZPhdjZVW3sdk6LXEGzHb7p Mfr7SEy3SXHyBSxJ3J2ncNNYVJsXG6Me10nj4cfCRFdTFjLo7q3SiCpjjEDM .nvra.GN39.E2CDTHWXPo8.xzfqrHCHKnf5QUYUVdoZPUjCSC7LU8.XtTUXl X8vr51GjwFGLC2AlMdLkU4RiaRrnmJuiudnDk0ZW+9p6TuKBe433JUCzp6fU iOF0SUk2UQYUPNTEkiZubvKa1tsmgL5SCTXGHnnG0CceLpkpR9Rs28IUESWl EwWNKfHlg.zj6Ee7S+nE8A+m9F7Cu40u9gMm+aRp3kYYkKd3GDOz5y+c7b96 K9gfvuIK68uNO6g2vUUL80WxihCVFD9vlB30e2SOrmxUb527RZ3nZNrljGrR 70vs1J9suWuZ3zaHVdG3RIJLgGj2Gfn6TcGcstEfvtH.hpFLlnBndjOLGQAI z98BXc6yQxghmOn6gZqj0ShPOXhynLOjzCESt+XwE8TxrCvrdXo16rqnLgvb HaFmbh29QD+K0DyNdjDwvzQL.NXpoMvoOBxkger0HwMRQbpbCh91fjjG9Idw prTH9SzaSea5a.GQEPnnh43WNefMlsOgx18n.vgUNO.tKl7tDyI3iHzafJHZ VVNedVEbGgYIY42i93prB0i7B7KT1LnnCiyAiinpBnsPV7OG.tYKfBsrJOkG UG5aq26iJw6GyJ4eM5mEgEKaNQPMEBUp.t8.krplOVTlZdJAW27bjvGK7p2p HQPgLOSJDYv4E9gQBYBjMUselRxDy+4WplIzm9JQAWOEmfb.E364B43CAwp5 uRRDEv8hWXprjADMUOYpOg9.bVQpEfhKgGCnAnk.rghBJCdTVICA3sDvAhE5 oU4hf67ea5zWPuILqrD8uiK+i477fjHIt9y.V88yy3uMsZUj7wnxGKNAdPx5 fAZMErDZOcJU4M01WFQokix.pKa+JE1WacmnKFeYd7b.0PeIzB8Kk+5WIZpB Ejt34KJeHgOCh4HK8Y3QiAkAfs8TRhhOkG7AAGQf0qxyfmQxa+PLb8Ex.2PS 4BdO5GB9Hvg+cfJCMofAIMu9Qz+UPCjckqVJlEmyA8Bf.rC6.3hAEuG8TdTU bZljQ0nr1ayIqmTwQYfyRGafZhur5vfuyMSqYNWmtAPwWHalDSuUgT0Bosh. JpAR89Y6Ez5QEfPTQO4J0DHLInIliz8BZV2JfV3Bd36qsQwAVVXbr1BGXp6s Sd5sSDruo74wofx.HxUgxQwTnMLqTXvRmiGh2PUZr5pBynKChjl6feNUjSRn hEUfRPT1GfG9Ik4TQBm.hEZZ.bc38HjAMKGzDRijEm1ifx1dbgzQyKh6FZc3 wOCkRJH+KUh0daWs6wzltWx1puXxlWW6NZWY2JiTBzzILRIANku02NourySM VI1VJTvQZff32AJr+dS9e34QAoA6EGXlGFH9yk7yyQAlVd3SR94g+TxOu1sU Flgd6ICI96LzazyPu1cgqsZ8r74SgF.65+efbMf4pGHT7lgHh30Sha3N5Ia. oqjMf7nsuMwycf7iYDybiAAVr3eC.oTMjpzEr8GDRc9bFRGHYXDrzg.Tlx+q NW8TY1IkzCfZ2IftkQstbB08HUezoDS+oFyI.cWIhWBaDiUo7qIrDO7f.L6n AXqCmyNT9act.z+Iv.GR0uES0ZXfjdz.IczAxQOUR+zvRsUTigRxmyPYeNlj yXv8Peef2ZFzuLzWPPeAE8ELzWXYlhe8WzAcUg+b1UkIoCLzIH60zwASGXau a1Dq2nUY.sox4vng+m0nACePngC9lEMLZMBPodOxf+yx5d4uMCTHm3kJvIIG jcLMedEQldkjpoBkQyjY1Hk.hmSY95Iwos8NDb9VSlIWOIntqgxryUjL6bCJ y1lli5tWWxrQ7YmqGYlc6shK1iY2dr0wtNjYxgHyzaq0OznY235awCr8zSz6 EGd1QNUKf.74dADTBbTbeotjpW95IolY0WpKYONY8M83Rx2MChx3fL+iG5Mm tXpdmvXj8uTvaAL1WjbbarQD4Z6kXBpnm6a69oKV2PY9WY174IbC3CaRQ9iK Q4sYGQpwdtZ5wFrc7n569.M83OOR5ydSB1ZcAWCxdbKuavz9LILxfD.wWO.W Nq+Zu4Es+AP6s5p9jDWH8ET+c85+XbW0.N1nDCTD7U4DGc6ohnU019fS7kQ0 o43luuOGjv5agHp0DT.CysOfgLR3xXlXTUKm16RivRsn3z0O6cl3YScAvtrb hwekGB7BZuqESUzBJWmCvK7t9HF8Ts6cUAPoFWso3aP8ApWyJ3wqOPo2pJDC BQ0NI0Pj8QCQ2r1L5vKaU5lDRYX7yRur1UYYZmJQ9iDHwN9dndB5n5ejflmm UsBwLHnDkKXWRuAkb3NeuzqRstiQGP.fCQFdHNzaE.8u58Nz9svFE9SGIE1X kv9Iwfl1BdNWjA7xcThsWCS847loyFD8pZq2E2F04lYULzBTDYhrFSDDJdjo fisN2NUN26e4xRu51zD5ZseJ4HC63WyIX6jRqsp0jangBnK.Qlo58PCpWevt ahzqK7fbKsdX6R64aao8LmWhBPh9jKVAPMzb5a2cV6opdWHneMmqMEmAGsPh ieigIjV+4gF1GgbMNXg+NH44YaRYyd..S1ThHzKhFwwGRaWVITqyj9FvPqMT d0pDuSqDrOGF.Uogf.juCFi9WAUkYR+rFPanDcPG8SbrtjyG03ZQ8m3AqC5H NcUUoXSwVrqXKVcZu.5ZnkwIfIVdXVZTwAuTTUiYuxwjZDK6ZgnRtYV8tJmP hEcuXgz2Goxyaiw35UkaWbpqtfzD02oUkkYqi.YQbZqIIWrIljFolsdmMKFR wCJ2+DTn.9QlkOld+d9Qy9IJdpLfy05Ik2b8GsG9h8rdm1ZFx1FrmmlA2snw qI9Mcdi2nr6q3Gc87nLawurbw1dda+tMyGJ9HaQmlkGwy6davisMgrkM65oz eulfYCzG46am8tSDK144xV4cEvVMTRXq9CIX8+ALNWb6sttKNkiZetnbz+lx cQnb1Nds2C0tvLNe14hwQtxYbxhqc17qHfamUcZZ3NYSWqjJuiDoizZ+ud2j naRK4k3346IIVdR1kKiQjM39adMamvc6n+Xp36Yf3SIGh3uKbquqs1JksTII kuJ7RrZSFb2Cn9j5a6DT8cMo0iczU+lsYaU8YNVh5k5uzJLU26ZcfuJE6XLY 0mcRp9NTCp+L+Ap+in7Xf3b9jFQBLtIY06PbrGhcrU6N00Qlaf9N0+QPo9nS P6qsI7aYNLSNOHpsAxis0ggnZLjYqyyFkdSqinVsPaqSDZaYBZ6c93uLCjGm iCroJVLzU45iNE.pIUfs3TWb.0FejHp9uANr0GcJPTroFDNOHpkIweLnI1QT dHl3P7LhOF3Ahd9rnvLwAMy5JSdNezGlsIsW9mW44r26js+alhxjlkdhN0YE YqiH5MTeWo6D4Qm.ieLS7OynmuVGSbmbFUlnWWhiQlhOeN+Yl35bq.tGo9JR cj8AVqdz7nSgVB9zNj.FTOU68o5d9KO5TUOGxVMw+jTO8T6wqD0hEiHsOJO5 TTOMoS.zlqN0SpZjz6GcH05ylVM0jwuidlkmAif374ih5M5QPfccr8Hqifff otN8pt3hUcaWu8nosBhwmD0Epw5KmoF.poxy4YHbnjqfPJqcM3Y2vun7nS.i f3eETiqcRX2LR.4QmhZrkoCSGwzZrqKHrVR8caari+55d2caPqmq5n.ywe8Q WrZL9fpwVXeaogMByE6y1SMdjk+gbavbN7fYvVtt1C2XwHJSzpk+tidUO25H UB9onw9mlFQ10fhpZBaDatcMTTEGcJpwzqg92qqiVtM6Cu0IRQ0ndEdfCAqV l0qYAUmPrctbxO4XCuPMa1asYzKDks1D52ZCne6Mednz9qW8+.vfqkDA -----------end_max5_patcher----------- */ Fritzing Circuit KiCad Schematic Video Demonstration 4.4.9 SerialCallResponseASCII Sketch Code /* Serial Call and Response in ASCII Language: Wiring/Arduino This program sends an ASCII A (byte of value 65) on startup and repeats that until it gets some data in. Then it waits for a byte in the serial port, and sends three ASCII-encoded, comma-separated sensor values, truncated by a linefeed and carriage return, whenever it gets a byte in. The circuit: - potentiometers attached to analog inputs 0 and 1 - pushbutton attached to digital I/O 2 created 26 Sep 2005 by Tom Igoe modified 24 Apr 2012 by Tom Igoe and Scott Fitzgerald Thanks to Greg Shakar and Scott Fitzgerald for the improvements This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialCallResponseASCII */ int firstSensor = 0; // first analog sensor int secondSensor = 0; // second analog sensor int thirdSensor = 0; // digital sensor int inByte = 0; // incoming serial byte void setup() { // start serial port at 9600 bps and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } pinMode(2, INPUT); // digital sensor is on digital pin 2 establishContact(); // send a byte to establish contact until receiver responds } void loop() { // if we get a valid byte, read analog ins: if (Serial.available() > 0) { // get incoming byte: inByte = Serial.read(); // read first analog input: firstSensor = analogRead(A0); // read second analog input: secondSensor = analogRead(A1); // read switch, map it to 0 or 255 thirdSensor = map(digitalRead(2), 0, 1, 0, 255); // send sensor values: Serial.print(firstSensor); Serial.print(\",\"); Serial.print(secondSensor); Serial.print(\",\"); Serial.println(thirdSensor); } } void establishContact() { while (Serial.available() <= 0) { Serial.println(\"0,0,0\"); // send an initial string delay(300); } } /* Processing code to run with this example: // This example code is in the public domain. import processing.serial.*; // import the Processing serial library Serial myPort; // The serial port float bgcolor; // Background color float fgcolor; // Fill color float xpos, ypos; // Starting position of the ball void setup() { size(640, 480); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino board, so I open Serial.list()[0]. // Change the 0 to the appropriate number of the serial port that your // microcontroller is attached to. myPort = new Serial(this, Serial.list()[0], 9600); // read bytes into a buffer until you get a linefeed (ASCII 10): myPort.bufferUntil('\\n'); // draw with smooth edges: smooth(); } void draw() { background(bgcolor); fill(fgcolor); // Draw the shape ellipse(xpos, ypos, 20, 20); } // serialEvent method is run automatically by the Processing applet whenever // the buffer reaches the byte value set in the bufferUntil() // method in the setup(): void serialEvent(Serial myPort) { // read the serial buffer: String myString = myPort.readStringUntil('\\n'); // if you got any bytes other than the linefeed: myString = trim(myString); // split the string at the commas and convert the sections into integers: int sensors[] = int(split(myString, ',')); // print out the values you got: for (int sensorNum = 0; sensorNum < sensors.length; sensorNum++) { print(\"Sensor \" + sensorNum + \": \" + sensors[sensorNum] + \"\\t\"); } // add a linefeed after all the sensor values are printed: println(); if (sensors.length > 1) { xpos = map(sensors[0], 0, 1023, 0, width); ypos = map(sensors[1], 0, 1023, 0, height); fgcolor = sensors[2]; } // send a byte to ask for more data: myPort.write(\"A\"); } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 3640.3oc6cs0jZajE94Y9UzKkeHoVloTeSHkm1II0VkeHIthSs6C1obIjZ.E KjHRhY7jT4+9d5KBj.jTCAXfoV6x.sj5VmyWet127ed6MCFm8EQw.z2f9.5l a9yau4F0kjW3FS4aFLO3KgIAEpGaPX174hzxAC02qT7kR80mkkUHPAnBQdbP BZQVdIZRd1bT4r3BDTmkU0YQPY3r3zoeJWDVpe2ttr6cFhvXt7KhyH8W26f9 USkhiTulrw+1czQUszjrzxzf4B0sdP9dqtS5x4woIhREQiWewrkkUW0oViTD +GpFASt2Qd0+51akeLzRPIU7DPXagIFnH.4653f9WAKKyxVHRQNcfDXlih2w puvbdWHAlcTPBRKHg4x5mr74EBMINHV1+iFL.8qG.VMWTTDLUrs.TBH+zAvP nTEhvvxun9pBd6FWH38DWH6DWv6ItbX.RKBOJ7XbP5ztvDesvhBLb6VTwcOg DmiBjnXfiIrjjED0CpP490PEmtPExwQA5EGUVjK.CKQJqtcYl0nCMRAJi76D Z7dQflCCVV1i+ENiTy3AwYaghEA4.KVJx+jHMXbhntJPceO3iBpPOPKtZqtU jUoXtw28fkEimmEIlOI.3Q4iMT9wO+iLxc9O7sN28928t6Ve8uMYo.7EUN6t ePVoUW+6E4hOW7CAgeaV1meWd1cuWnYLy8mKhhClGDd25F3ce+C2si1Ud42+ bZ3IQJOXg7q96t80e50YvDjqHw7VvkRTXhHHuKEerRwmqfBFsS.g9h.HZN3X hJf5Qd+xHZHgzc.mrqeYjbn4E84evfIDUjDtjNwD2iRHV6anmGdbmsfKxTTJ dd93rjtBJ2U42foCwZDqKfYzKkrh4VgYIY4FxVRmN2646f8ck+xw7KrjzOlZ ZYAVfdZgKlaWn29FzA8nfdR2quj.3ejflBJnKr.Dwpf13cZBm85P0rPj.rOB 6fvztPFGkVI0SAPi5NKHmih7E8Ph2e35uOtYN6x6JEQtJVWpV7gRtm2dZy9W +YMCxLHrEvAknQktDVdY7v82SFosgmSGHO56BRRt6mEEKxRKDnGd+2812h9X 5GSeODOcAJ.M9YHHAfjPkyD0GIugn.Ht6bQ.7TTS8DoPtCQCQxWobX+jYPUJ hPn3zgnx7kogphieFZ2j3TwDgH5dzaUscJ77kEnIY4hoYKglVYzcH5KKxJzu qmgegxl.0MLNGBNDsr.5IUz0iAPZFE.0TtLOEdClQYrAAeORwW+XVo3aP+hb DHUBCH.mfbEKfGOPyjQhGiCAdNUUBRcQjij4X.u5MZRDzHSyTDQFbcYdHHIM AzlF1lnoLjKG8UZH5guV1vEkA4kKWbOPGPC9YgjNdJHVy+ZJQ1.Cq.FUWQpA ke.8DbUwi.YEWBUCDhPyAXCEETFbuhICg9EIRiYnGVjKyt0+io.r+9vrxRz+ Nt7OlJxCRhT35u.X0amlI9X5xEQppQwneJrLarPVU7JkGYWVHz2njevz1UoX XkoEWOkxDWO9kXYocoTwuzF611zXJyimB3F5qf9nOT9qesryJTJ1EOcV4cIh IPVWYoOBUMFTl.4sGRRzRT4AOIkRjn8h7LnNJI2mhg6OSk5JZrPJ4i9gfu.R w+NHLCcpfAMij88n+qTPPMt4UTwj3bAnY.h.aIe.RiAEeF8Pdzx3zLkLUs1Z mcmczah0FH4ZmpLcp.rVbX3d0zalKhSiKAxBZ9BU2zTP3uPobgL1Q.U0.kl+ jcBZj1AMOpzsJYjdz0n53QXsfYrqELKblH7yUFoDfPVXbrwDGXqCjwjviT7a rXZbpxOvxzXvpOnPH0GlTJMZog8l2UZJcdPjxjG7ywIYgeFULaInFDk8jpxZ apvMA4cv9X.7.vaRRGFAcPYHMR0dF2BZC7wEJ2TOKeZnCRD+HzJo.OLWSW6r qk2wfI6pGf.pdjC4rpfL2YeK8JYloVf93.ocJEvocv9wAcEiMQgBtl.lb0y9 heKnvtGRs+iHOJHM3uaZbN1jDrhED4FfwfLPCEmH8jV.BB0Z+aF.Vkqc4apU EIb9a5zAcGt5Rf3WdsNJ3R4PXDU0mouHzIca0MWO.KpQjT8oq1SIyqV3mP24 ToxfHpdyOPNqgwoK.W.fxfRNtwsiDSBVlT9ociSMu+jfPQqUtk9paFLMONJK URFMpq7xUuvOXF1HBuN6ndhzfE6nxPXQkKKFGjKQNyHtSptYYVVRyaspyBD3 CRiA0YQYrlbgHdptY77E4wZk5UWSOf9yJByyRRZzT5673NtiNrvmhiJmoZq5 fI73wKp5DFrBihhmBNxadsxfoEMuRiIbutfVcM4FWuyr.2bvrlNF5.3U+q9C sKaa5jkMt70iSd8bC2ZbEFUuAa0DWqYF0tJ91p43649br2nZ2usLGuoxrnQq 6TArNx+1CjRLPpVWf62Kj59ZFRa38Y6D0kRo8AnT8b0g0e4p8+f6.P4sBnaX TqMmPsOdOcjG+dMtOmdzcgLdIGqjX0J+FAVrmSu.L8fAX19Ky1C.e1.z+IB2 qpeCIUV+.I4fARxQGH0i.9ECVZrhZMTheMCkc4XRMsoCgbef2ZFjaF5MXzaH n2PQugYmhe0WjdcU47Z1Ukhb6CwFISy2HNtcvtaNRWdshHNVgHcNMUlopRm4 tJByyLXfI0UN6GM7eUiFTm8BMbctZQC8atOegDu6oveXrgpeaGnfaETvsBJN 6AKuNsT4n+zRVXJtQd+ciEEYKyCq.8ptRTSdBRQrLNcUd5eXcjoa7fyhihZl UrNQxBYZo5g.vpdt8klkJi1QyPvdH7UFMStbvYu8Amu1nY7ECMKGXBqnY2KH Z18Jjl4aYNnEYiQWVzrUxytWNzL0VZ14xglI6isN5kAMi2GZlbYPyNma6FqC aJRs9qEogO+ovfvYFxxjGV07cLnH3QQzm.R.BG7SAkk4wiWVpC2p9jwX23ka 0zSz4M6e1QZY.8mljMNHwLURqZ9FuzslMk8ZJXtcMPeblVut1XYDhdMCpmjZ 8BAqsU9DezKxJAa8Hmbbfi+wccuVv7c0qELrEHB+UAhHWzCfCbKPEyBki24Z clythVwfkYSmlHrPdX8tC5v1iPb5ArPuOWc8NVrRZspq24UxhE0wBcAsMyt2 2LLuqvkKZRXjEq5CM6S3tq9Zm6HD+8Prm0F+jDWn1paUe+2ZuF259kxkiR5W Qf6vzKBtMm+gFrMeuWsKW.6B61VyWOFjz0Zsmwza+.ikxQcAL3iDtbLWMTKm OtyMEFcjWM9iu0rMa81D8kUl3v2ewcHWP5B2HX6kK7t7DL5fs6JVIrO0Z1l3 bEpOP3zih9.gbspPzKDYbRVAQ7CFhtZsYzhW1ko0WEJcG3oAC0aRIyxKsUEI +iDPwOLfp0uNA68MmtSUSmRuNb8d1ttWya7sVWf5Iwf.1LQtZUnqNvT1bS6z E5o2vfqNSH5bufQbuZV09M.E04Mj8XBUiBqNGl5FSt3NGlZaGRpV6wc4kiWi q0twaaORhul1jjsIi7cMjQlJJUaQuhR495nlfRQWRJXkrgmMGXWjKM4jdGJH yovkl4HUetutzWuY5tjFHneGn77rtG3iJ92whCVJxKhBwgGtRaFIzabfNrRn WThd9q24vsZjf9JvHwOKBhprFDmtXYIZ7xISjaO1GE4OK2V9yiS.qFhvrznh 8cKyMZs7EVepT01FlCe0rIC0lUk6NX4N9syCyAE660+ovE9hyGqjaGurrLak G0YwoMlFO4YMSZjd9DcWucsjUr1Yqgy8TluCY3N9Q8.+k0JCD3ZTS0CW8Qyb s19nOxrgjw7VFU+3ooYviK66pCfimt8AAxHOOBkK+EajC2yayWtciMzgdvpM NKORj29YyGcS4wFVlql0wcZTg1yw5wvMNiTpuUzpu.Y0miRlgO0w7wpZI2Em SUBGayVM5eqU4C+rV4ZSPkvXqLJbAHlR3mKwT5ISL8+Kv0k.GWEKwpP3ewk3 7omKIN7EtDmp4ZtHk0BfatXgLhgasHgZrVYaY8AIO7fq8Pas1fFzjd4ibwpd XO4GXOeOG+lcyasNh1R+wVx2yBxeTOT+wiZFYA0P48PNyiiVjAhJlNT4Qvpb uj3aN2qYqJcBfSWhMbf+YCPcsfbNeTC2l9WNc+5eIlkST0RJgupzIn+kysgC X6GGXnYpdYfP0GP6MKQXM3N1Ih6XVvcLuym7B0B5w8v.ahqBI49qJcJ.TaX. N+xBP4NGHhhqYfkRNM9q1f3ZweqyYCQYdGCSZGQ5wBx47o.Ssw+CkcgQOmud KZic4QKzCw+7ROm8nY2LfMsEDtdfeMKSn5Ev95IQhorcqJcBrzPsQUhRNe8M 1X6lhOezC4Bidv1nKcFs8YimJ9n8RWZXiO7aSCxDRLdjd91qU5TnmXCeRvmR 9jnm7b15RmJ9rO4Kr+IgO04BfczyOpqx9npzofOsIlaR8Mo0IUMR48i0mYly lVMwlw6gbloGRezy4yKEw6BHBBWik.eRi3DNM5KDahS.SOE1EjmXl7Uyqo9T AtQAO8fG3oLX3cZFxKh0FLNSRfDaoG74gdvW.ZDU9FMGSdFMBt+IQh.6eIvw FujTkJREGKKcJ3X2WtXf7Ub1HywEqxh2tJnE.FcZhMByrcXQw1x+bOWJYjpy lv8oq55aEHLcwD8hJjxbVU5EigcNtL7Ql76KVVp69Huhcb87vpoCkRYT+96v Hd5Ay1rofMqm+FkLYvv0+GL3FkL6bLp21kL6QFNV8BNM48foWBV4zt1wXm5V 4jkNEbL45dtNw13Iltmi9sAyY0S0l8BR+3yWjVXax7eOmKrp4m0QKIal6VYo SAf5XQxSrCa5l0qk45k5kAzqEgMNgzkz9FmL5abpnu4IhNzZ+0s+OKCSg0. -----------end_max5_patcher----------- */ Fritzing Circuit Same as Example SerialCallResponse KiCad Schematic Same as Example SerialCallResponse Video Demonstration 4.4.10 SerialEvent Sketch Code /* Serial Event example When new serial data arrives, this sketch adds it to a String. When a newline is received, the loop prints the string and clears it. A good test for this is to try it with a GPS receiver that sends out NMEA 0183 sentences. NOTE: The serialEvent() feature is not available on the Leonardo, Micro, or other ATmega32U4 based boards. created 9 May 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialEvent */ String inputString = \"\"; // a String to hold incoming data bool stringComplete = false; // whether the string is complete void setup() { // initialize serial: Serial.begin(9600); // reserve 200 bytes for the inputString: inputString.reserve(200); } void loop() { // print the string when a newline arrives: if (stringComplete) { Serial.println(inputString); // clear the string: inputString = \"\"; stringComplete = false; } } /* SerialEvent occurs whenever a new data comes in the hardware serial RX. This routine is run between each time loop() runs, so using delay inside loop can delay response. Multiple bytes of data may be available. */ void serialEvent() { while (Serial.available()) { // get the new byte: char inChar = (char)Serial.read(); // add it to the inputString: inputString += inChar; // if the incoming character is a newline, set a flag so the main loop can // do something about it: if (inChar == '\\n') { stringComplete = true; } } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.4.11 SerialPassthrough Sketch Code /* SerialPassthrough sketch Some boards, like the Arduino 101, the MKR1000, Zero, or the Micro, have one hardware serial port attached to Digital pins 0-1, and a separate USB serial port attached to the IDE Serial Monitor. This means that the \"serial passthrough\" which is possible with the Arduino UNO (commonly used to interact with devices/shields that require configuration via serial AT commands) will not work by default. This sketch allows you to emulate the serial passthrough behaviour. Any text you type in the IDE Serial monitor will be written out to the serial port on Digital pins 0 and 1, and vice-versa. On the 101, MKR1000, Zero, and Micro, \"Serial\" refers to the USB Serial port attached to the Serial Monitor, and \"Serial1\" refers to the hardware serial port attached to pins 0 and 1. This sketch will emulate Serial passthrough using those two Serial ports on the boards mentioned above, but you can change these names to connect any two serial ports on a board that has multiple ports. created 23 May 2016 by Erik Nyquist https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialPassthrough */ void setup() { Serial.begin(9600); Serial1.begin(9600); } void loop() { if (Serial.available()) { // If anything comes in Serial (USB), Serial1.write(Serial.read()); // read it and send it out Serial1 (pins 0 & 1) } if (Serial1.available()) { // If anything comes in Serial1 (pins 0 & 1) Serial.write(Serial1.read()); // read it and send it out Serial (USB) } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.4.12 VirtualColorMixer Sketch Code /* This example reads three analog sensors (potentiometers are easiest) and sends their values serially. The Processing and Max/MSP programs at the bottom take those three values and use them to change the background color of the screen. The circuit: - potentiometers attached to analog inputs 0, 1, and 2 created 2 Dec 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/VirtualColorMixer */ const int redPin = A0; // sensor to control red color const int greenPin = A1; // sensor to control green color const int bluePin = A2; // sensor to control blue color void setup() { Serial.begin(9600); } void loop() { Serial.print(analogRead(redPin)); Serial.print(\",\"); Serial.print(analogRead(greenPin)); Serial.print(\",\"); Serial.println(analogRead(bluePin)); } /* Processing code for this example // This example code is in the public domain. import processing.serial.*; float redValue = 0; // red value float greenValue = 0; // green value float blueValue = 0; // blue value Serial myPort; void setup() { size(200, 200); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino, so I open Serial.list()[0]. // Open whatever port is the one you're using. myPort = new Serial(this, Serial.list()[0], 9600); // don't generate a serialEvent() unless you get a newline character: myPort.bufferUntil('\\n'); } void draw() { // set the background color with the color values: background(redValue, greenValue, blueValue); } void serialEvent(Serial myPort) { // get the ASCII string: String inString = myPort.readStringUntil('\\n'); if (inString != null) { // trim off any whitespace: inString = trim(inString); // split the string on the commas and convert the resulting substrings // into an integer array: float[] colors = float(split(inString, \",\")); // if the array has at least three elements, you know you got the whole // thing. Put the numbers in the color variables: if (colors.length >= 3) { // map them to the range 0-255: redValue = map(colors[0], 0, 1023, 0, 255); greenValue = map(colors[1], 0, 1023, 0, 255); blueValue = map(colors[2], 0, 1023, 0, 255); } } } */ /* Max/MSP patch for this example ----------begin_max5_patcher---------- 1512.3oc4Z00aaaCE8YmeED9ktB35xOjrj1aAsXX4g8xZQeYoXfVh1gqRjdT TsIsn+2K+PJUovVVJ1VMdCAvxThV7bO7b48dIyWtXxzkxaYkSA+J3u.Sl7kK lLwcK6MlT2dxzB5so4zRW2lJXeRt7elNy+HM6Vs61uDDzbOYkNmo02sg4euS 4BSede8S2P0o2vEq+aEKU66PPP7b3LPHDauPvyCmAvv4v6+M7L2XXF2WfCaF lURgVPKbCxzKUbZdySDUEbgABN.ia08R9mccGYGn66qGutNir27qWbg8iY+7 HDRx.Hjf+OPHCQgPdpQHoxhBlwB+QF4cbkthlCRk4REnfeKScs3ZwaugWBbj .PS+.qDPAkZkgPlY5oPS4By2A5aTLFv9pounjsgpnZVF3x27pqtBrRpJnZaa C3WxTkfUJYA.BzR.BhIy.ehquw7dSoJCsrlATLckR.nhLPNWvVwL+Vp1LHL. SjMG.tRaG7OxT5R2c8Hx9B8.wLCxVaGI6qnpj45Ug84kL+6YIM8CqUxJyycF 7bqsBRULGvwfWyRMyovElat7NvqoejaLm4f+fkmyKuVTHy3q3ldhB.WtQY6Z x0BSOeSpTqA+FW+Yy3SyybH3sFy8p0RVCmaMpTyX6HdDZ2JsPbfSogbBMueH JLd6RMBdfRMzPjZvimuWIK2XgFA.ZmtfKoh0Sm88qc6OF4bDQ3P6kEtF6xej .OkjD4H5OllyS+.3FlhY0so4xRlWqyrXErQpt+2rsnXgQNZHZgmMVzEofW7T S4zORQtgIdDbRHrObRzSMNofUVZVcbKbhQZrSOo934TqRHIN2ncr7BF8TKR1 tHDqL.PejLRRPKMR.pKFAkbtDa+UOvsYsIFH0DYsTCjqZ66T1CmGeDILLpSm myk0SdkOKh5LUr4GbWwRYdW7fm.BvDmzHnSdH3biGpSbxxDNJoGDAD1ChH7L I0DaloOTBLvkO7zPs5HJnKNoGAXbol5eytUhfyiSfnjE1uAq+Fp0a+wygGwR q3ZI8.psJpkpJnyPzwmXBj7Sh.+bNvVZxlcKAm0OYHIxcIjzEKdRChgO5UMf LkMPNN0MfiS7Ev6TYQct.F5IWcCZ4504rGsiVswGWWSYyma01QcZgmL+f+sf oU18Hn6o6dXkMkFF14TL9rIAWE+6wvGV.p.TPqz3HK5L+VxYxl4UmBKEjr.B 6zinuKI3C+D2Y7azIM6N7QL6t+jQyZxymK1ToAKqVsxjlGyjz2c1kTK3180h kJEYkacWpv6lyp2VJTjWK47wHA6fyBOWxH9pUf6jUtZkLpNKW.9EeUBH3ymY XSQlaqGrkQMGzp20adYSmIOGjIABo1xZyAWJtCX9tg6+HMuhMCPyx76ao+Us UxmzUE79H8d2ZB1m1ztbnOa1mGeAq0awyK8a9UqBUc6pZolpzurTK232e5gp aInVw8QIIcpaiNSJfY4Z+92Cs+Mc+mgg2cEsvGlLY6V+1kMuioxnB5VM+fsY 9vSu4WI1PMBGXye6KXvNuzmZTh7U9h5j6vvASdngPdgOFxycNL6ia1axUMmT JIzebXcQCn3SKMf+4QCMmOZung+6xBCPLfwO8ngcEI52YJ1y7mx3CN9xKUYU bg7Y1yXjlKW6SrZnguQdsSfOSSDItqv2jwJFjavc1vO7OigyBr2+gDYorRk1 HXZpVFfu2FxXkZtfp4RQqNkX5y2sya3YYL2iavWAOaizH+pw.Ibg8f1I9h3Z 2B79sNeOHvBOtfEalWsvyu0KMf015.AaROvZ7vv5AhnndfHLbTgjcCK1KlHv gOk5B26OqrXjcJ005.QqCHn8fVTxnxfj93SfQiJlv8YV0VT9fVUwOOhSV3uD eeqCUClbBPa.j3vWDoMZssNTzRNEnE6gYPXazZaMF921syaLWyAeBXvCESA8 ASi6Zyw8.RQi65J8ZsNx3ho93OhGWENtWpowepae4YhCFeLErOLENtXJrOSc iadi39rf4hwc8xdhHz3gn3dBI7iDRlFe8huAfIZhq -----------end_max5_patcher----------- */ Fritzing Circuit KiCad Schematic Video Demonstration Section 4.5: 05.Control Examples 4.5.1 Arrays Sketch Code /* Arrays Demonstrates the use of an array to hold pin numbers in order to iterate over the pins in a sequence. Lights multiple LEDs in sequence, then in reverse. Unlike the For Loop tutorial, where the pins have to be contiguous, here the pins can be in any random order. The circuit: - LEDs from pins 2 through 7 to ground created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Arrays */ int timer = 100; // The higher the number, the slower the timing. int ledPins[] = { 2, 7, 4, 6, 5, 3 }; // an array of pin numbers to which LEDs are attached int pinCount = 6; // the number of pins (i.e. the length of the array) void setup() { // the array elements are numbered from 0 to (pinCount - 1). // use a for loop to initialize each pin as an output: for (int thisPin = 0; thisPin < pinCount; thisPin++) { pinMode(ledPins[thisPin], OUTPUT); } } void loop() { // loop from the lowest pin to the highest: for (int thisPin = 0; thisPin < pinCount; thisPin++) { // turn the pin on: digitalWrite(ledPins[thisPin], HIGH); delay(timer); // turn the pin off: digitalWrite(ledPins[thisPin], LOW); } // loop from the highest pin to the lowest: for (int thisPin = pinCount - 1; thisPin >= 0; thisPin--) { // turn the pin on: digitalWrite(ledPins[thisPin], HIGH); delay(timer); // turn the pin off: digitalWrite(ledPins[thisPin], LOW); } } Fritzing Circuit Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs. KiCad Schematic Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs. Video Demonstration 4.5.2 ForLoopIteration Sketch Code /* For Loop Iteration Demonstrates the use of a for() loop. Lights multiple LEDs in sequence, then in reverse. The circuit: - LEDs from pins 2 through 7 to ground created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ForLoopIteration */ int timer = 100; // The higher the number, the slower the timing. void setup() { // use a for loop to initialize each pin as an output: for (int thisPin = 2; thisPin < 8; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // loop from the lowest pin to the highest: for (int thisPin = 2; thisPin < 8; thisPin++) { // turn the pin on: digitalWrite(thisPin, HIGH); delay(timer); // turn the pin off: digitalWrite(thisPin, LOW); } // loop from the highest pin to the lowest: for (int thisPin = 7; thisPin >= 2; thisPin--) { // turn the pin on: digitalWrite(thisPin, HIGH); delay(timer); // turn the pin off: digitalWrite(thisPin, LOW); } } Fritzing Circuit Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs. KiCad Schematic Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs. Video Demonstration 4.5.3 IfStatementConditional Sketch Code /* Conditionals - If statement This example demonstrates the use of if() statements. It reads the state of a potentiometer (an analog input) and turns on an LED only if the potentiometer goes above a certain threshold level. It prints the analog value regardless of the level. The circuit: - potentiometer Center pin of the potentiometer goes to analog pin 0. Side pins of the potentiometer go to +5V and ground. - LED connected from digital pin 13 to ground through 220 ohm resistor - Note: On most Arduino boards, there is already an LED on the board connected to pin 13, so you don't need any extra components for this example. created 17 Jan 2009 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/ifStatementConditional // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/ifStatementConditional */ // These constants won't change: const int analogPin = A0; // pin that the sensor is attached to const int ledPin = 13; // pin that the LED is attached to const int threshold = 400; // an arbitrary threshold level that's in the range of the analog input void setup() { // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); // initialize serial communications: Serial.begin(9600); } void loop() { // read the value of the potentiometer: int analogValue = analogRead(analogPin); // if the analog value is high enough, turn on the LED: if (analogValue > threshold) { digitalWrite(ledPin, HIGH); } else { digitalWrite(ledPin, LOW); } // print the analog value: Serial.println(analogValue); delay(1); // delay in between reads for stability } Fritzing Circuit Same as Example AnalogReadSerial . KiCad Schematic Same as Example AnalogReadSerial . Video Demonstration 4.5.4 switchCase Sketch Code /* Switch statement Demonstrates the use of a switch statement. The switch statement allows you to choose from among a set of discrete values of a variable. It's like a series of if statements. To see this sketch in action, put the board and sensor in a well-lit room, open the Serial Monitor, and move your hand gradually down over the sensor. The circuit: - photoresistor from analog in 0 to +5V - 10K resistor from analog in 0 to ground created 1 Jul 2009 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/SwitchCase // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/SwitchCase */ // these constants won't change. They are the lowest and highest readings you // get from your sensor: const int sensorMin = 0; // sensor minimum, discovered through experiment const int sensorMax = 600; // sensor maximum, discovered through experiment void setup() { // initialize serial communication: Serial.begin(9600); } void loop() { // read the sensor: int sensorReading = analogRead(A0); // map the sensor range to a range of four options: int range = map(sensorReading, sensorMin, sensorMax, 0, 3); // do something different depending on the range value: switch (range) { case 0: // your hand is on the sensor Serial.println(\"dark\"); break; case 1: // your hand is close to the sensor Serial.println(\"dim\"); break; case 2: // your hand is a few inches from the sensor Serial.println(\"medium\"); break; case 3: // your hand is nowhere near the sensor Serial.println(\"bright\"); break; } delay(1); // delay in between reads for stability } Fritzing Circuit Same as Example AnalogInput . KiCad Schematic Same as Example AnalogInput . Video Demonstration 4.5.5 switchCase2 Sketch Code /* Switch statement with serial input Demonstrates the use of a switch statement. The switch statement allows you to choose from among a set of discrete values of a variable. It's like a series of if statements. To see this sketch in action, open the Serial monitor and send any character. The characters a, b, c, d, and e, will turn on LEDs. Any other character will turn the LEDs off. The circuit: - five LEDs attached to digital pins 2 through 6 through 220 ohm resistors created 1 Jul 2009 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/SwitchCase2 // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/SwitchCase2 */ void setup() { // initialize serial communication: Serial.begin(9600); // initialize the LED pins: for (int thisPin = 2; thisPin < 7; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // read the sensor: if (Serial.available() > 0) { int inByte = Serial.read(); // do something different depending on the character received. // The switch statement expects single number values for each case; in this // example, though, you're using single quotes to tell the controller to get // the ASCII value for the character. For example 'a' = 97, 'b' = 98, // and so forth: switch (inByte) { case 'a': digitalWrite(2, HIGH); break; case 'b': digitalWrite(3, HIGH); break; case 'c': digitalWrite(4, HIGH); break; case 'd': digitalWrite(5, HIGH); break; case 'e': digitalWrite(6, HIGH); break; default: // turn all the LEDs off: for (int thisPin = 2; thisPin < 7; thisPin++) { digitalWrite(thisPin, LOW); } } } } Fritzing Circuit Similar to Example AnalogWriteMega , but use 5 LEDs rather than 12 LEDs. KiCad Schematic Similar to Example AnalogWriteMega , but use 5 LEDs rather than 12 LEDs. Video Demonstration 4.5.6 WhileStatementConditional Sketch Code /* Conditionals - while statement This example demonstrates the use of while() statements. While the pushbutton is pressed, the sketch runs the calibration routine. The sensor readings during the while loop define the minimum and maximum of expected values from the photoresistor. This is a variation on the calibrate example. The circuit: - photoresistor connected from +5V to analog in pin 0 - 10 kilohm resistor connected from ground to analog in pin 0 - LED connected from digital pin 9 to ground through 220 ohm resistor - pushbutton attached from pin 2 to +5V - 10 kilohm resistor attached from pin 2 to ground created 17 Jan 2009 modified 30 Aug 2011 by Tom Igoe modified 20 Jan 2017 by Arturo Guadalupi This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/WhileStatementConditional // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/WhileStatementConditional */ // These constants won't change: const int sensorPin = A0; // pin that the sensor is attached to const int ledPin = 9; // pin that the LED is attached to const int indicatorLedPin = 13; // pin that the built-in LED is attached to const int buttonPin = 2; // pin that the button is attached to // These variables will change: int sensorMin = 1023; // minimum sensor value int sensorMax = 0; // maximum sensor value int sensorValue = 0; // the sensor value void setup() { // set the LED pins as outputs and the switch pin as input: pinMode(indicatorLedPin, OUTPUT); pinMode(ledPin, OUTPUT); pinMode(buttonPin, INPUT); } void loop() { // while the button is pressed, take calibration readings: while (digitalRead(buttonPin) == HIGH) { calibrate(); } // signal the end of the calibration period digitalWrite(indicatorLedPin, LOW); // read the sensor: sensorValue = analogRead(sensorPin); // apply the calibration to the sensor reading sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255); // in case the sensor value is outside the range seen during calibration sensorValue = constrain(sensorValue, 0, 255); // fade the LED using the calibrated value: analogWrite(ledPin, sensorValue); } void calibrate() { // turn on the indicator LED to indicate that calibration is happening: digitalWrite(indicatorLedPin, HIGH); // read the sensor: sensorValue = analogRead(sensorPin); // record the maximum sensor value if (sensorValue > sensorMax) { sensorMax = sensorValue; } // record the minimum sensor value if (sensorValue < sensorMin) { sensorMin = sensorValue; } } Fritzing Circuit KiCad Schematic Video Demonstration Section 4.6: 06.Sensors Examples 4.6.1 ADXL3xx Sketch Code /* ADXL3xx Reads an Analog Devices ADXL3xx accelerometer and communicates the acceleration to the computer. The pins used are designed to be easily compatible with the breakout boards from SparkFun, available from: https://www.sparkfun.com/categories/80 The circuit: - analog 0: accelerometer self test - analog 1: z-axis - analog 2: y-axis - analog 3: x-axis - analog 4: ground - analog 5: vcc created 2 Jul 2008 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ADXL3xx */ // these constants describe the pins. They won't change: const int groundpin = 18; // analog input pin 4 -- ground const int powerpin = 19; // analog input pin 5 -- voltage const int xpin = A3; // x-axis of the accelerometer const int ypin = A2; // y-axis const int zpin = A1; // z-axis (only on 3-axis models) void setup() { // initialize the serial communications: Serial.begin(9600); // Provide ground and power by using the analog inputs as normal digital pins. // This makes it possible to directly connect the breakout board to the // Arduino. If you use the normal 5V and GND pins on the Arduino, // you can remove these lines. pinMode(groundpin, OUTPUT); pinMode(powerpin, OUTPUT); digitalWrite(groundpin, LOW); digitalWrite(powerpin, HIGH); } void loop() { // print the sensor values: Serial.print(analogRead(xpin)); // print a tab between values: Serial.print(\"\\t\"); Serial.print(analogRead(ypin)); // print a tab between values: Serial.print(\"\\t\"); Serial.print(analogRead(zpin)); Serial.println(); // delay before next reading: delay(100); } Fritzing Circuit KiCad Schematic Video Demonstration 4.6.2 Knock Sketch Code /* Knock Sensor This sketch reads a piezo element to detect a knocking sound. It reads an analog pin and compares the result to a set threshold. If the result is greater than the threshold, it writes \"knock\" to the serial port, and toggles the LED on pin 13. The circuit: - positive connection of the piezo attached to analog in 0 - negative connection of the piezo attached to ground - 1 megohm resistor attached from analog in 0 to ground created 25 Mar 2007 by David Cuartielles <http://www.0j0.org> modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Knock */ // these constants won't change: const int ledPin = 13; // LED connected to digital pin 13 const int knockSensor = A0; // the piezo is connected to analog pin 0 const int threshold = 100; // threshold value to decide when the detected sound is a knock or not // these variables will change: int sensorReading = 0; // variable to store the value read from the sensor pin int ledState = LOW; // variable used to store the last LED status, to toggle the light void setup() { pinMode(ledPin, OUTPUT); // declare the ledPin as as OUTPUT Serial.begin(9600); // use the serial port } void loop() { // read the sensor and store it in the variable sensorReading: sensorReading = analogRead(knockSensor); // if the sensor reading is greater than the threshold: if (sensorReading >= threshold) { // toggle the status of the ledPin: ledState = !ledState; // update the LED pin itself: digitalWrite(ledPin, ledState); // send the string \"Knock!\" back to the computer, followed by newline Serial.println(\"Knock!\"); } delay(100); // delay to avoid overloading the serial port buffer } Fritzing Circuit KiCad Schematic Video Demonstration 4.6.3 Memsic2125 Note Ignored. Memsic 2125 is outdated and deprecated. Sketch Code Note Ignored. Memsic 2125 is outdated and deprecated. Fritzing Circuit Note Ignored. Memsic 2125 is outdated and deprecated. KiCad Schematic Note Ignored. Memsic 2125 is outdated and deprecated. Video Demonstration Note Ignored. Memsic 2125 is outdated and deprecated. 4.6.4 Ping Note SEN136B5B is outdated and deprecated. We're NOT using the demo from official Arduino examples, but use HC-SR04 as a replacement of SEN136B5B . For this particular example, please refer to Ultrasonic Sensor HC-SR04 and Arduino \u2013 Complete Guide . Sketch Code /* Ultrasonic Sensor HC-SR04 and Arduino Tutorial by Dejan Nedelkovski, www.HowToMechatronics.com */ // defines pins numbers const int trigPin = 9; const int echoPin = 10; // defines variables long duration; int distance; void setup() { pinMode(trigPin, OUTPUT); // Sets the trigPin as an Output pinMode(echoPin, INPUT); // Sets the echoPin as an Input Serial.begin(9600); // Starts the serial communication } void loop() { // Clears the trigPin digitalWrite(trigPin, LOW); delayMicroseconds(2); // Sets the trigPin on HIGH state for 10 micro seconds digitalWrite(trigPin, HIGH); delayMicroseconds(10); digitalWrite(trigPin, LOW); // Reads the echoPin, returns the sound wave travel time in microseconds duration = pulseIn(echoPin, HIGH); // Calculating the distance distance = duration * 0.034 / 2; // Prints the distance on the Serial Monitor Serial.print(\"Distance: \"); Serial.println(distance); } Fritzing Circuit KiCad Schematic Video Demonstration Section 4.7: 07.Display Examples 4.7.1 barGraph Sketch Code /* LED bar graph Turns on a series of LEDs based on the value of an analog sensor. This is a simple way to make a bar graph display. Though this graph uses 10 LEDs, you can use any number by changing the LED count and the pins in the array. This method can be used to control any series of digital outputs that depends on an analog input. The circuit: - LEDs from pins 2 through 11 to ground created 4 Sep 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/BarGraph */ // these constants won't change: const int analogPin = A0; // the pin that the potentiometer is attached to const int ledCount = 10; // the number of LEDs in the bar graph int ledPins[] = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }; // an array of pin numbers to which LEDs are attached void setup() { // loop over the pin array and set them all to output: for (int thisLed = 0; thisLed < ledCount; thisLed++) { pinMode(ledPins[thisLed], OUTPUT); } } void loop() { // read the potentiometer: int sensorReading = analogRead(analogPin); // map the result to a range from 0 to the number of LEDs: int ledLevel = map(sensorReading, 0, 1023, 0, ledCount); // loop over the LED array: for (int thisLed = 0; thisLed < ledCount; thisLed++) { // if the array element's index is less than ledLevel, // turn the pin for this element on: if (thisLed < ledLevel) { digitalWrite(ledPins[thisLed], HIGH); } // turn off all pins higher than the ledLevel: else { digitalWrite(ledPins[thisLed], LOW); } } } Fritzing Circuit KiCad Schematic Video Demonstration 4.7.2 RowColumnScanning Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix . Sketch Code Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix . Fritzing Circuit Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix . KiCad Schematic Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix . Video Demonstration Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix . Section 4.8: 08.Strings Examples 4.8.1 CharacterAnalysis Sketch Code /* Character analysis operators Examples using the character analysis operators. Send any byte and the sketch will tell you about it. created 29 Nov 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/CharacterAnalysis */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"send any byte and I'll tell you everything I can about it\"); Serial.println(); } void loop() { // get any incoming bytes: if (Serial.available() > 0) { int thisChar = Serial.read(); // say what was sent: Serial.print(\"You sent me: \\'\"); Serial.write(thisChar); Serial.print(\"\\' ASCII Value: \"); Serial.println(thisChar); // analyze what was sent: if (isAlphaNumeric(thisChar)) { Serial.println(\"it's alphanumeric\"); } if (isAlpha(thisChar)) { Serial.println(\"it's alphabetic\"); } if (isAscii(thisChar)) { Serial.println(\"it's ASCII\"); } if (isWhitespace(thisChar)) { Serial.println(\"it's whitespace\"); } if (isControl(thisChar)) { Serial.println(\"it's a control character\"); } if (isDigit(thisChar)) { Serial.println(\"it's a numeric digit\"); } if (isGraph(thisChar)) { Serial.println(\"it's a printable character that's not whitespace\"); } if (isLowerCase(thisChar)) { Serial.println(\"it's lower case\"); } if (isPrintable(thisChar)) { Serial.println(\"it's printable\"); } if (isPunct(thisChar)) { Serial.println(\"it's punctuation\"); } if (isSpace(thisChar)) { Serial.println(\"it's a space character\"); } if (isUpperCase(thisChar)) { Serial.println(\"it's upper case\"); } if (isHexadecimalDigit(thisChar)) { Serial.println(\"it's a valid hexadecimaldigit (i.e. 0 - 9, a - F, or A - F)\"); } // add some space and ask for another byte: Serial.println(); Serial.println(\"Give me another byte:\"); Serial.println(); } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.2 StringAdditionOperator Sketch Code /* Adding Strings together Examples of how to add Strings together You can also add several different data types to String, as shown here: created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringAdditionOperator */ // declare three Strings: String stringOne, stringTwo, stringThree; void setup() { // initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"You added \"); stringTwo = String(\"this string\"); stringThree = String(); // send an intro: Serial.println(\"\\n\\nAdding Strings together (concatenation):\"); Serial.println(); } void loop() { // adding a constant integer to a String: stringThree = stringOne + 123; Serial.println(stringThree); // prints \"You added 123\" // adding a constant long integer to a String: stringThree = stringOne + 123456789; Serial.println(stringThree); // prints \"You added 123456789\" // adding a constant character to a String: stringThree = stringOne + 'A'; Serial.println(stringThree); // prints \"You added A\" // adding a constant string to a String: stringThree = stringOne + \"abc\"; Serial.println(stringThree); // prints \"You added abc\" stringThree = stringOne + stringTwo; Serial.println(stringThree); // prints \"You added this string\" // adding a variable integer to a String: int sensorValue = analogRead(A0); stringOne = \"Sensor value: \"; stringThree = stringOne + sensorValue; Serial.println(stringThree); // prints \"Sensor Value: 401\" or whatever value analogRead(A0) has // adding a variable long integer to a String: stringOne = \"millis() value: \"; stringThree = stringOne + millis(); Serial.println(stringThree); // prints \"The millis: 345345\" or whatever value millis() has // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.3 StringAppendOperator Sketch Code /* Appending to Strings using the += operator and concat() Examples of how to append different data types to Strings created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringAppendOperator */ String stringOne, stringTwo; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"Sensor \"); stringTwo = String(\"value\"); // send an intro: Serial.println(\"\\n\\nAppending to a String:\"); Serial.println(); } void loop() { Serial.println(stringOne); // prints \"Sensor \" // adding a string to a String: stringOne += stringTwo; Serial.println(stringOne); // prints \"Sensor value\" // adding a constant string to a String: stringOne += \" for input \"; Serial.println(stringOne); // prints \"Sensor value for input\" // adding a constant character to a String: stringOne += 'A'; Serial.println(stringOne); // prints \"Sensor value for input A\" // adding a constant integer to a String: stringOne += 0; Serial.println(stringOne); // prints \"Sensor value for input A0\" // adding a constant string to a String: stringOne += \": \"; Serial.println(stringOne); // prints \"Sensor value for input\" // adding a variable integer to a String: stringOne += analogRead(A0); Serial.println(stringOne); // prints \"Sensor value for input A0: 456\" or whatever analogRead(A0) is Serial.println(\"\\n\\nchanging the Strings' values\"); stringOne = \"A long integer: \"; stringTwo = \"The millis(): \"; // adding a constant long integer to a String: stringOne += 123456789; Serial.println(stringOne); // prints \"A long integer: 123456789\" // using concat() to add a long variable to a String: stringTwo.concat(millis()); Serial.println(stringTwo); // prints \"The millis(): 43534\" or whatever the value of the millis() is // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.4 StringCaseChanges Sketch Code /* String Case changes Examples of how to change the case of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringCaseChanges */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString case changes:\"); Serial.println(); } void loop() { // toUpperCase() changes all letters to upper case: String stringOne = \"<html><head><body>\"; Serial.println(stringOne); stringOne.toUpperCase(); Serial.println(stringOne); // toLowerCase() changes all letters to lower case: String stringTwo = \"</BODY></HTML>\"; Serial.println(stringTwo); stringTwo.toLowerCase(); Serial.println(stringTwo); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.5 StringCharacters Sketch Code /* String charAt() and setCharAt() Examples of how to get and set characters of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringCharacters */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"\\n\\nString charAt() and setCharAt():\"); } void loop() { // make a String to report a sensor reading: String reportString = \"SensorReading: 456\"; Serial.println(reportString); // the reading's most significant digit is at position 15 in the reportString: char mostSignificantDigit = reportString.charAt(15); String message = \"Most significant digit of the sensor reading is: \"; Serial.println(message + mostSignificantDigit); // add blank space: Serial.println(); // you can also set the character of a String. Change the : to a = character reportString.setCharAt(13, '='); Serial.println(reportString); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.6 StringComparisonOperators Sketch Code /* Comparing Strings Examples of how to compare Strings using the comparison operators created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringComparisonOperators */ String stringOne, stringTwo; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"this\"); stringTwo = String(\"that\"); // send an intro: Serial.println(\"\\n\\nComparing Strings:\"); Serial.println(); } void loop() { // two Strings equal: if (stringOne == \"this\") { Serial.println(\"StringOne == \\\"this\\\"\"); } // two Strings not equal: if (stringOne != stringTwo) { Serial.println(stringOne + \" =! \" + stringTwo); } // two Strings not equal (case sensitivity matters): stringOne = \"This\"; stringTwo = \"this\"; if (stringOne != stringTwo) { Serial.println(stringOne + \" =! \" + stringTwo); } // you can also use equals() to see if two Strings are the same: if (stringOne.equals(stringTwo)) { Serial.println(stringOne + \" equals \" + stringTwo); } else { Serial.println(stringOne + \" does not equal \" + stringTwo); } // or perhaps you want to ignore case: if (stringOne.equalsIgnoreCase(stringTwo)) { Serial.println(stringOne + \" equals (ignoring case) \" + stringTwo); } else { Serial.println(stringOne + \" does not equal (ignoring case) \" + stringTwo); } // a numeric String compared to the number it represents: stringOne = \"1\"; int numberOne = 1; if (stringOne.toInt() == numberOne) { Serial.println(stringOne + \" = \" + numberOne); } // two numeric Strings compared: stringOne = \"2\"; stringTwo = \"1\"; if (stringOne >= stringTwo) { Serial.println(stringOne + \" >= \" + stringTwo); } // comparison operators can be used to compare Strings for alphabetic sorting too: stringOne = String(\"Brown\"); if (stringOne < \"Charles\") { Serial.println(stringOne + \" < Charles\"); } if (stringOne > \"Adams\") { Serial.println(stringOne + \" > Adams\"); } if (stringOne <= \"Browne\") { Serial.println(stringOne + \" <= Browne\"); } if (stringOne >= \"Brow\") { Serial.println(stringOne + \" >= Brow\"); } // the compareTo() operator also allows you to compare Strings // it evaluates on the first character that's different. // if the first character of the String you're comparing to comes first in // alphanumeric order, then compareTo() is greater than 0: stringOne = \"Cucumber\"; stringTwo = \"Cucuracha\"; if (stringOne.compareTo(stringTwo) < 0) { Serial.println(stringOne + \" comes before \" + stringTwo); } else { Serial.println(stringOne + \" comes after \" + stringTwo); } delay(10000); // because the next part is a loop: // compareTo() is handy when you've got Strings with numbers in them too: while (true) { stringOne = \"Sensor: \"; stringTwo = \"Sensor: \"; stringOne += analogRead(A0); stringTwo += analogRead(A5); if (stringOne.compareTo(stringTwo) < 0) { Serial.println(stringOne + \" comes before \" + stringTwo); } else { Serial.println(stringOne + \" comes after \" + stringTwo); } } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.7 StringConstructors Sketch Code /* String constructors Examples of how to create Strings from other data types created 27 Jul 2010 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringConstructors */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString Constructors:\"); Serial.println(); } void loop() { // using a constant String: String stringOne = \"Hello String\"; Serial.println(stringOne); // prints \"Hello String\" // converting a constant char into a String: stringOne = String('a'); Serial.println(stringOne); // prints \"a\" // converting a constant string into a String object: String stringTwo = String(\"This is a string\"); Serial.println(stringTwo); // prints \"This is a string\" // concatenating two strings: stringOne = String(stringTwo + \" with more\"); // prints \"This is a string with more\": Serial.println(stringOne); // using a constant integer: stringOne = String(13); Serial.println(stringOne); // prints \"13\" // using an int and a base: stringOne = String(analogRead(A0), DEC); // prints \"453\" or whatever the value of analogRead(A0) is Serial.println(stringOne); // using an int and a base (hexadecimal): stringOne = String(45, HEX); // prints \"2d\", which is the hexadecimal version of decimal 45: Serial.println(stringOne); // using an int and a base (binary) stringOne = String(255, BIN); // prints \"11111111\" which is the binary value of 255 Serial.println(stringOne); // using a long and a base: stringOne = String(millis(), DEC); // prints \"123456\" or whatever the value of millis() is: Serial.println(stringOne); // using a float and the right decimal places: stringOne = String(5.698, 3); Serial.println(stringOne); // using a float and less decimal places to use rounding: stringOne = String(5.698, 2); Serial.println(stringOne); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.8 StringIndexOf Sketch Code /* String indexOf() and lastIndexOf() functions Examples of how to evaluate, look for, and replace characters in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringIndexOf */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString indexOf() and lastIndexOf() functions:\"); Serial.println(); } void loop() { // indexOf() returns the position (i.e. index) of a particular character in a // String. For example, if you were parsing HTML tags, you could use it: String stringOne = \"<HTML><HEAD><BODY>\"; int firstClosingBracket = stringOne.indexOf('>'); Serial.println(\"The index of > in the string \" + stringOne + \" is \" + firstClosingBracket); stringOne = \"<HTML><HEAD><BODY>\"; int secondOpeningBracket = firstClosingBracket + 1; int secondClosingBracket = stringOne.indexOf('>', secondOpeningBracket); Serial.println(\"The index of the second > in the string \" + stringOne + \" is \" + secondClosingBracket); // you can also use indexOf() to search for Strings: stringOne = \"<HTML><HEAD><BODY>\"; int bodyTag = stringOne.indexOf(\"<BODY>\"); Serial.println(\"The index of the body tag in the string \" + stringOne + \" is \" + bodyTag); stringOne = \"<UL><LI>item<LI>item<LI>item</UL>\"; int firstListItem = stringOne.indexOf(\"<LI>\"); int secondListItem = stringOne.indexOf(\"<LI>\", firstListItem + 1); Serial.println(\"The index of the second list tag in the string \" + stringOne + \" is \" + secondListItem); // lastIndexOf() gives you the last occurrence of a character or string: int lastOpeningBracket = stringOne.lastIndexOf('<'); Serial.println(\"The index of the last < in the string \" + stringOne + \" is \" + lastOpeningBracket); int lastListItem = stringOne.lastIndexOf(\"<LI>\"); Serial.println(\"The index of the last list tag in the string \" + stringOne + \" is \" + lastListItem); // lastIndexOf() can also search for a string: stringOne = \"<p>Lorem ipsum dolor sit amet</p><p>Ipsem</p><p>Quod</p>\"; int lastParagraph = stringOne.lastIndexOf(\"<p\"); int secondLastGraf = stringOne.lastIndexOf(\"<p\", lastParagraph - 1); Serial.println(\"The index of the second to last paragraph tag \" + stringOne + \" is \" + secondLastGraf); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.9 StringLength Sketch Code /* String length() Examples of how to use length() in a String. Open the Serial Monitor and start sending characters to see the results. created 1 Aug 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringLengthTrim */ String txtMsg = \"\"; // a string for incoming text unsigned int lastStringLength = txtMsg.length(); // previous length of the String void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString length():\"); Serial.println(); } void loop() { // add any incoming characters to the String: while (Serial.available() > 0) { char inChar = Serial.read(); txtMsg += inChar; } // print the message and a notice if it's changed: if (txtMsg.length() != lastStringLength) { Serial.println(txtMsg); Serial.println(txtMsg.length()); // if the String's longer than 140 characters, complain: if (txtMsg.length() < 140) { Serial.println(\"That's a perfectly acceptable text message\"); } else { Serial.println(\"That's too long for a text message.\"); } // note the length for next time through the loop: lastStringLength = txtMsg.length(); } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.10 StringLengthTrim Sketch Code /* String length() and trim() Examples of how to use length() and trim() in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringLengthTrim */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString length() and trim():\"); Serial.println(); } void loop() { // here's a String with empty spaces at the end (called white space): String stringOne = \"Hello! \"; Serial.print(stringOne); Serial.print(\"<--- end of string. Length: \"); Serial.println(stringOne.length()); // trim the white space off the string: stringOne.trim(); Serial.print(stringOne); Serial.print(\"<--- end of trimmed string. Length: \"); Serial.println(stringOne.length()); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.11 StringReplace Sketch Code /* String replace() Examples of how to replace characters or substrings of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringReplace */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString replace:\\n\"); Serial.println(); } void loop() { String stringOne = \"<html><head><body>\"; Serial.println(stringOne); // replace() changes all instances of one substring with another: // first, make a copy of the original string: String stringTwo = stringOne; // then perform the replacements: stringTwo.replace(\"<\", \"</\"); // print the original: Serial.println(\"Original string: \" + stringOne); // and print the modified string: Serial.println(\"Modified string: \" + stringTwo); // you can also use replace() on single characters: String normalString = \"bookkeeper\"; Serial.println(\"normal: \" + normalString); String leetString = normalString; leetString.replace('o', '0'); leetString.replace('e', '3'); Serial.println(\"l33tspeak: \" + leetString); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.12 StringStartsWithEndsWith Sketch Code /* String startWith() and endsWith() Examples of how to use startsWith() and endsWith() in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringStartsWithEndsWith */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString startsWith() and endsWith():\"); Serial.println(); } void loop() { // startsWith() checks to see if a String starts with a particular substring: String stringOne = \"HTTP/1.1 200 OK\"; Serial.println(stringOne); if (stringOne.startsWith(\"HTTP/1.1\")) { Serial.println(\"Server's using http version 1.1\"); } // you can also look for startsWith() at an offset position in the string: stringOne = \"HTTP/1.1 200 OK\"; if (stringOne.startsWith(\"200 OK\", 9)) { Serial.println(\"Got an OK from the server\"); } // endsWith() checks to see if a String ends with a particular character: String sensorReading = \"sensor = \"; sensorReading += analogRead(A0); Serial.print(sensorReading); if (sensorReading.endsWith(\"0\")) { Serial.println(\". This reading is divisible by ten\"); } else { Serial.println(\". This reading is not divisible by ten\"); } // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.13 StringSubstring Sketch Code /* String substring() Examples of how to use substring in a String created 27 Jul 2010, modified 2 Apr 2012 by Zach Eveland This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringSubstring */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString substring():\"); Serial.println(); } void loop() { // Set up a String: String stringOne = \"Content-Type: text/html\"; Serial.println(stringOne); // substring(index) looks for the substring from the index position to the end: if (stringOne.substring(19) == \"html\") { Serial.println(\"It's an html file\"); } // you can also look for a substring in the middle of a string: if (stringOne.substring(14, 18) == \"text\") { Serial.println(\"It's a text-based file\"); } // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.8.14 StringToint Sketch Code /* String to Integer conversion Reads a serial input string until it sees a newline, then converts the string to a number if the characters are digits. The circuit: - No external components needed. created 29 Nov 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringToInt */ String inString = \"\"; // string to hold input void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString toInt():\"); Serial.println(); } void loop() { // Read serial input: while (Serial.available() > 0) { int inChar = Serial.read(); if (isDigit(inChar)) { // convert the incoming byte to a char and add it to the string: inString += (char)inChar; } // if you get a newline, print the string, then the string's value: if (inChar == '\\n') { Serial.print(\"Value:\"); Serial.println(inString.toInt()); Serial.print(\"String: \"); Serial.println(inString); // clear the string for new input: inString = \"\"; } } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration Section 4.9: 09.USB Examples 4.9.1 KeyboardLayout Sketch Code /* Keyboard logout This sketch demonstrates the Keyboard library. When you connect pin 2 to ground, it performs a logout. It uses keyboard combinations to do this, as follows: On Windows, CTRL-ALT-DEL followed by ALT-l On Ubuntu, CTRL-ALT-DEL, and ENTER On OSX, CMD-SHIFT-q To wake: Spacebar. Circuit: - Arduino Leonardo or Micro - wire to connect D2 to ground created 6 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardLogout */ #define OSX 0 #define WINDOWS 1 #define UBUNTU 2 #include \"Keyboard.h\" // change this to match your platform: int platform = OSX; void setup() { // make pin 2 an input and turn on the pull-up resistor so it goes high unless // connected to ground: pinMode(2, INPUT_PULLUP); Keyboard.begin(); } void loop() { while (digitalRead(2) == HIGH) { // do nothing until pin 2 goes low delay(500); } delay(1000); switch (platform) { case OSX: Keyboard.press(KEY_LEFT_GUI); // Shift-Q logs out: Keyboard.press(KEY_LEFT_SHIFT); Keyboard.press('Q'); delay(100); Keyboard.releaseAll(); // enter: Keyboard.write(KEY_RETURN); break; case WINDOWS: // CTRL-ALT-DEL: Keyboard.press(KEY_LEFT_CTRL); Keyboard.press(KEY_LEFT_ALT); Keyboard.press(KEY_DELETE); delay(100); Keyboard.releaseAll(); // ALT-l: delay(2000); Keyboard.press(KEY_LEFT_ALT); Keyboard.press('l'); Keyboard.releaseAll(); break; case UBUNTU: // CTRL-ALT-DEL: Keyboard.press(KEY_LEFT_CTRL); Keyboard.press(KEY_LEFT_ALT); Keyboard.press(KEY_DELETE); delay(1000); Keyboard.releaseAll(); // Enter to confirm logout: Keyboard.write(KEY_RETURN); break; } // do nothing: while (true) ; } Fritzing Circuit KiCad Schematic Video Demonstration 4.9.2 KeyboardMessage Sketch Code /* Keyboard Message test For the Arduino Leonardo and Micro. Sends a text string when a button is pressed. The circuit: - pushbutton attached from pin 4 to +5V - 10 kilohm resistor attached from pin 4 to ground created 24 Oct 2011 modified 27 Mar 2012 by Tom Igoe modified 11 Nov 2013 by Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardMessage */ #include \"Keyboard.h\" const int buttonPin = 4; // input pin for pushbutton int previousButtonState = HIGH; // for checking the state of a pushButton int counter = 0; // button push counter void setup() { // make the pushButton pin an input: pinMode(buttonPin, INPUT); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // read the pushbutton: int buttonState = digitalRead(buttonPin); // if the button state has changed, if ((buttonState != previousButtonState) // and it's currently pressed: && (buttonState == HIGH)) { // increment the button counter counter++; // type out a message Keyboard.print(\"You pressed the button \"); Keyboard.print(counter); Keyboard.println(\" times.\"); } // save the current button state for comparison next time: previousButtonState = buttonState; } Fritzing Circuit Same as Example DigitalReadSerial KiCad Schematic Same as Example DigitalReadSerial Video Demonstration 4.9.3 KeyboardReprogram Sketch Code /* Arduino Programs Blink This sketch demonstrates the Keyboard library. For Leonardo and Due boards only. When you connect pin 2 to ground, it creates a new window with a key combination (CTRL-N), then types in the Blink sketch, then auto-formats the text using another key combination (CTRL-T), then uploads the sketch to the currently selected Arduino using a final key combination (CTRL-U). Circuit: - Arduino Leonardo, Micro, Due, LilyPad USB, or Y\u00fan - wire to connect D2 to ground created 5 Mar 2012 modified 29 Mar 2012 by Tom Igoe modified 3 May 2014 by Scott Fitzgerald This example is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardReprogram */ #include \"Keyboard.h\" // use this option for OSX. // Comment it out if using Windows or Linux: char ctrlKey = KEY_LEFT_GUI; // use this option for Windows and Linux. // leave commented out if using OSX: // char ctrlKey = KEY_LEFT_CTRL; void setup() { // make pin 2 an input and turn on the pull-up resistor so it goes high unless // connected to ground: pinMode(2, INPUT_PULLUP); // initialize control over the keyboard: Keyboard.begin(); } void loop() { while (digitalRead(2) == HIGH) { // do nothing until pin 2 goes low delay(500); } delay(1000); // new document: Keyboard.press(ctrlKey); Keyboard.press('n'); delay(100); Keyboard.releaseAll(); // wait for new window to open: delay(1000); // versions of the Arduino IDE after 1.5 pre-populate new sketches with // setup() and loop() functions let's clear the window before typing anything new // select all Keyboard.press(ctrlKey); Keyboard.press('a'); delay(500); Keyboard.releaseAll(); // delete the selected text Keyboard.write(KEY_BACKSPACE); delay(500); // Type out \"blink\": Keyboard.println(\"void setup() {\"); Keyboard.println(\"pinMode(13, OUTPUT);\"); Keyboard.println(\"}\"); Keyboard.println(); Keyboard.println(\"void loop() {\"); Keyboard.println(\"digitalWrite(13, HIGH);\"); Keyboard.print(\"delay(3000);\"); // 3000 ms is too long. Delete it: for (int keystrokes = 0; keystrokes < 6; keystrokes++) { delay(500); Keyboard.write(KEY_BACKSPACE); } // make it 1000 instead: Keyboard.println(\"1000);\"); Keyboard.println(\"digitalWrite(13, LOW);\"); Keyboard.println(\"delay(1000);\"); Keyboard.println(\"}\"); // tidy up: Keyboard.press(ctrlKey); Keyboard.press('t'); delay(100); Keyboard.releaseAll(); delay(3000); // upload code: Keyboard.press(ctrlKey); Keyboard.press('u'); delay(100); Keyboard.releaseAll(); // wait for the sweet oblivion of reprogramming: while (true) ; } Fritzing Circuit Same as Example KeyboardLayout KiCad Schematic Same as Example KeyboardLayout Video Demonstration 4.9.4 KeyboardSerial Sketch Code /* Keyboard test For the Arduino Leonardo, Micro or Due Reads a byte from the serial port, sends a keystroke back. The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send A you get B, and so forth. The circuit: - none created 21 Oct 2011 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardSerial */ #include \"Keyboard.h\" void setup() { // open the serial port: Serial.begin(9600); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // check for incoming serial data: if (Serial.available() > 0) { // read incoming serial data: char inChar = Serial.read(); // Type the next ASCII value from what you received: Keyboard.write(inChar + 1); } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration 4.9.5 ButtonMouseControl Sketch Code /* ButtonMouseControl For Leonardo and Due boards only. Controls the mouse from five pushbuttons on an Arduino Leonardo, Micro or Due. Hardware: - five pushbuttons attached to D2, D3, D4, D5, D6 The mouse movement is always relative. This sketch reads four pushbuttons, and uses them to set the movement of the mouse. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the mouse commands. created 15 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ButtonMouseControl */ #include \"Mouse.h\" // set pin numbers for the five buttons: const int upButton = 2; const int downButton = 3; const int leftButton = 4; const int rightButton = 5; const int mouseButton = 6; int range = 5; // output range of X or Y movement; affects movement speed int responseDelay = 10; // response delay of the mouse, in ms void setup() { // initialize the buttons' inputs: pinMode(upButton, INPUT); pinMode(downButton, INPUT); pinMode(leftButton, INPUT); pinMode(rightButton, INPUT); pinMode(mouseButton, INPUT); // initialize mouse control: Mouse.begin(); } void loop() { // read the buttons: int upState = digitalRead(upButton); int downState = digitalRead(downButton); int rightState = digitalRead(rightButton); int leftState = digitalRead(leftButton); int clickState = digitalRead(mouseButton); // calculate the movement distance based on the button states: int xDistance = (leftState - rightState) * range; int yDistance = (upState - downState) * range; // if X or Y is non-zero, move: if ((xDistance != 0) || (yDistance != 0)) { Mouse.move(xDistance, yDistance, 0); } // if the mouse button is pressed: if (clickState == HIGH) { // if the mouse is not pressed, press it: if (!Mouse.isPressed(MOUSE_LEFT)) { Mouse.press(MOUSE_LEFT); } } // else the mouse button is not pressed: else { // if the mouse is pressed, release it: if (Mouse.isPressed(MOUSE_LEFT)) { Mouse.release(MOUSE_LEFT); } } // a delay so the mouse doesn't move too fast: delay(responseDelay); } Fritzing Circuit Same as Example KeyboardAndMouseControl KiCad Schematic Same as Example KeyboardAndMouseControl Video Demonstration 4.9.6 JoystickMouseControl Sketch Code /* JoystickMouseControl Controls the mouse from a joystick on an Arduino Leonardo, Micro or Due. Uses a pushbutton to turn on and off mouse control, and a second pushbutton to click the left mouse button. Hardware: - 2-axis joystick connected to pins A0 and A1 - pushbuttons connected to pin D2 and D3 The mouse movement is always relative. This sketch reads two analog inputs that range from 0 to 1023 (or less on either end) and translates them into ranges of -6 to 6. The sketch assumes that the joystick resting values are around the middle of the range, but that they vary within a threshold. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the command. This sketch includes a pushbutton to toggle the mouse control state, so you can turn on and off mouse control. created 15 Sep 2011 updated 28 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/JoystickMouseControl */ #include \"Mouse.h\" // set pin numbers for switch, joystick axes, and LED: const int switchPin = 2; // switch to turn on and off mouse control const int mouseButton = 3; // input pin for the mouse pushButton const int xAxis = A0; // joystick X axis const int yAxis = A1; // joystick Y axis const int ledPin = 5; // Mouse control LED // parameters for reading the joystick: int range = 12; // output range of X or Y movement int responseDelay = 5; // response delay of the mouse, in ms int threshold = range / 4; // resting threshold int center = range / 2; // resting position value bool mouseIsActive = false; // whether or not to control the mouse int lastSwitchState = LOW; // previous switch state void setup() { pinMode(switchPin, INPUT); // the switch pin pinMode(ledPin, OUTPUT); // the LED pin // take control of the mouse: Mouse.begin(); } void loop() { // read the switch: int switchState = digitalRead(switchPin); // if it's changed and it's high, toggle the mouse state: if (switchState != lastSwitchState) { if (switchState == HIGH) { mouseIsActive = !mouseIsActive; // turn on LED to indicate mouse state: digitalWrite(ledPin, mouseIsActive); } } // save switch state for next comparison: lastSwitchState = switchState; // read and scale the two axes: int xReading = readAxis(A0); int yReading = readAxis(A1); // if the mouse control state is active, move the mouse: if (mouseIsActive) { Mouse.move(xReading, yReading, 0); } // read the mouse button and click or not click: // if the mouse button is pressed: if (digitalRead(mouseButton) == HIGH) { // if the mouse is not pressed, press it: if (!Mouse.isPressed(MOUSE_LEFT)) { Mouse.press(MOUSE_LEFT); } } // else the mouse button is not pressed: else { // if the mouse is pressed, release it: if (Mouse.isPressed(MOUSE_LEFT)) { Mouse.release(MOUSE_LEFT); } } delay(responseDelay); } /* reads an axis (0 or 1 for x or y) and scales the analog input range to a range from 0 to <range> */ int readAxis(int thisAxis) { // read the analog input: int reading = analogRead(thisAxis); // map the reading from the analog input range to the output range: reading = map(reading, 0, 1023, 0, range); // if the output reading is outside from the rest position threshold, use it: int distance = reading - center; if (abs(distance) < threshold) { distance = 0; } // return the distance for this axis: return distance; } Fritzing Circuit KiCad Schematic Video Demonstration 4.9.7 KeyboardAndMouseControl Sketch Code /* KeyboardAndMouseControl Controls the mouse from five pushbuttons on an Arduino Leonardo, Micro or Due. Hardware: - five pushbuttons attached to D2, D3, D4, D5, D6 The mouse movement is always relative. This sketch reads four pushbuttons, and uses them to set the movement of the mouse. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the mouse commands. created 15 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardAndMouseControl */ #include \"Keyboard.h\" #include \"Mouse.h\" // set pin numbers for the five buttons: const int upButton = 2; const int downButton = 3; const int leftButton = 4; const int rightButton = 5; const int mouseButton = 6; void setup() { // initialize the buttons' inputs: pinMode(upButton, INPUT); pinMode(downButton, INPUT); pinMode(leftButton, INPUT); pinMode(rightButton, INPUT); pinMode(mouseButton, INPUT); Serial.begin(9600); // initialize mouse control: Mouse.begin(); Keyboard.begin(); } void loop() { // use serial input to control the mouse: if (Serial.available() > 0) { char inChar = Serial.read(); switch (inChar) { case 'u': // move mouse up Mouse.move(0, -40); break; case 'd': // move mouse down Mouse.move(0, 40); break; case 'l': // move mouse left Mouse.move(-40, 0); break; case 'r': // move mouse right Mouse.move(40, 0); break; case 'm': // perform mouse left click Mouse.click(MOUSE_LEFT); break; } } // use the pushbuttons to control the keyboard: if (digitalRead(upButton) == HIGH) { Keyboard.write('u'); } if (digitalRead(downButton) == HIGH) { Keyboard.write('d'); } if (digitalRead(leftButton) == HIGH) { Keyboard.write('l'); } if (digitalRead(rightButton) == HIGH) { Keyboard.write('r'); } if (digitalRead(mouseButton) == HIGH) { Keyboard.write('m'); } } Fritzing Circuit KiCad Schematic Video Demonstration Section 4.10: 10.StarterKit_BasicKit Examples Note ALL examples for this Section 4.10 are directly referenced from Programming in Arduino . 4.10.1 p02_SpaceshipInterface Sketch Code /* Arduino Starter Kit example Project 2 - Spaceship Interface This sketch is written to accompany Project 2 in the Arduino Starter Kit Parts required: - one green LED - two red LEDs - pushbutton - 10 kilohm resistor - three 220 ohm resistors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/02/29/project-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // Create a global variable to hold the state of the switch. This variable is // persistent throughout the program. Whenever you refer to switchState, you\u2019re // talking about the number it holds int switchstate = 0; void setup() { // declare the LED pins as outputs pinMode(3, OUTPUT); pinMode(4, OUTPUT); pinMode(5, OUTPUT); // declare the switch pin as an input pinMode(2, INPUT); } void loop() { // read the value of the switch // digitalRead() checks to see if there is voltage on the pin or not switchstate = digitalRead(2); // if the button is not pressed turn on the green LED and off the red LEDs if (switchstate == LOW) { digitalWrite(3, HIGH); // turn the green LED on pin 3 on digitalWrite(4, LOW); // turn the red LED on pin 4 off digitalWrite(5, LOW); // turn the red LED on pin 5 off } // this else is part of the above if() statement. // if the switch is not LOW (the button is pressed) turn off the green LED and // blink alternatively the red LEDs else { digitalWrite(3, LOW); // turn the green LED on pin 3 off digitalWrite(4, LOW); // turn the red LED on pin 4 off digitalWrite(5, HIGH); // turn the red LED on pin 5 on // wait for a quarter second before changing the light delay(250); digitalWrite(4, HIGH); // turn the red LED on pin 4 on digitalWrite(5, LOW); // turn the red LED on pin 5 off // wait for a quarter second before changing the light delay(250); } } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.2 p03_LoveOMeter Sketch Code /* Arduino Starter Kit example Project 3 - Love-O-Meter This sketch is written to accompany Project 3 in the Arduino Starter Kit Parts required: - one TMP36 temperature sensor - three red LEDs - three 220 ohm resistors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/02/29/projecte-3/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constant for the pin the sensor is connected to const int sensorPin = A0; // room temperature in Celsius const float baselineTemp = 20.0; void setup() { // open a serial connection to display values Serial.begin(9600); // set the LED pins as outputs // the for() loop saves some extra coding for (int pinNumber = 2; pinNumber < 5; pinNumber++) { pinMode(pinNumber, OUTPUT); digitalWrite(pinNumber, LOW); } } void loop() { // read the value on AnalogIn pin 0 and store it in a variable int sensorVal = analogRead(sensorPin); // send the 10-bit sensor value out the serial port Serial.print(\"sensor Value: \"); Serial.print(sensorVal); // convert the ADC reading to voltage float voltage = (sensorVal / 1024.0) * 5.0; // Send the voltage level out the Serial port Serial.print(\", Volts: \"); Serial.print(voltage); // convert the voltage to temperature in degrees C // the sensor changes 10 mV per degree // the datasheet says there's a 500 mV offset // ((voltage - 500 mV) times 100) Serial.print(\", degrees C: \"); float temperature = (voltage - .5) * 100; Serial.println(temperature); // if the current temperature is lower than the baseline turn off all LEDs if (temperature < baselineTemp + 2) { digitalWrite(2, LOW); digitalWrite(3, LOW); digitalWrite(4, LOW); } // if the temperature rises 2-4 degrees, turn an LED on else if (temperature >= baselineTemp + 2 && temperature < baselineTemp + 4) { digitalWrite(2, HIGH); digitalWrite(3, LOW); digitalWrite(4, LOW); } // if the temperature rises 4-6 degrees, turn a second LED on else if (temperature >= baselineTemp + 4 && temperature < baselineTemp + 6) { digitalWrite(2, HIGH); digitalWrite(3, HIGH); digitalWrite(4, LOW); } // if the temperature rises more than 6 degrees, turn all LEDs on else if (temperature >= baselineTemp + 6) { digitalWrite(2, HIGH); digitalWrite(3, HIGH); digitalWrite(4, HIGH); } delay(1); } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.3 p04_ColorMixingLamp Sketch Code /* Arduino Starter Kit example Project 4 - Color Mixing Lamp This sketch is written to accompany Project 3 in the Arduino Starter Kit Parts required: - one RGB LED - three 10 kilohm resistors - three 220 ohm resistors - three photoresistors - red green and blue colored gels created 13 Sep 2012 modified 14 Nov 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/01/project-04/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int greenLEDPin = 9; // LED connected to digital pin 9 const int redLEDPin = 10; // LED connected to digital pin 10 const int blueLEDPin = 11; // LED connected to digital pin 11 const int redSensorPin = A0; // pin with the photoresistor with the red gel const int greenSensorPin = A1; // pin with the photoresistor with the green gel const int blueSensorPin = A2; // pin with the photoresistor with the blue gel int redValue = 0; // value to write to the red LED int greenValue = 0; // value to write to the green LED int blueValue = 0; // value to write to the blue LED int redSensorValue = 0; // variable to hold the value from the red sensor int greenSensorValue = 0; // variable to hold the value from the green sensor int blueSensorValue = 0; // variable to hold the value from the blue sensor void setup() { // initialize serial communications at 9600 bps: Serial.begin(9600); // set the digital pins as outputs pinMode(greenLEDPin, OUTPUT); pinMode(redLEDPin, OUTPUT); pinMode(blueLEDPin, OUTPUT); } void loop() { // Read the sensors first: // read the value from the red-filtered photoresistor: redSensorValue = analogRead(redSensorPin); // give the ADC a moment to settle delay(5); // read the value from the green-filtered photoresistor: greenSensorValue = analogRead(greenSensorPin); // give the ADC a moment to settle delay(5); // read the value from the blue-filtered photoresistor: blueSensorValue = analogRead(blueSensorPin); // print out the values to the Serial Monitor Serial.print(\"raw sensor Values \\t red: \"); Serial.print(redSensorValue); Serial.print(\"\\t green: \"); Serial.print(greenSensorValue); Serial.print(\"\\t Blue: \"); Serial.println(blueSensorValue); /* In order to use the values from the sensor for the LED, you need to do some math. The ADC provides a 10-bit number, but analogWrite() uses 8 bits. You'll want to divide your sensor readings by 4 to keep them in range of the output. */ redValue = redSensorValue / 4; greenValue = greenSensorValue / 4; blueValue = blueSensorValue / 4; // print out the mapped values Serial.print(\"Mapped sensor Values \\t red: \"); Serial.print(redValue); Serial.print(\"\\t green: \"); Serial.print(greenValue); Serial.print(\"\\t Blue: \"); Serial.println(blueValue); /* Now that you have a usable value, it's time to PWM the LED. */ analogWrite(redLEDPin, redValue); analogWrite(greenLEDPin, greenValue); analogWrite(blueLEDPin, blueValue); } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.4 p05_ServoMoodIndicator Sketch Code /* Arduino Starter Kit example Project 5 - Servo Mood Indicator This sketch is written to accompany Project 5 in the Arduino Starter Kit Parts required: - servo motor - 10 kilohm potentiometer - two 100 uF electrolytic capacitors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/01/project-05/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // include the Servo library #include <Servo.h> Servo myServo; // create a servo object int const potPin = A0; // analog pin used to connect the potentiometer int potVal; // variable to read the value from the analog pin int angle; // variable to hold the angle for the servo motor void setup() { myServo.attach(9); // attaches the servo on pin 9 to the servo object Serial.begin(9600); // open a serial connection to your computer } void loop() { potVal = analogRead(potPin); // read the value of the potentiometer // print out the value to the Serial Monitor Serial.print(\"potVal: \"); Serial.print(potVal); // scale the numbers from the pot angle = map(potVal, 0, 1023, 0, 179); // print out the angle for the servo motor Serial.print(\", angle: \"); Serial.println(angle); // set the servo position myServo.write(angle); // wait for the servo to get there delay(15); } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.5 p06_LightTheremin Sketch Code /* Arduino Starter Kit example Project 6 - Light Theremin This sketch is written to accompany Project 6 in the Arduino Starter Kit Parts required: - photoresistor - 10 kilohm resistor - piezo created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/02/project-06/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // variable to hold sensor value int sensorValue; // variable to calibrate low value int sensorLow = 1023; // variable to calibrate high value int sensorHigh = 0; // LED pin const int ledPin = 13; void setup() { // Make the LED pin an output and turn it on pinMode(ledPin, OUTPUT); digitalWrite(ledPin, HIGH); // calibrate for the first five seconds after program runs while (millis() < 5000) { // record the maximum sensor value sensorValue = analogRead(A0); if (sensorValue > sensorHigh) { sensorHigh = sensorValue; } // record the minimum sensor value if (sensorValue < sensorLow) { sensorLow = sensorValue; } } // turn the LED off, signaling the end of the calibration period digitalWrite(ledPin, LOW); } void loop() { //read the input from A0 and store it in a variable sensorValue = analogRead(A0); // map the sensor values to a wide range of pitches int pitch = map(sensorValue, sensorLow, sensorHigh, 50, 4000); // play the tone for 20 ms on pin 8 tone(8, pitch, 20); // wait for a moment delay(10); } Fritzing Circuit Similar to Example tonePitchFollower , but use pin 8 instead of pin 9 . KiCad Schematic Similar to Example tonePitchFollower , but use pin 8 instead of pin 9 . Video Demonstration 4.10.6 p07_Keyboard Sketch Code /* Arduino Starter Kit example Project 7 - Keyboard This sketch is written to accompany Project 7 in the Arduino Starter Kit Parts required: - two 10 kilohm resistors - 1 megohm resistor - 220 ohm resistor - four pushbuttons - piezo created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/02/project-07/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // create an array of notes // the numbers below correspond to the frequencies of middle C, D, E, and F int notes[] = { 262, 294, 330, 349 }; void setup() { //start serial communication Serial.begin(9600); } void loop() { // create a local variable to hold the input on pin A0 int keyVal = analogRead(A0); // send the value from A0 to the Serial Monitor Serial.println(keyVal); // play the note corresponding to each value on A0 if (keyVal == 1023) { // play the first frequency in the array on pin 8 tone(8, notes[0]); } else if (keyVal >= 990 && keyVal <= 1010) { // play the second frequency in the array on pin 8 tone(8, notes[1]); } else if (keyVal >= 505 && keyVal <= 515) { // play the third frequency in the array on pin 8 tone(8, notes[2]); } else if (keyVal >= 5 && keyVal <= 10) { // play the fourth frequency in the array on pin 8 tone(8, notes[3]); } else { // if the value is out of range, play no tone noTone(8); } } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.7 p08_DigitalHourglass Sketch Code /* Arduino Starter Kit example Project 8 - Digital Hourglass This sketch is written to accompany Project 8 in the Arduino Starter Kit Parts required: - 10 kilohm resistor - six 220 ohm resistors - six LEDs - tilt switch created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/03/project-08-digital-hourglass/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constant for the switch pin const int switchPin = 8; unsigned long previousTime = 0; // store the last time an LED was updated int switchState = 0; // the current switch state int prevSwitchState = 0; // the previous switch state int led = 2; // a variable to refer to the LEDs // 600000 = 10 minutes in milliseconds long interval = 600000; // interval at which to light the next LED void setup() { // set the LED pins as outputs for (int x = 2; x < 8; x++) { pinMode(x, OUTPUT); } // set the tilt switch pin as input pinMode(switchPin, INPUT); } void loop() { // store the time since the Arduino started running in a variable unsigned long currentTime = millis(); // compare the current time to the previous time an LED turned on // if it is greater than your interval, run the if statement if (currentTime - previousTime > interval) { // save the current time as the last time you changed an LED previousTime = currentTime; // Turn the LED on digitalWrite(led, HIGH); // increment the led variable // in 10 minutes the next LED will light up led++; if (led == 7) { // the hour is up } } // read the switch value switchState = digitalRead(switchPin); // if the switch has changed if (switchState != prevSwitchState) { // turn all the LEDs low for (int x = 2; x < 8; x++) { digitalWrite(x, LOW); } // reset the LED variable to the first one led = 2; //reset the timer previousTime = currentTime; } // set the previous switch state to the current state prevSwitchState = switchState; } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.8 p09_MotorizedPinwheel Sketch Code /* Arduino Starter Kit example Project 9 - Motorized Pinwheel This sketch is written to accompany Project 9 in the Arduino Starter Kit Parts required: - 10 kilohm resistor - pushbutton - motor - 9V battery - IRF520 MOSFET - 1N4007 diode created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/04/project-10-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constants for the switch and motor pins const int switchPin = 2; // the number of the switch pin const int motorPin = 9; // the number of the motor pin int switchState = 0; // variable for reading the switch's status void setup() { // initialize the motor pin as an output: pinMode(motorPin, OUTPUT); // initialize the switch pin as an input: pinMode(switchPin, INPUT); } void loop() { // read the state of the switch value: switchState = digitalRead(switchPin); // check if the switch is pressed. if (switchState == HIGH) { // turn motor on: digitalWrite(motorPin, HIGH); } else { // turn motor off: digitalWrite(motorPin, LOW); } } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.9 p10_Zoetrope Description This examples deals with H-bridge using the integrated circuit SN754410 . Some external references are recommended to read: DC Motor Control Using an H-Bridge El puente H: Invirtiendo el sentido de giro de un motor con Arduino in Spanish Sketch Code /* Arduino Starter Kit example Project 10 - Zoetrope This sketch is written to accompany Project 10 in the Arduino Starter Kit Parts required: - two 10 kilohm resistors - two momentary pushbuttons - one 10 kilohm potentiometer - motor - 9V battery - H-Bridge created 13 Sep 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/05/project-11/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int controlPin1 = 2; // connected to pin 7 on the H-bridge const int controlPin2 = 3; // connected to pin 2 on the H-bridge const int enablePin = 9; // connected to pin 1 on the H-bridge const int directionSwitchPin = 4; // connected to the switch for direction const int onOffSwitchStateSwitchPin = 5; // connected to the switch for turning the motor on and off const int potPin = A0; // connected to the potentiometer's output // create some variables to hold values from your inputs int onOffSwitchState = 0; // current state of the on/off switch int previousOnOffSwitchState = 0; // previous position of the on/off switch int directionSwitchState = 0; // current state of the direction switch int previousDirectionSwitchState = 0; // previous state of the direction switch int motorEnabled = 0; // Turns the motor on/off int motorSpeed = 0; // speed of the motor int motorDirection = 1; // current direction of the motor void setup() { // initialize the inputs and outputs pinMode(directionSwitchPin, INPUT); pinMode(onOffSwitchStateSwitchPin, INPUT); pinMode(controlPin1, OUTPUT); pinMode(controlPin2, OUTPUT); pinMode(enablePin, OUTPUT); // pull the enable pin LOW to start digitalWrite(enablePin, LOW); } void loop() { // read the value of the on/off switch onOffSwitchState = digitalRead(onOffSwitchStateSwitchPin); delay(1); // read the value of the direction switch directionSwitchState = digitalRead(directionSwitchPin); // read the value of the pot and divide by 4 to get a value that can be // used for PWM motorSpeed = analogRead(potPin) / 4; // if the on/off button changed state since the last loop() if (onOffSwitchState != previousOnOffSwitchState) { // change the value of motorEnabled if pressed if (onOffSwitchState == HIGH) { motorEnabled = !motorEnabled; } } // if the direction button changed state since the last loop() if (directionSwitchState != previousDirectionSwitchState) { // change the value of motorDirection if pressed if (directionSwitchState == HIGH) { motorDirection = !motorDirection; } } // change the direction the motor spins by talking to the control pins // on the H-Bridge if (motorDirection == 1) { digitalWrite(controlPin1, HIGH); digitalWrite(controlPin2, LOW); } else { digitalWrite(controlPin1, LOW); digitalWrite(controlPin2, HIGH); } // if the motor is supposed to be on if (motorEnabled == 1) { // PWM the enable pin to vary the speed analogWrite(enablePin, motorSpeed); } else { // if the motor is not supposed to be on //turn the motor off analogWrite(enablePin, 0); } // save the current on/off switch state as the previous previousDirectionSwitchState = directionSwitchState; // save the current switch state as the previous previousOnOffSwitchState = onOffSwitchState; } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.10 p11_CrystalBall Sketch Code /* Arduino Starter Kit example Project 11 - Crystal Ball This sketch is written to accompany Project 11 in the Arduino Starter Kit Parts required: - 220 ohm resistor - 10 kilohm resistor - 10 kilohm potentiometer - 16x2 LCD screen - tilt switch created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/05/project-12/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // include the library code: #include <LiquidCrystal.h> // initialize the library with the numbers of the interface pins LiquidCrystal lcd(12, 11, 5, 4, 3, 2); // set up a constant for the tilt switch pin const int switchPin = 6; // variable to hold the value of the switch pin int switchState = 0; // variable to hold previous value of the switch pin int prevSwitchState = 0; // a variable to choose which reply from the crystal ball int reply; void setup() { // set up the number of columns and rows on the LCD lcd.begin(16, 2); // set up the switch pin as an input pinMode(switchPin, INPUT); // Print a message to the LCD. lcd.print(\"Ask the\"); // set the cursor to column 0, line 1 // line 1 is the second row, since counting begins with 0 lcd.setCursor(0, 1); // print to the second line lcd.print(\"Crystal Ball!\"); } void loop() { // check the status of the switch switchState = digitalRead(switchPin); // compare the switchState to its previous state if (switchState != prevSwitchState) { // if the state has changed from HIGH to LOW you know that the ball has been // tilted from one direction to the other if (switchState == LOW) { // randomly chose a reply reply = random(8); // clean up the screen before printing a new reply lcd.clear(); // set the cursor to column 0, line 0 lcd.setCursor(0, 0); // print some text lcd.print(\"the ball says:\"); // move the cursor to the second line lcd.setCursor(0, 1); // choose a saying to print based on the value in reply switch (reply) { case 0: lcd.print(\"Yes\"); break; case 1: lcd.print(\"Most likely\"); break; case 2: lcd.print(\"Certainly\"); break; case 3: lcd.print(\"Outlook good\"); break; case 4: lcd.print(\"Unsure\"); break; case 5: lcd.print(\"Ask again\"); break; case 6: lcd.print(\"Doubtful\"); break; case 7: lcd.print(\"No\"); break; } } } // save the current switch state as the last state prevSwitchState = switchState; } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.11 p12_KnockLock Sketch Code /* Arduino Starter Kit example Project 12 - Knock Lock This sketch is written to accompany Project 12 in the Arduino Starter Kit Parts required: - 1 megohm resistor - 10 kilohm resistor - three 220 ohm resistors - piezo - servo motor - push button - one red LED - one yellow LED - one green LED - 100 uF capacitor created 18 Sep 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/06/project-13/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // import the library #include <Servo.h> // create an instance of the Servo library Servo myServo; const int piezo = A0; // pin the piezo is attached to const int switchPin = 2; // pin the switch is attached to const int yellowLed = 3; // pin the yellow LED is attached to const int greenLed = 4; // pin the green LED is attached to const int redLed = 5; // pin the red LED is attached to // variable for the piezo value int knockVal; // variable for the switch value int switchVal; // variables for the high and low limits of the knock value const int quietKnock = 10; const int loudKnock = 100; // variable to indicate if locked or not bool locked = false; // how many valid knocks you've received int numberOfKnocks = 0; void setup() { // attach the servo to pin 9 myServo.attach(9); // make the LED pins outputs pinMode(yellowLed, OUTPUT); pinMode(redLed, OUTPUT); pinMode(greenLed, OUTPUT); // set the switch pin as an input pinMode(switchPin, INPUT); // start serial communication for debugging Serial.begin(9600); // turn the green LED on digitalWrite(greenLed, HIGH); // move the servo to the unlocked position myServo.write(0); // print status to the Serial Monitor Serial.println(\"the box is unlocked!\"); } void loop() { // if the box is unlocked if (locked == false) { // read the value of the switch pin switchVal = digitalRead(switchPin); // if the button is pressed, lock the box if (switchVal == HIGH) { // set the locked variable to \"true\" locked = true; // change the status LEDs digitalWrite(greenLed, LOW); digitalWrite(redLed, HIGH); // move the servo to the locked position myServo.write(90); // print out status Serial.println(\"the box is locked!\"); // wait for the servo to move into position delay(1000); } } // if the box is locked if (locked == true) { // check the value of the piezo knockVal = analogRead(piezo); // if there are not enough valid knocks if (numberOfKnocks < 3 && knockVal > 0) { // check to see if the knock is in range if (checkForKnock(knockVal) == true) { // increment the number of valid knocks numberOfKnocks++; } // print status of knocks Serial.print(3 - numberOfKnocks); Serial.println(\" more knocks to go\"); } // if there are three knocks if (numberOfKnocks >= 3) { // unlock the box locked = false; // move the servo to the unlocked position myServo.write(0); // wait for it to move delay(20); // change status LEDs digitalWrite(greenLed, HIGH); digitalWrite(redLed, LOW); Serial.println(\"the box is unlocked!\"); numberOfKnocks = 0; } } } // this function checks to see if a detected knock is within max and min range bool checkForKnock(int value) { // if the value of the knock is greater than the minimum, and larger // than the maximum if (value > quietKnock && value < loudKnock) { // turn the status LED on digitalWrite(yellowLed, HIGH); delay(50); digitalWrite(yellowLed, LOW); // print out the status Serial.print(\"Valid knock of value \"); Serial.println(value); // return true return true; } // if the knock is not within range else { // print status Serial.print(\"Bad knock value \"); Serial.println(value); // return false return false; } } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.12 p13_TouchSensorLamp Sketch Code /* Arduino Starter Kit example Project 13 - Touch Sensor Lamp This sketch is written to accompany Project 13 in the Arduino Starter Kit Parts required: - 1 megohm resistor - metal foil or copper mesh - 220 ohm resistor - LED Software required : - CapacitiveSensor library by Paul Badger https://www.arduino.cc/reference/en/libraries/capacitivesensor/ created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/06/project-14/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // import the library (must be located in the Arduino/libraries directory) #include <CapacitiveSensor.h> // create an instance of the library // pin 4 sends electrical energy // pin 2 senses senses a change CapacitiveSensor capSensor = CapacitiveSensor(4, 2); // threshold for turning the lamp on int threshold = 1000; // pin the LED is connected to const int ledPin = 12; void setup() { // open a serial connection Serial.begin(9600); // set the LED pin as an output pinMode(ledPin, OUTPUT); } void loop() { // store the value reported by the sensor in a variable long sensorValue = capSensor.capacitiveSensor(30); // print out the sensor value Serial.println(sensorValue); // if the value is greater than the threshold if (sensorValue > threshold) { // turn the LED on digitalWrite(ledPin, HIGH); } // if it's lower than the threshold else { // turn the LED off digitalWrite(ledPin, LOW); } delay(10); } Fritzing Circuit KiCad Schematic Video Demonstration 4.10.13 p14_TweakTheArduinoLogo Sketch Code /* Arduino Starter Kit example Project 14 - Tweak the Arduino Logo This sketch is written to accompany Project 14 in the Arduino Starter Kit Parts required: - 10 kilohm potentiometer Software required: - Processing (3.0 or newer) https://processing.org/ - Active Internet connection created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/08/project-14-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ void setup() { // initialize serial communication Serial.begin(9600); } void loop() { // read the value of A0, divide by 4 and send it as a byte over the // serial connection Serial.write(analogRead(A0) / 4); delay(1); } /* Processing code for this example // Tweak the Arduino Logo // by Scott Fitzgerald // This example code is in the public domain. // import the serial library import processing.serial.*; // create an instance of the serial library Serial myPort; // create an instance of PImage PImage logo; // a variable to hold the background color int bgcolor = 0; void setup() { size(1, 1); surface.setResizable(true); // set the color mode to Hue/Saturation/Brightness colorMode(HSB, 255); // load the Arduino logo into the PImage instance logo = loadImage(\"http://www.arduino.cc/arduino_logo.png\"); // make the window the same size as the image surface.setSize(logo.width, logo.height); // print a list of available serial ports to the Processing status window println(\"Available serial ports:\"); println(Serial.list()); // Tell the serial object the information it needs to communicate with the // Arduino. Change Serial.list()[0] to the correct port corresponding to // your Arduino board. The last parameter (e.g. 9600) is the speed of the // communication. It has to correspond to the value passed to // Serial.begin() in your Arduino sketch. myPort = new Serial(this, Serial.list()[0], 9600); // If you know the name of the port used by the Arduino board, you can // specify it directly like this. // port = new Serial(this, \"COM1\", 9600); } void draw() { // if there is information in the serial port if ( myPort.available() > 0) { // read the value and store it in a variable bgcolor = myPort.read(); // print the value to the status window println(bgcolor); } // Draw the background. the variable bgcolor contains the Hue, determined by // the value from the serial port background(bgcolor, 255, 255); // draw the Arduino logo image(logo, 0, 0); } */ Fritzing Circuit KiCad Schematic Video Demonstration 4.10.14 p15_HackingButtons Sketch Code /* Arduino Starter Kit example Project 15 - Hacking Buttons This sketch is written to accompany Project 15 in the Arduino Starter Kit Parts required: - battery powered component - 220 ohm resistor - 4N35 optocoupler created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/08/project-15/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int optoPin = 2; // the pin the optocoupler is connected to void setup() { // make the pin with the optocoupler an output pinMode(optoPin, OUTPUT); } void loop() { digitalWrite(optoPin, HIGH); // pull pin 2 HIGH, activating the optocoupler delay(15); // give the optocoupler a moment to activate digitalWrite(optoPin, LOW); // pull pin 2 low until you're ready to activate again delay(21000); // wait for 21 seconds } Fritzing Circuit KiCad Schematic Video Demonstration Section 4.11: 11.ArduinoISP Examples 4.11.1 ArduinoISP Sketch Code // https://docs.arduino.cc/built-in-examples/arduino-isp/ArduinoISP // ArduinoISP // Copyright (c) 2008-2011 Randall Bohn // If you require a license, see // https://opensource.org/licenses/bsd-license.php // // This sketch turns the Arduino into a AVRISP using the following Arduino pins: // // Pin 10 is used to reset the target microcontroller. // // By default, the hardware SPI pins MISO, MOSI and SCK are used to communicate // with the target. On all Arduinos, these pins can be found // on the ICSP/SPI header: // // MISO \u00b0. . 5V (!) Avoid this pin on Due, Zero... // SCK . . MOSI // . . GND // // On some Arduinos (Uno,...), pins MOSI, MISO and SCK are the same pins as // digital pin 11, 12 and 13, respectively. That is why many tutorials instruct // you to hook up the target to these pins. If you find this wiring more // practical, have a define USE_OLD_STYLE_WIRING. This will work even when not // using an Uno. (On an Uno this is not needed). // // Alternatively you can use any other digital pin by configuring // software ('BitBanged') SPI and having appropriate defines for PIN_MOSI, // PIN_MISO and PIN_SCK. // // IMPORTANT: When using an Arduino that is not 5V tolerant (Due, Zero, ...) as // the programmer, make sure to not expose any of the programmer's pins to 5V. // A simple way to accomplish this is to power the complete system (programmer // and target) at 3V3. // // Put an LED (with resistor) on the following pins: // 9: Heartbeat - shows the programmer is running // 8: Error - Lights up if something goes wrong (use red if that makes sense) // 7: Programming - In communication with the target // #include \"Arduino.h\" #undef SERIAL #define PROG_FLICKER true // Configure SPI clock (in Hz). // E.g. for an ATtiny @ 128 kHz: the datasheet states that both the high and low // SPI clock pulse must be > 2 CPU cycles, so take 3 cycles i.e. divide target // f_cpu by 6: // #define SPI_CLOCK (128000/6) // // A clock slow enough for an ATtiny85 @ 1 MHz, is a reasonable default: #define SPI_CLOCK (1000000 / 6) // Select hardware or software SPI, depending on SPI clock. // Currently only for AVR, for other architectures (Due, Zero,...), hardware SPI // is probably too fast anyway. #if defined(ARDUINO_ARCH_AVR) #if SPI_CLOCK > (F_CPU / 128) #define USE_HARDWARE_SPI #endif #endif // Configure which pins to use: // The standard pin configuration. #ifndef ARDUINO_HOODLOADER2 #define RESET 10 // Use pin 10 to reset the target rather than SS #define LED_HB 9 #define LED_ERR 8 #define LED_PMODE 7 // Uncomment following line to use the old Uno style wiring // (using pin 11, 12 and 13 instead of the SPI header) on Leonardo, Due... // #define USE_OLD_STYLE_WIRING #ifdef USE_OLD_STYLE_WIRING #define PIN_MOSI 11 #define PIN_MISO 12 #define PIN_SCK 13 #endif // HOODLOADER2 means running sketches on the ATmega16U2 serial converter chips // on Uno or Mega boards. We must use pins that are broken out: #else #define RESET 4 #define LED_HB 7 #define LED_ERR 6 #define LED_PMODE 5 #endif // By default, use hardware SPI pins: #ifndef PIN_MOSI #define PIN_MOSI MOSI #endif #ifndef PIN_MISO #define PIN_MISO MISO #endif #ifndef PIN_SCK #define PIN_SCK SCK #endif // Force bitbanged SPI if not using the hardware SPI pins: #if (PIN_MISO != MISO) || (PIN_MOSI != MOSI) || (PIN_SCK != SCK) #undef USE_HARDWARE_SPI #endif // Configure the serial port to use. // // Prefer the USB virtual serial port (aka. native USB port), if the Arduino has one: // - it does not autoreset (except for the magic baud rate of 1200). // - it is more reliable because of USB handshaking. // // Leonardo and similar have an USB virtual serial port: 'Serial'. // Due and Zero have an USB virtual serial port: 'SerialUSB'. // // On the Due and Zero, 'Serial' can be used too, provided you disable autoreset. // To use 'Serial': #define SERIAL Serial #ifdef SERIAL_PORT_USBVIRTUAL #define SERIAL SERIAL_PORT_USBVIRTUAL #else #define SERIAL Serial #endif // Configure the baud rate: #define BAUDRATE 19200 // #define BAUDRATE 115200 // #define BAUDRATE 1000000 #define HWVER 2 #define SWMAJ 1 #define SWMIN 18 // STK Definitions #define STK_OK 0x10 #define STK_FAILED 0x11 #define STK_UNKNOWN 0x12 #define STK_INSYNC 0x14 #define STK_NOSYNC 0x15 #define CRC_EOP 0x20 //ok it is a space... void pulse(int pin, int times); #ifdef USE_HARDWARE_SPI #include \"SPI.h\" #else #define SPI_MODE0 0x00 #if !defined(ARDUINO_API_VERSION) || ARDUINO_API_VERSION != 10001 // A SPISettings class is declared by ArduinoCore-API 1.0.1 class SPISettings { public: // clock is in Hz SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) : clockFreq(clock) { (void)bitOrder; (void)dataMode; }; uint32_t getClockFreq() const { return clockFreq; } private: uint32_t clockFreq; }; #endif // !defined(ARDUINO_API_VERSION) class BitBangedSPI { public: void begin() { digitalWrite(PIN_SCK, LOW); digitalWrite(PIN_MOSI, LOW); pinMode(PIN_SCK, OUTPUT); pinMode(PIN_MOSI, OUTPUT); pinMode(PIN_MISO, INPUT); } void beginTransaction(SPISettings settings) { pulseWidth = (500000 + settings.getClockFreq() - 1) / settings.getClockFreq(); if (pulseWidth == 0) { pulseWidth = 1; } } void end() {} uint8_t transfer(uint8_t b) { for (unsigned int i = 0; i < 8; ++i) { digitalWrite(PIN_MOSI, (b & 0x80) ? HIGH : LOW); digitalWrite(PIN_SCK, HIGH); delayMicroseconds(pulseWidth); b = (b << 1) | digitalRead(PIN_MISO); digitalWrite(PIN_SCK, LOW); // slow pulse delayMicroseconds(pulseWidth); } return b; } private: unsigned long pulseWidth; // in microseconds }; static BitBangedSPI SPI; #endif void setup() { SERIAL.begin(BAUDRATE); pinMode(LED_PMODE, OUTPUT); pulse(LED_PMODE, 2); pinMode(LED_ERR, OUTPUT); pulse(LED_ERR, 2); pinMode(LED_HB, OUTPUT); pulse(LED_HB, 2); } int ISPError = 0; int pmode = 0; // address for reading and writing, set by 'U' command unsigned int here; uint8_t buff[256]; // global block storage #define beget16(addr) (*addr * 256 + *(addr + 1)) typedef struct param { uint8_t devicecode; uint8_t revision; uint8_t progtype; uint8_t parmode; uint8_t polling; uint8_t selftimed; uint8_t lockbytes; uint8_t fusebytes; uint8_t flashpoll; uint16_t eeprompoll; uint16_t pagesize; uint16_t eepromsize; uint32_t flashsize; } parameter; parameter param; // this provides a heartbeat on pin 9, so you can tell the software is running. uint8_t hbval = 128; int8_t hbdelta = 8; void heartbeat() { static unsigned long last_time = 0; unsigned long now = millis(); if ((now - last_time) < 40) { return; } last_time = now; if (hbval > 192) { hbdelta = -hbdelta; } if (hbval < 32) { hbdelta = -hbdelta; } hbval += hbdelta; analogWrite(LED_HB, hbval); } static bool rst_active_high; void reset_target(bool reset) { digitalWrite(RESET, ((reset && rst_active_high) || (!reset && !rst_active_high)) ? HIGH : LOW); } void loop(void) { // is pmode active? if (pmode) { digitalWrite(LED_PMODE, HIGH); } else { digitalWrite(LED_PMODE, LOW); } // is there an error? if (ISPError) { digitalWrite(LED_ERR, HIGH); } else { digitalWrite(LED_ERR, LOW); } // light the heartbeat LED heartbeat(); if (SERIAL.available()) { avrisp(); } } uint8_t getch() { while (!SERIAL.available()) ; return SERIAL.read(); } void fill(int n) { for (int x = 0; x < n; x++) { buff[x] = getch(); } } #define PTIME 30 void pulse(int pin, int times) { do { digitalWrite(pin, HIGH); delay(PTIME); digitalWrite(pin, LOW); delay(PTIME); } while (times--); } void prog_lamp(int state) { if (PROG_FLICKER) { digitalWrite(LED_PMODE, state); } } uint8_t spi_transaction(uint8_t a, uint8_t b, uint8_t c, uint8_t d) { SPI.transfer(a); SPI.transfer(b); SPI.transfer(c); return SPI.transfer(d); } void empty_reply() { if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } void breply(uint8_t b) { if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)b); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } void get_version(uint8_t c) { switch (c) { case 0x80: breply(HWVER); break; case 0x81: breply(SWMAJ); break; case 0x82: breply(SWMIN); break; case 0x93: breply('S'); // serial programmer break; default: breply(0); } } void set_parameters() { // call this after reading parameter packet into buff[] param.devicecode = buff[0]; param.revision = buff[1]; param.progtype = buff[2]; param.parmode = buff[3]; param.polling = buff[4]; param.selftimed = buff[5]; param.lockbytes = buff[6]; param.fusebytes = buff[7]; param.flashpoll = buff[8]; // ignore buff[9] (= buff[8]) // following are 16 bits (big endian) param.eeprompoll = beget16(&buff[10]); param.pagesize = beget16(&buff[12]); param.eepromsize = beget16(&buff[14]); // 32 bits flashsize (big endian) param.flashsize = buff[16] * 0x01000000 + buff[17] * 0x00010000 + buff[18] * 0x00000100 + buff[19]; // AVR devices have active low reset, AT89Sx are active high rst_active_high = (param.devicecode >= 0xe0); } void start_pmode() { // Reset target before driving PIN_SCK or PIN_MOSI // SPI.begin() will configure SS as output, so SPI master mode is selected. // We have defined RESET as pin 10, which for many Arduinos is not the SS pin. // So we have to configure RESET as output here, // (reset_target() first sets the correct level) reset_target(true); pinMode(RESET, OUTPUT); SPI.begin(); SPI.beginTransaction(SPISettings(SPI_CLOCK, MSBFIRST, SPI_MODE0)); // See AVR datasheets, chapter \"SERIAL_PRG Programming Algorithm\": // Pulse RESET after PIN_SCK is low: digitalWrite(PIN_SCK, LOW); delay(20); // discharge PIN_SCK, value arbitrarily chosen reset_target(false); // Pulse must be minimum 2 target CPU clock cycles so 100 usec is ok for CPU // speeds above 20 KHz delayMicroseconds(100); reset_target(true); // Send the enable programming command: delay(50); // datasheet: must be > 20 msec spi_transaction(0xAC, 0x53, 0x00, 0x00); pmode = 1; } void end_pmode() { SPI.end(); // We're about to take the target out of reset so configure SPI pins as input pinMode(PIN_MOSI, INPUT); pinMode(PIN_SCK, INPUT); reset_target(false); pinMode(RESET, INPUT); pmode = 0; } void universal() { uint8_t ch; fill(4); ch = spi_transaction(buff[0], buff[1], buff[2], buff[3]); breply(ch); } void flash(uint8_t hilo, unsigned int addr, uint8_t data) { spi_transaction(0x40 + 8 * hilo, addr >> 8 & 0xFF, addr & 0xFF, data); } void commit(unsigned int addr) { if (PROG_FLICKER) { prog_lamp(LOW); } spi_transaction(0x4C, (addr >> 8) & 0xFF, addr & 0xFF, 0); if (PROG_FLICKER) { delay(PTIME); prog_lamp(HIGH); } } unsigned int current_page() { if (param.pagesize == 32) { return here & 0xFFFFFFF0; } if (param.pagesize == 64) { return here & 0xFFFFFFE0; } if (param.pagesize == 128) { return here & 0xFFFFFFC0; } if (param.pagesize == 256) { return here & 0xFFFFFF80; } return here; } void write_flash(int length) { fill(length); if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)write_flash_pages(length)); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } uint8_t write_flash_pages(int length) { int x = 0; unsigned int page = current_page(); while (x < length) { if (page != current_page()) { commit(page); page = current_page(); } flash(LOW, here, buff[x++]); flash(HIGH, here, buff[x++]); here++; } commit(page); return STK_OK; } #define EECHUNK (32) uint8_t write_eeprom(unsigned int length) { // here is a word address, get the byte address unsigned int start = here * 2; unsigned int remaining = length; if (length > param.eepromsize) { ISPError++; return STK_FAILED; } while (remaining > EECHUNK) { write_eeprom_chunk(start, EECHUNK); start += EECHUNK; remaining -= EECHUNK; } write_eeprom_chunk(start, remaining); return STK_OK; } // write (length) bytes, (start) is a byte address uint8_t write_eeprom_chunk(unsigned int start, unsigned int length) { // this writes byte-by-byte, page writing may be faster (4 bytes at a time) fill(length); prog_lamp(LOW); for (unsigned int x = 0; x < length; x++) { unsigned int addr = start + x; spi_transaction(0xC0, (addr >> 8) & 0xFF, addr & 0xFF, buff[x]); delay(45); } prog_lamp(HIGH); return STK_OK; } void program_page() { char result = (char)STK_FAILED; unsigned int length = 256 * getch(); length += getch(); char memtype = getch(); // flash memory @here, (length) bytes if (memtype == 'F') { write_flash(length); return; } if (memtype == 'E') { result = (char)write_eeprom(length); if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print(result); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } return; } SERIAL.print((char)STK_FAILED); return; } uint8_t flash_read(uint8_t hilo, unsigned int addr) { return spi_transaction(0x20 + hilo * 8, (addr >> 8) & 0xFF, addr & 0xFF, 0); } char flash_read_page(int length) { for (int x = 0; x < length; x += 2) { uint8_t low = flash_read(LOW, here); SERIAL.print((char)low); uint8_t high = flash_read(HIGH, here); SERIAL.print((char)high); here++; } return STK_OK; } char eeprom_read_page(int length) { // here again we have a word address int start = here * 2; for (int x = 0; x < length; x++) { int addr = start + x; uint8_t ee = spi_transaction(0xA0, (addr >> 8) & 0xFF, addr & 0xFF, 0xFF); SERIAL.print((char)ee); } return STK_OK; } void read_page() { char result = (char)STK_FAILED; int length = 256 * getch(); length += getch(); char memtype = getch(); if (CRC_EOP != getch()) { ISPError++; SERIAL.print((char)STK_NOSYNC); return; } SERIAL.print((char)STK_INSYNC); if (memtype == 'F') { result = flash_read_page(length); } if (memtype == 'E') { result = eeprom_read_page(length); } SERIAL.print(result); } void read_signature() { if (CRC_EOP != getch()) { ISPError++; SERIAL.print((char)STK_NOSYNC); return; } SERIAL.print((char)STK_INSYNC); uint8_t high = spi_transaction(0x30, 0x00, 0x00, 0x00); SERIAL.print((char)high); uint8_t middle = spi_transaction(0x30, 0x00, 0x01, 0x00); SERIAL.print((char)middle); uint8_t low = spi_transaction(0x30, 0x00, 0x02, 0x00); SERIAL.print((char)low); SERIAL.print((char)STK_OK); } ////////////////////////////////////////// ////////////////////////////////////////// //////////////////////////////////// //////////////////////////////////// void avrisp() { uint8_t ch = getch(); switch (ch) { case '0': // signon ISPError = 0; empty_reply(); break; case '1': if (getch() == CRC_EOP) { SERIAL.print((char)STK_INSYNC); SERIAL.print(\"AVR ISP\"); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } break; case 'A': get_version(getch()); break; case 'B': fill(20); set_parameters(); empty_reply(); break; case 'E': // extended parameters - ignore for now fill(5); empty_reply(); break; case 'P': if (!pmode) { start_pmode(); } empty_reply(); break; case 'U': // set address (word) here = getch(); here += 256 * getch(); empty_reply(); break; case 0x60: //STK_PROG_FLASH getch(); // low addr getch(); // high addr empty_reply(); break; case 0x61: //STK_PROG_DATA getch(); // data empty_reply(); break; case 0x64: //STK_PROG_PAGE program_page(); break; case 0x74: //STK_READ_PAGE 't' read_page(); break; case 'V': //0x56 universal(); break; case 'Q': //0x51 ISPError = 0; end_pmode(); empty_reply(); break; case 0x75: //STK_READ_SIGN 'u' read_signature(); break; // expecting a command, not CRC_EOP // this is how we can get back in sync case CRC_EOP: ISPError++; SERIAL.print((char)STK_NOSYNC); break; // anything else we will return STK_UNKNOWN default: ISPError++; if (CRC_EOP == getch()) { SERIAL.print((char)STK_UNKNOWN); } else { SERIAL.print((char)STK_NOSYNC); } } } Fritzing Circuit KiCad Schematic Video Demonstration Note In this chapter, all snippets of sketch codes are from the official Arduino Examples .","title":"Chapter 4 - Built-in Examples"},{"location":"04_builtin_examples/#chapter-4-arduino-build-in-examples","text":"Note In this chapter, all snippets of sketch codes are from the official Arduino Examples .","title":"Chapter 4: Arduino Build-in Examples"},{"location":"04_builtin_examples/#section-41-01basics-examples","text":"","title":"Section 4.1: 01.Basics Examples"},{"location":"04_builtin_examples/#411-analogreadserial","text":"","title":"4.1.1 AnalogReadSerial"},{"location":"04_builtin_examples/#sketch-code","text":"/* AnalogReadSerial Reads an analog input on pin 0, prints the result to the Serial Monitor. Graphical representation is available using Serial Plotter (Tools > Serial Plotter menu). Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogReadSerial */ // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); } // the loop routine runs over and over again forever: void loop() { // read the input on analog pin 0: int sensorValue = analogRead(A0); // print out the value you read: Serial.println(sensorValue); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#412-bareminimum","text":"","title":"4.1.2 BareMinimum"},{"location":"04_builtin_examples/#sketch-code_1","text":"void setup() { // put your setup code here, to run once: } void loop() { // put your main code here, to run repeatedly: } This sketch simply shows the standard template when coding for any Arduino boards. As you can see, there are typically only 2 functions : setup(): for initialization loop(): normally, a forever loop that runs infinitely From this bare minimum template, we can easily tell Arduino is a Microcontroller with a single thread , and of course for a single user .","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_1","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_1","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_1","text":"N/A","title":"Video Demonstration"},{"location":"04_builtin_examples/#413-blink","text":"","title":"4.1.3 Blink"},{"location":"04_builtin_examples/#sketch-code_2","text":"/* Blink Turns an LED on for one second, then off for one second, repeatedly. Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products modified 8 May 2014 by Scott Fitzgerald modified 2 Sep 2016 by Arturo Guadalupi modified 8 Sep 2016 by Colby Newman This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Blink */ // the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_2","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_2","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_2","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#414-digitalreadserial","text":"","title":"4.1.4 DigitalReadSerial"},{"location":"04_builtin_examples/#sketch-code_3","text":"/* DigitalReadSerial Reads a digital input on pin 2, prints the result to the Serial Monitor This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/DigitalReadSerial */ // digital pin 2 has a pushbutton attached to it. Give it a name: int pushButton = 2; // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); // make the pushbutton's pin an input: pinMode(pushButton, INPUT); } // the loop routine runs over and over again forever: void loop() { // read the input pin: int buttonState = digitalRead(pushButton); // print out the state of the button: Serial.println(buttonState); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_3","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_3","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_3","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#415-fade","text":"","title":"4.1.5 Fade"},{"location":"04_builtin_examples/#sketch-code_4","text":"/* Fade This example shows how to fade an LED on pin 9 using the analogWrite() function. The analogWrite() function uses PWM, so if you want to change the pin you're using, be sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with a \"~\" sign, like ~3, ~5, ~6, ~9, ~10 and ~11. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Fade */ int led = 9; // the PWM pin the LED is attached to int brightness = 0; // how bright the LED is int fadeAmount = 5; // how many points to fade the LED by // the setup routine runs once when you press reset: void setup() { // declare pin 9 to be an output: pinMode(led, OUTPUT); } // the loop routine runs over and over again forever: void loop() { // set the brightness of pin 9: analogWrite(led, brightness); // change the brightness for next time through the loop: brightness = brightness + fadeAmount; // reverse the direction of the fading at the ends of the fade: if (brightness <= 0 || brightness >= 255) { fadeAmount = -fadeAmount; } // wait for 30 milliseconds to see the dimming effect delay(30); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_4","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_4","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_4","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#416-readanalogvoltage","text":"","title":"4.1.6 ReadAnalogVoltage"},{"location":"04_builtin_examples/#sketch-code_5","text":"/* ReadAnalogVoltage Reads an analog input on pin 0, converts it to voltage, and prints the result to the Serial Monitor. Graphical representation is available using Serial Plotter (Tools > Serial Plotter menu). Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ReadAnalogVoltage */ // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); } // the loop routine runs over and over again forever: void loop() { // read the input on analog pin 0: int sensorValue = analogRead(A0); // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V): float voltage = sensorValue * (5.0 / 1023.0); // print out the value you read: Serial.println(voltage); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_5","text":"Same as Example AnalogReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_5","text":"Same as Example AnalogReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_5","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-42-02digital-examples","text":"","title":"Section 4.2: 02.Digital Examples"},{"location":"04_builtin_examples/#421-blinkwithoutdelay","text":"","title":"4.2.1 BlinkWithoutDelay"},{"location":"04_builtin_examples/#sketch-code_6","text":"/* Blink without Delay Turns on and off a light emitting diode (LED) connected to a digital pin, without using the delay() function. This means that other code can run at the same time without being interrupted by the LED code. The circuit: - Use the onboard LED. - Note: Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products created 2005 by David A. Mellis modified 8 Feb 2010 by Paul Stoffregen modified 11 Nov 2013 by Scott Fitzgerald modified 9 Jan 2017 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/BlinkWithoutDelay */ // constants won't change. Used here to set a pin number: const int ledPin = LED_BUILTIN; // the number of the LED pin // Variables will change: int ledState = LOW; // ledState used to set the LED // Generally, you should use \"unsigned long\" for variables that hold time // The value will quickly become too large for an int to store unsigned long previousMillis = 0; // will store last time LED was updated // constants won't change: const long interval = 1000; // interval at which to blink (milliseconds) void setup() { // set the digital pin as output: pinMode(ledPin, OUTPUT); } void loop() { // here is where you'd put code that needs to be running all the time. // check to see if it's time to blink the LED; that is, if the difference // between the current time and last time you blinked the LED is bigger than // the interval at which you want to blink the LED. unsigned long currentMillis = millis(); if (currentMillis - previousMillis >= interval) { // save the last time you blinked the LED previousMillis = currentMillis; // if the LED is off turn it on and vice-versa: if (ledState == LOW) { ledState = HIGH; } else { ledState = LOW; } // set the LED with the ledState of the variable: digitalWrite(ledPin, ledState); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_6","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_6","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_6","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#422-button","text":"","title":"4.2.2 Button"},{"location":"04_builtin_examples/#sketch-code_7","text":"/* Button Turns on and off a light emitting diode(LED) connected to digital pin 13, when pressing a pushbutton attached to pin 2. The circuit: - LED attached from pin 13 to ground through 220 ohm resistor - pushbutton attached to pin 2 from +5V - 10K resistor attached to pin 2 from ground - Note: on most Arduinos there is already an LED on the board attached to pin 13. created 2005 by DojoDave <http://www.0j0.org> modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Button */ // constants won't change. They're used here to set pin numbers: const int buttonPin = 2; // the number of the pushbutton pin const int ledPin = 13; // the number of the LED pin // variables will change: int buttonState = 0; // variable for reading the pushbutton status void setup() { // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); // initialize the pushbutton pin as an input: pinMode(buttonPin, INPUT); } void loop() { // read the state of the pushbutton value: buttonState = digitalRead(buttonPin); // check if the pushbutton is pressed. If it is, the buttonState is HIGH: if (buttonState == HIGH) { // turn LED on: digitalWrite(ledPin, HIGH); } else { // turn LED off: digitalWrite(ledPin, LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_7","text":"Same as Example DigitalReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_7","text":"Roughly the same as Example DigitalReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_7","text":"Same as Example DigitalReadSerial","title":"Video Demonstration"},{"location":"04_builtin_examples/#423-debounce","text":"","title":"4.2.3 Debounce"},{"location":"04_builtin_examples/#sketch-code_8","text":"/* Debounce Each time the input pin goes from LOW to HIGH (e.g. because of a push-button press), the output pin is toggled from LOW to HIGH or HIGH to LOW. There's a minimum delay between toggles to debounce the circuit (i.e. to ignore noise). The circuit: - LED attached from pin 13 to ground through 220 ohm resistor - pushbutton attached from pin 2 to +5V - 10 kilohm resistor attached from pin 2 to ground - Note: On most Arduino boards, there is already an LED on the board connected to pin 13, so you don't need any extra components for this example. created 21 Nov 2006 by David A. Mellis modified 30 Aug 2011 by Limor Fried modified 28 Dec 2012 by Mike Walters modified 30 Aug 2016 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Debounce */ // constants won't change. They're used here to set pin numbers: const int buttonPin = 2; // the number of the pushbutton pin const int ledPin = 13; // the number of the LED pin // Variables will change: int ledState = HIGH; // the current state of the output pin int buttonState; // the current reading from the input pin int lastButtonState = LOW; // the previous reading from the input pin // the following variables are unsigned longs because the time, measured in // milliseconds, will quickly become a bigger number than can be stored in an int. unsigned long lastDebounceTime = 0; // the last time the output pin was toggled unsigned long debounceDelay = 50; // the debounce time; increase if the output flickers void setup() { pinMode(buttonPin, INPUT); pinMode(ledPin, OUTPUT); // set initial LED state digitalWrite(ledPin, ledState); } void loop() { // read the state of the switch into a local variable: int reading = digitalRead(buttonPin); // check to see if you just pressed the button // (i.e. the input went from LOW to HIGH), and you've waited long enough // since the last press to ignore any noise: // If the switch changed, due to noise or pressing: if (reading != lastButtonState) { // reset the debouncing timer lastDebounceTime = millis(); } if ((millis() - lastDebounceTime) > debounceDelay) { // whatever the reading is at, it's been there for longer than the debounce // delay, so take it as the actual current state: // if the button state has changed: if (reading != buttonState) { buttonState = reading; // only toggle the LED if the new button state is HIGH if (buttonState == HIGH) { ledState = !ledState; } } } // set the LED: digitalWrite(ledPin, ledState); // save the reading. Next time through the loop, it'll be the lastButtonState: lastButtonState = reading; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_8","text":"Same as Example DigitalReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_8","text":"Same as Example DigitalReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_8","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#424-digitalinputpullup","text":"","title":"4.2.4 DigitalInputPullup"},{"location":"04_builtin_examples/#sketch-code_9","text":"/* Input Pull-up Serial This example demonstrates the use of pinMode(INPUT_PULLUP). It reads a digital input on pin 2 and prints the results to the Serial Monitor. The circuit: - momentary switch attached from pin 2 to ground - built-in LED on pin 13 Unlike pinMode(INPUT), there is no pull-down resistor necessary. An internal 20K-ohm resistor is pulled to 5V. This configuration causes the input to read HIGH when the switch is open, and LOW when it is closed. created 14 Mar 2012 by Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/InputPullupSerial */ void setup() { //start serial connection Serial.begin(9600); //configure pin 2 as an input and enable the internal pull-up resistor pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); } void loop() { //read the pushbutton value into a variable int sensorVal = digitalRead(2); //print out the value of the pushbutton Serial.println(sensorVal); // Keep in mind the pull-up means the pushbutton's logic is inverted. It goes // HIGH when it's open, and LOW when it's pressed. Turn on pin 13 when the // button's pressed, and off when it's not: if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_9","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_9","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_9","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#425-statechangedetection","text":"","title":"4.2.5 StateChangeDetection"},{"location":"04_builtin_examples/#sketch-code_10","text":"/* State change detection (edge detection) Often, you don't need to know the state of a digital input all the time, but you just need to know when the input changes from one state to another. For example, you want to know when a button goes from OFF to ON. This is called state change detection, or edge detection. This example shows how to detect when a button or button changes from off to on and on to off. The circuit: - pushbutton attached to pin 2 from +5V - 10 kilohm resistor attached to pin 2 from ground - LED attached from pin 13 to ground through 220 ohm resistor (or use the built-in LED on most Arduino boards) created 27 Sep 2005 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StateChangeDetection */ // this constant won't change: const int buttonPin = 2; // the pin that the pushbutton is attached to const int ledPin = 13; // the pin that the LED is attached to // Variables will change: int buttonPushCounter = 0; // counter for the number of button presses int buttonState = 0; // current state of the button int lastButtonState = 0; // previous state of the button void setup() { // initialize the button pin as a input: pinMode(buttonPin, INPUT); // initialize the LED as an output: pinMode(ledPin, OUTPUT); // initialize serial communication: Serial.begin(9600); } void loop() { // read the pushbutton input pin: buttonState = digitalRead(buttonPin); // compare the buttonState to its previous state if (buttonState != lastButtonState) { // if the state has changed, increment the counter if (buttonState == HIGH) { // if the current state is HIGH then the button went from off to on: buttonPushCounter++; Serial.println(\"on\"); Serial.print(\"number of button pushes: \"); Serial.println(buttonPushCounter); } else { // if the current state is LOW then the button went from on to off: Serial.println(\"off\"); } // Delay a little bit to avoid bouncing delay(50); } // save the current state as the last state, for next time through the loop lastButtonState = buttonState; // turns on the LED every four button pushes by checking the modulo of the // button push counter. the modulo function gives you the remainder of the // division of two numbers: if (buttonPushCounter % 4 == 0) { digitalWrite(ledPin, HIGH); } else { digitalWrite(ledPin, LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_10","text":"Same as Example DigitalReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_10","text":"Same as Example DigitalReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_10","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#426-tonekeyboard","text":"","title":"4.2.6 toneKeyboard"},{"location":"04_builtin_examples/#sketch-code_11","text":"/* Keyboard Plays a pitch that changes based on a changing analog input circuit: - three force-sensing resistors from +5V to analog in 0 through 5 - three 10 kilohm resistors from analog in 0 through 5 to ground - 8 ohm speaker on digital pin 8 created 21 Jan 2010 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneKeyboard */ #include \"pitches.h\" const int threshold = 10; // minimum reading of the sensors that generates a note // notes to play, corresponding to the 3 sensors: int notes[] = { NOTE_A4, NOTE_B4, NOTE_C3 }; void setup() { } void loop() { for (int thisSensor = 0; thisSensor < 3; thisSensor++) { // get a sensor reading: int sensorReading = analogRead(thisSensor); // if the sensor is pressed hard enough: if (sensorReading > threshold) { // play the note corresponding to this sensor: tone(8, notes[thisSensor], 20); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_11","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_11","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_11","text":"N/A","title":"Video Demonstration"},{"location":"04_builtin_examples/#427-tonemelody","text":"","title":"4.2.7 toneMelody"},{"location":"04_builtin_examples/#sketch-code_12","text":"/* Melody Plays a melody circuit: - 8 ohm speaker on digital pin 8 created 21 Jan 2010 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneMelody */ #include \"pitches.h\" // notes in the melody: int melody[] = { NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4 }; // note durations: 4 = quarter note, 8 = eighth note, etc.: int noteDurations[] = { 4, 8, 8, 4, 4, 4, 4, 4 }; void setup() { // iterate over the notes of the melody: for (int thisNote = 0; thisNote < 8; thisNote++) { // to calculate the note duration, take one second divided by the note type. //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc. int noteDuration = 1000 / noteDurations[thisNote]; tone(8, melody[thisNote], noteDuration); // to distinguish the notes, set a minimum time between them. // the note's duration + 30% seems to work well: int pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); // stop the tone playing: noTone(8); } } void loop() { // no need to repeat the melody. }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_12","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_12","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_12","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#428-tonemultiple","text":"","title":"4.2.8 toneMultiple"},{"location":"04_builtin_examples/#sketch-code_13","text":"/* Multiple tone player Plays multiple tones on multiple pins in sequence circuit: - three 8 ohm speakers on digital pins 6, 7, and 8 created 8 Mar 2010 by Tom Igoe based on a snippet from Greg Borenstein This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneMultiple */ void setup() { } void loop() { // turn off tone function for pin 8: noTone(8); // play a note on pin 6 for 200 ms: tone(6, 440, 200); delay(200); // turn off tone function for pin 6: noTone(6); // play a note on pin 7 for 500 ms: tone(7, 494, 500); delay(500); // turn off tone function for pin 7: noTone(7); // play a note on pin 8 for 300 ms: tone(8, 523, 300); delay(300); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_13","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_13","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_13","text":"N/A","title":"Video Demonstration"},{"location":"04_builtin_examples/#429-tonepitchfollower","text":"","title":"4.2.9 tonePitchFollower"},{"location":"04_builtin_examples/#sketch-code_14","text":"/* Pitch follower Plays a pitch that changes based on a changing analog input circuit: - 8 ohm speaker on digital pin 9 - photoresistor on analog 0 to 5V - 4.7 kilohm resistor on analog 0 to ground created 21 Jan 2010 modified 31 May 2012 by Tom Igoe, with suggestion from Michael Flynn This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/tonePitchFollower */ void setup() { // initialize serial communications (for debugging only): Serial.begin(9600); } void loop() { // read the sensor: int sensorReading = analogRead(A0); // print the sensor reading so you know its range Serial.println(sensorReading); // map the analog input range (in this case, 400 - 1000 from the photoresistor) // to the output pitch range (120 - 1500Hz) // change the minimum and maximum input numbers below depending on the range // your sensor's giving: int thisPitch = map(sensorReading, 400, 1000, 120, 1500); // play the pitch: tone(9, thisPitch, 10); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_14","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_14","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_14","text":"N/A","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-43-03analog-examples","text":"","title":"Section 4.3: 03.Analog Examples"},{"location":"04_builtin_examples/#431-analoginoutserial","text":"","title":"4.3.1 AnalogInOutSerial"},{"location":"04_builtin_examples/#sketch-code_15","text":"/* Analog input, analog output, serial output Reads an analog input pin, maps the result to a range from 0 to 255 and uses the result to set the pulse width modulation (PWM) of an output pin. Also prints the results to the Serial Monitor. The circuit: - potentiometer connected to analog pin 0. Center pin of the potentiometer goes to the analog pin. side pins of the potentiometer go to +5V and ground - LED connected from digital pin 9 to ground through 220 ohm resistor created 29 Dec. 2008 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogInOutSerial */ // These constants won't change. They're used to give names to the pins used: const int analogInPin = A0; // Analog input pin that the potentiometer is attached to const int analogOutPin = 9; // Analog output pin that the LED is attached to int sensorValue = 0; // value read from the pot int outputValue = 0; // value output to the PWM (analog out) void setup() { // initialize serial communications at 9600 bps: Serial.begin(9600); } void loop() { // read the analog in value: sensorValue = analogRead(analogInPin); // map it to the range of the analog out: outputValue = map(sensorValue, 0, 1023, 0, 255); // change the analog out value: analogWrite(analogOutPin, outputValue); // print the results to the Serial Monitor: Serial.print(\"sensor = \"); Serial.print(sensorValue); Serial.print(\"\\t output = \"); Serial.println(outputValue); // wait 2 milliseconds before the next loop for the analog-to-digital // converter to settle after the last reading: delay(2); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_15","text":"Same as Example AnalogReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_15","text":"Same as Example AnalogReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_15","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#432-analoginput","text":"","title":"4.3.2 AnalogInput"},{"location":"04_builtin_examples/#sketch-code_16","text":"/* Analog Input Demonstrates analog input by reading an analog sensor on analog pin 0 and turning on and off a light emitting diode(LED) connected to digital pin 13. The amount of time the LED will be on and off depends on the value obtained by analogRead(). The circuit: - potentiometer center pin of the potentiometer to the analog input 0 one side pin (either one) to ground the other side pin to +5V - LED anode (long leg) attached to digital output 13 through 220 ohm resistor cathode (short leg) attached to ground - Note: because most Arduinos have a built-in LED attached to pin 13 on the board, the LED is optional. created by David Cuartielles modified 30 Aug 2011 By Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogInput */ int sensorPin = A0; // select the input pin for the potentiometer int ledPin = 13; // select the pin for the LED int sensorValue = 0; // variable to store the value coming from the sensor void setup() { // declare the ledPin as an OUTPUT: pinMode(ledPin, OUTPUT); } void loop() { // read the value from the sensor: sensorValue = analogRead(sensorPin); // turn the ledPin on digitalWrite(ledPin, HIGH); // stop the program for <sensorValue> milliseconds: delay(sensorValue); // turn the ledPin off: digitalWrite(ledPin, LOW); // stop the program for for <sensorValue> milliseconds: delay(sensorValue); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_16","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#with-potentiometer","text":"Same as Example AnalogReadSerial","title":"With Potentiometer"},{"location":"04_builtin_examples/#with-photoresistor","text":"","title":"With Photoresistor"},{"location":"04_builtin_examples/#kicad-schematic_16","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#with-potentiometer_1","text":"Same as Example AnalogReadSerial","title":"With Potentiometer"},{"location":"04_builtin_examples/#with-photoresistor_1","text":"","title":"With Photoresistor"},{"location":"04_builtin_examples/#video-demonstration_16","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#433-analogwritemega","text":"","title":"4.3.3 AnalogWriteMega"},{"location":"04_builtin_examples/#sketch-code_17","text":"/* Mega analogWrite() test This sketch fades LEDs up and down one at a time on digital pins 2 through 13. This sketch was written for the Arduino Mega, and will not work on other boards. The circuit: - LEDs attached from pins 2 through 13 to ground. created 8 Feb 2009 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogWriteMega */ // These constants won't change. They're used to give names to the pins used: const int lowestPin = 2; const int highestPin = 13; void setup() { // set pins 2 through 13 as outputs: for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // iterate over the pins: for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) { // fade the LED on thisPin from off to brightest: for (int brightness = 0; brightness < 255; brightness++) { analogWrite(thisPin, brightness); delay(2); } // fade the LED on thisPin from brightest to off: for (int brightness = 255; brightness >= 0; brightness--) { analogWrite(thisPin, brightness); delay(2); } // pause between LEDs: delay(100); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_17","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_17","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_17","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#434-calibration","text":"","title":"4.3.4 Calibration"},{"location":"04_builtin_examples/#sketch-code_18","text":"/* Calibration Demonstrates one technique for calibrating sensor input. The sensor readings during the first five seconds of the sketch execution define the minimum and maximum of expected values attached to the sensor pin. The sensor minimum and maximum initial values may seem backwards. Initially, you set the minimum high and listen for anything lower, saving it as the new minimum. Likewise, you set the maximum low and listen for anything higher as the new maximum. The circuit: - analog sensor (potentiometer will do) attached to analog input 0 - LED attached from digital pin 9 to ground through 220 ohm resistor created 29 Oct 2008 by David A Mellis modified 30 Aug 2011 by Tom Igoe modified 07 Apr 2017 by Zachary J. Fields This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Calibration */ // These constants won't change: const int sensorPin = A0; // pin that the sensor is attached to const int ledPin = 9; // pin that the LED is attached to // variables: int sensorValue = 0; // the sensor value int sensorMin = 1023; // minimum sensor value int sensorMax = 0; // maximum sensor value void setup() { // turn on LED to signal the start of the calibration period: pinMode(13, OUTPUT); digitalWrite(13, HIGH); // calibrate during the first five seconds while (millis() < 5000) { sensorValue = analogRead(sensorPin); // record the maximum sensor value if (sensorValue > sensorMax) { sensorMax = sensorValue; } // record the minimum sensor value if (sensorValue < sensorMin) { sensorMin = sensorValue; } } // signal the end of the calibration period digitalWrite(13, LOW); } void loop() { // read the sensor: sensorValue = analogRead(sensorPin); // in case the sensor value is outside the range seen during calibration sensorValue = constrain(sensorValue, sensorMin, sensorMax); // apply the calibration to the sensor reading sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255); // fade the LED using the calibrated value: analogWrite(ledPin, sensorValue); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_18","text":"Note There is an error from the official Arduino built-in example Calibration . Please refer to my issue asked at Is the sketch for Calibration wrong?","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_18","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_18","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#435-fading","text":"","title":"4.3.5 Fading"},{"location":"04_builtin_examples/#sketch-code_19","text":"/* Fading This example shows how to fade an LED using the analogWrite() function. The circuit: - LED attached from digital pin 9 to ground through 220 ohm resistor. created 1 Nov 2008 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Fading */ int ledPin = 9; // LED connected to digital pin 9 void setup() { // nothing happens in setup } void loop() { // fade in from min to max in increments of 5 points: for (int fadeValue = 0; fadeValue <= 255; fadeValue += 5) { // sets the value (range from 0 to 255): analogWrite(ledPin, fadeValue); // wait for 30 milliseconds to see the dimming effect delay(30); } // fade out from max to min in increments of 5 points: for (int fadeValue = 255; fadeValue >= 0; fadeValue -= 5) { // sets the value (range from 0 to 255): analogWrite(ledPin, fadeValue); // wait for 30 milliseconds to see the dimming effect delay(30); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_19","text":"Same as Example Fade","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_19","text":"Same as Example Fade","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_19","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#436-smotthing","text":"","title":"4.3.6 Smotthing"},{"location":"04_builtin_examples/#sketch-code_20","text":"/* Smoothing Reads repeatedly from an analog input, calculating a running average and printing it to the computer. Keeps ten readings in an array and continually averages them. The circuit: - analog sensor (potentiometer will do) attached to analog input 0 created 22 Apr 2007 by David A. Mellis <dam@mellis.org> modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Smoothing */ // Define the number of samples to keep track of. The higher the number, the // more the readings will be smoothed, but the slower the output will respond to // the input. Using a constant rather than a normal variable lets us use this // value to determine the size of the readings array. const int numReadings = 10; int readings[numReadings]; // the readings from the analog input int readIndex = 0; // the index of the current reading int total = 0; // the running total int average = 0; // the average int inputPin = A0; void setup() { // initialize serial communication with computer: Serial.begin(9600); // initialize all the readings to 0: for (int thisReading = 0; thisReading < numReadings; thisReading++) { readings[thisReading] = 0; } } void loop() { // subtract the last reading: total = total - readings[readIndex]; // read from the sensor: readings[readIndex] = analogRead(inputPin); // add the reading to the total: total = total + readings[readIndex]; // advance to the next position in the array: readIndex = readIndex + 1; // if we're at the end of the array... if (readIndex >= numReadings) { // ...wrap around to the beginning: readIndex = 0; } // calculate the average: average = total / numReadings; // send it to the computer as ASCII digits Serial.println(average); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_20","text":"Same as Example AnalogReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_20","text":"Same as Example AnalogReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_20","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-44-04communication-examples","text":"","title":"Section 4.4: 04.Communication Examples"},{"location":"04_builtin_examples/#441-asciitable","text":"","title":"4.4.1 ASCIITable"},{"location":"04_builtin_examples/#sketch-code_21","text":"/* ASCII table Prints out byte values in all possible formats: - as raw binary values - as ASCII-encoded decimal, hex, octal, and binary values For more on ASCII, see http://www.asciitable.com and http://en.wikipedia.org/wiki/ASCII The circuit: No external hardware needed. created 2006 by Nicholas Zambetti <http://www.zambetti.com> modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ASCIITable */ void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // prints title with ending line break Serial.println(\"ASCII Table ~ Character Map\"); } // first visible ASCIIcharacter '!' is number 33: int thisByte = 33; // you can also write ASCII characters in single quotes. // for example, '!' is the same as 33, so you could also use this: // int thisByte = '!'; void loop() { // prints value unaltered, i.e. the raw binary version of the byte. // The Serial Monitor interprets all bytes as ASCII, so 33, the first number, // will show up as '!' Serial.write(thisByte); Serial.print(\", dec: \"); // prints value as string as an ASCII-encoded decimal (base 10). // Decimal is the default format for Serial.print() and Serial.println(), // so no modifier is needed: Serial.print(thisByte); // But you can declare the modifier for decimal if you want to. // this also works if you uncomment it: // Serial.print(thisByte, DEC); Serial.print(\", hex: \"); // prints value as string in hexadecimal (base 16): Serial.print(thisByte, HEX); Serial.print(\", oct: \"); // prints value as string in octal (base 8); Serial.print(thisByte, OCT); Serial.print(\", bin: \"); // prints value as string in binary (base 2) also prints ending line break: Serial.println(thisByte, BIN); // if printed last visible character '~' or 126, stop: if (thisByte == 126) { // you could also use if (thisByte == '~') { // This loop loops forever and does nothing while (true) { continue; } } // go on to the next character thisByte++; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_21","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_21","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_21","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#442-dimmer","text":"","title":"4.4.2 Dimmer"},{"location":"04_builtin_examples/#sketch-code_22","text":"/* Dimmer Demonstrates sending data from the computer to the Arduino board, in this case to control the brightness of an LED. The data is sent in individual bytes, each of which ranges from 0 to 255. Arduino reads these bytes and uses them to set the brightness of the LED. The circuit: - LED attached from digital pin 9 to ground through 220 ohm resistor. - Serial connection to Processing, Max/MSP, or another serial application created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Dimmer */ const int ledPin = 9; // the pin that the LED is attached to void setup() { // initialize the serial communication: Serial.begin(9600); // initialize the ledPin as an output: pinMode(ledPin, OUTPUT); } void loop() { byte brightness; // check if data has been sent from the computer: if (Serial.available()) { // read the most recent byte (which will be from 0 to 255): brightness = Serial.read(); // set the brightness of the LED: analogWrite(ledPin, brightness); } } /* Processing code for this example // Dimmer - sends bytes over a serial port // by David A. Mellis // This example code is in the public domain. import processing.serial.*; Serial port; void setup() { size(256, 150); println(\"Available serial ports:\"); // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // Uses the first port in this list (number 0). Change this to select the port // corresponding to your Arduino board. The last parameter (e.g. 9600) is the // speed of the communication. It has to correspond to the value passed to // Serial.begin() in your Arduino sketch. port = new Serial(this, Serial.list()[0], 9600); // If you know the name of the port used by the Arduino board, you can specify // it directly like this. //port = new Serial(this, \"COM1\", 9600); } void draw() { // draw a gradient from black to white for (int i = 0; i < 256; i++) { stroke(i); line(i, 0, i, 150); } // write the current X-position of the mouse to the serial port as // a single byte port.write(mouseX); } */ /* Max/MSP v5 patch for this example ----------begin_max5_patcher---------- 1008.3ocuXszaiaCD9r8uhA5rqAeHIa0aAMaAVf1S6hdoYQAsDiL6JQZHQ2M YWr+2KeX4vjnjXKKkKhhiGQ9MeyCNz+X9rnMp63sQvuB+MLa1OlOalSjUvrC ymEUytKuh05TKJWUWyk5nE9eSyuS6jesvHu4F4MxOuUzB6X57sPKWVzBLXiP xZtGj6q2vafaaT0.BzJfjj.p8ZPukazsQvpfcpFs8mXR3plh8BoBxURIOWyK rxspZ0YI.eTCEh5Vqp+wGtFXZMKe6CZc3yWZwTdCmYW.BBkdiby8v0r+ST.W sD9SdUkn8FYspPbqvnBNFtZWiUyLmleJWo0vuKzeuj2vpJLaWA7YiE7wREui FpDFDp1KcbAFcP5sJoVxp4NB5Jq40ougIDxJt1wo3GDZHiNocKhiIExx+owv AdOEAksDs.RRrOoww1Arc.9RvN2J9tamwjkcqknvAE0l+8WnjHqreNet8whK z6mukIK4d+Xknv3jstvJs8EirMMhxsZIusET25jXbX8xczIl5xPVxhPcTGFu xNDu9rXtUCg37g9Q8Yc+EuofIYmg8QdkPCrOnXsaHwYs3rWx9PGsO+pqueG2 uNQBqWFh1X7qQG+3.VHcHrfO1nyR2TlqpTM9MDsLKNCQVz6KO.+Sfc5j1Ykj jzkn2jwNDRP7LVb3d9LtoWBAOnvB92Le6yRmZ4UF7YpQhiFi7A5Ka8zXhKdA 4r9TRGG7V4COiSbAJKdXrWNhhF0hNUh7uBa4Mba0l7JUK+omjDMwkSn95Izr TOwkdp7W.oPRmNRQsiKeu4j3CkfVgt.NYPEYqMGvvJ48vIlPiyzrIuZskWIS xGJPcmPiWOfLodybH3wjPbMYwlbFIMNHPHFOtLBNaLSa9sGk1TxMzCX5KTa6 WIH2ocxSdngM0QPqFRxyPHFsprrhGc9Gy9xoBjz0NWdR2yW9DUa2F85jG2v9 FgTO4Q8qiC7fzzQNpmNpsY3BrYPVJBMJQ1uVmoItRhw9NrVGO3NMNzYZ+zS7 3WTvTOnUydG5kHMKLqAOjTe7fN2bGSxOZDkMrBrGQ9J1gONBEy0k4gVo8qHc cxmfxVihWz6a3yqY9NazzUYkua9UnynadOtogW.JfsVGRVNEbWF8I+eHtcwJ +wLXqZeSdWLo+FQF6731Tva0BISKTx.cLwmgJsUTTvkg1YsnXmxDge.CDR7x D6YmX6fMznaF7kdczmJXwm.XSOOrdoHhNA7GMiZYLZZR.+4lconMaJP6JOZ8 ftCs1YWHZI3o.sIXezX5ihMSuXzZtk3ai1mXRSczoCS32hAydeyXNEu5SHyS xqZqbd3ZLdera1iPqYxOm++v7SUSz -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_22","text":"Same as Example Fade","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_22","text":"Same as Example Fade","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_22","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#443-graph","text":"","title":"4.4.3 Graph"},{"location":"04_builtin_examples/#sketch-code_23","text":"/* Graph A simple example of communication from the Arduino board to the computer: The value of analog input 0 is sent out the serial port. We call this \"serial\" communication because the connection appears to both the Arduino and the computer as a serial port, even though it may actually use a USB cable. Bytes are sent one after another (serially) from the Arduino to the computer. You can use the Arduino Serial Monitor to view the sent data, or it can be read by Processing, PD, Max/MSP, or any other program capable of reading data from a serial port. The Processing code below graphs the data received so you can see the value of the analog input changing over time. The circuit: - any analog input sensor attached to analog in pin 0 created 2006 by David A. Mellis modified 9 Apr 2012 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Graph */ void setup() { // initialize the serial communication: Serial.begin(9600); } void loop() { // send the value of analog input 0: Serial.println(analogRead(A0)); // wait a bit for the analog-to-digital converter to stabilize after the last // reading: delay(2); } /* Processing code for this example // Graphing sketch // This program takes ASCII-encoded strings from the serial port at 9600 baud // and graphs them. It expects values in the range 0 to 1023, followed by a // newline, or newline and carriage return // created 20 Apr 2005 // updated 24 Nov 2015 // by Tom Igoe // This example code is in the public domain. import processing.serial.*; Serial myPort; // The serial port int xPos = 1; // horizontal position of the graph float inByte = 0; void setup () { // set the window size: size(400, 300); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino, so I open Serial.list()[0]. // Open whatever port is the one you're using. myPort = new Serial(this, Serial.list()[0], 9600); // don't generate a serialEvent() unless you get a newline character: myPort.bufferUntil('\\n'); // set initial background: background(0); } void draw () { // draw the line: stroke(127, 34, 255); line(xPos, height, xPos, height - inByte); // at the edge of the screen, go back to the beginning: if (xPos >= width) { xPos = 0; background(0); } else { // increment the horizontal position: xPos++; } } void serialEvent (Serial myPort) { // get the ASCII string: String inString = myPort.readStringUntil('\\n'); if (inString != null) { // trim off any whitespace: inString = trim(inString); // convert to an int and map to the screen height: inByte = float(inString); println(inByte); inByte = map(inByte, 0, 1023, 0, height); } } */ /* Max/MSP v5 patch for this example ----------begin_max5_patcher---------- 1591.3oc0YszbaaCD9r7uBL5RalQUAO3CvdyS5zVenWZxs5NcfHgjPCIfJIT RTxj+6AOHkoTDooroUs0AQPR73a+1cwtK3WtZxzEpOwqlB9YveAlL4KWMYh6 Q1GLo99ISKXeJMmU451zTUQAWpmNy+NM+SZ2y+sR1l02JuU9t0hJvFlNcMPy dOuBv.U5Rgb0LPpRpYBooM3529latArTUVvzZdFPtsXAuDrrTU.f.sBffXxL vGE50lIHkUVJXq3fRtdaoDvjYfbgjujaFJSCzq4.tLaN.bi1tJefWpqbO0uz 1IjIABoluxrJ1guxh2JfPO2B5zRNyBCLDFcqbwNvuv9fHCb8bvevyyEU2JKT YhkBSWPAfq2TZ6YhqmuMUo0feUn+rYpY4YtY+cFw3lUJdCMYAapZqzwUHX8S crjAd+SIOU6UBAwIygy.Q1+HAA1KH6EveWOFQlitUK92ehfal9kFhUxJ3tWc sgpxadigWExbt1o7Ps5dk3yttivyg20W0VcSmg1G90qtx92rAZbH4ez.ruy1 nhmaDPidE07J+5n2sg6E6oKXxUSmc20o6E3SPRDbrkXnPGUYE.i5nCNB9TxQ jG.G0kCTZtH88f07Rt0ZMMWUw8VvbKVAaTk6GyoraPdZff7rQTejBN54lgyv HE0Ft7AvIvvgvIwO23jBdUkYOuSvIFSiNcjFhiSsUBwsUCh1AgfNSBAeNDBZ DIDqY.f8.YjfjV1HAn9XDTxyNFYatVTkKx3kcK9GraZpI5jv7GOx+Z37Xh82 LSKHIDmDXaESoXRngIZQDKVkpxUkMCyXCQhcCK1z.G457gi3TzMz4RFD515F G3bIQQwcP3SOF0zlkGhiCBQ1kOHHFFlXaEBQIQnCwv9QF1LxPZ.A4jR5cyQs vbvHMJsLll01We+rE2LazX6zYmCraRrsPFwKg1ANBZFY.IAihr8Ox.aH0oAL hB8nQVw0FSJiZeunOykbT6t3r.NP8.iL+bnwNiXuVMNJH9H9YCm89CFXPBER bz422p8.O4dg6kRxdyjDqRwMIHTbT3QFLskxJ8tbmQK4tm0XGeZWF7wKKtYY aTAF.XPNFaaQBinQMJ4QLF0aNHF0JtYuHSxoUZfZY6.UU2ejJTb8lQw8Fo5k Rv6e2PI+fOM71o2ecY1VgTYdCSxxUqLokuYq9jYJi6lxPgD2NIPePLB0mwbG YA9Rgxdiu1k5xiLlSU6JVnx6wzg3sYHwTesB8Z5D7RiGZpXyvDNJY.DQX3.H hvmcUN4bP1yCkhpTle2P37jtBsKrLWcMScEmltOPv22ZfAqQAdKr9HzATQwZ q18PrUGt6Tst2XMCRUfGuhXs6ccn23YloomMqcTiC5iMGPsHsHRWhWFlaenV XcqwgCQiGGJzptyS2ZMODBz6fGza0bzmXBj7+DA94bvpR01MffAlueO7HwcI pWCwmzJdvi9ILgflLAFmyXB6O7ML0YbD26lenmcGxjVsZUN+A6pUK7AtTrPg M+eRYG0qD9j4I7eEbco8Xh6WcO.or9XDC6UCiewbXHkh6xm5LiPEkzpJDRTu mEB44Fgz4NCtJvX.SM1vo2SlTCZGAe7GZu6ahdRyzFOhYZ+mbVVSYptBw.K1 tboIkatIA7c1cTKD1u.honLYV04VkluHsXe0szv9pQCE9Ro3jaVB1o15pz2X zYoBvO5KXCAe0LCYJybE8ZODf4fV8t9qW0zYxq.YJfTosj1bv0xc.SaC0+AV 9V9L.KKyV3SyTcRtmzi6rO.O16USvts4B5xe9EymDvebK0eMfW6+NIsNlE2m eqRyJ0utRq13+RjmqYKN1e.4d61jjdsauXe3.2p6jgi9hsNIv97CoyJ01xzl c3ZhUCtSHx3UZgjoEJYqNY+hYs5zZQVFW19L3JDYaTlMLqAAt1G2yXlnFg9a 53L1FJVcv.cOX0dh7mCVGCLce7GFcQwDdH5Ta3nyAS0pQbHxegr+tGIZORgM RnMj5vGl1Fs16drnk7Tf1XOLgv1n0d2iEsCxR.eQsNOZ4FGF7whofgfI3kES 1kCeOX5L2rifbdu0A9ae2X.V33B1Z+.Bj1FrP5iFrCYCG5EUWSG.hhunHJd. HJ5hhnng3h9HPj4lud02.1bxGw. -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_23","text":"Same as Example AnalogReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_23","text":"Same as Example AnalogReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_23","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#444-midi","text":"","title":"4.4.4 Midi"},{"location":"04_builtin_examples/#sketch-code_24","text":"/* MIDI note player This sketch shows how to use the serial transmit pin (pin 1) to send MIDI note data. If this circuit is connected to a MIDI synth, it will play the notes F#-0 (0x1E) to F#-5 (0x5A) in sequence. The circuit: - digital in 1 connected to MIDI jack pin 5 - MIDI jack pin 2 connected to ground - MIDI jack pin 4 connected to +5V through 220 ohm resistor - Attach a MIDI cable to the jack, then to a MIDI synth, and play music. created 13 Jun 2006 modified 13 Aug 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Midi */ void setup() { // Set MIDI baud rate: Serial.begin(31250); } void loop() { // play notes from F#-0 (0x1E) to F#-5 (0x5A): for (int note = 0x1E; note < 0x5A; note++) { //Note on channel 1 (0x90), some note value (note), middle velocity (0x45): noteOn(0x90, note, 0x45); delay(100); //Note on channel 1 (0x90), some note value (note), silent velocity (0x00): noteOn(0x90, note, 0x00); delay(100); } } // plays a MIDI note. Doesn't check to see that cmd is greater than 127, or that // data values are less than 127: void noteOn(int cmd, int pitch, int velocity) { Serial.write(cmd); Serial.write(pitch); Serial.write(velocity); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_24","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_24","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_24","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#445-multiserial","text":"","title":"4.4.5 MultiSerial"},{"location":"04_builtin_examples/#sketch-code_25","text":"/* Multiple Serial test Receives from the main serial port, sends to the others. Receives from serial port 1, sends to the main serial (Serial 0). This example works only with boards with more than one serial like Arduino Mega, Due, Zero etc. The circuit: - any serial device attached to Serial port 1 - Serial Monitor open on Serial port 0 created 30 Dec 2008 modified 20 May 2012 by Tom Igoe & Jed Roach modified 27 Nov 2015 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/MultiSerialMega */ void setup() { // initialize both serial ports: Serial.begin(9600); Serial1.begin(9600); } void loop() { // read from port 1, send to port 0: if (Serial1.available()) { int inByte = Serial1.read(); Serial.write(inByte); } // read from port 0, send to port 1: if (Serial.available()) { int inByte = Serial.read(); Serial1.write(inByte); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_25","text":"Note There is ONLY 1 pair of RX and TX on Arduino UNO R4 WiFi .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_25","text":"Note There is an error from the official Arduino built-in example Use Multiple Serial Ports on the Arduino Mega . Please refer to my issue asked at RX to TX, and TX to RX?","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_25","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#446-physicalpixel","text":"","title":"4.4.6 PhysicalPixel"},{"location":"04_builtin_examples/#sketch-code_26","text":"/* Physical Pixel An example of using the Arduino board to receive data from the computer. In this case, the Arduino boards turns on an LED when it receives the character 'H', and turns off the LED when it receives the character 'L'. The data can be sent from the Arduino Serial Monitor, or another program like Processing (see code below), Flash (via a serial-net proxy), PD, or Max/MSP. The circuit: - LED connected from digital pin 13 to ground through 220 ohm resistor created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/PhysicalPixel */ const int ledPin = 13; // the pin that the LED is attached to int incomingByte; // a variable to read incoming serial data into void setup() { // initialize serial communication: Serial.begin(9600); // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); } void loop() { // see if there's incoming serial data: if (Serial.available() > 0) { // read the oldest byte in the serial buffer: incomingByte = Serial.read(); // if it's a capital H (ASCII 72), turn on the LED: if (incomingByte == 'H') { digitalWrite(ledPin, HIGH); } // if it's an L (ASCII 76) turn off the LED: if (incomingByte == 'L') { digitalWrite(ledPin, LOW); } } } /* Processing code for this example // Mouse over serial // Demonstrates how to send data to the Arduino I/O board, in order to turn ON // a light if the mouse is over a square and turn it off if the mouse is not. // created 2003-4 // based on examples by Casey Reas and Hernando Barragan // modified 30 Aug 2011 // by Tom Igoe // This example code is in the public domain. import processing.serial.*; float boxX; float boxY; int boxSize = 20; boolean mouseOverBox = false; Serial port; void setup() { size(200, 200); boxX = width / 2.0; boxY = height / 2.0; rectMode(RADIUS); // List all the available serial ports in the output pane. // You will need to choose the port that the Arduino board is connected to // from this list. The first port in the list is port #0 and the third port // in the list is port #2. // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // Open the port that the Arduino board is connected to (in this case #0) // Make sure to open the port at the same speed Arduino is using (9600bps) port = new Serial(this, Serial.list()[0], 9600); } void draw() { background(0); // Test if the cursor is over the box if (mouseX > boxX - boxSize && mouseX < boxX + boxSize && mouseY > boxY - boxSize && mouseY < boxY + boxSize) { mouseOverBox = true; // draw a line around the box and change its color: stroke(255); fill(153); // send an 'H' to indicate mouse is over square: port.write('H'); } else { // return the box to its inactive state: stroke(153); fill(153); // send an 'L' to turn the LED off: port.write('L'); mouseOverBox = false; } // Draw the box rect(boxX, boxY, boxSize, boxSize); } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 1672.3oc2ZszaaiCD9ryuBBebQVCQRYao8xhf1cQCPVfBzh8RRQ.sDsM2HSZ HQmlzh9eu7gjsjsEk7y0oWjiHoHm4aluYHGlueUmtiDuPy5B9Cv8fNc99Uc5 XZR2Pm726zcF4knDRlYXciDylQ4xtWa6SReQZZ+iSeMiEQR.ej8BM4A9C7OO kkAlSjQSAYTdbFfvA27o2c6sfO.Doqd6NfXgDHmRUCKkolg4hT06BfbQJGH3 5Qd2e8d.QJIQSow5tzebZ7BFW.FIHow8.2JAQpVIIYByxo9KIMkSjL9D0BRT sbGHZJIkDoZOSMuQT.8YZ5qpgGI3locF4IpQRzq2nDF+odZMIJkRjpEF44M3 A9nWAum7LKFbSOv+PSRXYOvmIhYiYpg.8A2LOUOxPyH+TjPJA+MS9sIzTRRr QP9rXF31IBZAHpVHkHrfaPRHLuUCzoj9GSoQRqIB52y6Z.tu8o4EX+fddfuj +MrXiwPL5+9cXwrOVvkbxLpomazHbQO7EyX7DpzXYgkFdF6algCQpkX4XUlo hA6oa7GWck9w0Gnmy6RXQOoQeCfWwlzsdnHLTq8n9PCHLv7Cxa6PAN3RCKjh ISRVZ+sSl704Tqt0kocE9R8J+P+RJOZ4ysp6gN0vppBbOTEN8qp0YCq5bq47 PUwfA5e766z7NbGMuncw7VgNRSyQhbnPMGrDsGaFSvKM5NcWoIVdZn44.eOi 9DTRUT.7jDQzSTiF4UzXLc7tLGh4T9pwaFQkGUGIiOOkpBSJUwGsBd40krHQ 9XEvwq2V6eLIhV6GuzP7uzzXBmzsXPSRYwBtVLp7s5lKVv6UN2VW7xRtYDbx 7s7wRgHYDI8YVFaTBshkP49R3rYpH3RlUhTQmK5jMadJyF3cYaTNQMGSyhRE IIUlJaOOukdhoOyhnekEKmZlqU3UkLrk7bpPrpztKBVUR1uorLddk6xIOqNt lBOroRrNVFJGLrDxudpET4kzkstNp2lzuUHVMgk5TDZx9GWumnoQTbhXsEtF tzCcM+z0QKXsngCUtTOEIN0SX2iHTTIIz968.Kf.uhfzUCUuAd3UKd.OKt.N HTynxTQyjpQD9jlwEXeKQxfHCBahUge6RprSa2V4m3aYOMyaP6gah2Yf1zbD jVwZVGFZHHxINFxpjr5CiTS9JiZn6e6nTlXQZTAFj6QCppQwzL0AxVtoi6WE QXsANkEGWMEuwNvhmKTnat7A9RqLq6pXuEwY6xM5xRraoTiurj51J1vKLzFs CvM7HI14Mpje6YRxHOSieTsJpvJORjxT1nERK6s7YTN7sr6rylNwf5zMiHI4 meZ4rTYt2PpVettZERbjJ6PjfqN2loPSrUcusH01CegsGEE5467rnCdqT1ES QxtCvFq.cvGz+BaAHXKzRSfP+2Jf.KCvj5ZLJRAhwi+SWHvPyN3vXiaPn6JR 3eoA.0TkFhTvpsDMIrL20nAkCI4EoYfSHAuiPBdmJRyd.IynYYjIzMvjOTKf 3DLvnvRLDLpWeEOYXMfAZqfQ0.qsnlUdmA33t8CNJ7MZEb.u7fiZHLYzDkJp R7CqEVLGN75U+1JXxFUY.xEEBcRCqhOEkz2bENEWnh4pbh0wY25EefbD6EmW UA6Ip8wFLyuFXx+Wrp8m6iff1B86W7bqJO9+mx8er4E3.abCLrYdA16sBuHx vKT6BlpIGQIhL55W7oicf3ayv3ixQCm4aQuY1HZUPQWY+cASx2WZ3f1fICuz vj5R5ZbM1y8gXYN4dIXaYGq4NhQvS5MmcDADy+S.j8CQ78vk7Q7gtPDX3kFh 3NGaAsYBUAO.8N1U4WKycxbQdrWxJdXd10gNIO+hkUMmm.CZwknu7JbNUYUq 0sOsTsI1QudDtjw0t+xZ85wWZd80tMCiiMADNX4UzrcSeK23su87IANqmA7j tiRzoXi2YRh67ldAk79gPmTe3YKuoY0qdEDV3X8xylCJMTN45JIakB7uY8XW uVr3PO8wWwEoTW8lsfraX7ZqzZDDXCRqNkztHsGCYpIDDAOqxDpMVUMKcOrp 942acPvx2NPocMC1wQZ8glRn3myTykVaEUNLoEeJjVaAevA4EAZnsNgkeyO+ 3rEZB7f0DTazDcQTNmdt8aACGi1QOWnMmd+.6YjMHH19OB5gKsMF877x8wsJ hN97JSnSfLUXGUoj6ujWXd6Pk1SAC+Pkogm.tZ.1lX1qL.pe6PE11DPeMMZ2 .P0K+3peBt3NskC -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_26","text":"Same as Example Blink","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_26","text":"Same as Example Blink","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_26","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#447-readasciistring","text":"","title":"4.4.7 ReadASCIIString"},{"location":"04_builtin_examples/#sketch-code_27","text":"/* Reading a serial ASCII-encoded string. This sketch demonstrates the Serial parseInt() function. It looks for an ASCII string of comma-separated values. It parses them into ints, and uses those to fade an RGB LED. Circuit: Common-Cathode RGB LED wired like so: - red anode: digital pin 3 through 220 ohm resistor - green anode: digital pin 5 through 220 ohm resistor - blue anode: digital pin 6 through 220 ohm resistor - cathode: GND created 13 Apr 2012 by Tom Igoe modified 14 Mar 2016 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ReadASCIIString */ // pins for the LEDs: const int redPin = 3; const int greenPin = 5; const int bluePin = 6; void setup() { // initialize serial: Serial.begin(9600); // make the pins outputs: pinMode(redPin, OUTPUT); pinMode(greenPin, OUTPUT); pinMode(bluePin, OUTPUT); } void loop() { // if there's any serial available, read it: while (Serial.available() > 0) { // look for the next valid integer in the incoming serial stream: int red = Serial.parseInt(); // do it again: int green = Serial.parseInt(); // do it again: int blue = Serial.parseInt(); // look for the newline. That's the end of your sentence: if (Serial.read() == '\\n') { // constrain the values to 0 - 255 and invert // if you're using a common-cathode LED, just use \"constrain(color, 0, 255);\" red = 255 - constrain(red, 0, 255); green = 255 - constrain(green, 0, 255); blue = 255 - constrain(blue, 0, 255); // fade the red, green, and blue legs of the LED: analogWrite(redPin, red); analogWrite(greenPin, green); analogWrite(bluePin, blue); // print the three numbers in one string as hexadecimal: Serial.print(red, HEX); Serial.print(green, HEX); Serial.println(blue, HEX); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_27","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_27","text":"Note There is an error from the official Arduino built-in example Read ASCII String .","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_27","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#448-serialcallresponse","text":"","title":"4.4.8 SerialCallResponse"},{"location":"04_builtin_examples/#sketch-code_28","text":"/* Serial Call and Response Language: Wiring/Arduino This program sends an ASCII A (byte of value 65) on startup and repeats that until it gets some data in. Then it waits for a byte in the serial port, and sends three sensor values whenever it gets a byte in. The circuit: - potentiometers attached to analog inputs 0 and 1 - pushbutton attached to digital I/O 2 created 26 Sep 2005 by Tom Igoe modified 24 Apr 2012 by Tom Igoe and Scott Fitzgerald Thanks to Greg Shakar and Scott Fitzgerald for the improvements This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialCallResponse */ int firstSensor = 0; // first analog sensor int secondSensor = 0; // second analog sensor int thirdSensor = 0; // digital sensor int inByte = 0; // incoming serial byte void setup() { // start serial port at 9600 bps: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } pinMode(2, INPUT); // digital sensor is on digital pin 2 establishContact(); // send a byte to establish contact until receiver responds } void loop() { // if we get a valid byte, read analog ins: if (Serial.available() > 0) { // get incoming byte: inByte = Serial.read(); // read first analog input, divide by 4 to make the range 0-255: firstSensor = analogRead(A0) / 4; // delay 10ms to let the ADC recover: delay(10); // read second analog input, divide by 4 to make the range 0-255: secondSensor = analogRead(1) / 4; // read switch, map it to 0 or 255L thirdSensor = map(digitalRead(2), 0, 1, 0, 255); // send sensor values: Serial.write(firstSensor); Serial.write(secondSensor); Serial.write(thirdSensor); } } void establishContact() { while (Serial.available() <= 0) { Serial.print('A'); // send a capital A delay(300); } } /* Processing sketch to run with this example: // This example code is in the public domain. import processing.serial.*; int bgcolor; // Background color int fgcolor; // Fill color Serial myPort; // The serial port int[] serialInArray = new int[3]; // Where we'll put what we receive int serialCount = 0; // A count of how many bytes we receive int xpos, ypos; // Starting position of the ball boolean firstContact = false; // Whether we've heard from the microcontroller void setup() { size(256, 256); // Stage size noStroke(); // No border on the next thing drawn // Set the starting position of the ball (middle of the stage) xpos = width / 2; ypos = height / 2; // Print a list of the serial ports for debugging purposes // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my FTDI // adaptor, so I open Serial.list()[0]. // On Windows machines, this generally opens COM1. // Open whatever port is the one you're using. String portName = Serial.list()[0]; myPort = new Serial(this, portName, 9600); } void draw() { background(bgcolor); fill(fgcolor); // Draw the shape ellipse(xpos, ypos, 20, 20); } void serialEvent(Serial myPort) { // read a byte from the serial port: int inByte = myPort.read(); // if this is the first byte received, and it's an A, clear the serial // buffer and note that you've had first contact from the microcontroller. // Otherwise, add the incoming byte to the array: if (firstContact == false) { if (inByte == 'A') { myPort.clear(); // clear the serial port buffer firstContact = true; // you've had first contact from the microcontroller myPort.write('A'); // ask for more } } else { // Add the latest byte from the serial port to array: serialInArray[serialCount] = inByte; serialCount++; // If we have 3 bytes: if (serialCount > 2 ) { xpos = serialInArray[0]; ypos = serialInArray[1]; fgcolor = serialInArray[2]; // print the values (for debugging purposes only): println(xpos + \"\\t\" + ypos + \"\\t\" + fgcolor); // Send a capital A to request new sensor readings: myPort.write('A'); // Reset serialCount: serialCount = 0; } } } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 3908.3oc6ckziiaiE9b0+J3XjCIXpp.WzZNMURv.jCInQ5fYNjNngrDssRKK 4nkp6JA4+973hrkrsjncKu0SRiXasQ83G+dKj7QV+4qtaxzrOxKlf9Zzuft6 t+7U2cm7ThSbm936lrL3igIAExaaRJ+CYS+sI2qtTI+ikxSuBMKNojm+N3D4 Aua5KkPwpuoUAkgKhSm+tbdXo5cQXVOhuGwrohuHD4WT7iXzupen3HY4BuqG rH0kzrrzxzfkb4kdJONHo9JoUKiSS3kRgjt4jYUk0mkznPJh+CYgHewpSqty xWVwUh3jIqkEYEfmqQEMr.ETbB+YddQbVZix+tIAqV03z203QDX4ukIKHm6W ep3T0ovqOUN+435m2Rcx+5U0E+FTzVBh9xOsHXIh5YuADg1x4IYgumG0r3mj shmFmtJmWvSKCJ0um0WNhOKnJo7c6GmZe8YAg7Ne381Rc2j44wQYoBgn0SJN c8qCHH1RhQqJi7NRCVsmGt.pGUESCxE31zDdCV.PRyxRZeo0MU.WOHMdYPIu LVIrT75BMd4p73zxVuHdZ.TFKJByyRRZUTpq77dtRDzZFx+PbT4BYY0DJgaO dUcSvj0XTT7bdQY6yUFLun8YZo71jl0TIt042RYNLa4RfCTWfsznKWDWfJpl tJHrbgV6t.AZInfzWP.4INpJHA8za91u+6QN1nk7hh.PpQwonxEbTAWzpilV MimilkmsDtPbo3TPiUdY0pGa9ZShS4gYUJz1pwE1iwCpxbAgJI9DGGwWNzFT ksLf3z7M0MybG6Hj1WngsD7VEXS8j5q7Wu5U0+39ir8QJJS5GMHdtRimL4m1 0e1EVX0YsE2YssINriYRoFRyWVMoRRUGQvnkmms3pnXDYHbBKMPpIOL5i1s8 3rMPwFcRCsGRyPH780.8HBnpWz.vlEQBWJ+0CSunehJSmJxiIZRtNGhhDYrU jt3ZQyA2fHJhZDifXIQHUHH8oGYgOREI5nqHIzhFWUndPyBdB3VzHJGwUhkV rgvRl2UCVNMHcd234lf1DN16HFEIdHt99A5hrp7v5WWMSBQZgMP.Tkwoqig8 W1.Sn1f3h3nn1wLpBypPDzlJ7XinEGkLiMPloWOhrgR7dpZWJQV1faDy35Qj MThMFkWFGsJChQPqrQp8iorV6Q28HBVF4nMVDJj7f1xyYACFScisg.ruLHOW uMUS4Am4pI4PTnHi.6bi02HNzSYnDBe4cgAgKzRk1jc8PJLoH3Ydz6.Q.7K8 tfxx73oUkJq1MGuCy5TpAi.POWZ3AenidLOOIaZPhdjZVW3sdk6LXEGzHb7p Mfr7SEy3SXHyBSxJ3J2ncNNYVJsXG6Me10nj4cfCRFdTFjLo7q3SiCpjjEDM .nvra.GN39.E2CDTHWXPo8.xzfqrHCHKnf5QUYUVdoZPUjCSC7LU8.XtTUXl X8vr51GjwFGLC2AlMdLkU4RiaRrnmJuiudnDk0ZW+9p6TuKBe433JUCzp6fU iOF0SUk2UQYUPNTEkiZubvKa1tsmgL5SCTXGHnnG0CceLpkpR9Rs28IUESWl EwWNKfHlg.zj6Ee7S+nE8A+m9F7Cu40u9gMm+aRp3kYYkKd3GDOz5y+c7b96 K9gfvuIK68uNO6g2vUUL80WxihCVFD9vlB30e2SOrmxUb527RZ3nZNrljGrR 70vs1J9suWuZ3zaHVdG3RIJLgGj2Gfn6TcGcstEfvtH.hpFLlnBndjOLGQAI z98BXc6yQxghmOn6gZqj0ShPOXhynLOjzCESt+XwE8TxrCvrdXo16rqnLgvb HaFmbh29QD+K0DyNdjDwvzQL.NXpoMvoOBxkger0HwMRQbpbCh91fjjG9Idw prTH9SzaSea5a.GQEPnnh43WNefMlsOgx18n.vgUNO.tKl7tDyI3iHzafJHZ VVNedVEbGgYIY42i93prB0i7B7KT1LnnCiyAiinpBnsPV7OG.tYKfBsrJOkG UG5aq26iJw6GyJ4eM5mEgEKaNQPMEBUp.t8.krplOVTlZdJAW27bjvGK7p2p HQPgLOSJDYv4E9gQBYBjMUselRxDy+4WplIzm9JQAWOEmfb.E364B43CAwp5 uRRDEv8hWXprjADMUOYpOg9.bVQpEfhKgGCnAnk.rghBJCdTVICA3sDvAhE5 oU4hf67ea5zWPuILqrD8uiK+i477fjHIt9y.V88yy3uMsZUj7wnxGKNAdPx5 fAZMErDZOcJU4M01WFQokix.pKa+JE1WacmnKFeYd7b.0PeIzB8Kk+5WIZpB Ejt34KJeHgOCh4HK8Y3QiAkAfs8TRhhOkG7AAGQf0qxyfmQxa+PLb8Ex.2PS 4BdO5GB9Hvg+cfJCMofAIMu9Qz+UPCjckqVJlEmyA8Bf.rC6.3hAEuG8TdTU bZljQ0nr1ayIqmTwQYfyRGafZhur5vfuyMSqYNWmtAPwWHalDSuUgT0Bosh. JpAR89Y6Ez5QEfPTQO4J0DHLInIliz8BZV2JfV3Bd36qsQwAVVXbr1BGXp6s Sd5sSDruo74wofx.HxUgxQwTnMLqTXvRmiGh2PUZr5pBynKChjl6feNUjSRn hEUfRPT1GfG9Ik4TQBm.hEZZ.bc38HjAMKGzDRijEm1ifx1dbgzQyKh6FZc3 wOCkRJH+KUh0daWs6wzltWx1puXxlWW6NZWY2JiTBzzILRIANku02NourySM VI1VJTvQZff32AJr+dS9e34QAoA6EGXlGFH9yk7yyQAlVd3SR94g+TxOu1sU Flgd6ICI96LzazyPu1cgqsZ8r74SgF.65+efbMf4pGHT7lgHh30Sha3N5Ia. oqjMf7nsuMwycf7iYDybiAAVr3eC.oTMjpzEr8GDRc9bFRGHYXDrzg.Tlx+q NW8TY1IkzCfZ2IftkQstbB08HUezoDS+oFyI.cWIhWBaDiUo7qIrDO7f.L6n AXqCmyNT9act.z+Iv.GR0uES0ZXfjdz.IczAxQOUR+zvRsUTigRxmyPYeNlj yXv8Peef2ZFzuLzWPPeAE8ELzWXYlhe8WzAcUg+b1UkIoCLzIH60zwASGXau a1Dq2nUY.sox4vng+m0nACePngC9lEMLZMBPodOxf+yx5d4uMCTHm3kJvIIG jcLMedEQldkjpoBkQyjY1Hk.hmSY95Iwos8NDb9VSlIWOIntqgxryUjL6bCJ y1lli5tWWxrQ7YmqGYlc6shK1iY2dr0wtNjYxgHyzaq0OznY235awCr8zSz6 EGd1QNUKf.74dADTBbTbeotjpW95IolY0WpKYONY8M83Rx2MChx3fL+iG5Mm tXpdmvXj8uTvaAL1WjbbarQD4Z6kXBpnm6a69oKV2PY9WY174IbC3CaRQ9iK Q4sYGQpwdtZ5wFrc7n569.M83OOR5ydSB1ZcAWCxdbKuavz9LILxfD.wWO.W Nq+Zu4Es+AP6s5p9jDWH8ET+c85+XbW0.N1nDCTD7U4DGc6ohnU019fS7kQ0 o43luuOGjv5agHp0DT.CysOfgLR3xXlXTUKm16RivRsn3z0O6cl3YScAvtrb hwekGB7BZuqESUzBJWmCvK7t9HF8Ts6cUAPoFWso3aP8ApWyJ3wqOPo2pJDC BQ0NI0Pj8QCQ2r1L5vKaU5lDRYX7yRur1UYYZmJQ9iDHwN9dndB5n5ejflmm UsBwLHnDkKXWRuAkb3NeuzqRstiQGP.fCQFdHNzaE.8u58Nz9svFE9SGIE1X kv9Iwfl1BdNWjA7xcThsWCS847loyFD8pZq2E2F04lYULzBTDYhrFSDDJdjo fisN2NUN26e4xRu51zD5ZseJ4HC63WyIX6jRqsp0jangBnK.Qlo58PCpWevt ahzqK7fbKsdX6R64aao8LmWhBPh9jKVAPMzb5a2cV6opdWHneMmqMEmAGsPh ieigIjV+4gF1GgbMNXg+NH44YaRYyd..S1ThHzKhFwwGRaWVITqyj9FvPqMT d0pDuSqDrOGF.Uogf.juCFi9WAUkYR+rFPanDcPG8SbrtjyG03ZQ8m3AqC5H NcUUoXSwVrqXKVcZu.5ZnkwIfIVdXVZTwAuTTUiYuxwjZDK6ZgnRtYV8tJmP hEcuXgz2Goxyaiw35UkaWbpqtfzD02oUkkYqi.YQbZqIIWrIljFolsdmMKFR wCJ2+DTn.9QlkOld+d9Qy9IJdpLfy05Ik2b8GsG9h8rdm1ZFx1FrmmlA2snw qI9Mcdi2nr6q3Gc87nLawurbw1dda+tMyGJ9HaQmlkGwy6davisMgrkM65oz eulfYCzG46am8tSDK144xV4cEvVMTRXq9CIX8+ALNWb6sttKNkiZetnbz+lx cQnb1Nds2C0tvLNe14hwQtxYbxhqc17qHfamUcZZ3NYSWqjJuiDoizZ+ud2j naRK4k3346IIVdR1kKiQjM39adMamvc6n+Xp36Yf3SIGh3uKbquqs1JksTII kuJ7RrZSFb2Cn9j5a6DT8cMo0iczU+lsYaU8YNVh5k5uzJLU26ZcfuJE6XLY 0mcRp9NTCp+L+Ap+in7Xf3b9jFQBLtIY06PbrGhcrU6N00Qlaf9N0+QPo9nS P6qsI7aYNLSNOHpsAxis0ggnZLjYqyyFkdSqinVsPaqSDZaYBZ6c93uLCjGm iCroJVLzU45iNE.pIUfs3TWb.0FejHp9uANr0GcJPTroFDNOHpkIweLnI1QT dHl3P7LhOF3Ahd9rnvLwAMy5JSdNezGlsIsW9mW44r26js+alhxjlkdhN0YE YqiH5MTeWo6D4Qm.ieLS7OynmuVGSbmbFUlnWWhiQlhOeN+Yl35bq.tGo9JR cj8AVqdz7nSgVB9zNj.FTOU68o5d9KO5TUOGxVMw+jTO8T6wqD0hEiHsOJO5 TTOMoS.zlqN0SpZjz6GcH05ylVM0jwuidlkmAif374ih5M5QPfccr8Hqifff otN8pt3hUcaWu8nosBhwmD0Epw5KmoF.poxy4YHbnjqfPJqcM3Y2vun7nS.i f3eETiqcRX2LR.4QmhZrkoCSGwzZrqKHrVR8caari+55d2caPqmq5n.ywe8Q WrZL9fpwVXeaogMByE6y1SMdjk+gbavbN7fYvVtt1C2XwHJSzpk+tidUO25H UB9onw9mlFQ10fhpZBaDatcMTTEGcJpwzqg92qqiVtM6Cu0IRQ0ndEdfCAqV l0qYAUmPrctbxO4XCuPMa1asYzKDks1D52ZCne6Mednz9qW8+.vfqkDA -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_28","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_28","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_28","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#449-serialcallresponseascii","text":"","title":"4.4.9 SerialCallResponseASCII"},{"location":"04_builtin_examples/#sketch-code_29","text":"/* Serial Call and Response in ASCII Language: Wiring/Arduino This program sends an ASCII A (byte of value 65) on startup and repeats that until it gets some data in. Then it waits for a byte in the serial port, and sends three ASCII-encoded, comma-separated sensor values, truncated by a linefeed and carriage return, whenever it gets a byte in. The circuit: - potentiometers attached to analog inputs 0 and 1 - pushbutton attached to digital I/O 2 created 26 Sep 2005 by Tom Igoe modified 24 Apr 2012 by Tom Igoe and Scott Fitzgerald Thanks to Greg Shakar and Scott Fitzgerald for the improvements This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialCallResponseASCII */ int firstSensor = 0; // first analog sensor int secondSensor = 0; // second analog sensor int thirdSensor = 0; // digital sensor int inByte = 0; // incoming serial byte void setup() { // start serial port at 9600 bps and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } pinMode(2, INPUT); // digital sensor is on digital pin 2 establishContact(); // send a byte to establish contact until receiver responds } void loop() { // if we get a valid byte, read analog ins: if (Serial.available() > 0) { // get incoming byte: inByte = Serial.read(); // read first analog input: firstSensor = analogRead(A0); // read second analog input: secondSensor = analogRead(A1); // read switch, map it to 0 or 255 thirdSensor = map(digitalRead(2), 0, 1, 0, 255); // send sensor values: Serial.print(firstSensor); Serial.print(\",\"); Serial.print(secondSensor); Serial.print(\",\"); Serial.println(thirdSensor); } } void establishContact() { while (Serial.available() <= 0) { Serial.println(\"0,0,0\"); // send an initial string delay(300); } } /* Processing code to run with this example: // This example code is in the public domain. import processing.serial.*; // import the Processing serial library Serial myPort; // The serial port float bgcolor; // Background color float fgcolor; // Fill color float xpos, ypos; // Starting position of the ball void setup() { size(640, 480); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino board, so I open Serial.list()[0]. // Change the 0 to the appropriate number of the serial port that your // microcontroller is attached to. myPort = new Serial(this, Serial.list()[0], 9600); // read bytes into a buffer until you get a linefeed (ASCII 10): myPort.bufferUntil('\\n'); // draw with smooth edges: smooth(); } void draw() { background(bgcolor); fill(fgcolor); // Draw the shape ellipse(xpos, ypos, 20, 20); } // serialEvent method is run automatically by the Processing applet whenever // the buffer reaches the byte value set in the bufferUntil() // method in the setup(): void serialEvent(Serial myPort) { // read the serial buffer: String myString = myPort.readStringUntil('\\n'); // if you got any bytes other than the linefeed: myString = trim(myString); // split the string at the commas and convert the sections into integers: int sensors[] = int(split(myString, ',')); // print out the values you got: for (int sensorNum = 0; sensorNum < sensors.length; sensorNum++) { print(\"Sensor \" + sensorNum + \": \" + sensors[sensorNum] + \"\\t\"); } // add a linefeed after all the sensor values are printed: println(); if (sensors.length > 1) { xpos = map(sensors[0], 0, 1023, 0, width); ypos = map(sensors[1], 0, 1023, 0, height); fgcolor = sensors[2]; } // send a byte to ask for more data: myPort.write(\"A\"); } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 3640.3oc6cs0jZajE94Y9UzKkeHoVloTeSHkm1II0VkeHIthSs6C1obIjZ.E KjHRhY7jT4+9d5KBj.jTCAXfoV6x.sj5VmyWet127ed6MCFm8EQw.z2f9.5l a9yau4F0kjW3FS4aFLO3KgIAEpGaPX174hzxAC02qT7kR80mkkUHPAnBQdbP BZQVdIZRd1bT4r3BDTmkU0YQPY3r3zoeJWDVpe2ttr6cFhvXt7KhyH8W26f9 USkhiTulrw+1czQUszjrzxzf4B0sdP9dqtS5x4woIhREQiWewrkkUW0oViTD +GpFASt2Qd0+51akeLzRPIU7DPXagIFnH.4653f9WAKKyxVHRQNcfDXlih2w puvbdWHAlcTPBRKHg4x5mr74EBMINHV1+iFL.8qG.VMWTTDLUrs.TBH+zAvP nTEhvvxun9pBd6FWH38DWH6DWv6ItbX.RKBOJ7XbP5ztvDesvhBLb6VTwcOg DmiBjnXfiIrjjED0CpP490PEmtPExwQA5EGUVjK.CKQJqtcYl0nCMRAJi76D Z7dQflCCVV1i+ENiTy3AwYaghEA4.KVJx+jHMXbhntJPceO3iBpPOPKtZqtU jUoXtw28fkEimmEIlOI.3Q4iMT9wO+iLxc9O7sN28928t6Ve8uMYo.7EUN6t ePVoUW+6E4hOW7CAgeaV1meWd1cuWnYLy8mKhhClGDd25F3ce+C2si1Ud42+ bZ3IQJOXg7q96t80e50YvDjqHw7VvkRTXhHHuKEerRwmqfBFsS.g9h.HZN3X hJf5Qd+xHZHgzc.mrqeYjbn4E84evfIDUjDtjNwD2iRHV6anmGdbmsfKxTTJ dd93rjtBJ2U42foCwZDqKfYzKkrh4VgYIY4FxVRmN2646f8ck+xw7KrjzOlZ ZYAVfdZgKlaWn29FzA8nfdR2quj.3ejflBJnKr.Dwpf13cZBm85P0rPj.rOB 6fvztPFGkVI0SAPi5NKHmih7E8Ph2e35uOtYN6x6JEQtJVWpV7gRtm2dZy9W +YMCxLHrEvAknQktDVdY7v82SFosgmSGHO56BRRt6mEEKxRKDnGd+2812h9X 5GSeODOcAJ.M9YHHAfjPkyD0GIugn.Ht6bQ.7TTS8DoPtCQCQxWobX+jYPUJ hPn3zgnx7kogphieFZ2j3TwDgH5dzaUscJ77kEnIY4hoYKglVYzcH5KKxJzu qmgegxl.0MLNGBNDsr.5IUz0iAPZFE.0TtLOEdClQYrAAeORwW+XVo3aP+hb DHUBCH.mfbEKfGOPyjQhGiCAdNUUBRcQjij4X.u5MZRDzHSyTDQFbcYdHHIM AzlF1lnoLjKG8UZH5guV1vEkA4kKWbOPGPC9YgjNdJHVy+ZJQ1.Cq.FUWQpA ke.8DbUwi.YEWBUCDhPyAXCEETFbuhICg9EIRiYnGVjKyt0+io.r+9vrxRz+ Nt7OlJxCRhT35u.X0amlI9X5xEQppQwneJrLarPVU7JkGYWVHz2njevz1UoX XkoEWOkxDWO9kXYocoTwuzF611zXJyimB3F5qf9nOT9qesryJTJ1EOcV4cIh IPVWYoOBUMFTl.4sGRRzRT4AOIkRjn8h7LnNJI2mhg6OSk5JZrPJ4i9gfu.R w+NHLCcpfAMij88n+qTPPMt4UTwj3bAnY.h.aIe.RiAEeF8Pdzx3zLkLUs1Z mcmczah0FH4ZmpLcp.rVbX3d0zalKhSiKAxBZ9BU2zTP3uPobgL1Q.U0.kl+ jcBZj1AMOpzsJYjdz0n53QXsfYrqELKblH7yUFoDfPVXbrwDGXqCjwjviT7a rXZbpxOvxzXvpOnPH0GlTJMZog8l2UZJcdPjxjG7ywIYgeFULaInFDk8jpxZ apvMA4cv9X.7.vaRRGFAcPYHMR0dF2BZC7wEJ2TOKeZnCRD+HzJo.OLWSW6r qk2wfI6pGf.pdjC4rpfL2YeK8JYloVf93.ocJEvocv9wAcEiMQgBtl.lb0y9 heKnvtGRs+iHOJHM3uaZbN1jDrhED4FfwfLPCEmH8jV.BB0Z+aF.Vkqc4apU EIb9a5zAcGt5Rf3WdsNJ3R4PXDU0mouHzIca0MWO.KpQjT8oq1SIyqV3mP24 ToxfHpdyOPNqgwoK.W.fxfRNtwsiDSBVlT9ociSMu+jfPQqUtk9paFLMONJK URFMpq7xUuvOXF1HBuN6ndhzfE6nxPXQkKKFGjKQNyHtSptYYVVRyaspyBD3 CRiA0YQYrlbgHdptY77E4wZk5UWSOf9yJByyRRZzT5673NtiNrvmhiJmoZq5 fI73wKp5DFrBihhmBNxadsxfoEMuRiIbutfVcM4FWuyr.2bvrlNF5.3U+q9C sKaa5jkMt70iSd8bC2ZbEFUuAa0DWqYF0tJ91p43649br2nZ2usLGuoxrnQq 6TArNx+1CjRLPpVWf62Kj59ZFRa38Y6D0kRo8AnT8b0g0e4p8+f6.P4sBnaX TqMmPsOdOcjG+dMtOmdzcgLdIGqjX0J+FAVrmSu.L8fAX19Ky1C.e1.z+IB2 qpeCIUV+.I4fARxQGH0i.9ECVZrhZMTheMCkc4XRMsoCgbef2ZFjaF5MXzaH n2PQugYmhe0WjdcU47Z1Ukhb6CwFISy2HNtcvtaNRWdshHNVgHcNMUlopRm4 tJByyLXfI0UN6GM7eUiFTm8BMbctZQC8atOegDu6oveXrgpeaGnfaETvsBJN 6AKuNsT4n+zRVXJtQd+ciEEYKyCq.8ptRTSdBRQrLNcUd5eXcjoa7fyhihZl UrNQxBYZo5g.vpdt8klkJi1QyPvdH7UFMStbvYu8Amu1nY7ECMKGXBqnY2KH Z18Jjl4aYNnEYiQWVzrUxytWNzL0VZ14xglI6isN5kAMi2GZlbYPyNma6FqC aJRs9qEogO+ovfvYFxxjGV07cLnH3QQzm.R.BG7SAkk4wiWVpC2p9jwX23ka 0zSz4M6e1QZY.8mljMNHwLURqZ9FuzslMk8ZJXtcMPeblVut1XYDhdMCpmjZ 8BAqsU9DezKxJAa8Hmbbfi+wccuVv7c0qELrEHB+UAhHWzCfCbKPEyBki24Z clythVwfkYSmlHrPdX8tC5v1iPb5ArPuOWc8NVrRZspq24UxhE0wBcAsMyt2 2LLuqvkKZRXjEq5CM6S3tq9Zm6HD+8Prm0F+jDWn1paUe+2ZuF259kxkiR5W Qf6vzKBtMm+gFrMeuWsKW.6B61VyWOFjz0Zsmwza+.ikxQcAL3iDtbLWMTKm OtyMEFcjWM9iu0rMa81D8kUl3v2ewcHWP5B2HX6kK7t7DL5fs6JVIrO0Z1l3 bEpOP3zih9.gbspPzKDYbRVAQ7CFhtZsYzhW1ko0WEJcG3oAC0aRIyxKsUEI +iDPwOLfp0uNA68MmtSUSmRuNb8d1ttWya7sVWf5Iwf.1LQtZUnqNvT1bS6z E5o2vfqNSH5bufQbuZV09M.E04Mj8XBUiBqNGl5FSt3NGlZaGRpV6wc4kiWi q0twaaORhul1jjsIi7cMjQlJJUaQuhR495nlfRQWRJXkrgmMGXWjKM4jdGJH yovkl4HUetutzWuY5tjFHneGn77rtG3iJ92whCVJxKhBwgGtRaFIzabfNrRn WThd9q24vsZjf9JvHwOKBhprFDmtXYIZ7xISjaO1GE4OK2V9yiS.qFhvrznh 8cKyMZs7EVepT01FlCe0rIC0lUk6NX4N9syCyAE660+ovE9hyGqjaGurrLak G0YwoMlFO4YMSZjd9DcWucsjUr1Yqgy8TluCY3N9Q8.+k0JCD3ZTS0CW8Qyb s19nOxrgjw7VFU+3ooYviK66pCfimt8AAxHOOBkK+EajC2yayWtciMzgdvpM NKORj29YyGcS4wFVlql0wcZTg1yw5wvMNiTpuUzpu.Y0miRlgO0w7wpZI2Em SUBGayVM5eqU4C+rV4ZSPkvXqLJbAHlR3mKwT5ISL8+Kv0k.GWEKwpP3ewk3 7omKIN7EtDmp4ZtHk0BfatXgLhgasHgZrVYaY8AIO7fq8Pas1fFzjd4ibwpd XO4GXOeOG+lcyasNh1R+wVx2yBxeTOT+wiZFYA0P48PNyiiVjAhJlNT4Qvpb uj3aN2qYqJcBfSWhMbf+YCPcsfbNeTC2l9WNc+5eIlkST0RJgupzIn+kysgC X6GGXnYpdYfP0GP6MKQXM3N1Ih6XVvcLuym7B0B5w8v.ahqBI49qJcJ.TaX. N+xBP4NGHhhqYfkRNM9q1f3ZweqyYCQYdGCSZGQ5wBx47o.Ssw+CkcgQOmud KZic4QKzCw+7ROm8nY2LfMsEDtdfeMKSn5Ev95IQhorcqJcBrzPsQUhRNe8M 1X6lhOezC4Bidv1nKcFs8YimJ9n8RWZXiO7aSCxDRLdjd91qU5TnmXCeRvmR 9jnm7b15RmJ9rO4Kr+IgO04BfczyOpqx9npzofOsIlaR8Mo0IUMR48i0mYly lVMwlw6gbloGRezy4yKEw6BHBBWik.eRi3DNM5KDahS.SOE1EjmXl7Uyqo9T AtQAO8fG3oLX3cZFxKh0FLNSRfDaoG74gdvW.ZDU9FMGSdFMBt+IQh.6eIvw FujTkJREGKKcJ3X2WtXf7Ub1HywEqxh2tJnE.FcZhMByrcXQw1x+bOWJYjpy lv8oq55aEHLcwD8hJjxbVU5EigcNtL7Ql76KVVp69Huhcb87vpoCkRYT+96v Hd5Ay1rofMqm+FkLYvv0+GL3FkL6bLp21kL6QFNV8BNM48foWBV4zt1wXm5V 4jkNEbL45dtNw13Iltmi9sAyY0S0l8BR+3yWjVXax7eOmKrp4m0QKIal6VYo SAf5XQxSrCa5l0qk45k5kAzqEgMNgzkz9FmL5abpnu4IhNzZ+0s+OKCSg0. -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_29","text":"Same as Example SerialCallResponse","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_29","text":"Same as Example SerialCallResponse","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_29","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4410-serialevent","text":"","title":"4.4.10 SerialEvent"},{"location":"04_builtin_examples/#sketch-code_30","text":"/* Serial Event example When new serial data arrives, this sketch adds it to a String. When a newline is received, the loop prints the string and clears it. A good test for this is to try it with a GPS receiver that sends out NMEA 0183 sentences. NOTE: The serialEvent() feature is not available on the Leonardo, Micro, or other ATmega32U4 based boards. created 9 May 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialEvent */ String inputString = \"\"; // a String to hold incoming data bool stringComplete = false; // whether the string is complete void setup() { // initialize serial: Serial.begin(9600); // reserve 200 bytes for the inputString: inputString.reserve(200); } void loop() { // print the string when a newline arrives: if (stringComplete) { Serial.println(inputString); // clear the string: inputString = \"\"; stringComplete = false; } } /* SerialEvent occurs whenever a new data comes in the hardware serial RX. This routine is run between each time loop() runs, so using delay inside loop can delay response. Multiple bytes of data may be available. */ void serialEvent() { while (Serial.available()) { // get the new byte: char inChar = (char)Serial.read(); // add it to the inputString: inputString += inChar; // if the incoming character is a newline, set a flag so the main loop can // do something about it: if (inChar == '\\n') { stringComplete = true; } } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_30","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_30","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_30","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4411-serialpassthrough","text":"","title":"4.4.11 SerialPassthrough"},{"location":"04_builtin_examples/#sketch-code_31","text":"/* SerialPassthrough sketch Some boards, like the Arduino 101, the MKR1000, Zero, or the Micro, have one hardware serial port attached to Digital pins 0-1, and a separate USB serial port attached to the IDE Serial Monitor. This means that the \"serial passthrough\" which is possible with the Arduino UNO (commonly used to interact with devices/shields that require configuration via serial AT commands) will not work by default. This sketch allows you to emulate the serial passthrough behaviour. Any text you type in the IDE Serial monitor will be written out to the serial port on Digital pins 0 and 1, and vice-versa. On the 101, MKR1000, Zero, and Micro, \"Serial\" refers to the USB Serial port attached to the Serial Monitor, and \"Serial1\" refers to the hardware serial port attached to pins 0 and 1. This sketch will emulate Serial passthrough using those two Serial ports on the boards mentioned above, but you can change these names to connect any two serial ports on a board that has multiple ports. created 23 May 2016 by Erik Nyquist https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialPassthrough */ void setup() { Serial.begin(9600); Serial1.begin(9600); } void loop() { if (Serial.available()) { // If anything comes in Serial (USB), Serial1.write(Serial.read()); // read it and send it out Serial1 (pins 0 & 1) } if (Serial1.available()) { // If anything comes in Serial1 (pins 0 & 1) Serial.write(Serial1.read()); // read it and send it out Serial (USB) } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_31","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_31","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_31","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4412-virtualcolormixer","text":"","title":"4.4.12 VirtualColorMixer"},{"location":"04_builtin_examples/#sketch-code_32","text":"/* This example reads three analog sensors (potentiometers are easiest) and sends their values serially. The Processing and Max/MSP programs at the bottom take those three values and use them to change the background color of the screen. The circuit: - potentiometers attached to analog inputs 0, 1, and 2 created 2 Dec 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/VirtualColorMixer */ const int redPin = A0; // sensor to control red color const int greenPin = A1; // sensor to control green color const int bluePin = A2; // sensor to control blue color void setup() { Serial.begin(9600); } void loop() { Serial.print(analogRead(redPin)); Serial.print(\",\"); Serial.print(analogRead(greenPin)); Serial.print(\",\"); Serial.println(analogRead(bluePin)); } /* Processing code for this example // This example code is in the public domain. import processing.serial.*; float redValue = 0; // red value float greenValue = 0; // green value float blueValue = 0; // blue value Serial myPort; void setup() { size(200, 200); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino, so I open Serial.list()[0]. // Open whatever port is the one you're using. myPort = new Serial(this, Serial.list()[0], 9600); // don't generate a serialEvent() unless you get a newline character: myPort.bufferUntil('\\n'); } void draw() { // set the background color with the color values: background(redValue, greenValue, blueValue); } void serialEvent(Serial myPort) { // get the ASCII string: String inString = myPort.readStringUntil('\\n'); if (inString != null) { // trim off any whitespace: inString = trim(inString); // split the string on the commas and convert the resulting substrings // into an integer array: float[] colors = float(split(inString, \",\")); // if the array has at least three elements, you know you got the whole // thing. Put the numbers in the color variables: if (colors.length >= 3) { // map them to the range 0-255: redValue = map(colors[0], 0, 1023, 0, 255); greenValue = map(colors[1], 0, 1023, 0, 255); blueValue = map(colors[2], 0, 1023, 0, 255); } } } */ /* Max/MSP patch for this example ----------begin_max5_patcher---------- 1512.3oc4Z00aaaCE8YmeED9ktB35xOjrj1aAsXX4g8xZQeYoXfVh1gqRjdT TsIsn+2K+PJUovVVJ1VMdCAvxThV7bO7b48dIyWtXxzkxaYkSA+J3u.Sl7kK lLwcK6MlT2dxzB5so4zRW2lJXeRt7elNy+HM6Vs61uDDzbOYkNmo02sg4euS 4BSede8S2P0o2vEq+aEKU66PPP7b3LPHDauPvyCmAvv4v6+M7L2XXF2WfCaF lURgVPKbCxzKUbZdySDUEbgABN.ia08R9mccGYGn66qGutNir27qWbg8iY+7 HDRx.Hjf+OPHCQgPdpQHoxhBlwB+QF4cbkthlCRk4REnfeKScs3ZwaugWBbj .PS+.qDPAkZkgPlY5oPS4By2A5aTLFv9pounjsgpnZVF3x27pqtBrRpJnZaa C3WxTkfUJYA.BzR.BhIy.ehquw7dSoJCsrlATLckR.nhLPNWvVwL+Vp1LHL. SjMG.tRaG7OxT5R2c8Hx9B8.wLCxVaGI6qnpj45Ug84kL+6YIM8CqUxJyycF 7bqsBRULGvwfWyRMyovElat7NvqoejaLm4f+fkmyKuVTHy3q3ldhB.WtQY6Z x0BSOeSpTqA+FW+Yy3SyybH3sFy8p0RVCmaMpTyX6HdDZ2JsPbfSogbBMueH JLd6RMBdfRMzPjZvimuWIK2XgFA.ZmtfKoh0Sm88qc6OF4bDQ3P6kEtF6xej .OkjD4H5OllyS+.3FlhY0so4xRlWqyrXErQpt+2rsnXgQNZHZgmMVzEofW7T S4zORQtgIdDbRHrObRzSMNofUVZVcbKbhQZrSOo934TqRHIN2ncr7BF8TKR1 tHDqL.PejLRRPKMR.pKFAkbtDa+UOvsYsIFH0DYsTCjqZ66T1CmGeDILLpSm myk0SdkOKh5LUr4GbWwRYdW7fm.BvDmzHnSdH3biGpSbxxDNJoGDAD1ChH7L I0DaloOTBLvkO7zPs5HJnKNoGAXbol5eytUhfyiSfnjE1uAq+Fp0a+wygGwR q3ZI8.psJpkpJnyPzwmXBj7Sh.+bNvVZxlcKAm0OYHIxcIjzEKdRChgO5UMf LkMPNN0MfiS7Ev6TYQct.F5IWcCZ4504rGsiVswGWWSYyma01QcZgmL+f+sf oU18Hn6o6dXkMkFF14TL9rIAWE+6wvGV.p.TPqz3HK5L+VxYxl4UmBKEjr.B 6zinuKI3C+D2Y7azIM6N7QL6t+jQyZxymK1ToAKqVsxjlGyjz2c1kTK3180h kJEYkacWpv6lyp2VJTjWK47wHA6fyBOWxH9pUf6jUtZkLpNKW.9EeUBH3ymY XSQlaqGrkQMGzp20adYSmIOGjIABo1xZyAWJtCX9tg6+HMuhMCPyx76ao+Us UxmzUE79H8d2ZB1m1ztbnOa1mGeAq0awyK8a9UqBUc6pZolpzurTK232e5gp aInVw8QIIcpaiNSJfY4Z+92Cs+Mc+mgg2cEsvGlLY6V+1kMuioxnB5VM+fsY 9vSu4WI1PMBGXye6KXvNuzmZTh7U9h5j6vvASdngPdgOFxycNL6ia1axUMmT JIzebXcQCn3SKMf+4QCMmOZung+6xBCPLfwO8ngcEI52YJ1y7mx3CN9xKUYU bg7Y1yXjlKW6SrZnguQdsSfOSSDItqv2jwJFjavc1vO7OigyBr2+gDYorRk1 HXZpVFfu2FxXkZtfp4RQqNkX5y2sya3YYL2iavWAOaizH+pw.Ibg8f1I9h3Z 2B79sNeOHvBOtfEalWsvyu0KMf015.AaROvZ7vv5AhnndfHLbTgjcCK1KlHv gOk5B26OqrXjcJ005.QqCHn8fVTxnxfj93SfQiJlv8YV0VT9fVUwOOhSV3uD eeqCUClbBPa.j3vWDoMZssNTzRNEnE6gYPXazZaMF921syaLWyAeBXvCESA8 ASi6Zyw8.RQi65J8ZsNx3ho93OhGWENtWpowepae4YhCFeLErOLENtXJrOSc iadi39rf4hwc8xdhHz3gn3dBI7iDRlFe8huAfIZhq -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_32","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_32","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_32","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-45-05control-examples","text":"","title":"Section 4.5: 05.Control Examples"},{"location":"04_builtin_examples/#451-arrays","text":"","title":"4.5.1 Arrays"},{"location":"04_builtin_examples/#sketch-code_33","text":"/* Arrays Demonstrates the use of an array to hold pin numbers in order to iterate over the pins in a sequence. Lights multiple LEDs in sequence, then in reverse. Unlike the For Loop tutorial, where the pins have to be contiguous, here the pins can be in any random order. The circuit: - LEDs from pins 2 through 7 to ground created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Arrays */ int timer = 100; // The higher the number, the slower the timing. int ledPins[] = { 2, 7, 4, 6, 5, 3 }; // an array of pin numbers to which LEDs are attached int pinCount = 6; // the number of pins (i.e. the length of the array) void setup() { // the array elements are numbered from 0 to (pinCount - 1). // use a for loop to initialize each pin as an output: for (int thisPin = 0; thisPin < pinCount; thisPin++) { pinMode(ledPins[thisPin], OUTPUT); } } void loop() { // loop from the lowest pin to the highest: for (int thisPin = 0; thisPin < pinCount; thisPin++) { // turn the pin on: digitalWrite(ledPins[thisPin], HIGH); delay(timer); // turn the pin off: digitalWrite(ledPins[thisPin], LOW); } // loop from the highest pin to the lowest: for (int thisPin = pinCount - 1; thisPin >= 0; thisPin--) { // turn the pin on: digitalWrite(ledPins[thisPin], HIGH); delay(timer); // turn the pin off: digitalWrite(ledPins[thisPin], LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_33","text":"Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs.","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_33","text":"Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs.","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_33","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#452-forloopiteration","text":"","title":"4.5.2 ForLoopIteration"},{"location":"04_builtin_examples/#sketch-code_34","text":"/* For Loop Iteration Demonstrates the use of a for() loop. Lights multiple LEDs in sequence, then in reverse. The circuit: - LEDs from pins 2 through 7 to ground created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ForLoopIteration */ int timer = 100; // The higher the number, the slower the timing. void setup() { // use a for loop to initialize each pin as an output: for (int thisPin = 2; thisPin < 8; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // loop from the lowest pin to the highest: for (int thisPin = 2; thisPin < 8; thisPin++) { // turn the pin on: digitalWrite(thisPin, HIGH); delay(timer); // turn the pin off: digitalWrite(thisPin, LOW); } // loop from the highest pin to the lowest: for (int thisPin = 7; thisPin >= 2; thisPin--) { // turn the pin on: digitalWrite(thisPin, HIGH); delay(timer); // turn the pin off: digitalWrite(thisPin, LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_34","text":"Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs.","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_34","text":"Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs.","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_34","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#453-ifstatementconditional","text":"","title":"4.5.3 IfStatementConditional"},{"location":"04_builtin_examples/#sketch-code_35","text":"/* Conditionals - If statement This example demonstrates the use of if() statements. It reads the state of a potentiometer (an analog input) and turns on an LED only if the potentiometer goes above a certain threshold level. It prints the analog value regardless of the level. The circuit: - potentiometer Center pin of the potentiometer goes to analog pin 0. Side pins of the potentiometer go to +5V and ground. - LED connected from digital pin 13 to ground through 220 ohm resistor - Note: On most Arduino boards, there is already an LED on the board connected to pin 13, so you don't need any extra components for this example. created 17 Jan 2009 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/ifStatementConditional // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/ifStatementConditional */ // These constants won't change: const int analogPin = A0; // pin that the sensor is attached to const int ledPin = 13; // pin that the LED is attached to const int threshold = 400; // an arbitrary threshold level that's in the range of the analog input void setup() { // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); // initialize serial communications: Serial.begin(9600); } void loop() { // read the value of the potentiometer: int analogValue = analogRead(analogPin); // if the analog value is high enough, turn on the LED: if (analogValue > threshold) { digitalWrite(ledPin, HIGH); } else { digitalWrite(ledPin, LOW); } // print the analog value: Serial.println(analogValue); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_35","text":"Same as Example AnalogReadSerial .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_35","text":"Same as Example AnalogReadSerial .","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_35","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#454-switchcase","text":"","title":"4.5.4 switchCase"},{"location":"04_builtin_examples/#sketch-code_36","text":"/* Switch statement Demonstrates the use of a switch statement. The switch statement allows you to choose from among a set of discrete values of a variable. It's like a series of if statements. To see this sketch in action, put the board and sensor in a well-lit room, open the Serial Monitor, and move your hand gradually down over the sensor. The circuit: - photoresistor from analog in 0 to +5V - 10K resistor from analog in 0 to ground created 1 Jul 2009 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/SwitchCase // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/SwitchCase */ // these constants won't change. They are the lowest and highest readings you // get from your sensor: const int sensorMin = 0; // sensor minimum, discovered through experiment const int sensorMax = 600; // sensor maximum, discovered through experiment void setup() { // initialize serial communication: Serial.begin(9600); } void loop() { // read the sensor: int sensorReading = analogRead(A0); // map the sensor range to a range of four options: int range = map(sensorReading, sensorMin, sensorMax, 0, 3); // do something different depending on the range value: switch (range) { case 0: // your hand is on the sensor Serial.println(\"dark\"); break; case 1: // your hand is close to the sensor Serial.println(\"dim\"); break; case 2: // your hand is a few inches from the sensor Serial.println(\"medium\"); break; case 3: // your hand is nowhere near the sensor Serial.println(\"bright\"); break; } delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_36","text":"Same as Example AnalogInput .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_36","text":"Same as Example AnalogInput .","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_36","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#455-switchcase2","text":"","title":"4.5.5 switchCase2"},{"location":"04_builtin_examples/#sketch-code_37","text":"/* Switch statement with serial input Demonstrates the use of a switch statement. The switch statement allows you to choose from among a set of discrete values of a variable. It's like a series of if statements. To see this sketch in action, open the Serial monitor and send any character. The characters a, b, c, d, and e, will turn on LEDs. Any other character will turn the LEDs off. The circuit: - five LEDs attached to digital pins 2 through 6 through 220 ohm resistors created 1 Jul 2009 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/SwitchCase2 // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/SwitchCase2 */ void setup() { // initialize serial communication: Serial.begin(9600); // initialize the LED pins: for (int thisPin = 2; thisPin < 7; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // read the sensor: if (Serial.available() > 0) { int inByte = Serial.read(); // do something different depending on the character received. // The switch statement expects single number values for each case; in this // example, though, you're using single quotes to tell the controller to get // the ASCII value for the character. For example 'a' = 97, 'b' = 98, // and so forth: switch (inByte) { case 'a': digitalWrite(2, HIGH); break; case 'b': digitalWrite(3, HIGH); break; case 'c': digitalWrite(4, HIGH); break; case 'd': digitalWrite(5, HIGH); break; case 'e': digitalWrite(6, HIGH); break; default: // turn all the LEDs off: for (int thisPin = 2; thisPin < 7; thisPin++) { digitalWrite(thisPin, LOW); } } } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_37","text":"Similar to Example AnalogWriteMega , but use 5 LEDs rather than 12 LEDs.","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_37","text":"Similar to Example AnalogWriteMega , but use 5 LEDs rather than 12 LEDs.","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_37","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#456-whilestatementconditional","text":"","title":"4.5.6 WhileStatementConditional"},{"location":"04_builtin_examples/#sketch-code_38","text":"/* Conditionals - while statement This example demonstrates the use of while() statements. While the pushbutton is pressed, the sketch runs the calibration routine. The sensor readings during the while loop define the minimum and maximum of expected values from the photoresistor. This is a variation on the calibrate example. The circuit: - photoresistor connected from +5V to analog in pin 0 - 10 kilohm resistor connected from ground to analog in pin 0 - LED connected from digital pin 9 to ground through 220 ohm resistor - pushbutton attached from pin 2 to +5V - 10 kilohm resistor attached from pin 2 to ground created 17 Jan 2009 modified 30 Aug 2011 by Tom Igoe modified 20 Jan 2017 by Arturo Guadalupi This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/WhileStatementConditional // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/WhileStatementConditional */ // These constants won't change: const int sensorPin = A0; // pin that the sensor is attached to const int ledPin = 9; // pin that the LED is attached to const int indicatorLedPin = 13; // pin that the built-in LED is attached to const int buttonPin = 2; // pin that the button is attached to // These variables will change: int sensorMin = 1023; // minimum sensor value int sensorMax = 0; // maximum sensor value int sensorValue = 0; // the sensor value void setup() { // set the LED pins as outputs and the switch pin as input: pinMode(indicatorLedPin, OUTPUT); pinMode(ledPin, OUTPUT); pinMode(buttonPin, INPUT); } void loop() { // while the button is pressed, take calibration readings: while (digitalRead(buttonPin) == HIGH) { calibrate(); } // signal the end of the calibration period digitalWrite(indicatorLedPin, LOW); // read the sensor: sensorValue = analogRead(sensorPin); // apply the calibration to the sensor reading sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255); // in case the sensor value is outside the range seen during calibration sensorValue = constrain(sensorValue, 0, 255); // fade the LED using the calibrated value: analogWrite(ledPin, sensorValue); } void calibrate() { // turn on the indicator LED to indicate that calibration is happening: digitalWrite(indicatorLedPin, HIGH); // read the sensor: sensorValue = analogRead(sensorPin); // record the maximum sensor value if (sensorValue > sensorMax) { sensorMax = sensorValue; } // record the minimum sensor value if (sensorValue < sensorMin) { sensorMin = sensorValue; } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_38","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_38","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_38","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-46-06sensors-examples","text":"","title":"Section 4.6: 06.Sensors Examples"},{"location":"04_builtin_examples/#461-adxl3xx","text":"","title":"4.6.1 ADXL3xx"},{"location":"04_builtin_examples/#sketch-code_39","text":"/* ADXL3xx Reads an Analog Devices ADXL3xx accelerometer and communicates the acceleration to the computer. The pins used are designed to be easily compatible with the breakout boards from SparkFun, available from: https://www.sparkfun.com/categories/80 The circuit: - analog 0: accelerometer self test - analog 1: z-axis - analog 2: y-axis - analog 3: x-axis - analog 4: ground - analog 5: vcc created 2 Jul 2008 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ADXL3xx */ // these constants describe the pins. They won't change: const int groundpin = 18; // analog input pin 4 -- ground const int powerpin = 19; // analog input pin 5 -- voltage const int xpin = A3; // x-axis of the accelerometer const int ypin = A2; // y-axis const int zpin = A1; // z-axis (only on 3-axis models) void setup() { // initialize the serial communications: Serial.begin(9600); // Provide ground and power by using the analog inputs as normal digital pins. // This makes it possible to directly connect the breakout board to the // Arduino. If you use the normal 5V and GND pins on the Arduino, // you can remove these lines. pinMode(groundpin, OUTPUT); pinMode(powerpin, OUTPUT); digitalWrite(groundpin, LOW); digitalWrite(powerpin, HIGH); } void loop() { // print the sensor values: Serial.print(analogRead(xpin)); // print a tab between values: Serial.print(\"\\t\"); Serial.print(analogRead(ypin)); // print a tab between values: Serial.print(\"\\t\"); Serial.print(analogRead(zpin)); Serial.println(); // delay before next reading: delay(100); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_39","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_39","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_39","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#462-knock","text":"","title":"4.6.2 Knock"},{"location":"04_builtin_examples/#sketch-code_40","text":"/* Knock Sensor This sketch reads a piezo element to detect a knocking sound. It reads an analog pin and compares the result to a set threshold. If the result is greater than the threshold, it writes \"knock\" to the serial port, and toggles the LED on pin 13. The circuit: - positive connection of the piezo attached to analog in 0 - negative connection of the piezo attached to ground - 1 megohm resistor attached from analog in 0 to ground created 25 Mar 2007 by David Cuartielles <http://www.0j0.org> modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Knock */ // these constants won't change: const int ledPin = 13; // LED connected to digital pin 13 const int knockSensor = A0; // the piezo is connected to analog pin 0 const int threshold = 100; // threshold value to decide when the detected sound is a knock or not // these variables will change: int sensorReading = 0; // variable to store the value read from the sensor pin int ledState = LOW; // variable used to store the last LED status, to toggle the light void setup() { pinMode(ledPin, OUTPUT); // declare the ledPin as as OUTPUT Serial.begin(9600); // use the serial port } void loop() { // read the sensor and store it in the variable sensorReading: sensorReading = analogRead(knockSensor); // if the sensor reading is greater than the threshold: if (sensorReading >= threshold) { // toggle the status of the ledPin: ledState = !ledState; // update the LED pin itself: digitalWrite(ledPin, ledState); // send the string \"Knock!\" back to the computer, followed by newline Serial.println(\"Knock!\"); } delay(100); // delay to avoid overloading the serial port buffer }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_40","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_40","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_40","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#463-memsic2125","text":"Note Ignored. Memsic 2125 is outdated and deprecated.","title":"4.6.3 Memsic2125"},{"location":"04_builtin_examples/#sketch-code_41","text":"Note Ignored. Memsic 2125 is outdated and deprecated.","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_41","text":"Note Ignored. Memsic 2125 is outdated and deprecated.","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_41","text":"Note Ignored. Memsic 2125 is outdated and deprecated.","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_41","text":"Note Ignored. Memsic 2125 is outdated and deprecated.","title":"Video Demonstration"},{"location":"04_builtin_examples/#464-ping","text":"Note SEN136B5B is outdated and deprecated. We're NOT using the demo from official Arduino examples, but use HC-SR04 as a replacement of SEN136B5B . For this particular example, please refer to Ultrasonic Sensor HC-SR04 and Arduino \u2013 Complete Guide .","title":"4.6.4 Ping"},{"location":"04_builtin_examples/#sketch-code_42","text":"/* Ultrasonic Sensor HC-SR04 and Arduino Tutorial by Dejan Nedelkovski, www.HowToMechatronics.com */ // defines pins numbers const int trigPin = 9; const int echoPin = 10; // defines variables long duration; int distance; void setup() { pinMode(trigPin, OUTPUT); // Sets the trigPin as an Output pinMode(echoPin, INPUT); // Sets the echoPin as an Input Serial.begin(9600); // Starts the serial communication } void loop() { // Clears the trigPin digitalWrite(trigPin, LOW); delayMicroseconds(2); // Sets the trigPin on HIGH state for 10 micro seconds digitalWrite(trigPin, HIGH); delayMicroseconds(10); digitalWrite(trigPin, LOW); // Reads the echoPin, returns the sound wave travel time in microseconds duration = pulseIn(echoPin, HIGH); // Calculating the distance distance = duration * 0.034 / 2; // Prints the distance on the Serial Monitor Serial.print(\"Distance: \"); Serial.println(distance); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_42","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_42","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_42","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-47-07display-examples","text":"","title":"Section 4.7: 07.Display Examples"},{"location":"04_builtin_examples/#471-bargraph","text":"","title":"4.7.1 barGraph"},{"location":"04_builtin_examples/#sketch-code_43","text":"/* LED bar graph Turns on a series of LEDs based on the value of an analog sensor. This is a simple way to make a bar graph display. Though this graph uses 10 LEDs, you can use any number by changing the LED count and the pins in the array. This method can be used to control any series of digital outputs that depends on an analog input. The circuit: - LEDs from pins 2 through 11 to ground created 4 Sep 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/BarGraph */ // these constants won't change: const int analogPin = A0; // the pin that the potentiometer is attached to const int ledCount = 10; // the number of LEDs in the bar graph int ledPins[] = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }; // an array of pin numbers to which LEDs are attached void setup() { // loop over the pin array and set them all to output: for (int thisLed = 0; thisLed < ledCount; thisLed++) { pinMode(ledPins[thisLed], OUTPUT); } } void loop() { // read the potentiometer: int sensorReading = analogRead(analogPin); // map the result to a range from 0 to the number of LEDs: int ledLevel = map(sensorReading, 0, 1023, 0, ledCount); // loop over the LED array: for (int thisLed = 0; thisLed < ledCount; thisLed++) { // if the array element's index is less than ledLevel, // turn the pin for this element on: if (thisLed < ledLevel) { digitalWrite(ledPins[thisLed], HIGH); } // turn off all pins higher than the ledLevel: else { digitalWrite(ledPins[thisLed], LOW); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_43","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_43","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_43","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#472-rowcolumnscanning","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"4.7.2 RowColumnScanning"},{"location":"04_builtin_examples/#sketch-code_44","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_44","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_44","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_44","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-48-08strings-examples","text":"","title":"Section 4.8: 08.Strings Examples"},{"location":"04_builtin_examples/#481-characteranalysis","text":"","title":"4.8.1 CharacterAnalysis"},{"location":"04_builtin_examples/#sketch-code_45","text":"/* Character analysis operators Examples using the character analysis operators. Send any byte and the sketch will tell you about it. created 29 Nov 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/CharacterAnalysis */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"send any byte and I'll tell you everything I can about it\"); Serial.println(); } void loop() { // get any incoming bytes: if (Serial.available() > 0) { int thisChar = Serial.read(); // say what was sent: Serial.print(\"You sent me: \\'\"); Serial.write(thisChar); Serial.print(\"\\' ASCII Value: \"); Serial.println(thisChar); // analyze what was sent: if (isAlphaNumeric(thisChar)) { Serial.println(\"it's alphanumeric\"); } if (isAlpha(thisChar)) { Serial.println(\"it's alphabetic\"); } if (isAscii(thisChar)) { Serial.println(\"it's ASCII\"); } if (isWhitespace(thisChar)) { Serial.println(\"it's whitespace\"); } if (isControl(thisChar)) { Serial.println(\"it's a control character\"); } if (isDigit(thisChar)) { Serial.println(\"it's a numeric digit\"); } if (isGraph(thisChar)) { Serial.println(\"it's a printable character that's not whitespace\"); } if (isLowerCase(thisChar)) { Serial.println(\"it's lower case\"); } if (isPrintable(thisChar)) { Serial.println(\"it's printable\"); } if (isPunct(thisChar)) { Serial.println(\"it's punctuation\"); } if (isSpace(thisChar)) { Serial.println(\"it's a space character\"); } if (isUpperCase(thisChar)) { Serial.println(\"it's upper case\"); } if (isHexadecimalDigit(thisChar)) { Serial.println(\"it's a valid hexadecimaldigit (i.e. 0 - 9, a - F, or A - F)\"); } // add some space and ask for another byte: Serial.println(); Serial.println(\"Give me another byte:\"); Serial.println(); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_45","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_45","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_45","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#482-stringadditionoperator","text":"","title":"4.8.2 StringAdditionOperator"},{"location":"04_builtin_examples/#sketch-code_46","text":"/* Adding Strings together Examples of how to add Strings together You can also add several different data types to String, as shown here: created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringAdditionOperator */ // declare three Strings: String stringOne, stringTwo, stringThree; void setup() { // initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"You added \"); stringTwo = String(\"this string\"); stringThree = String(); // send an intro: Serial.println(\"\\n\\nAdding Strings together (concatenation):\"); Serial.println(); } void loop() { // adding a constant integer to a String: stringThree = stringOne + 123; Serial.println(stringThree); // prints \"You added 123\" // adding a constant long integer to a String: stringThree = stringOne + 123456789; Serial.println(stringThree); // prints \"You added 123456789\" // adding a constant character to a String: stringThree = stringOne + 'A'; Serial.println(stringThree); // prints \"You added A\" // adding a constant string to a String: stringThree = stringOne + \"abc\"; Serial.println(stringThree); // prints \"You added abc\" stringThree = stringOne + stringTwo; Serial.println(stringThree); // prints \"You added this string\" // adding a variable integer to a String: int sensorValue = analogRead(A0); stringOne = \"Sensor value: \"; stringThree = stringOne + sensorValue; Serial.println(stringThree); // prints \"Sensor Value: 401\" or whatever value analogRead(A0) has // adding a variable long integer to a String: stringOne = \"millis() value: \"; stringThree = stringOne + millis(); Serial.println(stringThree); // prints \"The millis: 345345\" or whatever value millis() has // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_46","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_46","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_46","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#483-stringappendoperator","text":"","title":"4.8.3 StringAppendOperator"},{"location":"04_builtin_examples/#sketch-code_47","text":"/* Appending to Strings using the += operator and concat() Examples of how to append different data types to Strings created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringAppendOperator */ String stringOne, stringTwo; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"Sensor \"); stringTwo = String(\"value\"); // send an intro: Serial.println(\"\\n\\nAppending to a String:\"); Serial.println(); } void loop() { Serial.println(stringOne); // prints \"Sensor \" // adding a string to a String: stringOne += stringTwo; Serial.println(stringOne); // prints \"Sensor value\" // adding a constant string to a String: stringOne += \" for input \"; Serial.println(stringOne); // prints \"Sensor value for input\" // adding a constant character to a String: stringOne += 'A'; Serial.println(stringOne); // prints \"Sensor value for input A\" // adding a constant integer to a String: stringOne += 0; Serial.println(stringOne); // prints \"Sensor value for input A0\" // adding a constant string to a String: stringOne += \": \"; Serial.println(stringOne); // prints \"Sensor value for input\" // adding a variable integer to a String: stringOne += analogRead(A0); Serial.println(stringOne); // prints \"Sensor value for input A0: 456\" or whatever analogRead(A0) is Serial.println(\"\\n\\nchanging the Strings' values\"); stringOne = \"A long integer: \"; stringTwo = \"The millis(): \"; // adding a constant long integer to a String: stringOne += 123456789; Serial.println(stringOne); // prints \"A long integer: 123456789\" // using concat() to add a long variable to a String: stringTwo.concat(millis()); Serial.println(stringTwo); // prints \"The millis(): 43534\" or whatever the value of the millis() is // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_47","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_47","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_47","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#484-stringcasechanges","text":"","title":"4.8.4 StringCaseChanges"},{"location":"04_builtin_examples/#sketch-code_48","text":"/* String Case changes Examples of how to change the case of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringCaseChanges */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString case changes:\"); Serial.println(); } void loop() { // toUpperCase() changes all letters to upper case: String stringOne = \"<html><head><body>\"; Serial.println(stringOne); stringOne.toUpperCase(); Serial.println(stringOne); // toLowerCase() changes all letters to lower case: String stringTwo = \"</BODY></HTML>\"; Serial.println(stringTwo); stringTwo.toLowerCase(); Serial.println(stringTwo); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_48","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_48","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_48","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#485-stringcharacters","text":"","title":"4.8.5 StringCharacters"},{"location":"04_builtin_examples/#sketch-code_49","text":"/* String charAt() and setCharAt() Examples of how to get and set characters of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringCharacters */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"\\n\\nString charAt() and setCharAt():\"); } void loop() { // make a String to report a sensor reading: String reportString = \"SensorReading: 456\"; Serial.println(reportString); // the reading's most significant digit is at position 15 in the reportString: char mostSignificantDigit = reportString.charAt(15); String message = \"Most significant digit of the sensor reading is: \"; Serial.println(message + mostSignificantDigit); // add blank space: Serial.println(); // you can also set the character of a String. Change the : to a = character reportString.setCharAt(13, '='); Serial.println(reportString); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_49","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_49","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_49","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#486-stringcomparisonoperators","text":"","title":"4.8.6 StringComparisonOperators"},{"location":"04_builtin_examples/#sketch-code_50","text":"/* Comparing Strings Examples of how to compare Strings using the comparison operators created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringComparisonOperators */ String stringOne, stringTwo; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"this\"); stringTwo = String(\"that\"); // send an intro: Serial.println(\"\\n\\nComparing Strings:\"); Serial.println(); } void loop() { // two Strings equal: if (stringOne == \"this\") { Serial.println(\"StringOne == \\\"this\\\"\"); } // two Strings not equal: if (stringOne != stringTwo) { Serial.println(stringOne + \" =! \" + stringTwo); } // two Strings not equal (case sensitivity matters): stringOne = \"This\"; stringTwo = \"this\"; if (stringOne != stringTwo) { Serial.println(stringOne + \" =! \" + stringTwo); } // you can also use equals() to see if two Strings are the same: if (stringOne.equals(stringTwo)) { Serial.println(stringOne + \" equals \" + stringTwo); } else { Serial.println(stringOne + \" does not equal \" + stringTwo); } // or perhaps you want to ignore case: if (stringOne.equalsIgnoreCase(stringTwo)) { Serial.println(stringOne + \" equals (ignoring case) \" + stringTwo); } else { Serial.println(stringOne + \" does not equal (ignoring case) \" + stringTwo); } // a numeric String compared to the number it represents: stringOne = \"1\"; int numberOne = 1; if (stringOne.toInt() == numberOne) { Serial.println(stringOne + \" = \" + numberOne); } // two numeric Strings compared: stringOne = \"2\"; stringTwo = \"1\"; if (stringOne >= stringTwo) { Serial.println(stringOne + \" >= \" + stringTwo); } // comparison operators can be used to compare Strings for alphabetic sorting too: stringOne = String(\"Brown\"); if (stringOne < \"Charles\") { Serial.println(stringOne + \" < Charles\"); } if (stringOne > \"Adams\") { Serial.println(stringOne + \" > Adams\"); } if (stringOne <= \"Browne\") { Serial.println(stringOne + \" <= Browne\"); } if (stringOne >= \"Brow\") { Serial.println(stringOne + \" >= Brow\"); } // the compareTo() operator also allows you to compare Strings // it evaluates on the first character that's different. // if the first character of the String you're comparing to comes first in // alphanumeric order, then compareTo() is greater than 0: stringOne = \"Cucumber\"; stringTwo = \"Cucuracha\"; if (stringOne.compareTo(stringTwo) < 0) { Serial.println(stringOne + \" comes before \" + stringTwo); } else { Serial.println(stringOne + \" comes after \" + stringTwo); } delay(10000); // because the next part is a loop: // compareTo() is handy when you've got Strings with numbers in them too: while (true) { stringOne = \"Sensor: \"; stringTwo = \"Sensor: \"; stringOne += analogRead(A0); stringTwo += analogRead(A5); if (stringOne.compareTo(stringTwo) < 0) { Serial.println(stringOne + \" comes before \" + stringTwo); } else { Serial.println(stringOne + \" comes after \" + stringTwo); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_50","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_50","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_50","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#487-stringconstructors","text":"","title":"4.8.7 StringConstructors"},{"location":"04_builtin_examples/#sketch-code_51","text":"/* String constructors Examples of how to create Strings from other data types created 27 Jul 2010 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringConstructors */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString Constructors:\"); Serial.println(); } void loop() { // using a constant String: String stringOne = \"Hello String\"; Serial.println(stringOne); // prints \"Hello String\" // converting a constant char into a String: stringOne = String('a'); Serial.println(stringOne); // prints \"a\" // converting a constant string into a String object: String stringTwo = String(\"This is a string\"); Serial.println(stringTwo); // prints \"This is a string\" // concatenating two strings: stringOne = String(stringTwo + \" with more\"); // prints \"This is a string with more\": Serial.println(stringOne); // using a constant integer: stringOne = String(13); Serial.println(stringOne); // prints \"13\" // using an int and a base: stringOne = String(analogRead(A0), DEC); // prints \"453\" or whatever the value of analogRead(A0) is Serial.println(stringOne); // using an int and a base (hexadecimal): stringOne = String(45, HEX); // prints \"2d\", which is the hexadecimal version of decimal 45: Serial.println(stringOne); // using an int and a base (binary) stringOne = String(255, BIN); // prints \"11111111\" which is the binary value of 255 Serial.println(stringOne); // using a long and a base: stringOne = String(millis(), DEC); // prints \"123456\" or whatever the value of millis() is: Serial.println(stringOne); // using a float and the right decimal places: stringOne = String(5.698, 3); Serial.println(stringOne); // using a float and less decimal places to use rounding: stringOne = String(5.698, 2); Serial.println(stringOne); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_51","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_51","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_51","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#488-stringindexof","text":"","title":"4.8.8 StringIndexOf"},{"location":"04_builtin_examples/#sketch-code_52","text":"/* String indexOf() and lastIndexOf() functions Examples of how to evaluate, look for, and replace characters in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringIndexOf */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString indexOf() and lastIndexOf() functions:\"); Serial.println(); } void loop() { // indexOf() returns the position (i.e. index) of a particular character in a // String. For example, if you were parsing HTML tags, you could use it: String stringOne = \"<HTML><HEAD><BODY>\"; int firstClosingBracket = stringOne.indexOf('>'); Serial.println(\"The index of > in the string \" + stringOne + \" is \" + firstClosingBracket); stringOne = \"<HTML><HEAD><BODY>\"; int secondOpeningBracket = firstClosingBracket + 1; int secondClosingBracket = stringOne.indexOf('>', secondOpeningBracket); Serial.println(\"The index of the second > in the string \" + stringOne + \" is \" + secondClosingBracket); // you can also use indexOf() to search for Strings: stringOne = \"<HTML><HEAD><BODY>\"; int bodyTag = stringOne.indexOf(\"<BODY>\"); Serial.println(\"The index of the body tag in the string \" + stringOne + \" is \" + bodyTag); stringOne = \"<UL><LI>item<LI>item<LI>item</UL>\"; int firstListItem = stringOne.indexOf(\"<LI>\"); int secondListItem = stringOne.indexOf(\"<LI>\", firstListItem + 1); Serial.println(\"The index of the second list tag in the string \" + stringOne + \" is \" + secondListItem); // lastIndexOf() gives you the last occurrence of a character or string: int lastOpeningBracket = stringOne.lastIndexOf('<'); Serial.println(\"The index of the last < in the string \" + stringOne + \" is \" + lastOpeningBracket); int lastListItem = stringOne.lastIndexOf(\"<LI>\"); Serial.println(\"The index of the last list tag in the string \" + stringOne + \" is \" + lastListItem); // lastIndexOf() can also search for a string: stringOne = \"<p>Lorem ipsum dolor sit amet</p><p>Ipsem</p><p>Quod</p>\"; int lastParagraph = stringOne.lastIndexOf(\"<p\"); int secondLastGraf = stringOne.lastIndexOf(\"<p\", lastParagraph - 1); Serial.println(\"The index of the second to last paragraph tag \" + stringOne + \" is \" + secondLastGraf); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_52","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_52","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_52","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#489-stringlength","text":"","title":"4.8.9 StringLength"},{"location":"04_builtin_examples/#sketch-code_53","text":"/* String length() Examples of how to use length() in a String. Open the Serial Monitor and start sending characters to see the results. created 1 Aug 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringLengthTrim */ String txtMsg = \"\"; // a string for incoming text unsigned int lastStringLength = txtMsg.length(); // previous length of the String void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString length():\"); Serial.println(); } void loop() { // add any incoming characters to the String: while (Serial.available() > 0) { char inChar = Serial.read(); txtMsg += inChar; } // print the message and a notice if it's changed: if (txtMsg.length() != lastStringLength) { Serial.println(txtMsg); Serial.println(txtMsg.length()); // if the String's longer than 140 characters, complain: if (txtMsg.length() < 140) { Serial.println(\"That's a perfectly acceptable text message\"); } else { Serial.println(\"That's too long for a text message.\"); } // note the length for next time through the loop: lastStringLength = txtMsg.length(); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_53","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_53","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_53","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4810-stringlengthtrim","text":"","title":"4.8.10 StringLengthTrim"},{"location":"04_builtin_examples/#sketch-code_54","text":"/* String length() and trim() Examples of how to use length() and trim() in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringLengthTrim */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString length() and trim():\"); Serial.println(); } void loop() { // here's a String with empty spaces at the end (called white space): String stringOne = \"Hello! \"; Serial.print(stringOne); Serial.print(\"<--- end of string. Length: \"); Serial.println(stringOne.length()); // trim the white space off the string: stringOne.trim(); Serial.print(stringOne); Serial.print(\"<--- end of trimmed string. Length: \"); Serial.println(stringOne.length()); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_54","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_54","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_54","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4811-stringreplace","text":"","title":"4.8.11 StringReplace"},{"location":"04_builtin_examples/#sketch-code_55","text":"/* String replace() Examples of how to replace characters or substrings of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringReplace */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString replace:\\n\"); Serial.println(); } void loop() { String stringOne = \"<html><head><body>\"; Serial.println(stringOne); // replace() changes all instances of one substring with another: // first, make a copy of the original string: String stringTwo = stringOne; // then perform the replacements: stringTwo.replace(\"<\", \"</\"); // print the original: Serial.println(\"Original string: \" + stringOne); // and print the modified string: Serial.println(\"Modified string: \" + stringTwo); // you can also use replace() on single characters: String normalString = \"bookkeeper\"; Serial.println(\"normal: \" + normalString); String leetString = normalString; leetString.replace('o', '0'); leetString.replace('e', '3'); Serial.println(\"l33tspeak: \" + leetString); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_55","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_55","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_55","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4812-stringstartswithendswith","text":"","title":"4.8.12 StringStartsWithEndsWith"},{"location":"04_builtin_examples/#sketch-code_56","text":"/* String startWith() and endsWith() Examples of how to use startsWith() and endsWith() in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringStartsWithEndsWith */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString startsWith() and endsWith():\"); Serial.println(); } void loop() { // startsWith() checks to see if a String starts with a particular substring: String stringOne = \"HTTP/1.1 200 OK\"; Serial.println(stringOne); if (stringOne.startsWith(\"HTTP/1.1\")) { Serial.println(\"Server's using http version 1.1\"); } // you can also look for startsWith() at an offset position in the string: stringOne = \"HTTP/1.1 200 OK\"; if (stringOne.startsWith(\"200 OK\", 9)) { Serial.println(\"Got an OK from the server\"); } // endsWith() checks to see if a String ends with a particular character: String sensorReading = \"sensor = \"; sensorReading += analogRead(A0); Serial.print(sensorReading); if (sensorReading.endsWith(\"0\")) { Serial.println(\". This reading is divisible by ten\"); } else { Serial.println(\". This reading is not divisible by ten\"); } // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_56","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_56","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_56","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4813-stringsubstring","text":"","title":"4.8.13 StringSubstring"},{"location":"04_builtin_examples/#sketch-code_57","text":"/* String substring() Examples of how to use substring in a String created 27 Jul 2010, modified 2 Apr 2012 by Zach Eveland This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringSubstring */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString substring():\"); Serial.println(); } void loop() { // Set up a String: String stringOne = \"Content-Type: text/html\"; Serial.println(stringOne); // substring(index) looks for the substring from the index position to the end: if (stringOne.substring(19) == \"html\") { Serial.println(\"It's an html file\"); } // you can also look for a substring in the middle of a string: if (stringOne.substring(14, 18) == \"text\") { Serial.println(\"It's a text-based file\"); } // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_57","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_57","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_57","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4814-stringtoint","text":"","title":"4.8.14 StringToint"},{"location":"04_builtin_examples/#sketch-code_58","text":"/* String to Integer conversion Reads a serial input string until it sees a newline, then converts the string to a number if the characters are digits. The circuit: - No external components needed. created 29 Nov 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringToInt */ String inString = \"\"; // string to hold input void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString toInt():\"); Serial.println(); } void loop() { // Read serial input: while (Serial.available() > 0) { int inChar = Serial.read(); if (isDigit(inChar)) { // convert the incoming byte to a char and add it to the string: inString += (char)inChar; } // if you get a newline, print the string, then the string's value: if (inChar == '\\n') { Serial.print(\"Value:\"); Serial.println(inString.toInt()); Serial.print(\"String: \"); Serial.println(inString); // clear the string for new input: inString = \"\"; } } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_58","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_58","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_58","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-49-09usb-examples","text":"","title":"Section 4.9: 09.USB Examples"},{"location":"04_builtin_examples/#491-keyboardlayout","text":"","title":"4.9.1 KeyboardLayout"},{"location":"04_builtin_examples/#sketch-code_59","text":"/* Keyboard logout This sketch demonstrates the Keyboard library. When you connect pin 2 to ground, it performs a logout. It uses keyboard combinations to do this, as follows: On Windows, CTRL-ALT-DEL followed by ALT-l On Ubuntu, CTRL-ALT-DEL, and ENTER On OSX, CMD-SHIFT-q To wake: Spacebar. Circuit: - Arduino Leonardo or Micro - wire to connect D2 to ground created 6 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardLogout */ #define OSX 0 #define WINDOWS 1 #define UBUNTU 2 #include \"Keyboard.h\" // change this to match your platform: int platform = OSX; void setup() { // make pin 2 an input and turn on the pull-up resistor so it goes high unless // connected to ground: pinMode(2, INPUT_PULLUP); Keyboard.begin(); } void loop() { while (digitalRead(2) == HIGH) { // do nothing until pin 2 goes low delay(500); } delay(1000); switch (platform) { case OSX: Keyboard.press(KEY_LEFT_GUI); // Shift-Q logs out: Keyboard.press(KEY_LEFT_SHIFT); Keyboard.press('Q'); delay(100); Keyboard.releaseAll(); // enter: Keyboard.write(KEY_RETURN); break; case WINDOWS: // CTRL-ALT-DEL: Keyboard.press(KEY_LEFT_CTRL); Keyboard.press(KEY_LEFT_ALT); Keyboard.press(KEY_DELETE); delay(100); Keyboard.releaseAll(); // ALT-l: delay(2000); Keyboard.press(KEY_LEFT_ALT); Keyboard.press('l'); Keyboard.releaseAll(); break; case UBUNTU: // CTRL-ALT-DEL: Keyboard.press(KEY_LEFT_CTRL); Keyboard.press(KEY_LEFT_ALT); Keyboard.press(KEY_DELETE); delay(1000); Keyboard.releaseAll(); // Enter to confirm logout: Keyboard.write(KEY_RETURN); break; } // do nothing: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_59","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_59","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_59","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#492-keyboardmessage","text":"","title":"4.9.2 KeyboardMessage"},{"location":"04_builtin_examples/#sketch-code_60","text":"/* Keyboard Message test For the Arduino Leonardo and Micro. Sends a text string when a button is pressed. The circuit: - pushbutton attached from pin 4 to +5V - 10 kilohm resistor attached from pin 4 to ground created 24 Oct 2011 modified 27 Mar 2012 by Tom Igoe modified 11 Nov 2013 by Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardMessage */ #include \"Keyboard.h\" const int buttonPin = 4; // input pin for pushbutton int previousButtonState = HIGH; // for checking the state of a pushButton int counter = 0; // button push counter void setup() { // make the pushButton pin an input: pinMode(buttonPin, INPUT); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // read the pushbutton: int buttonState = digitalRead(buttonPin); // if the button state has changed, if ((buttonState != previousButtonState) // and it's currently pressed: && (buttonState == HIGH)) { // increment the button counter counter++; // type out a message Keyboard.print(\"You pressed the button \"); Keyboard.print(counter); Keyboard.println(\" times.\"); } // save the current button state for comparison next time: previousButtonState = buttonState; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_60","text":"Same as Example DigitalReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_60","text":"Same as Example DigitalReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_60","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#493-keyboardreprogram","text":"","title":"4.9.3 KeyboardReprogram"},{"location":"04_builtin_examples/#sketch-code_61","text":"/* Arduino Programs Blink This sketch demonstrates the Keyboard library. For Leonardo and Due boards only. When you connect pin 2 to ground, it creates a new window with a key combination (CTRL-N), then types in the Blink sketch, then auto-formats the text using another key combination (CTRL-T), then uploads the sketch to the currently selected Arduino using a final key combination (CTRL-U). Circuit: - Arduino Leonardo, Micro, Due, LilyPad USB, or Y\u00fan - wire to connect D2 to ground created 5 Mar 2012 modified 29 Mar 2012 by Tom Igoe modified 3 May 2014 by Scott Fitzgerald This example is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardReprogram */ #include \"Keyboard.h\" // use this option for OSX. // Comment it out if using Windows or Linux: char ctrlKey = KEY_LEFT_GUI; // use this option for Windows and Linux. // leave commented out if using OSX: // char ctrlKey = KEY_LEFT_CTRL; void setup() { // make pin 2 an input and turn on the pull-up resistor so it goes high unless // connected to ground: pinMode(2, INPUT_PULLUP); // initialize control over the keyboard: Keyboard.begin(); } void loop() { while (digitalRead(2) == HIGH) { // do nothing until pin 2 goes low delay(500); } delay(1000); // new document: Keyboard.press(ctrlKey); Keyboard.press('n'); delay(100); Keyboard.releaseAll(); // wait for new window to open: delay(1000); // versions of the Arduino IDE after 1.5 pre-populate new sketches with // setup() and loop() functions let's clear the window before typing anything new // select all Keyboard.press(ctrlKey); Keyboard.press('a'); delay(500); Keyboard.releaseAll(); // delete the selected text Keyboard.write(KEY_BACKSPACE); delay(500); // Type out \"blink\": Keyboard.println(\"void setup() {\"); Keyboard.println(\"pinMode(13, OUTPUT);\"); Keyboard.println(\"}\"); Keyboard.println(); Keyboard.println(\"void loop() {\"); Keyboard.println(\"digitalWrite(13, HIGH);\"); Keyboard.print(\"delay(3000);\"); // 3000 ms is too long. Delete it: for (int keystrokes = 0; keystrokes < 6; keystrokes++) { delay(500); Keyboard.write(KEY_BACKSPACE); } // make it 1000 instead: Keyboard.println(\"1000);\"); Keyboard.println(\"digitalWrite(13, LOW);\"); Keyboard.println(\"delay(1000);\"); Keyboard.println(\"}\"); // tidy up: Keyboard.press(ctrlKey); Keyboard.press('t'); delay(100); Keyboard.releaseAll(); delay(3000); // upload code: Keyboard.press(ctrlKey); Keyboard.press('u'); delay(100); Keyboard.releaseAll(); // wait for the sweet oblivion of reprogramming: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_61","text":"Same as Example KeyboardLayout","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_61","text":"Same as Example KeyboardLayout","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_61","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#494-keyboardserial","text":"","title":"4.9.4 KeyboardSerial"},{"location":"04_builtin_examples/#sketch-code_62","text":"/* Keyboard test For the Arduino Leonardo, Micro or Due Reads a byte from the serial port, sends a keystroke back. The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send A you get B, and so forth. The circuit: - none created 21 Oct 2011 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardSerial */ #include \"Keyboard.h\" void setup() { // open the serial port: Serial.begin(9600); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // check for incoming serial data: if (Serial.available() > 0) { // read incoming serial data: char inChar = Serial.read(); // Type the next ASCII value from what you received: Keyboard.write(inChar + 1); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_62","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_62","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_62","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#495-buttonmousecontrol","text":"","title":"4.9.5 ButtonMouseControl"},{"location":"04_builtin_examples/#sketch-code_63","text":"/* ButtonMouseControl For Leonardo and Due boards only. Controls the mouse from five pushbuttons on an Arduino Leonardo, Micro or Due. Hardware: - five pushbuttons attached to D2, D3, D4, D5, D6 The mouse movement is always relative. This sketch reads four pushbuttons, and uses them to set the movement of the mouse. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the mouse commands. created 15 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ButtonMouseControl */ #include \"Mouse.h\" // set pin numbers for the five buttons: const int upButton = 2; const int downButton = 3; const int leftButton = 4; const int rightButton = 5; const int mouseButton = 6; int range = 5; // output range of X or Y movement; affects movement speed int responseDelay = 10; // response delay of the mouse, in ms void setup() { // initialize the buttons' inputs: pinMode(upButton, INPUT); pinMode(downButton, INPUT); pinMode(leftButton, INPUT); pinMode(rightButton, INPUT); pinMode(mouseButton, INPUT); // initialize mouse control: Mouse.begin(); } void loop() { // read the buttons: int upState = digitalRead(upButton); int downState = digitalRead(downButton); int rightState = digitalRead(rightButton); int leftState = digitalRead(leftButton); int clickState = digitalRead(mouseButton); // calculate the movement distance based on the button states: int xDistance = (leftState - rightState) * range; int yDistance = (upState - downState) * range; // if X or Y is non-zero, move: if ((xDistance != 0) || (yDistance != 0)) { Mouse.move(xDistance, yDistance, 0); } // if the mouse button is pressed: if (clickState == HIGH) { // if the mouse is not pressed, press it: if (!Mouse.isPressed(MOUSE_LEFT)) { Mouse.press(MOUSE_LEFT); } } // else the mouse button is not pressed: else { // if the mouse is pressed, release it: if (Mouse.isPressed(MOUSE_LEFT)) { Mouse.release(MOUSE_LEFT); } } // a delay so the mouse doesn't move too fast: delay(responseDelay); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_63","text":"Same as Example KeyboardAndMouseControl","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_63","text":"Same as Example KeyboardAndMouseControl","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_63","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#496-joystickmousecontrol","text":"","title":"4.9.6 JoystickMouseControl"},{"location":"04_builtin_examples/#sketch-code_64","text":"/* JoystickMouseControl Controls the mouse from a joystick on an Arduino Leonardo, Micro or Due. Uses a pushbutton to turn on and off mouse control, and a second pushbutton to click the left mouse button. Hardware: - 2-axis joystick connected to pins A0 and A1 - pushbuttons connected to pin D2 and D3 The mouse movement is always relative. This sketch reads two analog inputs that range from 0 to 1023 (or less on either end) and translates them into ranges of -6 to 6. The sketch assumes that the joystick resting values are around the middle of the range, but that they vary within a threshold. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the command. This sketch includes a pushbutton to toggle the mouse control state, so you can turn on and off mouse control. created 15 Sep 2011 updated 28 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/JoystickMouseControl */ #include \"Mouse.h\" // set pin numbers for switch, joystick axes, and LED: const int switchPin = 2; // switch to turn on and off mouse control const int mouseButton = 3; // input pin for the mouse pushButton const int xAxis = A0; // joystick X axis const int yAxis = A1; // joystick Y axis const int ledPin = 5; // Mouse control LED // parameters for reading the joystick: int range = 12; // output range of X or Y movement int responseDelay = 5; // response delay of the mouse, in ms int threshold = range / 4; // resting threshold int center = range / 2; // resting position value bool mouseIsActive = false; // whether or not to control the mouse int lastSwitchState = LOW; // previous switch state void setup() { pinMode(switchPin, INPUT); // the switch pin pinMode(ledPin, OUTPUT); // the LED pin // take control of the mouse: Mouse.begin(); } void loop() { // read the switch: int switchState = digitalRead(switchPin); // if it's changed and it's high, toggle the mouse state: if (switchState != lastSwitchState) { if (switchState == HIGH) { mouseIsActive = !mouseIsActive; // turn on LED to indicate mouse state: digitalWrite(ledPin, mouseIsActive); } } // save switch state for next comparison: lastSwitchState = switchState; // read and scale the two axes: int xReading = readAxis(A0); int yReading = readAxis(A1); // if the mouse control state is active, move the mouse: if (mouseIsActive) { Mouse.move(xReading, yReading, 0); } // read the mouse button and click or not click: // if the mouse button is pressed: if (digitalRead(mouseButton) == HIGH) { // if the mouse is not pressed, press it: if (!Mouse.isPressed(MOUSE_LEFT)) { Mouse.press(MOUSE_LEFT); } } // else the mouse button is not pressed: else { // if the mouse is pressed, release it: if (Mouse.isPressed(MOUSE_LEFT)) { Mouse.release(MOUSE_LEFT); } } delay(responseDelay); } /* reads an axis (0 or 1 for x or y) and scales the analog input range to a range from 0 to <range> */ int readAxis(int thisAxis) { // read the analog input: int reading = analogRead(thisAxis); // map the reading from the analog input range to the output range: reading = map(reading, 0, 1023, 0, range); // if the output reading is outside from the rest position threshold, use it: int distance = reading - center; if (abs(distance) < threshold) { distance = 0; } // return the distance for this axis: return distance; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_64","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_64","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_64","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#497-keyboardandmousecontrol","text":"","title":"4.9.7 KeyboardAndMouseControl"},{"location":"04_builtin_examples/#sketch-code_65","text":"/* KeyboardAndMouseControl Controls the mouse from five pushbuttons on an Arduino Leonardo, Micro or Due. Hardware: - five pushbuttons attached to D2, D3, D4, D5, D6 The mouse movement is always relative. This sketch reads four pushbuttons, and uses them to set the movement of the mouse. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the mouse commands. created 15 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardAndMouseControl */ #include \"Keyboard.h\" #include \"Mouse.h\" // set pin numbers for the five buttons: const int upButton = 2; const int downButton = 3; const int leftButton = 4; const int rightButton = 5; const int mouseButton = 6; void setup() { // initialize the buttons' inputs: pinMode(upButton, INPUT); pinMode(downButton, INPUT); pinMode(leftButton, INPUT); pinMode(rightButton, INPUT); pinMode(mouseButton, INPUT); Serial.begin(9600); // initialize mouse control: Mouse.begin(); Keyboard.begin(); } void loop() { // use serial input to control the mouse: if (Serial.available() > 0) { char inChar = Serial.read(); switch (inChar) { case 'u': // move mouse up Mouse.move(0, -40); break; case 'd': // move mouse down Mouse.move(0, 40); break; case 'l': // move mouse left Mouse.move(-40, 0); break; case 'r': // move mouse right Mouse.move(40, 0); break; case 'm': // perform mouse left click Mouse.click(MOUSE_LEFT); break; } } // use the pushbuttons to control the keyboard: if (digitalRead(upButton) == HIGH) { Keyboard.write('u'); } if (digitalRead(downButton) == HIGH) { Keyboard.write('d'); } if (digitalRead(leftButton) == HIGH) { Keyboard.write('l'); } if (digitalRead(rightButton) == HIGH) { Keyboard.write('r'); } if (digitalRead(mouseButton) == HIGH) { Keyboard.write('m'); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_65","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_65","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_65","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-410-10starterkit_basickit-examples","text":"Note ALL examples for this Section 4.10 are directly referenced from Programming in Arduino .","title":"Section 4.10: 10.StarterKit_BasicKit Examples"},{"location":"04_builtin_examples/#4101-p02_spaceshipinterface","text":"","title":"4.10.1 p02_SpaceshipInterface"},{"location":"04_builtin_examples/#sketch-code_66","text":"/* Arduino Starter Kit example Project 2 - Spaceship Interface This sketch is written to accompany Project 2 in the Arduino Starter Kit Parts required: - one green LED - two red LEDs - pushbutton - 10 kilohm resistor - three 220 ohm resistors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/02/29/project-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // Create a global variable to hold the state of the switch. This variable is // persistent throughout the program. Whenever you refer to switchState, you\u2019re // talking about the number it holds int switchstate = 0; void setup() { // declare the LED pins as outputs pinMode(3, OUTPUT); pinMode(4, OUTPUT); pinMode(5, OUTPUT); // declare the switch pin as an input pinMode(2, INPUT); } void loop() { // read the value of the switch // digitalRead() checks to see if there is voltage on the pin or not switchstate = digitalRead(2); // if the button is not pressed turn on the green LED and off the red LEDs if (switchstate == LOW) { digitalWrite(3, HIGH); // turn the green LED on pin 3 on digitalWrite(4, LOW); // turn the red LED on pin 4 off digitalWrite(5, LOW); // turn the red LED on pin 5 off } // this else is part of the above if() statement. // if the switch is not LOW (the button is pressed) turn off the green LED and // blink alternatively the red LEDs else { digitalWrite(3, LOW); // turn the green LED on pin 3 off digitalWrite(4, LOW); // turn the red LED on pin 4 off digitalWrite(5, HIGH); // turn the red LED on pin 5 on // wait for a quarter second before changing the light delay(250); digitalWrite(4, HIGH); // turn the red LED on pin 4 on digitalWrite(5, LOW); // turn the red LED on pin 5 off // wait for a quarter second before changing the light delay(250); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_66","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_66","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_66","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4102-p03_loveometer","text":"","title":"4.10.2 p03_LoveOMeter"},{"location":"04_builtin_examples/#sketch-code_67","text":"/* Arduino Starter Kit example Project 3 - Love-O-Meter This sketch is written to accompany Project 3 in the Arduino Starter Kit Parts required: - one TMP36 temperature sensor - three red LEDs - three 220 ohm resistors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/02/29/projecte-3/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constant for the pin the sensor is connected to const int sensorPin = A0; // room temperature in Celsius const float baselineTemp = 20.0; void setup() { // open a serial connection to display values Serial.begin(9600); // set the LED pins as outputs // the for() loop saves some extra coding for (int pinNumber = 2; pinNumber < 5; pinNumber++) { pinMode(pinNumber, OUTPUT); digitalWrite(pinNumber, LOW); } } void loop() { // read the value on AnalogIn pin 0 and store it in a variable int sensorVal = analogRead(sensorPin); // send the 10-bit sensor value out the serial port Serial.print(\"sensor Value: \"); Serial.print(sensorVal); // convert the ADC reading to voltage float voltage = (sensorVal / 1024.0) * 5.0; // Send the voltage level out the Serial port Serial.print(\", Volts: \"); Serial.print(voltage); // convert the voltage to temperature in degrees C // the sensor changes 10 mV per degree // the datasheet says there's a 500 mV offset // ((voltage - 500 mV) times 100) Serial.print(\", degrees C: \"); float temperature = (voltage - .5) * 100; Serial.println(temperature); // if the current temperature is lower than the baseline turn off all LEDs if (temperature < baselineTemp + 2) { digitalWrite(2, LOW); digitalWrite(3, LOW); digitalWrite(4, LOW); } // if the temperature rises 2-4 degrees, turn an LED on else if (temperature >= baselineTemp + 2 && temperature < baselineTemp + 4) { digitalWrite(2, HIGH); digitalWrite(3, LOW); digitalWrite(4, LOW); } // if the temperature rises 4-6 degrees, turn a second LED on else if (temperature >= baselineTemp + 4 && temperature < baselineTemp + 6) { digitalWrite(2, HIGH); digitalWrite(3, HIGH); digitalWrite(4, LOW); } // if the temperature rises more than 6 degrees, turn all LEDs on else if (temperature >= baselineTemp + 6) { digitalWrite(2, HIGH); digitalWrite(3, HIGH); digitalWrite(4, HIGH); } delay(1); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_67","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_67","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_67","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4103-p04_colormixinglamp","text":"","title":"4.10.3 p04_ColorMixingLamp"},{"location":"04_builtin_examples/#sketch-code_68","text":"/* Arduino Starter Kit example Project 4 - Color Mixing Lamp This sketch is written to accompany Project 3 in the Arduino Starter Kit Parts required: - one RGB LED - three 10 kilohm resistors - three 220 ohm resistors - three photoresistors - red green and blue colored gels created 13 Sep 2012 modified 14 Nov 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/01/project-04/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int greenLEDPin = 9; // LED connected to digital pin 9 const int redLEDPin = 10; // LED connected to digital pin 10 const int blueLEDPin = 11; // LED connected to digital pin 11 const int redSensorPin = A0; // pin with the photoresistor with the red gel const int greenSensorPin = A1; // pin with the photoresistor with the green gel const int blueSensorPin = A2; // pin with the photoresistor with the blue gel int redValue = 0; // value to write to the red LED int greenValue = 0; // value to write to the green LED int blueValue = 0; // value to write to the blue LED int redSensorValue = 0; // variable to hold the value from the red sensor int greenSensorValue = 0; // variable to hold the value from the green sensor int blueSensorValue = 0; // variable to hold the value from the blue sensor void setup() { // initialize serial communications at 9600 bps: Serial.begin(9600); // set the digital pins as outputs pinMode(greenLEDPin, OUTPUT); pinMode(redLEDPin, OUTPUT); pinMode(blueLEDPin, OUTPUT); } void loop() { // Read the sensors first: // read the value from the red-filtered photoresistor: redSensorValue = analogRead(redSensorPin); // give the ADC a moment to settle delay(5); // read the value from the green-filtered photoresistor: greenSensorValue = analogRead(greenSensorPin); // give the ADC a moment to settle delay(5); // read the value from the blue-filtered photoresistor: blueSensorValue = analogRead(blueSensorPin); // print out the values to the Serial Monitor Serial.print(\"raw sensor Values \\t red: \"); Serial.print(redSensorValue); Serial.print(\"\\t green: \"); Serial.print(greenSensorValue); Serial.print(\"\\t Blue: \"); Serial.println(blueSensorValue); /* In order to use the values from the sensor for the LED, you need to do some math. The ADC provides a 10-bit number, but analogWrite() uses 8 bits. You'll want to divide your sensor readings by 4 to keep them in range of the output. */ redValue = redSensorValue / 4; greenValue = greenSensorValue / 4; blueValue = blueSensorValue / 4; // print out the mapped values Serial.print(\"Mapped sensor Values \\t red: \"); Serial.print(redValue); Serial.print(\"\\t green: \"); Serial.print(greenValue); Serial.print(\"\\t Blue: \"); Serial.println(blueValue); /* Now that you have a usable value, it's time to PWM the LED. */ analogWrite(redLEDPin, redValue); analogWrite(greenLEDPin, greenValue); analogWrite(blueLEDPin, blueValue); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_68","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_68","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_68","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4104-p05_servomoodindicator","text":"","title":"4.10.4 p05_ServoMoodIndicator"},{"location":"04_builtin_examples/#sketch-code_69","text":"/* Arduino Starter Kit example Project 5 - Servo Mood Indicator This sketch is written to accompany Project 5 in the Arduino Starter Kit Parts required: - servo motor - 10 kilohm potentiometer - two 100 uF electrolytic capacitors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/01/project-05/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // include the Servo library #include <Servo.h> Servo myServo; // create a servo object int const potPin = A0; // analog pin used to connect the potentiometer int potVal; // variable to read the value from the analog pin int angle; // variable to hold the angle for the servo motor void setup() { myServo.attach(9); // attaches the servo on pin 9 to the servo object Serial.begin(9600); // open a serial connection to your computer } void loop() { potVal = analogRead(potPin); // read the value of the potentiometer // print out the value to the Serial Monitor Serial.print(\"potVal: \"); Serial.print(potVal); // scale the numbers from the pot angle = map(potVal, 0, 1023, 0, 179); // print out the angle for the servo motor Serial.print(\", angle: \"); Serial.println(angle); // set the servo position myServo.write(angle); // wait for the servo to get there delay(15); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_69","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_69","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_69","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4105-p06_lighttheremin","text":"","title":"4.10.5 p06_LightTheremin"},{"location":"04_builtin_examples/#sketch-code_70","text":"/* Arduino Starter Kit example Project 6 - Light Theremin This sketch is written to accompany Project 6 in the Arduino Starter Kit Parts required: - photoresistor - 10 kilohm resistor - piezo created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/02/project-06/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // variable to hold sensor value int sensorValue; // variable to calibrate low value int sensorLow = 1023; // variable to calibrate high value int sensorHigh = 0; // LED pin const int ledPin = 13; void setup() { // Make the LED pin an output and turn it on pinMode(ledPin, OUTPUT); digitalWrite(ledPin, HIGH); // calibrate for the first five seconds after program runs while (millis() < 5000) { // record the maximum sensor value sensorValue = analogRead(A0); if (sensorValue > sensorHigh) { sensorHigh = sensorValue; } // record the minimum sensor value if (sensorValue < sensorLow) { sensorLow = sensorValue; } } // turn the LED off, signaling the end of the calibration period digitalWrite(ledPin, LOW); } void loop() { //read the input from A0 and store it in a variable sensorValue = analogRead(A0); // map the sensor values to a wide range of pitches int pitch = map(sensorValue, sensorLow, sensorHigh, 50, 4000); // play the tone for 20 ms on pin 8 tone(8, pitch, 20); // wait for a moment delay(10); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_70","text":"Similar to Example tonePitchFollower , but use pin 8 instead of pin 9 .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_70","text":"Similar to Example tonePitchFollower , but use pin 8 instead of pin 9 .","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_70","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4106-p07_keyboard","text":"","title":"4.10.6 p07_Keyboard"},{"location":"04_builtin_examples/#sketch-code_71","text":"/* Arduino Starter Kit example Project 7 - Keyboard This sketch is written to accompany Project 7 in the Arduino Starter Kit Parts required: - two 10 kilohm resistors - 1 megohm resistor - 220 ohm resistor - four pushbuttons - piezo created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/02/project-07/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // create an array of notes // the numbers below correspond to the frequencies of middle C, D, E, and F int notes[] = { 262, 294, 330, 349 }; void setup() { //start serial communication Serial.begin(9600); } void loop() { // create a local variable to hold the input on pin A0 int keyVal = analogRead(A0); // send the value from A0 to the Serial Monitor Serial.println(keyVal); // play the note corresponding to each value on A0 if (keyVal == 1023) { // play the first frequency in the array on pin 8 tone(8, notes[0]); } else if (keyVal >= 990 && keyVal <= 1010) { // play the second frequency in the array on pin 8 tone(8, notes[1]); } else if (keyVal >= 505 && keyVal <= 515) { // play the third frequency in the array on pin 8 tone(8, notes[2]); } else if (keyVal >= 5 && keyVal <= 10) { // play the fourth frequency in the array on pin 8 tone(8, notes[3]); } else { // if the value is out of range, play no tone noTone(8); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_71","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_71","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_71","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4107-p08_digitalhourglass","text":"","title":"4.10.7 p08_DigitalHourglass"},{"location":"04_builtin_examples/#sketch-code_72","text":"/* Arduino Starter Kit example Project 8 - Digital Hourglass This sketch is written to accompany Project 8 in the Arduino Starter Kit Parts required: - 10 kilohm resistor - six 220 ohm resistors - six LEDs - tilt switch created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/03/project-08-digital-hourglass/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constant for the switch pin const int switchPin = 8; unsigned long previousTime = 0; // store the last time an LED was updated int switchState = 0; // the current switch state int prevSwitchState = 0; // the previous switch state int led = 2; // a variable to refer to the LEDs // 600000 = 10 minutes in milliseconds long interval = 600000; // interval at which to light the next LED void setup() { // set the LED pins as outputs for (int x = 2; x < 8; x++) { pinMode(x, OUTPUT); } // set the tilt switch pin as input pinMode(switchPin, INPUT); } void loop() { // store the time since the Arduino started running in a variable unsigned long currentTime = millis(); // compare the current time to the previous time an LED turned on // if it is greater than your interval, run the if statement if (currentTime - previousTime > interval) { // save the current time as the last time you changed an LED previousTime = currentTime; // Turn the LED on digitalWrite(led, HIGH); // increment the led variable // in 10 minutes the next LED will light up led++; if (led == 7) { // the hour is up } } // read the switch value switchState = digitalRead(switchPin); // if the switch has changed if (switchState != prevSwitchState) { // turn all the LEDs low for (int x = 2; x < 8; x++) { digitalWrite(x, LOW); } // reset the LED variable to the first one led = 2; //reset the timer previousTime = currentTime; } // set the previous switch state to the current state prevSwitchState = switchState; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_72","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_72","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_72","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4108-p09_motorizedpinwheel","text":"","title":"4.10.8 p09_MotorizedPinwheel"},{"location":"04_builtin_examples/#sketch-code_73","text":"/* Arduino Starter Kit example Project 9 - Motorized Pinwheel This sketch is written to accompany Project 9 in the Arduino Starter Kit Parts required: - 10 kilohm resistor - pushbutton - motor - 9V battery - IRF520 MOSFET - 1N4007 diode created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/04/project-10-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constants for the switch and motor pins const int switchPin = 2; // the number of the switch pin const int motorPin = 9; // the number of the motor pin int switchState = 0; // variable for reading the switch's status void setup() { // initialize the motor pin as an output: pinMode(motorPin, OUTPUT); // initialize the switch pin as an input: pinMode(switchPin, INPUT); } void loop() { // read the state of the switch value: switchState = digitalRead(switchPin); // check if the switch is pressed. if (switchState == HIGH) { // turn motor on: digitalWrite(motorPin, HIGH); } else { // turn motor off: digitalWrite(motorPin, LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_73","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_73","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_73","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#4109-p10_zoetrope","text":"","title":"4.10.9 p10_Zoetrope"},{"location":"04_builtin_examples/#description","text":"This examples deals with H-bridge using the integrated circuit SN754410 . Some external references are recommended to read: DC Motor Control Using an H-Bridge El puente H: Invirtiendo el sentido de giro de un motor con Arduino in Spanish","title":"Description"},{"location":"04_builtin_examples/#sketch-code_74","text":"/* Arduino Starter Kit example Project 10 - Zoetrope This sketch is written to accompany Project 10 in the Arduino Starter Kit Parts required: - two 10 kilohm resistors - two momentary pushbuttons - one 10 kilohm potentiometer - motor - 9V battery - H-Bridge created 13 Sep 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/05/project-11/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int controlPin1 = 2; // connected to pin 7 on the H-bridge const int controlPin2 = 3; // connected to pin 2 on the H-bridge const int enablePin = 9; // connected to pin 1 on the H-bridge const int directionSwitchPin = 4; // connected to the switch for direction const int onOffSwitchStateSwitchPin = 5; // connected to the switch for turning the motor on and off const int potPin = A0; // connected to the potentiometer's output // create some variables to hold values from your inputs int onOffSwitchState = 0; // current state of the on/off switch int previousOnOffSwitchState = 0; // previous position of the on/off switch int directionSwitchState = 0; // current state of the direction switch int previousDirectionSwitchState = 0; // previous state of the direction switch int motorEnabled = 0; // Turns the motor on/off int motorSpeed = 0; // speed of the motor int motorDirection = 1; // current direction of the motor void setup() { // initialize the inputs and outputs pinMode(directionSwitchPin, INPUT); pinMode(onOffSwitchStateSwitchPin, INPUT); pinMode(controlPin1, OUTPUT); pinMode(controlPin2, OUTPUT); pinMode(enablePin, OUTPUT); // pull the enable pin LOW to start digitalWrite(enablePin, LOW); } void loop() { // read the value of the on/off switch onOffSwitchState = digitalRead(onOffSwitchStateSwitchPin); delay(1); // read the value of the direction switch directionSwitchState = digitalRead(directionSwitchPin); // read the value of the pot and divide by 4 to get a value that can be // used for PWM motorSpeed = analogRead(potPin) / 4; // if the on/off button changed state since the last loop() if (onOffSwitchState != previousOnOffSwitchState) { // change the value of motorEnabled if pressed if (onOffSwitchState == HIGH) { motorEnabled = !motorEnabled; } } // if the direction button changed state since the last loop() if (directionSwitchState != previousDirectionSwitchState) { // change the value of motorDirection if pressed if (directionSwitchState == HIGH) { motorDirection = !motorDirection; } } // change the direction the motor spins by talking to the control pins // on the H-Bridge if (motorDirection == 1) { digitalWrite(controlPin1, HIGH); digitalWrite(controlPin2, LOW); } else { digitalWrite(controlPin1, LOW); digitalWrite(controlPin2, HIGH); } // if the motor is supposed to be on if (motorEnabled == 1) { // PWM the enable pin to vary the speed analogWrite(enablePin, motorSpeed); } else { // if the motor is not supposed to be on //turn the motor off analogWrite(enablePin, 0); } // save the current on/off switch state as the previous previousDirectionSwitchState = directionSwitchState; // save the current switch state as the previous previousOnOffSwitchState = onOffSwitchState; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_74","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_74","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_74","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#41010-p11_crystalball","text":"","title":"4.10.10 p11_CrystalBall"},{"location":"04_builtin_examples/#sketch-code_75","text":"/* Arduino Starter Kit example Project 11 - Crystal Ball This sketch is written to accompany Project 11 in the Arduino Starter Kit Parts required: - 220 ohm resistor - 10 kilohm resistor - 10 kilohm potentiometer - 16x2 LCD screen - tilt switch created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/05/project-12/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // include the library code: #include <LiquidCrystal.h> // initialize the library with the numbers of the interface pins LiquidCrystal lcd(12, 11, 5, 4, 3, 2); // set up a constant for the tilt switch pin const int switchPin = 6; // variable to hold the value of the switch pin int switchState = 0; // variable to hold previous value of the switch pin int prevSwitchState = 0; // a variable to choose which reply from the crystal ball int reply; void setup() { // set up the number of columns and rows on the LCD lcd.begin(16, 2); // set up the switch pin as an input pinMode(switchPin, INPUT); // Print a message to the LCD. lcd.print(\"Ask the\"); // set the cursor to column 0, line 1 // line 1 is the second row, since counting begins with 0 lcd.setCursor(0, 1); // print to the second line lcd.print(\"Crystal Ball!\"); } void loop() { // check the status of the switch switchState = digitalRead(switchPin); // compare the switchState to its previous state if (switchState != prevSwitchState) { // if the state has changed from HIGH to LOW you know that the ball has been // tilted from one direction to the other if (switchState == LOW) { // randomly chose a reply reply = random(8); // clean up the screen before printing a new reply lcd.clear(); // set the cursor to column 0, line 0 lcd.setCursor(0, 0); // print some text lcd.print(\"the ball says:\"); // move the cursor to the second line lcd.setCursor(0, 1); // choose a saying to print based on the value in reply switch (reply) { case 0: lcd.print(\"Yes\"); break; case 1: lcd.print(\"Most likely\"); break; case 2: lcd.print(\"Certainly\"); break; case 3: lcd.print(\"Outlook good\"); break; case 4: lcd.print(\"Unsure\"); break; case 5: lcd.print(\"Ask again\"); break; case 6: lcd.print(\"Doubtful\"); break; case 7: lcd.print(\"No\"); break; } } } // save the current switch state as the last state prevSwitchState = switchState; }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_75","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_75","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_75","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#41011-p12_knocklock","text":"","title":"4.10.11 p12_KnockLock"},{"location":"04_builtin_examples/#sketch-code_76","text":"/* Arduino Starter Kit example Project 12 - Knock Lock This sketch is written to accompany Project 12 in the Arduino Starter Kit Parts required: - 1 megohm resistor - 10 kilohm resistor - three 220 ohm resistors - piezo - servo motor - push button - one red LED - one yellow LED - one green LED - 100 uF capacitor created 18 Sep 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/06/project-13/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // import the library #include <Servo.h> // create an instance of the Servo library Servo myServo; const int piezo = A0; // pin the piezo is attached to const int switchPin = 2; // pin the switch is attached to const int yellowLed = 3; // pin the yellow LED is attached to const int greenLed = 4; // pin the green LED is attached to const int redLed = 5; // pin the red LED is attached to // variable for the piezo value int knockVal; // variable for the switch value int switchVal; // variables for the high and low limits of the knock value const int quietKnock = 10; const int loudKnock = 100; // variable to indicate if locked or not bool locked = false; // how many valid knocks you've received int numberOfKnocks = 0; void setup() { // attach the servo to pin 9 myServo.attach(9); // make the LED pins outputs pinMode(yellowLed, OUTPUT); pinMode(redLed, OUTPUT); pinMode(greenLed, OUTPUT); // set the switch pin as an input pinMode(switchPin, INPUT); // start serial communication for debugging Serial.begin(9600); // turn the green LED on digitalWrite(greenLed, HIGH); // move the servo to the unlocked position myServo.write(0); // print status to the Serial Monitor Serial.println(\"the box is unlocked!\"); } void loop() { // if the box is unlocked if (locked == false) { // read the value of the switch pin switchVal = digitalRead(switchPin); // if the button is pressed, lock the box if (switchVal == HIGH) { // set the locked variable to \"true\" locked = true; // change the status LEDs digitalWrite(greenLed, LOW); digitalWrite(redLed, HIGH); // move the servo to the locked position myServo.write(90); // print out status Serial.println(\"the box is locked!\"); // wait for the servo to move into position delay(1000); } } // if the box is locked if (locked == true) { // check the value of the piezo knockVal = analogRead(piezo); // if there are not enough valid knocks if (numberOfKnocks < 3 && knockVal > 0) { // check to see if the knock is in range if (checkForKnock(knockVal) == true) { // increment the number of valid knocks numberOfKnocks++; } // print status of knocks Serial.print(3 - numberOfKnocks); Serial.println(\" more knocks to go\"); } // if there are three knocks if (numberOfKnocks >= 3) { // unlock the box locked = false; // move the servo to the unlocked position myServo.write(0); // wait for it to move delay(20); // change status LEDs digitalWrite(greenLed, HIGH); digitalWrite(redLed, LOW); Serial.println(\"the box is unlocked!\"); numberOfKnocks = 0; } } } // this function checks to see if a detected knock is within max and min range bool checkForKnock(int value) { // if the value of the knock is greater than the minimum, and larger // than the maximum if (value > quietKnock && value < loudKnock) { // turn the status LED on digitalWrite(yellowLed, HIGH); delay(50); digitalWrite(yellowLed, LOW); // print out the status Serial.print(\"Valid knock of value \"); Serial.println(value); // return true return true; } // if the knock is not within range else { // print status Serial.print(\"Bad knock value \"); Serial.println(value); // return false return false; } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_76","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_76","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_76","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#41012-p13_touchsensorlamp","text":"","title":"4.10.12 p13_TouchSensorLamp"},{"location":"04_builtin_examples/#sketch-code_77","text":"/* Arduino Starter Kit example Project 13 - Touch Sensor Lamp This sketch is written to accompany Project 13 in the Arduino Starter Kit Parts required: - 1 megohm resistor - metal foil or copper mesh - 220 ohm resistor - LED Software required : - CapacitiveSensor library by Paul Badger https://www.arduino.cc/reference/en/libraries/capacitivesensor/ created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/06/project-14/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // import the library (must be located in the Arduino/libraries directory) #include <CapacitiveSensor.h> // create an instance of the library // pin 4 sends electrical energy // pin 2 senses senses a change CapacitiveSensor capSensor = CapacitiveSensor(4, 2); // threshold for turning the lamp on int threshold = 1000; // pin the LED is connected to const int ledPin = 12; void setup() { // open a serial connection Serial.begin(9600); // set the LED pin as an output pinMode(ledPin, OUTPUT); } void loop() { // store the value reported by the sensor in a variable long sensorValue = capSensor.capacitiveSensor(30); // print out the sensor value Serial.println(sensorValue); // if the value is greater than the threshold if (sensorValue > threshold) { // turn the LED on digitalWrite(ledPin, HIGH); } // if it's lower than the threshold else { // turn the LED off digitalWrite(ledPin, LOW); } delay(10); }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_77","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_77","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_77","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#41013-p14_tweakthearduinologo","text":"","title":"4.10.13 p14_TweakTheArduinoLogo"},{"location":"04_builtin_examples/#sketch-code_78","text":"/* Arduino Starter Kit example Project 14 - Tweak the Arduino Logo This sketch is written to accompany Project 14 in the Arduino Starter Kit Parts required: - 10 kilohm potentiometer Software required: - Processing (3.0 or newer) https://processing.org/ - Active Internet connection created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/08/project-14-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ void setup() { // initialize serial communication Serial.begin(9600); } void loop() { // read the value of A0, divide by 4 and send it as a byte over the // serial connection Serial.write(analogRead(A0) / 4); delay(1); } /* Processing code for this example // Tweak the Arduino Logo // by Scott Fitzgerald // This example code is in the public domain. // import the serial library import processing.serial.*; // create an instance of the serial library Serial myPort; // create an instance of PImage PImage logo; // a variable to hold the background color int bgcolor = 0; void setup() { size(1, 1); surface.setResizable(true); // set the color mode to Hue/Saturation/Brightness colorMode(HSB, 255); // load the Arduino logo into the PImage instance logo = loadImage(\"http://www.arduino.cc/arduino_logo.png\"); // make the window the same size as the image surface.setSize(logo.width, logo.height); // print a list of available serial ports to the Processing status window println(\"Available serial ports:\"); println(Serial.list()); // Tell the serial object the information it needs to communicate with the // Arduino. Change Serial.list()[0] to the correct port corresponding to // your Arduino board. The last parameter (e.g. 9600) is the speed of the // communication. It has to correspond to the value passed to // Serial.begin() in your Arduino sketch. myPort = new Serial(this, Serial.list()[0], 9600); // If you know the name of the port used by the Arduino board, you can // specify it directly like this. // port = new Serial(this, \"COM1\", 9600); } void draw() { // if there is information in the serial port if ( myPort.available() > 0) { // read the value and store it in a variable bgcolor = myPort.read(); // print the value to the status window println(bgcolor); } // Draw the background. the variable bgcolor contains the Hue, determined by // the value from the serial port background(bgcolor, 255, 255); // draw the Arduino logo image(logo, 0, 0); } */","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_78","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_78","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_78","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#41014-p15_hackingbuttons","text":"","title":"4.10.14 p15_HackingButtons"},{"location":"04_builtin_examples/#sketch-code_79","text":"/* Arduino Starter Kit example Project 15 - Hacking Buttons This sketch is written to accompany Project 15 in the Arduino Starter Kit Parts required: - battery powered component - 220 ohm resistor - 4N35 optocoupler created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/08/project-15/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int optoPin = 2; // the pin the optocoupler is connected to void setup() { // make the pin with the optocoupler an output pinMode(optoPin, OUTPUT); } void loop() { digitalWrite(optoPin, HIGH); // pull pin 2 HIGH, activating the optocoupler delay(15); // give the optocoupler a moment to activate digitalWrite(optoPin, LOW); // pull pin 2 low until you're ready to activate again delay(21000); // wait for 21 seconds }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_79","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_79","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_79","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/#section-411-11arduinoisp-examples","text":"","title":"Section 4.11: 11.ArduinoISP Examples"},{"location":"04_builtin_examples/#4111-arduinoisp","text":"","title":"4.11.1 ArduinoISP"},{"location":"04_builtin_examples/#sketch-code_80","text":"// https://docs.arduino.cc/built-in-examples/arduino-isp/ArduinoISP // ArduinoISP // Copyright (c) 2008-2011 Randall Bohn // If you require a license, see // https://opensource.org/licenses/bsd-license.php // // This sketch turns the Arduino into a AVRISP using the following Arduino pins: // // Pin 10 is used to reset the target microcontroller. // // By default, the hardware SPI pins MISO, MOSI and SCK are used to communicate // with the target. On all Arduinos, these pins can be found // on the ICSP/SPI header: // // MISO \u00b0. . 5V (!) Avoid this pin on Due, Zero... // SCK . . MOSI // . . GND // // On some Arduinos (Uno,...), pins MOSI, MISO and SCK are the same pins as // digital pin 11, 12 and 13, respectively. That is why many tutorials instruct // you to hook up the target to these pins. If you find this wiring more // practical, have a define USE_OLD_STYLE_WIRING. This will work even when not // using an Uno. (On an Uno this is not needed). // // Alternatively you can use any other digital pin by configuring // software ('BitBanged') SPI and having appropriate defines for PIN_MOSI, // PIN_MISO and PIN_SCK. // // IMPORTANT: When using an Arduino that is not 5V tolerant (Due, Zero, ...) as // the programmer, make sure to not expose any of the programmer's pins to 5V. // A simple way to accomplish this is to power the complete system (programmer // and target) at 3V3. // // Put an LED (with resistor) on the following pins: // 9: Heartbeat - shows the programmer is running // 8: Error - Lights up if something goes wrong (use red if that makes sense) // 7: Programming - In communication with the target // #include \"Arduino.h\" #undef SERIAL #define PROG_FLICKER true // Configure SPI clock (in Hz). // E.g. for an ATtiny @ 128 kHz: the datasheet states that both the high and low // SPI clock pulse must be > 2 CPU cycles, so take 3 cycles i.e. divide target // f_cpu by 6: // #define SPI_CLOCK (128000/6) // // A clock slow enough for an ATtiny85 @ 1 MHz, is a reasonable default: #define SPI_CLOCK (1000000 / 6) // Select hardware or software SPI, depending on SPI clock. // Currently only for AVR, for other architectures (Due, Zero,...), hardware SPI // is probably too fast anyway. #if defined(ARDUINO_ARCH_AVR) #if SPI_CLOCK > (F_CPU / 128) #define USE_HARDWARE_SPI #endif #endif // Configure which pins to use: // The standard pin configuration. #ifndef ARDUINO_HOODLOADER2 #define RESET 10 // Use pin 10 to reset the target rather than SS #define LED_HB 9 #define LED_ERR 8 #define LED_PMODE 7 // Uncomment following line to use the old Uno style wiring // (using pin 11, 12 and 13 instead of the SPI header) on Leonardo, Due... // #define USE_OLD_STYLE_WIRING #ifdef USE_OLD_STYLE_WIRING #define PIN_MOSI 11 #define PIN_MISO 12 #define PIN_SCK 13 #endif // HOODLOADER2 means running sketches on the ATmega16U2 serial converter chips // on Uno or Mega boards. We must use pins that are broken out: #else #define RESET 4 #define LED_HB 7 #define LED_ERR 6 #define LED_PMODE 5 #endif // By default, use hardware SPI pins: #ifndef PIN_MOSI #define PIN_MOSI MOSI #endif #ifndef PIN_MISO #define PIN_MISO MISO #endif #ifndef PIN_SCK #define PIN_SCK SCK #endif // Force bitbanged SPI if not using the hardware SPI pins: #if (PIN_MISO != MISO) || (PIN_MOSI != MOSI) || (PIN_SCK != SCK) #undef USE_HARDWARE_SPI #endif // Configure the serial port to use. // // Prefer the USB virtual serial port (aka. native USB port), if the Arduino has one: // - it does not autoreset (except for the magic baud rate of 1200). // - it is more reliable because of USB handshaking. // // Leonardo and similar have an USB virtual serial port: 'Serial'. // Due and Zero have an USB virtual serial port: 'SerialUSB'. // // On the Due and Zero, 'Serial' can be used too, provided you disable autoreset. // To use 'Serial': #define SERIAL Serial #ifdef SERIAL_PORT_USBVIRTUAL #define SERIAL SERIAL_PORT_USBVIRTUAL #else #define SERIAL Serial #endif // Configure the baud rate: #define BAUDRATE 19200 // #define BAUDRATE 115200 // #define BAUDRATE 1000000 #define HWVER 2 #define SWMAJ 1 #define SWMIN 18 // STK Definitions #define STK_OK 0x10 #define STK_FAILED 0x11 #define STK_UNKNOWN 0x12 #define STK_INSYNC 0x14 #define STK_NOSYNC 0x15 #define CRC_EOP 0x20 //ok it is a space... void pulse(int pin, int times); #ifdef USE_HARDWARE_SPI #include \"SPI.h\" #else #define SPI_MODE0 0x00 #if !defined(ARDUINO_API_VERSION) || ARDUINO_API_VERSION != 10001 // A SPISettings class is declared by ArduinoCore-API 1.0.1 class SPISettings { public: // clock is in Hz SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) : clockFreq(clock) { (void)bitOrder; (void)dataMode; }; uint32_t getClockFreq() const { return clockFreq; } private: uint32_t clockFreq; }; #endif // !defined(ARDUINO_API_VERSION) class BitBangedSPI { public: void begin() { digitalWrite(PIN_SCK, LOW); digitalWrite(PIN_MOSI, LOW); pinMode(PIN_SCK, OUTPUT); pinMode(PIN_MOSI, OUTPUT); pinMode(PIN_MISO, INPUT); } void beginTransaction(SPISettings settings) { pulseWidth = (500000 + settings.getClockFreq() - 1) / settings.getClockFreq(); if (pulseWidth == 0) { pulseWidth = 1; } } void end() {} uint8_t transfer(uint8_t b) { for (unsigned int i = 0; i < 8; ++i) { digitalWrite(PIN_MOSI, (b & 0x80) ? HIGH : LOW); digitalWrite(PIN_SCK, HIGH); delayMicroseconds(pulseWidth); b = (b << 1) | digitalRead(PIN_MISO); digitalWrite(PIN_SCK, LOW); // slow pulse delayMicroseconds(pulseWidth); } return b; } private: unsigned long pulseWidth; // in microseconds }; static BitBangedSPI SPI; #endif void setup() { SERIAL.begin(BAUDRATE); pinMode(LED_PMODE, OUTPUT); pulse(LED_PMODE, 2); pinMode(LED_ERR, OUTPUT); pulse(LED_ERR, 2); pinMode(LED_HB, OUTPUT); pulse(LED_HB, 2); } int ISPError = 0; int pmode = 0; // address for reading and writing, set by 'U' command unsigned int here; uint8_t buff[256]; // global block storage #define beget16(addr) (*addr * 256 + *(addr + 1)) typedef struct param { uint8_t devicecode; uint8_t revision; uint8_t progtype; uint8_t parmode; uint8_t polling; uint8_t selftimed; uint8_t lockbytes; uint8_t fusebytes; uint8_t flashpoll; uint16_t eeprompoll; uint16_t pagesize; uint16_t eepromsize; uint32_t flashsize; } parameter; parameter param; // this provides a heartbeat on pin 9, so you can tell the software is running. uint8_t hbval = 128; int8_t hbdelta = 8; void heartbeat() { static unsigned long last_time = 0; unsigned long now = millis(); if ((now - last_time) < 40) { return; } last_time = now; if (hbval > 192) { hbdelta = -hbdelta; } if (hbval < 32) { hbdelta = -hbdelta; } hbval += hbdelta; analogWrite(LED_HB, hbval); } static bool rst_active_high; void reset_target(bool reset) { digitalWrite(RESET, ((reset && rst_active_high) || (!reset && !rst_active_high)) ? HIGH : LOW); } void loop(void) { // is pmode active? if (pmode) { digitalWrite(LED_PMODE, HIGH); } else { digitalWrite(LED_PMODE, LOW); } // is there an error? if (ISPError) { digitalWrite(LED_ERR, HIGH); } else { digitalWrite(LED_ERR, LOW); } // light the heartbeat LED heartbeat(); if (SERIAL.available()) { avrisp(); } } uint8_t getch() { while (!SERIAL.available()) ; return SERIAL.read(); } void fill(int n) { for (int x = 0; x < n; x++) { buff[x] = getch(); } } #define PTIME 30 void pulse(int pin, int times) { do { digitalWrite(pin, HIGH); delay(PTIME); digitalWrite(pin, LOW); delay(PTIME); } while (times--); } void prog_lamp(int state) { if (PROG_FLICKER) { digitalWrite(LED_PMODE, state); } } uint8_t spi_transaction(uint8_t a, uint8_t b, uint8_t c, uint8_t d) { SPI.transfer(a); SPI.transfer(b); SPI.transfer(c); return SPI.transfer(d); } void empty_reply() { if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } void breply(uint8_t b) { if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)b); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } void get_version(uint8_t c) { switch (c) { case 0x80: breply(HWVER); break; case 0x81: breply(SWMAJ); break; case 0x82: breply(SWMIN); break; case 0x93: breply('S'); // serial programmer break; default: breply(0); } } void set_parameters() { // call this after reading parameter packet into buff[] param.devicecode = buff[0]; param.revision = buff[1]; param.progtype = buff[2]; param.parmode = buff[3]; param.polling = buff[4]; param.selftimed = buff[5]; param.lockbytes = buff[6]; param.fusebytes = buff[7]; param.flashpoll = buff[8]; // ignore buff[9] (= buff[8]) // following are 16 bits (big endian) param.eeprompoll = beget16(&buff[10]); param.pagesize = beget16(&buff[12]); param.eepromsize = beget16(&buff[14]); // 32 bits flashsize (big endian) param.flashsize = buff[16] * 0x01000000 + buff[17] * 0x00010000 + buff[18] * 0x00000100 + buff[19]; // AVR devices have active low reset, AT89Sx are active high rst_active_high = (param.devicecode >= 0xe0); } void start_pmode() { // Reset target before driving PIN_SCK or PIN_MOSI // SPI.begin() will configure SS as output, so SPI master mode is selected. // We have defined RESET as pin 10, which for many Arduinos is not the SS pin. // So we have to configure RESET as output here, // (reset_target() first sets the correct level) reset_target(true); pinMode(RESET, OUTPUT); SPI.begin(); SPI.beginTransaction(SPISettings(SPI_CLOCK, MSBFIRST, SPI_MODE0)); // See AVR datasheets, chapter \"SERIAL_PRG Programming Algorithm\": // Pulse RESET after PIN_SCK is low: digitalWrite(PIN_SCK, LOW); delay(20); // discharge PIN_SCK, value arbitrarily chosen reset_target(false); // Pulse must be minimum 2 target CPU clock cycles so 100 usec is ok for CPU // speeds above 20 KHz delayMicroseconds(100); reset_target(true); // Send the enable programming command: delay(50); // datasheet: must be > 20 msec spi_transaction(0xAC, 0x53, 0x00, 0x00); pmode = 1; } void end_pmode() { SPI.end(); // We're about to take the target out of reset so configure SPI pins as input pinMode(PIN_MOSI, INPUT); pinMode(PIN_SCK, INPUT); reset_target(false); pinMode(RESET, INPUT); pmode = 0; } void universal() { uint8_t ch; fill(4); ch = spi_transaction(buff[0], buff[1], buff[2], buff[3]); breply(ch); } void flash(uint8_t hilo, unsigned int addr, uint8_t data) { spi_transaction(0x40 + 8 * hilo, addr >> 8 & 0xFF, addr & 0xFF, data); } void commit(unsigned int addr) { if (PROG_FLICKER) { prog_lamp(LOW); } spi_transaction(0x4C, (addr >> 8) & 0xFF, addr & 0xFF, 0); if (PROG_FLICKER) { delay(PTIME); prog_lamp(HIGH); } } unsigned int current_page() { if (param.pagesize == 32) { return here & 0xFFFFFFF0; } if (param.pagesize == 64) { return here & 0xFFFFFFE0; } if (param.pagesize == 128) { return here & 0xFFFFFFC0; } if (param.pagesize == 256) { return here & 0xFFFFFF80; } return here; } void write_flash(int length) { fill(length); if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)write_flash_pages(length)); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } uint8_t write_flash_pages(int length) { int x = 0; unsigned int page = current_page(); while (x < length) { if (page != current_page()) { commit(page); page = current_page(); } flash(LOW, here, buff[x++]); flash(HIGH, here, buff[x++]); here++; } commit(page); return STK_OK; } #define EECHUNK (32) uint8_t write_eeprom(unsigned int length) { // here is a word address, get the byte address unsigned int start = here * 2; unsigned int remaining = length; if (length > param.eepromsize) { ISPError++; return STK_FAILED; } while (remaining > EECHUNK) { write_eeprom_chunk(start, EECHUNK); start += EECHUNK; remaining -= EECHUNK; } write_eeprom_chunk(start, remaining); return STK_OK; } // write (length) bytes, (start) is a byte address uint8_t write_eeprom_chunk(unsigned int start, unsigned int length) { // this writes byte-by-byte, page writing may be faster (4 bytes at a time) fill(length); prog_lamp(LOW); for (unsigned int x = 0; x < length; x++) { unsigned int addr = start + x; spi_transaction(0xC0, (addr >> 8) & 0xFF, addr & 0xFF, buff[x]); delay(45); } prog_lamp(HIGH); return STK_OK; } void program_page() { char result = (char)STK_FAILED; unsigned int length = 256 * getch(); length += getch(); char memtype = getch(); // flash memory @here, (length) bytes if (memtype == 'F') { write_flash(length); return; } if (memtype == 'E') { result = (char)write_eeprom(length); if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print(result); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } return; } SERIAL.print((char)STK_FAILED); return; } uint8_t flash_read(uint8_t hilo, unsigned int addr) { return spi_transaction(0x20 + hilo * 8, (addr >> 8) & 0xFF, addr & 0xFF, 0); } char flash_read_page(int length) { for (int x = 0; x < length; x += 2) { uint8_t low = flash_read(LOW, here); SERIAL.print((char)low); uint8_t high = flash_read(HIGH, here); SERIAL.print((char)high); here++; } return STK_OK; } char eeprom_read_page(int length) { // here again we have a word address int start = here * 2; for (int x = 0; x < length; x++) { int addr = start + x; uint8_t ee = spi_transaction(0xA0, (addr >> 8) & 0xFF, addr & 0xFF, 0xFF); SERIAL.print((char)ee); } return STK_OK; } void read_page() { char result = (char)STK_FAILED; int length = 256 * getch(); length += getch(); char memtype = getch(); if (CRC_EOP != getch()) { ISPError++; SERIAL.print((char)STK_NOSYNC); return; } SERIAL.print((char)STK_INSYNC); if (memtype == 'F') { result = flash_read_page(length); } if (memtype == 'E') { result = eeprom_read_page(length); } SERIAL.print(result); } void read_signature() { if (CRC_EOP != getch()) { ISPError++; SERIAL.print((char)STK_NOSYNC); return; } SERIAL.print((char)STK_INSYNC); uint8_t high = spi_transaction(0x30, 0x00, 0x00, 0x00); SERIAL.print((char)high); uint8_t middle = spi_transaction(0x30, 0x00, 0x01, 0x00); SERIAL.print((char)middle); uint8_t low = spi_transaction(0x30, 0x00, 0x02, 0x00); SERIAL.print((char)low); SERIAL.print((char)STK_OK); } ////////////////////////////////////////// ////////////////////////////////////////// //////////////////////////////////// //////////////////////////////////// void avrisp() { uint8_t ch = getch(); switch (ch) { case '0': // signon ISPError = 0; empty_reply(); break; case '1': if (getch() == CRC_EOP) { SERIAL.print((char)STK_INSYNC); SERIAL.print(\"AVR ISP\"); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } break; case 'A': get_version(getch()); break; case 'B': fill(20); set_parameters(); empty_reply(); break; case 'E': // extended parameters - ignore for now fill(5); empty_reply(); break; case 'P': if (!pmode) { start_pmode(); } empty_reply(); break; case 'U': // set address (word) here = getch(); here += 256 * getch(); empty_reply(); break; case 0x60: //STK_PROG_FLASH getch(); // low addr getch(); // high addr empty_reply(); break; case 0x61: //STK_PROG_DATA getch(); // data empty_reply(); break; case 0x64: //STK_PROG_PAGE program_page(); break; case 0x74: //STK_READ_PAGE 't' read_page(); break; case 'V': //0x56 universal(); break; case 'Q': //0x51 ISPError = 0; end_pmode(); empty_reply(); break; case 0x75: //STK_READ_SIGN 'u' read_signature(); break; // expecting a command, not CRC_EOP // this is how we can get back in sync case CRC_EOP: ISPError++; SERIAL.print((char)STK_NOSYNC); break; // anything else we will return STK_UNKNOWN default: ISPError++; if (CRC_EOP == getch()) { SERIAL.print((char)STK_UNKNOWN); } else { SERIAL.print((char)STK_NOSYNC); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/#fritzing-circuit_80","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/#kicad-schematic_80","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/#video-demonstration_80","text":"Note In this chapter, all snippets of sketch codes are from the official Arduino Examples .","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/","text":"Chapter 5: Arduino Build-in Examples Section 5.1: AnalogWave Note All 3 examples under this section 5.1 are sharing the same Fritzing Circuit and KiCad Schematic . Fritzing Circuit KiCad Schematic 5.1.1 DACEqualTemperedScale Sketch Code /* Plays a tone in response to a potentiometer formula from https://newt.phys.unsw.edu.au/jw/notes.html and https://en.wikipedia.org/wiki/MIDI_tuning_standard: the MIDI protocol divides the notes of an equal-tempered scale into 128 possible note values. Middle A is MIDI note value 69. There is a formula for converting MIDI note numbers (0-127) to pitches. This sketch reduces that to the notes 21 - 108, which are the 88 keys found on a piano: frequency = 440 * ((noteNumber - 69) / 12.0)^2 You can see this applied in the code below. circuit: * audio amp (LM386 used for testing) input+ attached to A0 * audio amp input- attached to ground * 4-8-ohm speaker attached to amp output+ * Potentiometer connected to pin A5 created 18 Dec 2018 modified 3 Jul 2023 by Tom Igoe See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ // include the AnalogWave library: #include \"analogWave.h\" analogWave wave(DAC); // middle A is the reference frequency for an // equal-tempered scale. Set its frequency and note value: #define NOTE_A4 69 // MIDI note value for middle A #define FREQ_A4 440 // frequency for middle A const int speakerPin = A0; // the pin number for the speaker void setup() { Serial.begin(9600); wave.sine(10); } void loop() { // convert sensor reading to 21 - 108 range // which is the range of MIDI notes on an 88-key keyboard // (from A0 to C8): int sensorReading = analogRead(A5); int noteValue = map(sensorReading, 0, 1023, 21, 108); // then convert to frequency: float frequency = FREQ_A4 * pow(2, ((noteValue - NOTE_A4) / 12.0)); int freq = int(frequency); // turn the speaker on: wave.freq(freq); Serial.print(\"note value: \"+ String(noteValue) + \" freq: \"); Serial.println(freq); delay(500); } Video Demonstration 5.1.2 DACJacques Sketch Code /* DAC Melody player Generates a series of tones from MIDI note values using the Uno R4 DAC and the AnalogWave Library. The melody is \"Frere Jacques\" circuit: * audio amp (LM386 used for testing) input+ attached to A0 * audio amp input- attached to ground * 4-8-ohm speaker attached to amp output+ * Potentiometer connected to pin A5 created 13 Feb 2017 modified 3 Jul 2023 by Tom Igoe See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ #include \"analogWave.h\" analogWave wave(DAC); #define NOTE_A4 69 // MIDI note value for middle A #define FREQ_A4 440 // frequency for middle A // the tonic, or first note of the key signature for the song: int tonic = 65; // the melody sequence. Note values are relative to the tonic: int melody[] = {1, 3, 5, 1, 1, 3, 5, 1, 5, 6, 8, 5, 6, 8, 8, 10, 8, 6, 5, 1, 8, 10, 8, 6, 5, 1, 1, -4, 1, 1, -4, 1 }; // the rhythm sequence. Values are 1/note, e.g. 4 = 1/4 note: int rhythm[] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 2, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 4, 4, 4, 4, 2, 4, 4, 2 }; // which note of the melody to play: int noteCounter = 0; int bpm = 120; // beats per minute // duration of a beat in ms float beatDuration = 60.0 / bpm * 1000; void setup() { // start the sine wave generator: wave.sine(10); } void loop() { // current note is an element of the array: int currentNote = melody[noteCounter] + tonic; // play a note from the melody: // convert MIDI note number to frequency: float frequency = FREQ_A4 * pow(2, ((currentNote - NOTE_A4) / 12.0)); // all the notes in this are sixteenth notes, // which is 1/4 of a beat, so: float noteDuration = beatDuration * (4.0 / rhythm[noteCounter]); // turn the note on: wave.freq(frequency); // tone(speakerPin, frequency, noteDuration * 0.85); // keep it on for the appropriate duration: delay(noteDuration * 0.85); wave.stop(); delay(noteDuration * 0.15); // turn the note off: // noTone(speakerPin); // increment the note number for next time through the loop: noteCounter++; // keep the note in the range from 0 - 32 using modulo: noteCounter = noteCounter % 32; } Video Demonstration 5.1.3 SineWave Sketch Code /* SineWave Generates a pre-generated sawtooth-waveform. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ #include \"analogWave.h\" // Include the library for analog waveform generation analogWave wave(DAC); // Create an instance of the analogWave class, using the DAC pin int freq = 10; // in hertz, change accordingly void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 wave.sine(freq); // Generate a sine wave with the initial frequency } void loop() { // Read an analog value from pin A5 and map it to a frequency range freq = map(analogRead(A5), 0, 1024, 0, 10000); // Print the updated frequency to the serial monitor Serial.println(\"Frequency is now \" + String(freq) + \" hz\"); wave.freq(freq); // Set the frequency of the waveform generator to the updated value delay(1000); // Delay for one second before repeating } Video Demonstration Section 5.2: Arduino_CAN Note CAN1 is only available on Portenta C33 , which is to be ignored in this section. 5.2.1 CANRead Sketch Code /* CANRead Receive and read CAN Bus messages See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/can */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } if (!CAN.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } void loop() { if (CAN.available()) { CanMsg const msg = CAN.read(); Serial.println(msg); } } Fritzing Circuit KiCad Schematic Video Demonstration 5.2.2 CANWrite Sketch Code /* CANWrite Write and send CAN Bus messages See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/can */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * CONSTANTS **************************************************************************************/ static uint32_t const CAN_ID = 0x20; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } if (!CAN.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } static uint32_t msg_cnt = 0; void loop() { /* Assemble a CAN message with the format of * 0xCA 0xFE 0x00 0x00 [4 byte message counter] */ uint8_t const msg_data[] = {0xCA,0xFE,0,0,0,0,0,0}; memcpy((void *)(msg_data + 4), &msg_cnt, sizeof(msg_cnt)); CanMsg const msg(CanStandardId(CAN_ID), sizeof(msg_data), msg_data); /* Transmit the CAN message, capture and display an * error core in case of failure. */ if (int const rc = CAN.write(msg); rc < 0) { Serial.print (\"CAN.write(...) failed with error code \"); Serial.println(rc); for (;;) { } } /* Increase the message counter. */ msg_cnt++; /* Only send one message per second. */ delay(1000); } Fritzing Circuit KiCad Schematic Video Demonstration Section 5.3: Arduino_FreeRTOS Note No additional circuit is required for this section 5.3 . 5.3.1 FreeRTOS-Blink Sketch Code /* The code demonstrates the usage of FreeRTOS (Real-Time Operating System) to run concurrent tasks. One task is responsible for running the loop() logic (in a thread-safe manner), while the other task blinks an LED using the built-in LED on non-Portenta boards or the RGB LED on the Portenta C33 board. */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_FreeRTOS.h> /************************************************************************************** * GLOBAL VARIABLES **************************************************************************************/ TaskHandle_t loop_task, blinky_task; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } #if defined(ARDUINO_PORTENTA_C33) /* Only the Portenta C33 has an RGB LED. */ pinMode(LEDR, OUTPUT); digitalWrite(LEDR, LOW); #endif /* Init a task that calls 'loop' * since after the call to * 'vTaskStartScheduler' we'll never * get out of setup() and therefore * would never get to loop(), as we * are leaving the default execution * flow. */ auto const rc_loop = xTaskCreate ( loop_thread_func, static_cast<const char*>(\"Loop Thread\"), 512 / 4, /* usStackDepth in words */ nullptr, /* pvParameters */ 1, /* uxPriority */ &loop_task /* pxCreatedTask */ ); if (rc_loop != pdPASS) { Serial.println(\"Failed to create 'loop' thread\"); return; } auto const rc_blinky = xTaskCreate ( blinky_thread_func, static_cast<const char*>(\"Blinky Thread\"), 512 / 4, /* usStackDepth in words */ nullptr, /* pvParameters */ 1, /* uxPriority */ &blinky_task /* pxCreatedTask */ ); if (rc_blinky != pdPASS) { Serial.println(\"Failed to create 'loop' thread\"); return; } Serial.println(\"Starting scheduler ...\"); /* Start the scheduler. */ vTaskStartScheduler(); /* We'll never get here. */ for( ;; ); } void loop() { #if defined(ARDUINO_PORTENTA_C33) /* Only the Portenta C33 has an RGB LED. */ digitalWrite(LEDR, !digitalRead(LEDR)); #else Serial.println(millis()); #endif vTaskDelay(configTICK_RATE_HZ/4); } void loop_thread_func(void *pvParameters) { for(;;) { loop(); taskYIELD(); } } void blinky_thread_func(void *pvParameters) { /* setup() */ pinMode(LED_BUILTIN, OUTPUT); digitalWrite(LED_BUILTIN, LOW); /* loop() */ for(;;) { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); vTaskDelay(configTICK_RATE_HZ); } } Video Demonstration Section 5.4: EEPROM Note No additional circuit is required for this section 5.4 . 5.4.1 eeprom_clear Sketch Code /* * EEPROM Clear * * Sets all of the bytes of the EEPROM to 0. * Please see eeprom_iteration for a more in depth * look at how to traverse the EEPROM. * * This example code is in the public domain. */ #include <EEPROM.h> void setup() { // initialize the LED pin as an output. pinMode(13, OUTPUT); /*** Iterate through each byte of the EEPROM storage. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ for (int i = 0 ; i < EEPROM.length() ; i++) { EEPROM.write(i, 0); } // turn the LED on when we're done digitalWrite(13, HIGH); } void loop() { /** Empty loop. **/ } Video Demonstration 5.4.2 eeprom_crc Sketch Code /*** Written by Christopher Andrews. CRC algorithm generated by pycrc, MIT licence ( https://github.com/tpircher/pycrc ). A CRC is a simple way of checking whether data has changed or become corrupted. This example calculates a CRC value directly on the EEPROM values. The purpose of this example is to highlight how the EEPROM object can be used just like an array. ***/ #include <Arduino.h> #include <EEPROM.h> void setup() { //Start serial Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } //Print length of data to run CRC on. Serial.print(\"EEPROM length: \"); Serial.println(EEPROM.length()); //Print the result of calling eeprom_crc() Serial.print(\"CRC32 of EEPROM data: 0x\"); Serial.println(eeprom_crc(), HEX); Serial.print(\"\\n\\nDone!\"); } void loop() { /* Empty loop */ } unsigned long eeprom_crc(void) { const unsigned long crc_table[16] = { 0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c, 0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c }; unsigned long crc = ~0L; for (int index = 0 ; index < EEPROM.length() ; ++index) { crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4); crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4); crc = ~crc; } return crc; } Video Demonstration 5.4.3 eeprom_get Sketch Code /*** eeprom_get example. This shows how to use the EEPROM.get() method. To pre-set the EEPROM data, run the example sketch eeprom_put. This sketch will run without it, however, the values shown will be shown from what ever is already on the EEPROM. This may cause the serial object to print out a large string of garbage if there is no null character inside one of the strings loaded. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void setup() { float f = 0.00f; //Variable to store data read from EEPROM. int eeAddress = 0; //EEPROM address to start reading from Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Read float from EEPROM: \"); //Get the float data from the EEPROM at position 'eeAddress' EEPROM.get(eeAddress, f); Serial.println(f, 3); //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float. /*** As get also returns a reference to 'f', you can use it inline. E.g: Serial.print( EEPROM.get( eeAddress, f ) ); ***/ /*** Get can be used with custom structures too. I have separated this into an extra function. ***/ secondTest(); //Run the next test. } struct MyObject { float field1; byte field2; char name[10]; }; void secondTest() { int eeAddress = sizeof(float); //Move address to the next byte after float 'f'. MyObject customVar; //Variable to store custom object read from EEPROM. EEPROM.get(eeAddress, customVar); Serial.println(\"Read custom object from EEPROM: \"); Serial.println(customVar.field1); Serial.println(customVar.field2); Serial.println(customVar.name); } void loop() { /* Empty loop */ } Video Demonstration 5.4.4 eeprom_iteration Sketch Code /*** eeprom_iteration example. A set of example snippets highlighting the simplest methods for traversing the EEPROM. Running this sketch is not necessary, this is simply highlighting certain programming methods. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void setup() { /*** Iterate the EEPROM using a for loop. ***/ for (int index = 0 ; index < EEPROM.length() ; index++) { //Add one to each cell in the EEPROM EEPROM[ index ] += 1; } /*** Iterate the EEPROM using a while loop. ***/ int index = 0; while (index < EEPROM.length()) { //Add one to each cell in the EEPROM EEPROM[ index ] += 1; index++; } /*** Iterate the EEPROM using a do-while loop. ***/ int idx = 0; //Used 'idx' to avoid name conflict with 'index' above. do { //Add one to each cell in the EEPROM EEPROM[ idx ] += 1; idx++; } while (idx < EEPROM.length()); } //End of setup function. void loop() {} Video Demonstration 5.4.5 eeprom_put Sketch Code /*** eeprom_put example. This shows how to use the EEPROM.put() method. Also, this sketch will pre-set the EEPROM data for the example sketch eeprom_get. Note, unlike the single byte version EEPROM.write(), the put method will use update semantics. As in a byte will only be written to the EEPROM if the data is actually different. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> struct MyObject { float field1; byte field2; char name[10]; }; void setup() { Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } float f = 123.456f; //Variable to store in EEPROM. int eeAddress = 0; //Location we want the data to be put. //One simple call, with the address first and the object second. EEPROM.put(eeAddress, f); Serial.println(\"Written float data type!\"); /** Put is designed for use with custom structures also. **/ //Data to store. MyObject customVar = { 3.14f, 65, \"Working!\" }; eeAddress += sizeof(float); //Move address to the next byte after float 'f'. EEPROM.put(eeAddress, customVar); Serial.print(\"Written custom data type! \\n\\nView the example sketch eeprom_get to see how you can retrieve the values!\"); } void loop() { /* Empty loop */ } Video Demonstration 5.4.6 eeprom_read Sketch Code /* EEPROM Read Reads the value of each byte of the EEPROM and prints it to the computer. This example code is in the public domain. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom */ // Include the EEPROM library #include <EEPROM.h> // start reading from the first byte (address 0) of the EEPROM int address = 0; byte value; void setup() { // initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } } void loop() { // read a byte from the current address of the EEPROM value = EEPROM.read(address); Serial.print(address); Serial.print(\"\\t\"); Serial.print(value, DEC); Serial.println(); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM.length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM.length() - 1; ***/ delay(500); } Video Demonstration 5.4.7 eeprom_update Sketch Code /*** EEPROM Update method Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. If a value has not changed in the EEPROM, it is not overwritten which would reduce the life span of the EEPROM unnecessarily. Released using MIT licence. ***/ #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int address = 0; void setup() { /** Empty setup **/ } void loop() { /*** need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Update the particular EEPROM cell. these values will remain there when the board is turned off. ***/ EEPROM.update(address, val); /*** The function EEPROM.update(address, val) is equivalent to the following: if( EEPROM.read(address) != val ){ EEPROM.write(address, val); } ***/ /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM.length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM.length() - 1; ***/ delay(100); } Video Demonstration 5.4.8 eeprom_write Sketch Code /* EEPROM Write Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom */ // Include the EEPROM library #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int addr = 0; void setup() { /** Empty setup. **/ } void loop() { /*** Need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Write the value to the appropriate byte of the EEPROM. these values will remain there when the board is turned off. ***/ EEPROM.write(addr, val); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ addr = addr + 1; if (addr == EEPROM.length()) { addr = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++addr &= EEPROM.length() - 1; ***/ delay(100); } Video Demonstration Section 5.5: Ethernet Note No additional circuit is required for this section 5.5 . 5.5.1 AdvancedChatServer Sketch Code /* Advanced Chat Server A more advanced server that distributes any incoming messages to all connected clients but the client the message comes from. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe redesigned to make use of operator== 25 Nov 2013 by Norbert Truchsess */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); EthernetClient clients[8]; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // initialize the Ethernet device Ethernet.begin(mac, ip, myDns, gateway, subnet); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); Serial.print(\"Chat server address:\"); Serial.println(Ethernet.localIP()); } void loop() { // check for any new client connecting, and say hello (before any incoming data) EthernetClient newClient = server.accept(); if (newClient) { for (byte i=0; i < 8; i++) { if (!clients[i]) { Serial.print(\"We have a new client #\"); Serial.println(i); newClient.print(\"Hello, client number: \"); newClient.println(i); // Once we \"accept\", the client is no longer tracked by EthernetServer // so we must store it into our list of clients clients[i] = newClient; break; } } } // check for incoming data from all clients for (byte i=0; i < 8; i++) { if (clients[i] && clients[i].available() > 0) { // read bytes from a client byte buffer[80]; int count = clients[i].read(buffer, 80); // write the bytes to all other connected clients for (byte j=0; j < 8; j++) { if (j != i && clients[j].connected()) { clients[j].write(buffer, count); } } } } // stop any clients which disconnect for (byte i=0; i < 8; i++) { if (clients[i] && !clients[i].connected()) { Serial.print(\"disconnect client #\"); Serial.println(i); clients[i].stop(); } } } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.2 BarometricPressureWebServer Sketch Code /* SCP1000 Barometric Pressure Sensor Display Serves the output of a Barometric Pressure Sensor as a web page. Uses the SPI library. For details on the sensor, see: http://www.sparkfun.com/commerce/product_info.php?products_id=8161 This sketch adapted from Nathan Seidle's SCP1000 example for PIC: http://www.sparkfun.com/datasheets/Sensors/SCP1000-Testing.zip TODO: this hardware is long obsolete. This example program should be rewritten to use https://www.sparkfun.com/products/9721 Circuit: SCP1000 sensor attached to pins 6,7, and 11 - 13: DRDY: pin 6 CSB: pin 7 MOSI: pin 11 MISO: pin 12 SCK: pin 13 created 31 July 2010 by Tom Igoe */ #include <Ethernet.h> // the sensor communicates using SPI, so include the library: #include <SPI.h> // assign a MAC address for the Ethernet controller. // fill in your address here: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // assign an IP address for the controller: IPAddress ip(192, 168, 1, 20); // Initialize the Ethernet server library // with the IP address and port you want to use // (port 80 is default for HTTP): EthernetServer server(80); //Sensor's memory register addresses: const int PRESSURE = 0x1F; //3 most significant bits of pressure const int PRESSURE_LSB = 0x20; //16 least significant bits of pressure const int TEMPERATURE = 0x21; //16 bit temperature reading // pins used for the connection with the sensor // the others you need are controlled by the SPI library): const int dataReadyPin = 6; const int chipSelectPin = 7; float temperature = 0.0; long pressure = 0; long lastReadingTime = 0; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the SPI library: SPI.begin(); // start the Ethernet connection Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); // initialize the data ready and chip select pins: pinMode(dataReadyPin, INPUT); pinMode(chipSelectPin, OUTPUT); //Configure SCP1000 for low noise configuration: writeRegister(0x02, 0x2D); writeRegister(0x01, 0x03); writeRegister(0x03, 0x02); // give the sensor and Ethernet shield time to set up: delay(1000); //Set the sensor to high resolution mode to start readings: writeRegister(0x03, 0x0A); } void loop() { // check for a reading no more than once a second. if (millis() - lastReadingTime > 1000) { // if there's a reading ready, read it: // don't do anything until the data ready pin is high: if (digitalRead(dataReadyPin) == HIGH) { getData(); // timestamp the last time you got a reading: lastReadingTime = millis(); } } // listen for incoming Ethernet connections: listenForEthernetClients(); } void getData() { Serial.println(\"Getting reading\"); //Read the temperature data int tempData = readRegister(0x21, 2); // convert the temperature to Celsius and display it: temperature = (float)tempData / 20.0; //Read the pressure data highest 3 bits: byte pressureDataHigh = readRegister(0x1F, 1); pressureDataHigh &= 0b00000111; //you only needs bits 2 to 0 //Read the pressure data lower 16 bits: unsigned int pressureDataLow = readRegister(0x20, 2); //combine the two parts into one 19-bit number: pressure = ((pressureDataHigh << 16) | pressureDataLow) / 4; Serial.print(\"Temperature: \"); Serial.print(temperature); Serial.println(\" degrees C\"); Serial.print(\"Pressure: \" + String(pressure)); Serial.println(\" Pa\"); } void listenForEthernetClients() { // listen for incoming clients EthernetClient client = server.available(); if (client) { Serial.println(\"Got a client\"); // an HTTP request ends with a blank line bool currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(); // print the current readings, in HTML format: client.print(\"Temperature: \"); client.print(temperature); client.print(\" degrees C\"); client.println(\"<br />\"); client.print(\"Pressure: \" + String(pressure)); client.print(\" Pa\"); client.println(\"<br />\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); } } //Send a write command to SCP1000 void writeRegister(byte registerName, byte registerValue) { // SCP1000 expects the register name in the upper 6 bits // of the byte: registerName <<= 2; // command (read or write) goes in the lower two bits: registerName |= 0b00000010; //Write command // take the chip select low to select the device: digitalWrite(chipSelectPin, LOW); SPI.transfer(registerName); //Send register location SPI.transfer(registerValue); //Send value to record into register // take the chip select high to de-select: digitalWrite(chipSelectPin, HIGH); } //Read register from the SCP1000: unsigned int readRegister(byte registerName, int numBytes) { byte inByte = 0; // incoming from the SPI read unsigned int result = 0; // result to return // SCP1000 expects the register name in the upper 6 bits // of the byte: registerName <<= 2; // command (read or write) goes in the lower two bits: registerName &= 0b11111100; //Read command // take the chip select low to select the device: digitalWrite(chipSelectPin, LOW); // send the device the register you want to read: SPI.transfer(registerName); // send a value of 0 to read the first byte returned: inByte = SPI.transfer(0x00); result = inByte; // if there's more than one byte returned, // shift the first byte then get the second byte: if (numBytes > 1) { result = inByte << 8; inByte = SPI.transfer(0x00); result = result | inByte; } // take the chip select high to de-select: digitalWrite(chipSelectPin, HIGH); // return the result: return (result); } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.3 ChatServer Sketch Code /* Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); bool alreadyConnected = false; // whether or not the client was connected previously void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // initialize the Ethernet device Ethernet.begin(mac, ip, myDns, gateway, subnet); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); Serial.print(\"Chat server address:\"); Serial.println(Ethernet.localIP()); } void loop() { // wait for a new client: EthernetClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!alreadyConnected) { // clear out the input buffer: client.flush(); Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); alreadyConnected = true; } if (client.available() > 0) { // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.write(thisChar); } } } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.4 DhcpAddressPrinter Sketch Code /* DHCP-based IP printer This sketch uses the DHCP extensions to the Ethernet library to get an IP address via DHCP and print the address obtained. using an Arduino WIZnet Ethernet shield. Circuit: Ethernet shield attached to pins 10, 11, 12, 13 created 12 April 2011 modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); } else if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // no point in carrying on, so do nothing forevermore: while (true) { delay(1); } } // print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); } void loop() { switch (Ethernet.maintain()) { case 1: //renewed fail Serial.println(\"Error: renewed fail\"); break; case 2: //renewed success Serial.println(\"Renewed success\"); //print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); break; case 3: //rebind fail Serial.println(\"Error: rebind fail\"); break; case 4: //rebind success Serial.println(\"Rebind success\"); //print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); break; default: //nothing happened break; } } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.5 DhcpChatServer Sketch Code /* DHCP Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. THis version attempts to get an IP address using DHCP Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 21 May 2011 modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi Based on ChatServer example by David A. Mellis */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); bool gotAMessage = false; // whether or not you got a message from the client yet void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Trying to get an IP address using DHCP\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // initialize the Ethernet device not using DHCP: Ethernet.begin(mac, ip, myDns, gateway, subnet); } // print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); // start listening for clients server.begin(); } void loop() { // wait for a new client: EthernetClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!gotAMessage) { Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); gotAMessage = true; } // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.print(thisChar); Ethernet.maintain(); } } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.6 LinkStatus Sketch Code /* Link Status This sketch prints the Ethernet link status. When the Ethernet cable is connected the link status should go to \"ON\". NOTE: Only WIZnet W5200 and W5500 are capable of reporting the link status. W5100 will report \"Unknown\". Hardware: - Ethernet shield or equivalent board/shield with WIZnet W5200/W5500 Written by Cristian Maglie This example is public domain. */ #include <SPI.h> #include <Ethernet.h> void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet Serial.begin(9600); } void loop() { auto link = Ethernet.linkStatus(); Serial.print(\"Link status: \"); switch (link) { case Unknown: Serial.println(\"Unknown\"); break; case LinkON: Serial.println(\"ON\"); break; case LinkOFF: Serial.println(\"OFF\"); break; } delay(1000); } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.7 PagerServer Sketch Code /* Pager Server A simple server that echoes any incoming messages to all connected clients. Connect two or more telnet sessions to see how server.available() and server.print() works. created in September 2020 for the Ethernet library by Juraj Andrassy https://github.com/jandrassy */ #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); EthernetServer server(2323); void setup() { Serial.begin(9600); while (!Serial); // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } server.begin(); IPAddress ip = Ethernet.localIP(); Serial.println(); Serial.print(\"To access the server, connect with Telnet client to \"); Serial.print(ip); Serial.println(\" 2323\"); } void loop() { EthernetClient client = server.available(); // returns first client which has data to read or a 'false' client if (client) { // client is true only if it is connected and has data to read String s = client.readStringUntil('\\n'); // read the message incoming from one of the clients s.trim(); // trim eventual \\r Serial.println(s); // print the message to Serial Monitor client.print(\"echo: \"); // this is only for the sending client server.println(s); // send the message to all connected clients #ifndef ARDUINO_ARCH_SAM server.flush(); // flush the buffers #endif /* !defined(ARDUINO_ARCH_SAM) */ } } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.8 TelnetClient Sketch Code /* Telnet client This sketch connects to a telnet server (http://www.google.com) using an Arduino WIZnet Ethernet shield. You'll need a telnet server to test this with. Processing's ChatServer example (part of the Network library) works well, running on port 10002. It can be found as part of the examples in the Processing application, available at https://processing.org/ Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 14 Sep 2010 modified 9 Apr 2012 by Tom Igoe */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); // Enter the IP address of the server you're connecting to: IPAddress server(1, 1, 1, 1); // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 23 is default for telnet; // if you're using Processing's ChatServer, use port 10002): EthernetClient client; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the Ethernet connection: Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } while (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); delay(500); } // give the Ethernet shield a second to initialize: delay(1000); Serial.println(\"connecting...\"); // if you get a connection, report back via serial: if (client.connect(server, 10002)) { Serial.println(\"connected\"); } else { // if you didn't get a connection to the server: Serial.println(\"connection failed\"); } } void loop() { // if there are incoming bytes available // from the server, read them and print them: if (client.available()) { char c = client.read(); Serial.print(c); } // as long as there are bytes in the serial queue, // read them and send them out the socket if it's open: while (Serial.available() > 0) { char inChar = Serial.read(); if (client.connected()) { client.print(inChar); } } // if the server's disconnected, stop the client: if (!client.connected()) { Serial.println(); Serial.println(\"disconnecting.\"); client.stop(); // do nothing: while (true) { delay(1); } } } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.9 UdpNtpClient Sketch Code /* Udp NTP Client Get the time from a Network Time Protocol (NTP) time server Demonstrates use of UDP sendPacket and ReceivePacket For more on NTP time servers and the messages needed to communicate with them, see https://en.wikipedia.org/wiki/Network_Time_Protocol created 4 Sep 2010 by Michael Margolis modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi This code is in the public domain. */ #include <SPI.h> #include <Ethernet.h> #include <EthernetUdp.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; unsigned int localPort = 8888; // local port to listen for UDP packets const char timeServer[] = \"time.nist.gov\"; // time.nist.gov NTP server const int NTP_PACKET_SIZE = 48; // NTP time stamp is in the first 48 bytes of the message byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming and outgoing packets // A UDP instance to let us send and receive packets over UDP EthernetUDP Udp; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start Ethernet and UDP if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); } else if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // no point in carrying on, so do nothing forevermore: while (true) { delay(1); } } Udp.begin(localPort); } void loop() { sendNTPpacket(timeServer); // send an NTP packet to a time server // wait to see if a reply is available delay(1000); if (Udp.parsePacket()) { // We've received a packet, read the data from it Udp.read(packetBuffer, NTP_PACKET_SIZE); // read the packet into the buffer // the timestamp starts at byte 40 of the received packet and is four bytes, // or two words, long. First, extract the two words: unsigned long highWord = word(packetBuffer[40], packetBuffer[41]); unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]); // combine the four bytes (two words) into a long integer // this is NTP time (seconds since Jan 1 1900): unsigned long secsSince1900 = highWord << 16 | lowWord; Serial.print(\"Seconds since Jan 1 1900 = \"); Serial.println(secsSince1900); // now convert NTP time into everyday time: Serial.print(\"Unix time = \"); // Unix time starts on Jan 1 1970. In seconds, that's 2208988800: const unsigned long seventyYears = 2208988800UL; // subtract seventy years: unsigned long epoch = secsSince1900 - seventyYears; // print Unix time: Serial.println(epoch); // print the hour, minute and second: Serial.print(\"The UTC time is \"); // UTC is the time at Greenwich Meridian (GMT) Serial.print((epoch % 86400L) / 3600); // print the hour (86400 equals secs per day) Serial.print(':'); if (((epoch % 3600) / 60) < 10) { // In the first 10 minutes of each hour, we'll want a leading '0' Serial.print('0'); } Serial.print((epoch % 3600) / 60); // print the minute (3600 equals secs per minute) Serial.print(':'); if ((epoch % 60) < 10) { // In the first 10 seconds of each minute, we'll want a leading '0' Serial.print('0'); } Serial.println(epoch % 60); // print the second } // wait ten seconds before asking for the time again delay(10000); Ethernet.maintain(); } // send an NTP request to the time server at the given address void sendNTPpacket(const char * address) { // set all bytes in the buffer to 0 memset(packetBuffer, 0, NTP_PACKET_SIZE); // Initialize values needed to form NTP request // (see URL above for details on the packets) packetBuffer[0] = 0b11100011; // LI, Version, Mode packetBuffer[1] = 0; // Stratum, or type of clock packetBuffer[2] = 6; // Polling Interval packetBuffer[3] = 0xEC; // Peer Clock Precision // 8 bytes of zero for Root Delay & Root Dispersion packetBuffer[12] = 49; packetBuffer[13] = 0x4E; packetBuffer[14] = 49; packetBuffer[15] = 52; // all NTP fields have been given values, now // you can send a packet requesting a timestamp: Udp.beginPacket(address, 123); // NTP requests are to port 123 Udp.write(packetBuffer, NTP_PACKET_SIZE); Udp.endPacket(); } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.10 UDPSendReceiveString Sketch Code /* UDPSendReceiveString This sketch receives UDP message strings, prints them to the serial port and sends an \"acknowledge\" string back to the sender A Processing sketch is included at the end of file that can be used to send and receive messages for testing with a computer. created 21 Aug 2010 by Michael Margolis This code is in the public domain. */ #include <Ethernet.h> #include <EthernetUdp.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); unsigned int localPort = 8888; // local port to listen on // buffers for receiving and sending data char packetBuffer[UDP_TX_PACKET_MAX_SIZE]; // buffer to hold incoming packet, char ReplyBuffer[] = \"acknowledged\"; // a string to send back // An EthernetUDP instance to let us send and receive packets over UDP EthernetUDP Udp; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the Ethernet Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start UDP Udp.begin(localPort); } void loop() { // if there's data available, read a packet int packetSize = Udp.parsePacket(); if (packetSize) { Serial.print(\"Received packet of size \"); Serial.println(packetSize); Serial.print(\"From \"); IPAddress remote = Udp.remoteIP(); for (int i=0; i < 4; i++) { Serial.print(remote[i], DEC); if (i < 3) { Serial.print(\".\"); } } Serial.print(\", port \"); Serial.println(Udp.remotePort()); // read the packet into packetBuffer Udp.read(packetBuffer, UDP_TX_PACKET_MAX_SIZE); Serial.println(\"Contents:\"); Serial.println(packetBuffer); // send a reply to the IP address and port that sent us the packet we received Udp.beginPacket(Udp.remoteIP(), Udp.remotePort()); Udp.write(ReplyBuffer); Udp.endPacket(); } delay(10); } /* Processing sketch to run with this example ===================================================== // Processing UDP example to send and receive string data from Arduino // press any key to send the \"Hello Arduino\" message import hypermedia.net.*; UDP udp; // define the UDP object void setup() { udp = new UDP( this, 6000 ); // create a new datagram connection on port 6000 //udp.log( true ); // <-- printout the connection activity udp.listen( true ); // and wait for incoming message } void draw() { } void keyPressed() { String ip = \"192.168.1.177\"; // the remote IP address int port = 8888; // the destination port udp.send(\"Hello World\", ip, port ); // the message to send } void receive( byte[] data ) { // <-- default handler //void receive( byte[] data, String ip, int port ) { // <-- extended handler for(int i=0; i < data.length; i++) print(char(data[i])); println(); } */ Fritzing Circuit KiCad Schematic Video Demonstration 5.5.11 WebClient Sketch Code /* Web client This sketch connects to a website (http://www.google.com) using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe, based on work by Adrian McEwen */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // if you don't want to use DNS (and reduce your sketch size) // use the numeric IP instead of the name for the server: //IPAddress server(74,125,232,128); // numeric IP for Google (no DNS) char server[] = \"www.google.com\"; // name address for Google (using DNS) // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); IPAddress myDns(192, 168, 0, 1); // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 80 is default for HTTP): EthernetClient client; // Variables to measure the speed unsigned long beginMicros, endMicros; unsigned long byteCount = 0; bool printWebData = true; // set to false for better speed measurement void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip, myDns); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } // give the Ethernet shield a second to initialize: delay(1000); Serial.print(\"connecting to \"); Serial.print(server); Serial.println(\"...\"); // if you get a connection, report back via serial: if (client.connect(server, 80)) { Serial.print(\"connected to \"); Serial.println(client.remoteIP()); // Make a HTTP request: client.println(\"GET /search?q=arduino HTTP/1.1\"); client.println(\"Host: www.google.com\"); client.println(\"Connection: close\"); client.println(); } else { // if you didn't get a connection to the server: Serial.println(\"connection failed\"); } beginMicros = micros(); } void loop() { // if there are incoming bytes available // from the server, read them and print them: int len = client.available(); if (len > 0) { byte buffer[80]; if (len > 80) len = 80; client.read(buffer, len); if (printWebData) { Serial.write(buffer, len); // show in the serial monitor (slows some boards) } byteCount = byteCount + len; } // if the server's disconnected, stop the client: if (!client.connected()) { endMicros = micros(); Serial.println(); Serial.println(\"disconnecting.\"); client.stop(); Serial.print(\"Received \"); Serial.print(byteCount); Serial.print(\" bytes in \"); float seconds = (float)(endMicros - beginMicros) / 1000000.0; Serial.print(seconds, 4); float rate = (float)byteCount / seconds / 1000.0; Serial.print(\", rate = \"); Serial.print(rate); Serial.print(\" kbytes/second\"); Serial.println(); // do nothing forevermore: while (true) { delay(1); } } } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.12 WebClientRepeating Sketch Code /* Repeating Web client This sketch connects to a web server and makes a request using a WIZnet Ethernet shield. You can use the Arduino Ethernet Shield, or the Adafruit Ethernet shield, either one will work, as long as it's got a WIZnet Ethernet module on board. This example uses DNS, by assigning the Ethernet client with a MAC address, IP address, and DNS address. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 19 Apr 2012 by Tom Igoe modified 21 Jan 2014 by Federico Vanzati https://www.arduino.cc/en/Tutorial/WebClientRepeating This code is in the public domain. */ #include <SPI.h> #include <Ethernet.h> // assign a MAC address for the Ethernet controller. // fill in your address here: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); IPAddress myDns(192, 168, 0, 1); // initialize the library instance: EthernetClient client; char server[] = \"www.arduino.cc\"; // also change the Host line in httpRequest() //IPAddress server(64,131,82,241); unsigned long lastConnectionTime = 0; // last time you connected to the server, in milliseconds const unsigned long postingInterval = 10*1000; // delay between updates, in milliseconds void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start serial port: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip, myDns); Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } // give the Ethernet shield a second to initialize: delay(1000); } void loop() { // if there's incoming data from the net connection. // send it out the serial port. This is for debugging // purposes only: if (client.available()) { char c = client.read(); Serial.write(c); } // if ten seconds have passed since your last connection, // then connect again and send data: if (millis() - lastConnectionTime > postingInterval) { httpRequest(); } } // this method makes a HTTP connection to the server: void httpRequest() { // close any connection before send a new request. // This will free the socket on the Ethernet shield client.stop(); // if there's a successful connection: if (client.connect(server, 80)) { Serial.println(\"connecting...\"); // send the HTTP GET request: client.println(\"GET /latest.txt HTTP/1.1\"); client.println(\"Host: www.arduino.cc\"); client.println(\"User-Agent: arduino-ethernet\"); client.println(\"Connection: close\"); client.println(); // note the time that the connection was made: lastConnectionTime = millis(); } else { // if you couldn't make a connection: Serial.println(\"connection failed\"); } } Fritzing Circuit KiCad Schematic Video Demonstration 5.5.13 WebServer Sketch Code /* Web Server A simple web server that shows the value of the analog input pins. using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 * Analog inputs attached to pins A0 through A5 (optional) created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); // Initialize the Ethernet server library // with the IP address and port you want to use // (port 80 is default for HTTP): EthernetServer server(80); void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"Ethernet WebServer Example\"); // start the Ethernet connection and the server: Ethernet.begin(mac, ip); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start the server server.begin(); Serial.print(\"server is at \"); Serial.println(Ethernet.localIP()); } void loop() { // listen for incoming clients EthernetClient client = server.available(); if (client) { Serial.println(\"new client\"); // an HTTP request ends with a blank line bool currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); Serial.write(c); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(\"Connection: close\"); // the connection will be closed after completion of the response client.println(\"Refresh: 5\"); // refresh the page automatically every 5 sec client.println(); client.println(\"<!DOCTYPE HTML>\"); client.println(\"<html>\"); // output the value of each analog input pin for (int analogChannel = 0; analogChannel < 6; analogChannel++) { int sensorReading = analogRead(analogChannel); client.print(\"analog input \"); client.print(analogChannel); client.print(\" is \"); client.print(sensorReading); client.println(\"<br />\"); } client.println(\"</html>\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } Fritzing Circuit KiCad Schematic Video Demonstration Section 5.6: Firmata Note No additional circuit is required for this section 5.6 . 5.6.1 AllInputsFirmata Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* * This firmware reads all inputs and sends them as fast as it can. It was * inspired by the ease-of-use of the Arduino2Max program. * * This example code is in the public domain. */ #include <Firmata.h> byte pin; int analogValue; int previousAnalogValues[TOTAL_ANALOG_PINS]; byte portStatus[TOTAL_PORTS]; // each bit: 1=pin is digital input, 0=other/ignore byte previousPINs[TOTAL_PORTS]; /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you get long, random delays. So only read analogs every 20ms or so */ int samplingInterval = 19; // how often to run the main loop (in ms) void sendPort(byte portNumber, byte portValue) { portValue = portValue & portStatus[portNumber]; if (previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } void setup() { byte i, port, status; Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); for (pin = 0; pin < TOTAL_PINS; pin++) { if IS_PIN_DIGITAL(pin) pinMode(PIN_TO_DIGITAL(pin), INPUT); } for (port = 0; port < TOTAL_PORTS; port++) { status = 0; for (i = 0; i < 8; i++) { if (IS_PIN_DIGITAL(port * 8 + i)) status |= (1 << i); } portStatus[port] = status; } Firmata.begin(57600); } void loop() { byte i; for (i = 0; i < TOTAL_PORTS; i++) { sendPort(i, readPort(i, 0xff)); } /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you get long, random delays. So only read analogs every 20ms or so */ currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; while (Firmata.available()) { Firmata.processInput(); } for (pin = 0; pin < TOTAL_ANALOG_PINS; pin++) { analogValue = analogRead(pin); if (analogValue != previousAnalogValues[pin]) { Firmata.sendAnalog(pin, analogValue); previousAnalogValues[pin] = analogValue; } } } } Video Demonstration 5.6.2 AnalogFirmata Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This firmware supports as many analog ports as possible, all analog inputs, * four PWM outputs, and two with servo support. * * This example code is in the public domain. */ #include <Servo.h> #include <Firmata.h> /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* servos */ Servo servo9, servo10; // one instance per pin /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting int analogPin = 0; // counter for reading analog pins /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /*============================================================================== * FUNCTIONS *============================================================================*/ void analogWriteCallback(byte pin, int value) { switch (pin) { case 9: servo9.write(value); break; case 10: servo10.write(value); break; case 3: case 5: case 6: case 11: // PWM pins analogWrite(pin, value); break; } } // ----------------------------------------------------------------------------- // sets bits in a bit array (int) to toggle the reporting of the analogIns void reportAnalogCallback(byte pin, int value) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << pin); } else { // everything but 0 enables reporting of that pin analogInputsToReport = analogInputsToReport | (1 << pin); } // TODO: save status to EEPROM here, if changed } /*============================================================================== * SETUP() *============================================================================*/ void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); servo9.attach(9); servo10.attach(10); Firmata.begin(57600); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { while (Firmata.available()) Firmata.processInput(); currentMillis = millis(); if (currentMillis - previousMillis > 20) { previousMillis += 20; // run this every 20ms for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) { if ( analogInputsToReport & (1 << analogPin) ) Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } Video Demonstration 5.6.3 EchoString Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This sketch accepts strings and raw sysex messages and echos them back. * * This example code is in the public domain. */ #include <Firmata.h> void stringCallback(char *myString) { Firmata.sendString(myString); } void sysexCallback(byte command, byte argc, byte *argv) { Firmata.sendSysex(command, argc, argv); } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(STRING_DATA, stringCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.begin(57600); } void loop() { while (Firmata.available()) { Firmata.processInput(); } } Video Demonstration 5.6.4 OldStandardFirmata Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. */ /* * This is an old version of StandardFirmata (v2.0). It is kept here because * its the last version that works on an ATMEGA8 chip. Also, it can be used * for host software that has not been updated to a newer version of the * protocol. It also uses the old baud rate of 115200 rather than 57600. */ #include <EEPROM.h> #include <Firmata.h> /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting int analogPin = 0; // counter for reading analog pins /* digital pins */ byte reportPINs[TOTAL_PORTS]; // PIN == input port byte previousPINs[TOTAL_PORTS]; // PIN == input port byte pinStatus[TOTAL_PINS]; // store pin status, default OUTPUT byte portStatus[TOTAL_PORTS]; /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /*============================================================================== * FUNCTIONS *============================================================================*/ void outputPort(byte portNumber, byte portValue) { portValue = portValue & ~ portStatus[portNumber]; if (previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; Firmata.sendDigitalPort(portNumber, portValue); } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { byte i, tmp; for (i = 0; i < TOTAL_PORTS; i++) { if (reportPINs[i]) { switch (i) { case 0: outputPort(0, PIND & ~ B00000011); break; // ignore Rx/Tx 0/1 case 1: outputPort(1, PINB); break; case 2: outputPort(2, PINC); break; } } } } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { byte port = 0; byte offset = 0; if (pin < 8) { port = 0; offset = 0; } else if (pin < 14) { port = 1; offset = 8; } else if (pin < 22) { port = 2; offset = 14; } if (pin > 1) { // ignore RxTx (pins 0 and 1) pinStatus[pin] = mode; switch (mode) { case INPUT: pinMode(pin, INPUT); portStatus[port] = portStatus[port] & ~ (1 << (pin - offset)); break; case OUTPUT: digitalWrite(pin, LOW); // disable PWM case PWM: pinMode(pin, OUTPUT); portStatus[port] = portStatus[port] | (1 << (pin - offset)); break; //case ANALOG: // TODO figure this out default: Firmata.sendString(\"\"); } // TODO: save status to EEPROM here, if changed } } void analogWriteCallback(byte pin, int value) { setPinModeCallback(pin, PIN_MODE_PWM); analogWrite(pin, value); } void digitalWriteCallback(byte port, int value) { switch (port) { case 0: // pins 2-7 (don't change Rx/Tx, pins 0 and 1) // 0xFF03 == B1111111100000011 0x03 == B00000011 PORTD = (value & ~ 0xFF03) | (PORTD & 0x03); break; case 1: // pins 8-13 (14,15 are disabled for the crystal) PORTB = (byte)value; break; case 2: // analog pins used as digital PORTC = (byte)value; break; } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte pin, int value) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << pin); } else { // everything but 0 enables reporting of that pin analogInputsToReport = analogInputsToReport | (1 << pin); } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { reportPINs[port] = (byte)value; if (port == 2) // turn off analog reporting when used as digital analogInputsToReport = 0; } /*============================================================================== * SETUP() *============================================================================*/ void setup() { byte i; Firmata.setFirmwareVersion(2, 0); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); portStatus[0] = B00000011; // ignore Tx/RX pins portStatus[1] = B11000000; // ignore 14/15 pins portStatus[2] = B00000000; // for(i=0; i<TOTAL_PINS; ++i) { // TODO make this work with analogs for (i = 0; i < 14; ++i) { setPinModeCallback(i, OUTPUT); } // set all outputs to 0 to make sure internal pull-up resistors are off PORTB = 0; // pins 8-15 PORTC = 0; // analog port PORTD = 0; // pins 0-7 // TODO rethink the init, perhaps it should report analog on default for (i = 0; i < TOTAL_PORTS; ++i) { reportPINs[i] = false; } // TODO: load state from EEPROM here /* send digital inputs here, if enabled, to set the initial state on the * host computer, since once in the loop(), this firmware will only send * digital data on change. */ if (reportPINs[0]) outputPort(0, PIND & ~ B00000011); // ignore Rx/Tx 0/1 if (reportPINs[1]) outputPort(1, PINB); if (reportPINs[2]) outputPort(2, PINC); Firmata.begin(115200); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); currentMillis = millis(); if (currentMillis - previousMillis > 20) { previousMillis += 20; // run this every 20ms /* SERIALREAD - Serial.read() uses a 128 byte circular buffer, so handle * all serialReads at once, i.e. empty the buffer */ while (Firmata.available()) Firmata.processInput(); /* SEND FTDI WRITE BUFFER - make sure that the FTDI buffer doesn't go over * 60 bytes. use a timer to sending an event character every 4 ms to * trigger the buffer to dump. */ /* ANALOGREAD - right after the event character, do all of the * analogReads(). These only need to be done every 4ms. */ for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) { if ( analogInputsToReport & (1 << analogPin) ) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } } Video Demonstration 5.6.5 ServoFirmata Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This firmware supports as many servos as possible using the Servo library * included in Arduino 0017 * * This example code is in the public domain. */ #include <Servo.h> #include <Firmata.h> Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte servoCount = 0; void analogWriteCallback(byte pin, int value) { if (IS_PIN_DIGITAL(pin)) { servos[servoPinMap[pin]].write(value); } } void systemResetCallback() { servoCount = 0; } void setup() { byte pin; Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); Firmata.begin(57600); systemResetCallback(); // attach servos from first digital pin up to max number of // servos supported for the board for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { if (servoCount < MAX_SERVOS) { servoPinMap[pin] = servoCount; servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); servoCount++; } } } } void loop() { while (Firmata.available()) Firmata.processInput(); } Video Demonstration 5.6.6 SimpleAnalogFirmata Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Supports as many analog inputs and analog PWM outputs as possible. * * This example code is in the public domain. */ #include <Firmata.h> byte analogPin = 0; void analogWriteCallback(byte pin, int value) { if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_DIGITAL(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), value); } } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.begin(57600); } void loop() { while (Firmata.available()) { Firmata.processInput(); } // do one analogRead per loop, so if PC is sending a lot of // analog write messages, we will only delay 1 analogRead Firmata.sendAnalog(analogPin, analogRead(analogPin)); analogPin = analogPin + 1; if (analogPin >= TOTAL_ANALOG_PINS) analogPin = 0; } Video Demonstration 5.6.7 SimpleDigitalFirmata Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Supports as many digital inputs and outputs as possible. * * This example code is in the public domain. */ #include <Firmata.h> byte previousPIN[TOTAL_PORTS]; // PIN means PORT for input byte previousPORT[TOTAL_PORTS]; void outputPort(byte portNumber, byte portValue) { // only send the data when it changes, otherwise you get too many messages! if (previousPIN[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPIN[portNumber] = portValue; } } void setPinModeCallback(byte pin, int mode) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), mode); } } void digitalWriteCallback(byte port, int value) { byte i; byte currentPinValue, previousPinValue; if (port < TOTAL_PORTS && value != previousPORT[port]) { for (i = 0; i < 8; i++) { currentPinValue = (byte) value & (1 << i); previousPinValue = previousPORT[port] & (1 << i); if (currentPinValue != previousPinValue) { digitalWrite(i + (port * 8), currentPinValue); } } previousPORT[port] = value; } } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.begin(57600); } void loop() { byte i; for (i = 0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, 0xff)); } while (Firmata.available()) { Firmata.processInput(); } } Video Demonstration 5.6.8 StandardFirmataBLE Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega, // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this: // Serial1.begin(57600); // Firmata.begin(Serial1); // However do not do this if you are using SERIAL_MESSAGE Firmata.begin(57600); while (!Serial) { ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101 } systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif } Video Demonstration 5.6.9 StandardFirmataChipKIT Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. Copyright (C) 2015 Brian Schmalz. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ #include <SoftPWMServo.h> // Gives us PWM and Servo on every pin #include <Wire.h> #include <Firmata.h> #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; SoftServo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* Sets a pin that is in Servo mode to a particular output value * (i.e. pulse width). Different boards may have different ways of * setting servo values, so putting it in a function keeps things cleaner. */ void servoWrite(byte pin, int value) { SoftPWMServoPWMWrite(PIN_TO_PWM(pin), value); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); servoWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) servoWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); /* For chipKIT Pi board, we need to use Serial1. All others just use Serial. */ #if defined(_BOARD_CHIPKIT_PI_) Serial1.begin(57600); Firmata.begin(Serial1); #else Firmata.begin(57600); #endif systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } } Video Demonstration 5.6.10 StandardFirmataEthernet Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2017 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated March 10th, 2020 */ /* README StandardFirmataEthernet is a TCP client/server implementation. You will need a Firmata client library with a network transport that can act as a TCP server or client in order to establish a connection between StandardFirmataEthernet and the Firmata client application. To use StandardFirmataEthernet you will need to have one of the following boards or shields: - Arduino Ethernet shield (or clone) - Arduino Ethernet board (or clone) - Arduino Yun Follow the instructions in the ethernetConfig.h file (ethernetConfig.h tab in Arduino IDE) to configure your particular hardware. NOTE: If you are using an Arduino Ethernet shield you cannot use the following pins on the following boards. Firmata will ignore any requests to use these pins: - Arduino Uno or other ATMega328 boards: (D4, D10, D11, D12, D13) - Arduino Mega: (D4, D10, D50, D51, D52, D53) - Arduino Leonardo: (D4, D10) - Arduino Due: (D4, D10) - Arduino Zero: (D4, D10) If you are using an ArduinoEthernet board, the following pins cannot be used (same as Uno): - D4, D10, D11, D12, D13 */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> /* * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your * connection that may help in the event of connection issues. If defined, some boards may not begin * executing this sketch until the Serial console is opened. */ //#define SERIAL_DEBUG #include \"utility/firmataDebug.h\" // follow the instructions in ethernetConfig.h to configure your particular hardware #include \"ethernetConfig.h\" #include \"utility/EthernetClientStream.h\" #include \"utility/EthernetServerStream.h\" /* * Uncomment the following include to enable interfacing with Serial devices via hardware or * software serial. * * DO NOT uncomment if you are running StandardFirmataEthernet on an Arduino Leonardo, * Arduino Micro or other ATMega32u4-based board or you will not have enough Flash and RAM * remaining to reliably run Firmata. Arduino Yun is okay because it doesn't import the Ethernet * libraries. */ // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. //#include \"utility/SerialFirmata.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #if defined remote_ip && !defined remote_host #ifdef local_ip EthernetClientStream stream(client, local_ip, remote_ip, NULL, network_port); #else EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), remote_ip, NULL, network_port); #endif #endif #if !defined remote_ip && defined remote_host #ifdef local_ip EthernetClientStream stream(client, local_ip, IPAddress(0, 0, 0, 0), remote_host, network_port ); #else EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), IPAddress(0, 0, 0, 0), remote_host, network_port); #endif #endif #if !defined remote_ip && !defined remote_host #ifdef local_ip EthernetServerStream stream(local_ip, network_port); #else EthernetServerStream stream(IPAddress(0, 0, 0, 0), network_port); #endif #endif #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous mode */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Stream output queue using Stream.write() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { // turn on/off reporting reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } #ifdef ETHERNETCLIENTSTREAM_H /* * Called when a TCP connection is either connected or disconnected. * TODO: * - report connected or reconnected state to host (to be added to protocol) * - report current state to host (to be added to protocol) */ void hostConnectionCallback(byte state) { switch (state) { case HOST_CONNECTION_CONNECTED: DEBUG_PRINTLN( \"TCP connection established\" ); break; case HOST_CONNECTION_DISCONNECTED: DEBUG_PRINTLN( \"TCP connection disconnected\" ); break; } } #endif void printEthernetStatus() { DEBUG_PRINT(\"Local IP Address: \"); IPAddress ip = Ethernet.localIP(); DEBUG_PRINTLN(ip); #ifdef remote_ip DEBUG_PRINT(\"Connecting to server at: \"); DEBUG_PRINTLN(remote_ip); #endif } /* * StandardFirmataEthernet communicates with Ethernet shields over SPI. Therefore all * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication. * Additional pins may also need to be ignored depending on the particular board or * shield in use. */ void ignorePins() { #ifdef IS_IGNORE_PIN for (byte i = 0; i < TOTAL_PINS; i++) { if (IS_IGNORE_PIN(i)) { Firmata.setPinMode(i, PIN_MODE_IGNORE); } } #endif #ifdef WIZ5100_ETHERNET // Arduino Ethernet and Arduino EthernetShield have SD SS wired to D4 pinMode(PIN_TO_DIGITAL(4), OUTPUT); // switch off SD card bypassing Firmata digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA #endif #endif // WIZ5100_ETHERNET } void initTransport() { #ifdef ETHERNETCLIENTSTREAM_H stream.attach(hostConnectionCallback); #endif #ifdef YUN_ETHERNET Bridge.begin(); #else #ifdef local_ip Ethernet.begin((uint8_t *)mac, local_ip); //start ethernet #else DEBUG_PRINTLN(\"Local IP will be requested from DHCP...\"); //start ethernet using dhcp if (Ethernet.begin((uint8_t *)mac) == 0) { DEBUG_PRINTLN(\"Failed to configure Ethernet using DHCP\"); } #endif #endif printEthernetStatus(); } void initFirmata() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); ignorePins(); // start up Network Firmata: Firmata.begin(stream); systemResetCallback(); // Initialize default configuration } void setup() { DEBUG_BEGIN(9600); initTransport(); initFirmata(); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * Stream buffer using Stream.write() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif #if !defined local_ip && !defined YUN_ETHERNET // only necessary when using DHCP, ensures local IP is updated appropriately if it changes if (Ethernet.maintain()) { stream.maintain(Ethernet.localIP()); } #endif } Video Demonstration 5.6.11 StandardFirmataPlus Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ /* README StandardFirmataPlus adds additional features that may exceed the Flash and RAM sizes of Arduino boards such as ATMega328p (Uno) and ATMega32u4 (Leonardo, Micro, Yun, etc). It is best to use StandardFirmataPlus with higher memory boards such as the Arduino Mega, Arduino Due, Teensy 3.0/3.1/3.2. All Firmata examples that are appended with \"Plus\" add the following features: - Ability to interface with serial devices using UART, USART, or SoftwareSerial depending on the capatilities of the board. NOTE: In order to use SoftwareSerial with the Firmata Serial feature, StandardFirmataPlus must be compiled with Arduino v1.6.6 or newer. At the time of this writing, StandardFirmataPlus will still compile and run on ATMega328p and ATMega32u4-based boards, but future versions of this sketch may not as new features are added. */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. #include \"utility/SerialFirmata.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); // Save a couple of seconds by disabling the startup blink sequence. Firmata.disableBlinkVersion(); // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega, // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this: // Serial1.begin(57600); // Firmata.begin(Serial1); // However do not do this if you are using SERIAL_MESSAGE Firmata.begin(57600); while (!Serial) { ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101 } systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif } Video Demonstration 5.6.12 StandardFirmataWiFi Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. Copyright (C) 2015-2016 Jesse Frush. All rights reserved. Copyright (C) 2016 Jens B. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ /* README StandardFirmataWiFi enables the use of Firmata over a TCP connection. It can be configured as either a TCP server or TCP client. To use StandardFirmataWiFi you will need to have one of the following boards or shields: - Arduino WiFi Shield (or clone) - Arduino WiFi Shield 101 - Arduino MKR1000 board - Arduino MKRWIFI1010 board - ESP8266 WiFi board compatible with ESP8266 Arduino core Follow the instructions in the wifiConfig.h file (wifiConfig.h tab in Arduino IDE) to configure your particular hardware. Dependencies: - WiFi Shield 101 requires version 0.7.0 or higher of the WiFi101 library (available in Arduino 1.6.8 or higher, or update the library via the Arduino Library Manager or clone from source: https://github.com/arduino-libraries/WiFi101) - ESP8266 requires the Arduino ESP8266 core v2.1.0 or higher which can be obtained here: https://github.com/esp8266/Arduino In order to use the WiFi Shield 101 with Firmata you will need a board with at least 35k of Flash memory. This means you cannot use the WiFi Shield 101 with an Arduino Uno or any other ATmega328p-based microcontroller or with an Arduino Leonardo or other ATmega32u4-based microcontroller. Some boards that will work are: - Arduino Zero - Arduino Due - Arduino 101 - Arduino Mega NOTE: If you are using an Arduino WiFi (legacy) shield you cannot use the following pins on the following boards. Firmata will ignore any requests to use these pins: - Arduino Uno or other ATMega328 boards: (D4, D7, D10, D11, D12, D13) - Arduino Mega: (D4, D7, D10, D50, D51, D52, D53) - Arduino Due, Zero or Leonardo: (D4, D7, D10) If you are using an Arduino WiFi 101 shield you cannot use the following pins on the following boards: - Arduino Due or Zero: (D5, D7, D10) - Arduino Mega: (D5, D7, D10, D50, D52, D53) */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> /* * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your * connection that may help in the event of connection issues. If defined, some boards may not begin * executing this sketch until the Serial console is opened. */ //#define SERIAL_DEBUG #include \"utility/firmataDebug.h\" /* * Uncomment the following include to enable interfacing with Serial devices via hardware or * software serial. */ // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. //#include \"utility/SerialFirmata.h\" // follow the instructions in wifiConfig.h to configure your particular hardware #include \"wifiConfig.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 #define MAX_CONN_ATTEMPTS 20 // [500 ms] -> 10 s /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif #ifdef STATIC_IP_ADDRESS IPAddress local_ip(STATIC_IP_ADDRESS); #endif #ifdef SUBNET_MASK IPAddress subnet(SUBNET_MASK); #endif #ifdef GATEWAY_IP_ADDRESS IPAddress gateway(GATEWAY_IP_ADDRESS); #endif int connectionAttempts = 0; bool streamConnected = false; /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous mode */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Stream output queue using Stream.write() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- // function forward declarations for xtensa compiler (ESP8266) void enableI2CPins(); void disableI2CPins(); void reportAnalogCallback(byte analogPin, int value); // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } /* * Called when a TCP connection is either connected or disconnected. * TODO: * - report connected or reconnected state to host (to be added to protocol) * - report current state to host (to be added to protocol) */ void hostConnectionCallback(byte state) { switch (state) { case HOST_CONNECTION_CONNECTED: DEBUG_PRINTLN( \"TCP connection established\" ); break; case HOST_CONNECTION_DISCONNECTED: DEBUG_PRINTLN( \"TCP connection disconnected\" ); break; } } /* * Print the status of the WiFi connection. This is the connection to the access point rather * than the TCP connection. */ void printWifiStatus() { if ( WiFi.status() != WL_CONNECTED ) { DEBUG_PRINT( \"WiFi connection failed. Status value: \" ); DEBUG_PRINTLN( WiFi.status() ); } else { // print the SSID of the network you're attached to: DEBUG_PRINT( \"SSID: \" ); DEBUG_PRINTLN( WiFi.SSID() ); // print your WiFi shield's IP address: DEBUG_PRINT( \"IP Address: \" ); IPAddress ip = WiFi.localIP(); DEBUG_PRINTLN( ip ); // print the received signal strength: DEBUG_PRINT( \"signal strength (RSSI): \" ); long rssi = WiFi.RSSI(); DEBUG_PRINT( rssi ); DEBUG_PRINTLN( \" dBm\" ); } } /* * StandardFirmataWiFi communicates with WiFi shields over SPI. Therefore all * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication. * Additional pins may also need to be ignored depending on the particular board or * shield in use. */ void ignorePins() { #ifdef IS_IGNORE_PIN for (byte i = 0; i < TOTAL_PINS; i++) { if (IS_IGNORE_PIN(i)) { Firmata.setPinMode(i, PIN_MODE_IGNORE); } } #endif //Set up controls for the Arduino WiFi Shield SS for the SD Card #ifdef ARDUINO_WIFI_SHIELD // Arduino WiFi Shield has SD SS wired to D4 pinMode(PIN_TO_DIGITAL(4), OUTPUT); // switch off SD card bypassing Firmata digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA #endif //defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) #endif //ARDUINO_WIFI_SHIELD } void initTransport() { // This statement will clarify how a connection is being made DEBUG_PRINT( \"StandardFirmataWiFi will attempt a WiFi connection \" ); #if defined(WIFI_101) DEBUG_PRINTLN( \"using the WiFi 101 library.\" ); #elif defined(ARDUINO_WIFI_SHIELD) DEBUG_PRINTLN( \"using the legacy WiFi library.\" ); #elif defined(ESP8266_WIFI) DEBUG_PRINTLN( \"using the ESP8266 WiFi library.\" ); #elif defined(HUZZAH_WIFI) DEBUG_PRINTLN( \"using the HUZZAH WiFi library.\" ); #elif defined(WIFI_NINA) DEBUG_PRINTLN( \"using the WiFi NINA library.\" ); //else should never happen here as error-checking in wifiConfig.h will catch this #endif //defined(WIFI_101) // Configure WiFi IP Address #ifdef STATIC_IP_ADDRESS DEBUG_PRINT( \"Using static IP: \" ); DEBUG_PRINTLN( local_ip ); #if defined(ESP8266_WIFI) || (defined(SUBNET_MASK) && defined(GATEWAY_IP_ADDRESS)) stream.config( local_ip , gateway, subnet ); #else // you can also provide a static IP in the begin() functions, but this simplifies // ifdef logic in this sketch due to support for all different encryption types. stream.config( local_ip ); #endif #else DEBUG_PRINTLN( \"IP will be requested from DHCP ...\" ); #endif stream.attach(hostConnectionCallback); // Configure WiFi security and initiate WiFi connection #if defined(WIFI_WEP_SECURITY) DEBUG_PRINT( \"Attempting to connect to WEP SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid, wep_index, wep_key); #elif defined(WIFI_WPA_SECURITY) DEBUG_PRINT( \"Attempting to connect to WPA SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid, wpa_passphrase); #else //OPEN network DEBUG_PRINTLN( \"Attempting to connect to open SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid); #endif //defined(WIFI_WEP_SECURITY) DEBUG_PRINTLN( \"WiFi setup done\" ); // Wait for connection to access point to be established. while (WiFi.status() != WL_CONNECTED && ++connectionAttempts <= MAX_CONN_ATTEMPTS) { delay(500); DEBUG_PRINT(\".\"); } printWifiStatus(); } void initFirmata() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); ignorePins(); // Initialize Firmata to use the WiFi stream object as the transport. Firmata.begin(stream); systemResetCallback(); // reset to default config } void setup() { DEBUG_BEGIN(9600); initTransport(); initFirmata(); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * Stream buffer using Stream.write() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) { Firmata.processInput(); } // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif stream.maintain(); } Video Demonstration Section 5.7: Keyboard Note No additional circuit is required for this section 5.7 . 5.7.1 Serial Sketch Code /* Keyboard test For the Arduino Leonardo, Micro or Due Reads a byte from the serial port, sends a keystroke back. The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send A you get B, and so forth. The circuit: - none created 21 Oct 2011 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardSerial */ #include \"Keyboard.h\" void setup() { // open the serial port: Serial.begin(9600); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // check for incoming serial data: if (Serial.available() > 0) { // read incoming serial data: char inChar = Serial.read(); // Type the next ASCII value from what you received: Keyboard.write(inChar + 1); } } Video Demonstration Section 5.8: LED_Matrix Note No additional circuit is required for this section 5.8 . 5.8.1 DisplaySingleFrame Sketch Code /* Single Frame Displays single frames using matrix.loadFrame See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library #include \"frames.h\" // Include a header file containing frame data ArduinoLEDMatrix matrix; // Create an instance of the ArduinoLEDMatrix class void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 matrix.begin(); // Initialize the LED matrix } void loop() { // Load and display the \"chip\" frame on the LED matrix matrix.loadFrame(chip); delay(500); // Pause for 500 milliseconds (half a second) // Load and display the \"danger\" frame on the LED matrix matrix.loadFrame(danger); delay(500); // Load and display the \"happy\" frame on the LED matrix matrix.loadFrame(happy); delay(500); // Load and display the \"heart\" frame on the LED matrix matrix.loadFrame(heart); delay(500); // Print the current value of millis() to the serial monitor Serial.println(millis()); } Video Demonstration 5.8.2 GameOfLife Sketch Code /* Game Of Life The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. Example developed starting from Toby Oxborrow's sketch https://github.com/tobyoxborrow/gameoflife-arduino/blob/master/GameOfLife.ino See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library // grid dimensions. should not be larger than 8x8 #define MAX_Y 8 #define MAX_X 12 // time to wait between turns #define TURN_DELAY 200 // how many turns per game before starting a new game // you can also use the reset button on the board #define TURNS_MAX 60 // number of patterns in predefined list #define MAX_PATTERNS 4 // how many turns to wait if there are no changes before starting a new game #define NO_CHANGES_RESET 4 int turns = 0; // counter for turns int noChanges = 0; // counter for turns without changes // game state. 0 is dead cell, 1 is live cell uint8_t grid[MAX_Y][MAX_X] = { {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, }; int currentPattern = 0; String patternNames[] = { \"Glider\", \"Light-weight spaceship\", \"R-Pentomino\", \"Diehard\" }; // custom starting grid patterns boolean cGrids[][MAX_Y][MAX_X] = { { /* Glider */ {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* Light-weight spaceship */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* R-Pentomino */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* Die hard */ {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} } }; ArduinoLEDMatrix matrix; void setup() { Serial.begin(9600); delay(1000); Serial.println(\"Conway's game of life on Arduino LED Matrix\"); matrix.begin(); resetGrid(); displayGrid(); } void loop() { delay(TURN_DELAY); playGoL(); turns++; // reset the grid if no changes have occured recently // for when the game enters a static stable state if (noChanges > NO_CHANGES_RESET) { resetGrid(); } // reset the grid if the loop has been running a long time // for when the game cycles between a few stable states if (turns > TURNS_MAX) { resetGrid(); } displayGrid(); } // play game of life void playGoL() { /* 1. Any live cell with fewer than two neighbours dies, as if by loneliness. 2. Any live cell with more than three neighbours dies, as if by overcrowding. 3. Any live cell with two or three neighbours lives, unchanged, to the next generation. 4. Any dead cell with exactly three neighbours comes to life. */ boolean newGrid[MAX_Y][MAX_X] = { {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { int neighboughs = countNeighbours(y, x); if (grid[y][x] == 1) { if ((neighboughs == 2) || (neighboughs == 3)) { newGrid[y][x] = 1; } else { newGrid[y][x] = 0; } } else { if (neighboughs == 3) { newGrid[y][x] = 1; } else { newGrid[y][x] = 0; } } } } // update the current grid from the new grid and count how many changes // occured int changes = 0; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { if (newGrid[y][x] != grid[y][x]) { changes++; } grid[y][x] = newGrid[y][x]; } } // update global counter when no changes occured if (changes == 0) { noChanges++; } } // count the number of neighbour live cells for a given cell int countNeighbours(int y, int x) { int count = 0; // -- Row above us --- if (y > 0) { // above left if (x > 0) { count += grid[y - 1][x - 1]; } // above count += grid[y - 1][x]; // above right if ((x + 1) < 8) { count += grid[y - 1][x + 1]; } } // -- Same row ------- // left if (x > 0) { count += grid[y][x - 1]; } // right if ((x + 1) < 8) { count += grid[y][x + 1]; } // -- Row below us --- if ((y + 1) < 8) { // below left if (x > 0) { count += grid[y + 1][x - 1]; } // below count += grid[y + 1][x]; // below right if ((x + 1) < 8) { count += grid[y + 1][x + 1]; } } return count; } // reset the grid void resetGrid() { Serial.print(\"Current pattern: \"); Serial.println(patternNames[currentPattern]); noChanges = 0; turns = 0; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { grid[y][x] = cGrids[currentPattern][y][x]; } } currentPattern++; if(currentPattern >= MAX_PATTERNS){ currentPattern = 0; } } // display the current grid to the LED matrix void displayGrid() { matrix.renderBitmap(grid, 8, 12); } Video Demonstration 5.8.3 LivePreview Sketch Code /* This sketch allows live editing of the matrix pixels using WebSerial To test, head to https://ledmatrix-editor.arduino.cc The LED Matrix editor is part of Arduino Labs (https://labs.arduino.cc/), and is therefore considered experimental software. Don't forget to close any serial monitor already opened. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library ArduinoLEDMatrix matrix; // Create an instance of the ArduinoLEDMatrix class void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 matrix.begin(); // Initialize the LED matrix } // Define an array to hold pixel data for a single frame (4 pixels) uint32_t frame[] = { 0, 0, 0, 0xFFFF }; void loop() { // Check if there are at least 12 bytes available in the serial buffer if(Serial.available() >= 12){ // Read 4 bytes from the serial buffer and compose them into a 32-bit value for each element in the frame frame[0] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; frame[1] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; frame[2] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; // Load and display the received frame data on the LED matrix matrix.loadFrame(frame); } } Video Demonstration 5.8.4 MatrixFrameBuffer Sketch Code /* Matrix Frame Buffer This Arduino sketch demonstrates the creation and manipulation of a frame buffer for the LED matrix. The frame buffer is used to control the lighting of individual LEDs on the matrix, turning them randomly on and off. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ // Include the LED_Matrix library #include \"Arduino_LED_Matrix.h\" // Create an instance of the ArduinoLEDMatrix class ArduinoLEDMatrix matrix; // Define the frame array for the LED matrix with pixel values uint8_t frame[8][12] = { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 } }; // Set up time intervals and dimensions for the matrix unsigned long lastTickTime, lastGameTickTime; #define UPDATE_INTERVAL 100 #define GAME_UPDATE_INTERVAL 66 #define ROWS 8 #define COLUMNS 12 // Variables to track the current positions uint8_t pointX = 0, pointY = 0; void setup() { // Initialize serial communication and delaying for setup Serial.begin(115200); delay(1500); // Initialize the LED matrix matrix.begin(); // Initialize time tracking variables lastGameTickTime = lastTickTime = millis(); } void loop() { // Track the current time unsigned long msNow = millis(); // Update the game logic with a fixed interval if (msNow - lastGameTickTime > GAME_UPDATE_INTERVAL) { // Increment pointX and handling wraparound pointX++; if (pointX >= COLUMNS) { pointX = 0; pointY++; if (pointY >= ROWS) { pointY = 0; } } // Generate random positions and pixel value pointX = random(COLUMNS); pointY = random(ROWS); uint8_t pixelValue = random(2); // Update the frame with the new pixel value frame[pointY][pointX] = pixelValue; // Update the last game tick time lastGameTickTime = msNow; } // Render the LED matrix with the current frame at a fixed interval if (msNow - lastTickTime > UPDATE_INTERVAL) { matrix.renderBitmap(frame, 8, 12); // Update the last rendering tick time lastTickTime = msNow; } } Video Demonstration 5.8.5 MatrixIntro Sketch Code /* Heart Animation Sketch This is the default sketch that comes shipped with every UNO R4 WiFi board. After the animation (a heart) is complete, the built-in LED blinks infinitely. No additional circuit required. created 26 Jun 2023 by Martino Facchin See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ // include the LED Matrix library from the Uno R4 core: #include \"Arduino_LED_Matrix.h\" // make an instance of the library: ArduinoLEDMatrix matrix; //include the \"animation.h\" header file that stores the frames for the animation #include \"animation.h\" void setup() { Serial.begin(115200); //load frames from the animation.h file matrix.loadSequence(frames); // start the matrix matrix.begin(); // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds // matrix.autoscroll(300); //play the animation on the matrix matrix.play(true); //define LED_BUILTIN as an output pinMode(LED_BUILTIN, OUTPUT); } void loop() { //blinks the built-in LED every second digitalWrite(LED_BUILTIN, HIGH); delay(1000); digitalWrite(LED_BUILTIN, LOW); delay(1000); } Video Demonstration 5.8.6 PlayAnimation Sketch Code /* Play Animation Sketch shows animation defined in animation.h See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" //Include the LED_Matrix library #include \"animation.h\" //Include animation.h header file // Create an instance of the ArduinoLEDMatrix class ArduinoLEDMatrix matrix; void setup() { Serial.begin(115200); // you can also load frames at runtime, without stopping the refresh matrix.loadSequence(animation); matrix.begin(); // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds // matrix.autoscroll(300); matrix.play(true); } void loop() { delay(500); Serial.println(millis()); } Video Demonstration 5.8.7 TextWithArduinoGraphics Sketch Code // To use ArduinoGraphics APIs, please include BEFORE Arduino_LED_Matrix #include \"ArduinoGraphics.h\" #include \"Arduino_LED_Matrix.h\" ArduinoLEDMatrix matrix; void setup() { Serial.begin(115200); matrix.begin(); matrix.beginDraw(); matrix.stroke(0xFFFFFFFF); // add some static text // will only show \"UNO\" (not enough space on the display) const char text[] = \"UNO r4\"; matrix.textFont(Font_4x6); matrix.beginText(0, 1, 0xFFFFFF); matrix.println(text); matrix.endText(); matrix.endDraw(); delay(2000); } void loop() { // Make it scroll! matrix.beginDraw(); matrix.stroke(0xFFFFFFFF); matrix.textScrollSpeed(50); // add the text const char text[] = \" Scrolling text! \"; matrix.textFont(Font_5x7); matrix.beginText(0, 1, 0xFFFFFF); matrix.println(text); matrix.endText(SCROLL_LEFT); matrix.endDraw(); } Video Demonstration Section 5.9: LiquidCrystal 5.9.1 Autoscroll Sketch Code /* LiquidCrystal Library - Autoscroll Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch demonstrates the use of the autoscroll() and noAutoscroll() functions to make new text scroll or not. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalAutoscroll */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); } void loop() { // set the cursor to (0,0): lcd.setCursor(0, 0); // print from 0 to 9: for (int thisChar = 0; thisChar < 10; thisChar++) { lcd.print(thisChar); delay(500); } // set the cursor to (16,1): lcd.setCursor(16, 1); // set the display to automatically scroll: lcd.autoscroll(); // print from 0 to 9: for (int thisChar = 0; thisChar < 10; thisChar++) { lcd.print(thisChar); delay(500); } // turn off automatic scrolling lcd.noAutoscroll(); // clear screen for the next loop: lcd.clear(); } Fritzing Circuit KiCad Schematic Video Demonstration 5.9.2 Blink Sketch Code /* LiquidCrystal Library - Blink Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and makes the cursor block blink. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalBlink */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the blinking cursor: lcd.noBlink(); delay(3000); // Turn on the blinking cursor: lcd.blink(); delay(3000); } Fritzing Circuit KiCad Schematic Video Demonstration 5.9.3 Cursor Sketch Code /* LiquidCrystal Library - Cursor Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the cursor() and noCursor() methods to turn on and off the cursor. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalCursor */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the cursor: lcd.noCursor(); delay(500); // Turn on the cursor: lcd.cursor(); delay(500); } `` #### [Fritzing] Circuit #### [KiCad] Schematic #### Video Demonstration [Fritzing]: https://fritzing.org/ [KiCad]: https://www.kicad.org/ [Arduino]: https://arduino.cc [Microcontroller]: https://en.wikipedia.org/wiki/Microcontroller ### 5.9.4 CustomCharacter #### Sketch Code ```C /* LiquidCrystal Library - Custom Characters Demonstrates how to add custom characters on an LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"I <heart> Arduino!\" and a little dancing man to the LCD. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K potentiometer: * ends to +5V and ground * wiper to LCD VO pin (pin 3) * 10K poterntiometer on pin A0 created 21 Mar 2011 by Tom Igoe modified 11 Nov 2013 by Scott Fitzgerald modified 7 Nov 2016 by Arturo Guadalupi Based on Adafruit's example at https://github.com/adafruit/SPI_VFD/blob/master/examples/createChar/createChar.pde This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalCustomCharacter Also useful: http://icontexto.com/charactercreator/ */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); // make some custom characters: byte heart[8] = { 0b00000, 0b01010, 0b11111, 0b11111, 0b11111, 0b01110, 0b00100, 0b00000 }; byte smiley[8] = { 0b00000, 0b00000, 0b01010, 0b00000, 0b00000, 0b10001, 0b01110, 0b00000 }; byte frownie[8] = { 0b00000, 0b00000, 0b01010, 0b00000, 0b00000, 0b00000, 0b01110, 0b10001 }; byte armsDown[8] = { 0b00100, 0b01010, 0b00100, 0b00100, 0b01110, 0b10101, 0b00100, 0b01010 }; byte armsUp[8] = { 0b00100, 0b01010, 0b00100, 0b10101, 0b01110, 0b00100, 0b00100, 0b01010 }; void setup() { // initialize LCD and set up the number of columns and rows: lcd.begin(16, 2); // create a new character lcd.createChar(0, heart); // create a new character lcd.createChar(1, smiley); // create a new character lcd.createChar(2, frownie); // create a new character lcd.createChar(3, armsDown); // create a new character lcd.createChar(4, armsUp); // set the cursor to the top left lcd.setCursor(0, 0); // Print a message to the lcd. lcd.print(\"I \"); lcd.write(byte(0)); // when calling lcd.write() '0' must be cast as a byte lcd.print(\" Arduino! \"); lcd.write((byte)1); } void loop() { // read the potentiometer on A0: int sensorReading = analogRead(A0); // map the result to 200 - 1000: int delayTime = map(sensorReading, 0, 1023, 200, 1000); // set the cursor to the bottom row, 5th position: lcd.setCursor(4, 1); // draw the little man, arms down: lcd.write(3); delay(delayTime); lcd.setCursor(4, 1); // draw him arms up: lcd.write(4); delay(delayTime); } Fritzing Circuit KiCad Schematic Video Demonstration 5.9.5 Display Sketch Code /* LiquidCrystal Library - display() and noDisplay() Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the display() and noDisplay() functions to turn on and off the display. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalDisplay */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the display: lcd.noDisplay(); delay(500); // Turn on the display: lcd.display(); delay(500); } Fritzing Circuit KiCad Schematic Video Demonstration 5.9.6 HelloWorld Sketch Code /* LiquidCrystal Library - Hello World Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and shows the time. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * LCD VSS pin to ground * LCD VCC pin to 5V * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalHelloWorld */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // set the cursor to column 0, line 1 // (note: line 1 is the second row, since counting begins with 0): lcd.setCursor(0, 1); // print the number of seconds since reset: lcd.print(millis() / 1000); } Fritzing Circuit KiCad Schematic Video Demonstration 5.9.7 Scroll Sketch Code /* LiquidCrystal Library - scrollDisplayLeft() and scrollDisplayRight() Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the scrollDisplayLeft() and scrollDisplayRight() methods to scroll the text. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalScroll */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); delay(1000); } void loop() { // scroll 13 positions (string length) to the left // to move it offscreen left: for (int positionCounter = 0; positionCounter < 13; positionCounter++) { // scroll one position left: lcd.scrollDisplayLeft(); // wait a bit: delay(150); } // scroll 29 positions (string length + display length) to the right // to move it offscreen right: for (int positionCounter = 0; positionCounter < 29; positionCounter++) { // scroll one position right: lcd.scrollDisplayRight(); // wait a bit: delay(150); } // scroll 16 positions (display length + string length) to the left // to move it back to center: for (int positionCounter = 0; positionCounter < 16; positionCounter++) { // scroll one position left: lcd.scrollDisplayLeft(); // wait a bit: delay(150); } // delay at the end of the full loop: delay(1000); } Fritzing Circuit KiCad Schematic Video Demonstration 5.9.8 SerialDisplay Sketch Code /* LiquidCrystal Library - Serial Input Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch displays text sent over the serial port (e.g. from the Serial Monitor) on an attached LCD. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalSerialDisplay */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // initialize the serial communications: Serial.begin(9600); } void loop() { // when characters arrive over the serial port... if (Serial.available()) { // wait a bit for the entire message to arrive delay(100); // clear the screen lcd.clear(); // read all the available characters while (Serial.available() > 0) { // display each character to the LCD lcd.write(Serial.read()); } } } Fritzing Circuit KiCad Schematic Video Demonstration 5.9.9 setCursor Sketch Code /* LiquidCrystal Library - setCursor Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints to all the positions of the LCD using the setCursor() method: The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalSetCursor */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); // these constants won't change. But you can change the size of // your LCD using them: const int numRows = 2; const int numCols = 16; void setup() { // set up the LCD's number of columns and rows: lcd.begin(numCols, numRows); } void loop() { // loop from ASCII 'a' to ASCII 'z': for (int thisLetter = 'a'; thisLetter <= 'z'; thisLetter++) { // loop over the columns: for (int thisRow = 0; thisRow < numRows; thisRow++) { // loop over the rows: for (int thisCol = 0; thisCol < numCols; thisCol++) { // set the cursor position: lcd.setCursor(thisCol, thisRow); // print the letter: lcd.write(thisLetter); delay(200); } } } } Fritzing Circuit KiCad Schematic Video Demonstration 5.9.10 TextDirection Sketch Code /* LiquidCrystal Library - TextDirection Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch demonstrates how to use leftToRight() and rightToLeft() to move the cursor. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalTextDirection */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); int thisChar = 'a'; void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // turn on the cursor: lcd.cursor(); } void loop() { // reverse directions at 'm': if (thisChar == 'm') { // go right for the next letter lcd.rightToLeft(); } // reverse again at 's': if (thisChar == 's') { // go left for the next letter lcd.leftToRight(); } // reset at 'z': if (thisChar > 'z') { // go to (0,0): lcd.home(); // start again at 0 thisChar = 'a'; } // print the character lcd.write(thisChar); // wait a second: delay(1000); // increment the letter: thisChar++; } Fritzing Circuit KiCad Schematic Video Demonstration Section 5.10: OPAMP Note No additional circuit is required for this section 5.10 . 5.10.1 start_opamp Sketch Code #include <OPAMP.h> void setup () { Serial.begin(9600); delay(2000); // serial monitor delay // activate OPAMP, default channel 0 // Plus: Analog A1 // Minus: Analog A2 // Output: Analog A3 if (!OPAMP.begin(OPAMP_SPEED_HIGHSPEED)) { Serial.println(\"Failed to start OPAMP!\"); } bool const isRunning = OPAMP.isRunning(0); if (isRunning) { Serial.println(\"OPAMP running on channel 0!\"); } else { Serial.println(\"OPAMP channel 0 is not running!\"); } } void loop() { delay(1000); // do nothing } Video Demonstration Section 5.11: OTAUpdate Note No additional circuit is required for this section 5.11 . 5.11.1 OTA Sketch Code /* OTA This sketch demonstrates how to make an OTA Update on the UNO R4 WiFi. Upload the sketch and wait for the invasion! */ #include \"WiFiS3.h\" #include \"OTAUpdate.h\" #include \"root_ca.h\" #include \"arduino_secrets.h\" char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; OTAUpdate ota; static char const OTA_FILE_LOCATION[] = \"https://downloads.arduino.cc/ota/UNOR4WIFI_Animation.ota\"; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the Wi-Fi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with Wi-Fi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to Wi-Fi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 1 seconds for connection: delay(1000); } printWiFiStatus(); OTAUpdate::Error ret = OTAUpdate::Error::None; ret = ota.begin(\"/update.bin\"); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.begin() error: \"); Serial.println((int)ret); return; } ret = ota.setCACert(root_ca); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.setCACert() error: \"); Serial.println((int)ret); return; } int ota_size = ota.download(OTA_FILE_LOCATION, \"/update.bin\"); if(ota_size <= 0) { Serial.println(\"ota.download() error: \"); Serial.println(ota_size); return; } ret = ota.verify(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.verify() error: \"); Serial.println((int)ret); return; } ret = ota.update(\"/update.bin\"); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.update() error: \"); Serial.println((int)ret); return; } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ delay(1000); } /* -------------------------------------------------------------------------- */ void printWiFiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Video Demonstration 5.11.2 WiFiFirmwareOTA Sketch Code /* OTA This sketch demonstrates how to make the UNO R4 WiFi self-update its Wi-Fi module firmware via OTA. Upload the Sketch and wait for Serial detach. After the update the new Wi-Fi firmware version will be 98.98.98 WARNING: running this sketch will load a test Wi-Fi firmware version on the UNO R4 WiFi module. To restore a production firmware use the Arduino Firmware Uploader or the update packages available here: https://github.com/arduino/uno-r4-wifi-usb-bridge/releases */ #include \"WiFiS3.h\" #include \"OTAUpdate.h\" #include \"root_ca.h\" #include \"arduino_secrets.h\" char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; OTAUpdate ota; static char const OTA_FILE_LOCATION[] = \"https://downloads.arduino.cc/ota/UNOR4USBBridge.ino.ota\"; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the Wi-Fi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with Wi-Fi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } Serial.print(\"Current Wi-Fi firmware version: \"); Serial.println(fv); // attempt to connect to Wi-Fi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 1 seconds for connection: delay(1000); } printWiFiStatus(); OTAUpdate::Error ret = OTAUpdate::Error::None; ret = ota.begin(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.begin() error: \"); Serial.println((int)ret); return; } ret = ota.setCACert(root_ca); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.setCACert() error: \"); Serial.println((int)ret); return; } int ota_size = ota.download(OTA_FILE_LOCATION); if(ota_size <= 0) { Serial.println(\"ota.download() error: \"); Serial.println(ota_size); return; } ret = ota.verify(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.verify() error: \"); Serial.println((int)ret); return; } ret = ota.update(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.update() error: \"); Serial.println((int)ret); return; } ret = ota.reset(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.reset() error: \"); Serial.println((int)ret); return; } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ String fv = WiFi.firmwareVersion(); Serial.print(\"Updated Wi-Fi firmware version: \"); Serial.println(fv); delay(1000); } /* -------------------------------------------------------------------------- */ void printWiFiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Video Demonstration Section 5.12: RTC Note No additional circuit is required for this section 5.12 . 5.12.1 RTC_Alarm Sketch Code /* * RTC_Alarm * * This example demonstrates how to use the alarm functionality of the RTC * (Real Time Clock) on the Portenta C33 and UNO R4 Minima / WiFi. * * It turns on the built-in LED when the alarm * is triggered, which is once every minute in this example. * In addition, inside the loop, we print the state of the alarm * continuously, which is either 0 (LOW) or 1 (HIGH). * * Note that the Portenta C33's LED is inverted and will be lit when * the state is 0 (LOW). * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ unsigned long previousMillis = 0; const long interval = 1000; bool ledState = false; // Include the RTC library #include \"RTC.h\" void setup() { //initialize Serial Communication Serial.begin(9600); //define LED as output pinMode(LED_BUILTIN, OUTPUT); // Initialize the RTC RTC.begin(); // RTC.setTime() must be called for RTC.setAlarmCallback to work, but it doesn't matter // what date and time it's set to in this example RTCTime initialTime(7, Month::JUNE, 2023, 13, 03, 00, DayOfWeek::WEDNESDAY, SaveLight::SAVING_TIME_ACTIVE); RTC.setTime(initialTime); // Trigger the alarm every time the seconds are zero RTCTime alarmTime; alarmTime.setSecond(0); // Make sure to only match on the seconds in this example - not on any other parts of the date/time AlarmMatch matchTime; matchTime.addMatchSecond(); //sets the alarm callback RTC.setAlarmCallback(alarmCallback, alarmTime, matchTime); } void loop() { // in the loop, we continuously print the alarm's current state // this is for debugging only and has no effect on the alarm whatsoever unsigned long currentMillis = millis(); if (currentMillis - previousMillis >= interval) { // save the last time you blinked the LED previousMillis = currentMillis; Serial.print(\"Alarm state: \"); Serial.println(ledState); } } // this function activates every minute // and changes the ledState boolean void alarmCallback() { if (!ledState) { digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } ledState = !ledState; } Video Demonstration 5.12.2 RTC_AutomaticExample Sketch Code /* * RTC_AutomaticExample * * This example sets the RTC (Real Time Clock) on the Portenta C33 automatically by * retrieving the date and time from the computer you upload the sketch from, at the * point when you start the upload. * * Next, it gets the current time from the RTC and prints it to the Serial Monitor. * It then sets an RTC alarm to fire every time the seconds value of the time is zero. * The alarm, which now goes off once a minute, triggers a callback that prints the * current time to the Serial Monitor. * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" DayOfWeek convertDayOfWeek(String s) { if (s == String(\"Mon\")) { return DayOfWeek::MONDAY; } if (s == String(\"Tue\")) { return DayOfWeek::TUESDAY; } if (s == String(\"Wed\")) { return DayOfWeek::WEDNESDAY; } if (s == String(\"Thu\")) { return DayOfWeek::THURSDAY; } if (s == String(\"Fri\")) { return DayOfWeek::FRIDAY; } if (s == String(\"Sat\")) { return DayOfWeek::SATURDAY; } if (s == String(\"Sun\")) { return DayOfWeek::SUNDAY; } } Month convertMonth(String s) { if (s == String(\"Jan\")) { return Month::JANUARY; } if (s == String(\"Feb\")) { return Month::FEBRUARY; } if (s == String(\"Mar\")) { return Month::MARCH; } if (s == String(\"Apr\")) { return Month::APRIL; } if (s == String(\"May\")) { return Month::MAY; } if (s == String(\"Jun\")) { return Month::JUNE; } if (s == String(\"Jul\")) { return Month::JULY; } if (s == String(\"Aug\")) { return Month::AUGUST; } if (s == String(\"Sep\")) { return Month::SEPTEMBER; } if (s == String(\"Oct\")) { return Month::OCTOBER; } if (s == String(\"Nov\")) { return Month::NOVEMBER; } if (s == String(\"Dec\")) { return Month::DECEMBER; } } RTCTime currentRTCTime() { // Get a compilation timestamp of the format: Wed May 10 08:54:31 2023 // __TIMESTAMP__ is a GNU C extension macro // We can't use the standard macros __DATE__ and __TIME__ because they don't provide the day of the week String timeStamp = __TIMESTAMP__; // Extract the day of the week int pos1 = timeStamp.indexOf(\" \"); DayOfWeek dayOfWeek = convertDayOfWeek(timeStamp.substring(0, pos1)); // Extract the month ++pos1; int pos2 = timeStamp.indexOf(\" \", pos1); Month month = convertMonth(timeStamp.substring(pos1, pos2)); // Extract the day pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int day = timeStamp.substring(pos1, pos2).toInt(); // Extract the hour pos1 = ++pos2; pos2 = timeStamp.indexOf(\":\", pos1); int hour = timeStamp.substring(pos1, pos2).toInt(); // Extract the minute pos1 = ++pos2; pos2 = timeStamp.indexOf(\":\", pos1); int minute = timeStamp.substring(pos1, pos2).toInt(); // Extract the second pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int second = timeStamp.substring(pos1, pos2).toInt(); // Extract the year pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int year = timeStamp.substring(pos1, pos2).toInt(); return RTCTime(day, month, year, hour, minute, second, dayOfWeek, SaveLight::SAVING_TIME_INACTIVE); } void alarmCallback() { Serial.println(\"An alarm was triggered at:\"); RTCTime currentTime; RTC.getTime(currentTime); Serial.print(currentTime.getYear()); Serial.print(\"-\"); Serial.print(Month2int(currentTime.getMonth())); Serial.print(\"-\"); Serial.print(currentTime.getDayOfMonth()); Serial.print(\" \"); Serial.print(currentTime.getHour()); Serial.print(\":\"); Serial.print(currentTime.getMinutes()); Serial.print(\":\"); Serial.println(currentTime.getSeconds()); } void setup() { Serial.begin(9600); while (!Serial) ; // Initialize the RTC RTC.begin(); // Get the current date and time when the sketch is uploaded and set the RTC RTCTime timeToSet = currentRTCTime(); RTC.setTime(timeToSet); // Retrieve the date and time from the RTC and print them Serial.println(\"The RTC was just set to: \"); RTCTime currentTime; RTC.getTime(currentTime); Serial.print(currentTime.getYear()); Serial.print(\"-\"); Serial.print(Month2int(currentTime.getMonth())); Serial.print(\"-\"); Serial.print(currentTime.getDayOfMonth()); Serial.print(\" \"); Serial.print(currentTime.getHour()); Serial.print(\":\"); Serial.print(currentTime.getMinutes()); Serial.print(\":\"); Serial.println(currentTime.getSeconds()); // Create an alarm time with the seconds value set to zero RTCTime alarmTime; alarmTime.setSecond(0); // Tell the RTC to only match on the seconds value AlarmMatch alarmMatch; alarmMatch.addMatchSecond(); // Set the alarm callback function RTC.setAlarmCallback(alarmCallback, alarmTime, alarmMatch); } void loop() { } Video Demonstration 5.12.3 RTC_NTPSync Sketch Code /** * RTC_NTPSync * * This example shows how to set the RTC (Real Time Clock) on the Portenta C33 / UNO R4 WiFi * to the current date and time retrieved from an NTP server on the Internet (pool.ntp.org). * Then the current time from the RTC is printed to the Serial port. * * Instructions: * 1. Download the NTPClient library (https://github.com/arduino-libraries/NTPClient) through the Library Manager * 2. Change the WiFi credentials in the arduino_secrets.h file to match your WiFi network. * 3. Upload this sketch to Portenta C33 / UNO R4 WiFi. * 4. Open the Serial Monitor. * * Initial author: Sebastian Romero @sebromero * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" //Include the NTP library #include <NTPClient.h> #if defined(ARDUINO_PORTENTA_C33) #include <WiFiC3.h> #elif defined(ARDUINO_UNOWIFIR4) #include <WiFiS3.h> #endif #include <WiFiUdp.h> #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int wifiStatus = WL_IDLE_STATUS; WiFiUDP Udp; // A UDP instance to let us send and receive packets over UDP NTPClient timeClient(Udp); void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } void connectToWiFi(){ // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (wifiStatus != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: wifiStatus = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } Serial.println(\"Connected to WiFi\"); printWifiStatus(); } void setup(){ Serial.begin(9600); while (!Serial); connectToWiFi(); RTC.begin(); Serial.println(\"\\nStarting connection to server...\"); timeClient.begin(); timeClient.update(); // Get the current date and time from an NTP server and convert // it to UTC +2 by passing the time zone offset in hours. // You may change the time zone offset to your local one. auto timeZoneOffsetHours = 2; auto unixTime = timeClient.getEpochTime() + (timeZoneOffsetHours * 3600); Serial.print(\"Unix time = \"); Serial.println(unixTime); RTCTime timeToSet = RTCTime(unixTime); RTC.setTime(timeToSet); // Retrieve the date and time from the RTC and print them RTCTime currentTime; RTC.getTime(currentTime); Serial.println(\"The RTC was just set to: \" + String(currentTime)); } void loop(){} Video Demonstration 5.12.4 RTC_PeriodicExample Sketch Code /* * RTC_PeriodicExample * * This example demonstrates how to use the periodic callback functionality of the RTC * (Real Time Clock) on the Portenta C33. * * It blinks the built-in LED at progressively faster and slower rates repeatedly. * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" #define BLINK_DELAY 2000 // This is the callback function to be passed to RTC.setPeriodicCallback() void periodicCallback() { static bool ledState = false; if (ledState == true) { digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } ledState = !ledState; } void setup() { pinMode(LED_BUILTIN, OUTPUT); // Initialize the RTC RTC.begin(); // RTC.setTime() must be called for RTC.setPeriodicCallback to work, but it doesn't matter // what date and time it's set to RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE); RTC.setTime(mytime); } void loop() { RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N32_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC); delay(BLINK_DELAY); } Video Demonstration 5.12.5 Test_RTC Sketch Code /* Test RTC A test sketch showcasing all RTC showcasing various functionalities related to the RTC module, including setting the time, handling interrupts, and reading time values. Find the full UNO R4 WiFi RTC documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" // Define the interrupt pin for LED control during interrupts const int LED_ON_INTERRUPT = 22; // Callback function for periodic interrupt void periodic_cbk() { static bool clb_st = false; // Toggle the LED based on callback state if (clb_st) { digitalWrite(LED_ON_INTERRUPT, HIGH); } else { digitalWrite(LED_ON_INTERRUPT, LOW); } clb_st = !clb_st; // Toggle callback state // Print message indicating periodic interrupt Serial.println(\"PERIODIC INTERRUPT\"); } void alarm_cbk() { Serial.println(\"ALARM INTERRUPT\"); } // Callback function for alarm interrupt void setup() { // Initialize serial communication Serial.begin(9600); // Wait for serial connection while (!Serial) { } // Set LED pins as outputs pinMode(LED_BUILTIN, OUTPUT); pinMode(LED_ON_INTERRUPT, OUTPUT); // Initialize the RTC RTC.begin(); // Set a specific initial time (August 25, 2022, 14:37:00 Thursday) RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE); RTCTime savedTime; RTC.getTime(savedTime); // Set the initial time if RTC is not running if (!RTC.isRunning()) { if (savedTime.getYear() != 2000) { RTC.setTime(mytime); } else { RTC.setTime(savedTime); } } // Create an alarm time set to 35 seconds RTCTime alarmtime; alarmtime.setSecond(35); // Create an AlarmMatch object to match seconds AlarmMatch am; am.addMatchSecond(); // Set the periodic callback function to run once every 2 seconds if (!RTC.setPeriodicCallback(periodic_cbk, Period::ONCE_EVERY_2_SEC)) { Serial.println(\"ERROR: periodic callback not set\"); } // Set the alarm callback function with the alarm time and matching condition if (!RTC.setAlarmCallback(alarm_cbk, alarmtime, am)) { Serial.println(\"ERROR: alarm callback not set\"); } } void loop() { static bool status = false; RTCTime currenttime; // Check if RTC is running and print status if (status) { // Toggle LED and display RTC status if 'status' is true if (RTC.isRunning()) { Serial.println(\"RTC is running\"); } else { Serial.println(\"RTC is not running\"); } /* GET CURRENT TIME FROM RTC */ RTC.getTime(currenttime); /* PRINT CURRENT TIME on Serial */ Serial.print(\"Current time: \"); /* DATE */ Serial.print(currenttime.getDayOfMonth()); Serial.print(\"/\"); Serial.print(Month2int(currenttime.getMonth())); Serial.print(\"/\"); Serial.print(currenttime.getYear()); Serial.print(\" - \"); /* ORE:MINUTI:SECONDI */ Serial.print(currenttime.getHour()); Serial.print(\":\"); Serial.print(currenttime.getMinutes()); Serial.print(\":\"); Serial.println(currenttime.getSeconds()); digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } status = !status; delay(1000); } Video Demonstration Section 5.13: SD 5.13.1 CardInfo Sketch Code /* SD card test This example shows how use the utility libraries on which the' SD library is based in order to get info about your SD card. Very useful for testing a card when you're not sure whether its working or not. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila ** CS - depends on your SD card shield or module. Pin 4 used here for consistency with other Arduino examples created 28 Mar 2011 by Limor Fried modified 9 Apr 2012 by Tom Igoe */ // include the SD library: #include <SPI.h> #include <SD.h> // set up variables using the SD utility library functions: Sd2Card card; SdVolume volume; SdFile root; // change this to match your SD shield or module; // Arduino Ethernet shield: pin 4 // Adafruit SD shields and modules: pin 10 // Sparkfun SD shield: pin 8 // MKRZero SD: SDCARD_SS_PIN const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"\\nInitializing SD card...\"); // we'll use the initialization code from the utility libraries // since we're just testing if the card is working! if (!card.init(SPI_HALF_SPEED, chipSelect)) { Serial.println(\"initialization failed. Things to check:\"); Serial.println(\"* is a card inserted?\"); Serial.println(\"* is your wiring correct?\"); Serial.println(\"* did you change the chipSelect pin to match your shield or module?\"); while (1); } else { Serial.println(\"Wiring is correct and a card is present.\"); } // print the type of card Serial.println(); Serial.print(\"Card type: \"); switch (card.type()) { case SD_CARD_TYPE_SD1: Serial.println(\"SD1\"); break; case SD_CARD_TYPE_SD2: Serial.println(\"SD2\"); break; case SD_CARD_TYPE_SDHC: Serial.println(\"SDHC\"); break; default: Serial.println(\"Unknown\"); } // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32 if (!volume.init(card)) { Serial.println(\"Could not find FAT16/FAT32 partition.\\nMake sure you've formatted the card\"); while (1); } Serial.print(\"Clusters: \"); Serial.println(volume.clusterCount()); Serial.print(\"Blocks x Cluster: \"); Serial.println(volume.blocksPerCluster()); Serial.print(\"Total Blocks: \"); Serial.println(volume.blocksPerCluster() * volume.clusterCount()); Serial.println(); // print the type and size of the first FAT-type volume uint32_t volumesize; Serial.print(\"Volume type is: FAT\"); Serial.println(volume.fatType(), DEC); volumesize = volume.blocksPerCluster(); // clusters are collections of blocks volumesize *= volume.clusterCount(); // we'll have a lot of clusters volumesize /= 2; // SD card blocks are always 512 bytes (2 blocks are 1KB) Serial.print(\"Volume size (Kb): \"); Serial.println(volumesize); Serial.print(\"Volume size (Mb): \"); volumesize /= 1024; Serial.println(volumesize); Serial.print(\"Volume size (Gb): \"); Serial.println((float)volumesize / 1024.0); Serial.println(\"\\nFiles found on the card (name, date and size in bytes): \"); root.openRoot(volume); // list all files in the card with date and size root.ls(LS_R | LS_DATE | LS_SIZE); } void loop(void) { } Fritzing Circuit KiCad Schematic Video Demonstration 5.13.2 CardInfo Sketch Code /* SD card test This example shows how use the utility libraries on which the' SD library is based in order to get info about your SD card. Very useful for testing a card when you're not sure whether its working or not. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila ** CS - depends on your SD card shield or module. Pin 4 used here for consistency with other Arduino examples created 28 Mar 2011 by Limor Fried modified 9 Apr 2012 by Tom Igoe */ // include the SD library: #include <SPI.h> #include <SD.h> // set up variables using the SD utility library functions: Sd2Card card; SdVolume volume; SdFile root; // change this to match your SD shield or module; // Arduino Ethernet shield: pin 4 // Adafruit SD shields and modules: pin 10 // Sparkfun SD shield: pin 8 // MKRZero SD: SDCARD_SS_PIN const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"\\nInitializing SD card...\"); // we'll use the initialization code from the utility libraries // since we're just testing if the card is working! if (!card.init(SPI_HALF_SPEED, chipSelect)) { Serial.println(\"initialization failed. Things to check:\"); Serial.println(\"* is a card inserted?\"); Serial.println(\"* is your wiring correct?\"); Serial.println(\"* did you change the chipSelect pin to match your shield or module?\"); while (1); } else { Serial.println(\"Wiring is correct and a card is present.\"); } // print the type of card Serial.println(); Serial.print(\"Card type: \"); switch (card.type()) { case SD_CARD_TYPE_SD1: Serial.println(\"SD1\"); break; case SD_CARD_TYPE_SD2: Serial.println(\"SD2\"); break; case SD_CARD_TYPE_SDHC: Serial.println(\"SDHC\"); break; default: Serial.println(\"Unknown\"); } // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32 if (!volume.init(card)) { Serial.println(\"Could not find FAT16/FAT32 partition.\\nMake sure you've formatted the card\"); while (1); } Serial.print(\"Clusters: \"); Serial.println(volume.clusterCount()); Serial.print(\"Blocks x Cluster: \"); Serial.println(volume.blocksPerCluster()); Serial.print(\"Total Blocks: \"); Serial.println(volume.blocksPerCluster() * volume.clusterCount()); Serial.println(); // print the type and size of the first FAT-type volume uint32_t volumesize; Serial.print(\"Volume type is: FAT\"); Serial.println(volume.fatType(), DEC); volumesize = volume.blocksPerCluster(); // clusters are collections of blocks volumesize *= volume.clusterCount(); // we'll have a lot of clusters volumesize /= 2; // SD card blocks are always 512 bytes (2 blocks are 1KB) Serial.print(\"Volume size (Kb): \"); Serial.println(volumesize); Serial.print(\"Volume size (Mb): \"); volumesize /= 1024; Serial.println(volumesize); Serial.print(\"Volume size (Gb): \"); Serial.println((float)volumesize / 1024.0); Serial.println(\"\\nFiles found on the card (name, date and size in bytes): \"); root.openRoot(volume); // list all files in the card with date and size root.ls(LS_R | LS_DATE | LS_SIZE); } void loop(void) { } Fritzing Circuit KiCad Schematic Video Demonstration 5.13.3 Datalogger Sketch Code /* SD card datalogger This example shows how to log data from three analog sensors to an SD card using the SD library. The circuit: analog sensors on analog ins 0, 1, and 2 SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created 24 Nov 2010 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); // see if the card is present and can be initialized: if (!SD.begin(chipSelect)) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } Serial.println(\"card initialized.\"); } void loop() { // make a string for assembling the data to log: String dataString = \"\"; // read three sensors and append to the string: for (int analogPin = 0; analogPin < 3; analogPin++) { int sensor = analogRead(analogPin); dataString += String(sensor); if (analogPin < 2) { dataString += \",\"; } } // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. File dataFile = SD.open(\"datalog.txt\", FILE_WRITE); // if the file is available, write to it: if (dataFile) { dataFile.println(dataString); dataFile.close(); // print to the serial port too: Serial.println(dataString); } // if the file isn't open, pop up an error: else { Serial.println(\"error opening datalog.txt\"); } } Fritzing Circuit KiCad Schematic Video Demonstration 5.13.4 DumpFile Sketch Code /* SD card file dump This example shows how to read a file from the SD card using the SD library and send it over the serial port. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created 22 December 2010 by Limor Fried modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); // see if the card is present and can be initialized: if (!SD.begin(chipSelect)) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } Serial.println(\"card initialized.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. File dataFile = SD.open(\"datalog.txt\"); // if the file is available, write to it: if (dataFile) { while (dataFile.available()) { Serial.write(dataFile.read()); } dataFile.close(); } // if the file isn't open, pop up an error: else { Serial.println(\"error opening datalog.txt\"); } } void loop() { } Fritzing Circuit KiCad Schematic Video Demonstration 5.13.5 Files Sketch Code /* SD card basic file example This example shows how to create and destroy an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } // open a new file and immediately close it: Serial.println(\"Creating example.txt...\"); myFile = SD.open(\"example.txt\", FILE_WRITE); myFile.close(); // Check to see if the file exists: if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } // delete the file: Serial.println(\"Removing example.txt...\"); SD.remove(\"example.txt\"); if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } } void loop() { // nothing happens after setup finishes. } Fritzing Circuit KiCad Schematic Video Demonstration 5.13.6 NonBlockingWrite Sketch Code /* Non-blocking Write This example demonstrates how to perform non-blocking writes to a file on a SD card. The file will contain the current millis() value every 10ms. If the SD card is busy, the data will be buffered in order to not block the sketch. NOTE: myFile.availableForWrite() will automatically sync the file contents as needed. You may lose some unsynced data still if myFile.sync() or myFile.close() is not called. The circuit: - Arduino MKR Zero board - micro SD card attached This example code is in the public domain. */ #include <SD.h> // file name to use for writing const char filename[] = \"demo.txt\"; // File object to represent file File txtFile; // string to buffer output String buffer; unsigned long lastMillis = 0; void setup() { Serial.begin(9600); while (!Serial); // reserve 1kB for String used as a buffer buffer.reserve(1024); // set LED pin to output, used to blink when writing pinMode(LED_BUILTIN, OUTPUT); // init the SD card if (!SD.begin()) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } // If you want to start from an empty file, // uncomment the next line: // SD.remove(filename); // try to open the file for writing txtFile = SD.open(filename, FILE_WRITE); if (!txtFile) { Serial.print(\"error opening \"); Serial.println(filename); while (1); } // add some new lines to start txtFile.println(); txtFile.println(\"Hello World!\"); } void loop() { // check if it's been over 10 ms since the last line added unsigned long now = millis(); if ((now - lastMillis) >= 10) { // add a new line to the buffer buffer += \"Hello \"; buffer += now; buffer += \"\\r\\n\"; lastMillis = now; } // check if the SD card is available to write data without blocking // and if the buffered data is enough for the full chunk size unsigned int chunkSize = txtFile.availableForWrite(); if (chunkSize && buffer.length() >= chunkSize) { // write to file and blink LED digitalWrite(LED_BUILTIN, HIGH); txtFile.write(buffer.c_str(), chunkSize); digitalWrite(LED_BUILTIN, LOW); // remove written data from buffer buffer.remove(0, chunkSize); } } Fritzing Circuit KiCad Schematic Video Demonstration 5.13.7 ReadWrite Sketch Code /* SD card read/write This example shows how to read and write data to and from an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. myFile = SD.open(\"test.txt\", FILE_WRITE); // if the file opened okay, write to it: if (myFile) { Serial.print(\"Writing to test.txt...\"); myFile.println(\"testing 1, 2, 3.\"); // close the file: myFile.close(); Serial.println(\"done.\"); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } // re-open the file for reading: myFile = SD.open(\"test.txt\"); if (myFile) { Serial.println(\"test.txt:\"); // read from the file until there's nothing else in it: while (myFile.available()) { Serial.write(myFile.read()); } // close the file: myFile.close(); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } } void loop() { // nothing happens after setup } /* SD card read/write This example shows how to read and write data to and from an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. myFile = SD.open(\"test.txt\", FILE_WRITE); // if the file opened okay, write to it: if (myFile) { Serial.print(\"Writing to test.txt...\"); myFile.println(\"testing 1, 2, 3.\"); // close the file: myFile.close(); Serial.println(\"done.\"); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } // re-open the file for reading: myFile = SD.open(\"test.txt\"); if (myFile) { Serial.println(\"test.txt:\"); // read from the file until there's nothing else in it: while (myFile.available()) { Serial.write(myFile.read()); } // close the file: myFile.close(); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } } void loop() { // nothing happens after setup } Fritzing Circuit KiCad Schematic Video Demonstration Section 5.14: SDU 5.14.1 Usage Sketch Code /* Usage This example demonstrates how to use the UNO R4 SDU library to update a sketch on an Arduino UNO R4 (WiFi, Minima) board using an SD card. It prints out the date and time the sketch was compiled at to both Serial and Serial1. Circuit: * Arduino UNO R4 Minima or WiFi board * SD shield or breakout connected with CS pin of 4 * SD card Non-Arduino UNO R4 board are NOT supported. Steps to update sketch via SD card: 1) Upload this sketch or another sketch that includes the SDU library via #include <SDU.h> 2) Update the sketch as desired. For this example the sketch prints out the compiled date and time so no updates are needed. 3) In the IDE select: Sketch -> Export Compiled Binary 4) Copy the .bin file from the sketch's folder to the SD card and rename the file to UPDATE.bin. Eject the SD card from your PC. 5) Insert the SD card into the board, shield or breakout and press the reset button or power cycle the board. The SDU library will then update the sketch on the board with the contents of UPDATE.bin created 23 March 2017 by Sandeep Mistry */ /* Include the SDU library This will add some code to the sketch before setup() is called to check if an SD card is present and UPDATE.bin exists on the SD card. If UPDATE.bin is present, the file is used to update the sketch running on the board. After this UPDATE.bin is deleted from the SD card. */ #include <SDU.h> String message; void setup() { Serial.begin(115200); // Wait for Serial Monitor connection while (!Serial.available()) { Serial.println(\"Send any key.\"); delay(1000); } message += \"Sketch compile date and time: \"; message += __DATE__; message += \" \"; message += __TIME__; // print out the sketch compile date and time on the serial port Serial.println(message); } void loop() { // add you own code here } Fritzing Circuit KiCad Schematic Video Demonstration Section 5.15: Servo 5.15.1 Knob Sketch Code /* Controlling a servo position using a potentiometer (variable resistor) by Michal Rinott <http://people.interaction-ivrea.it/m.rinott> modified on 8 Nov 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/Knob */ #include <Servo.h> Servo myservo; // create servo object to control a servo int potpin = A0; // analog pin used to connect the potentiometer int val; // variable to read the value from the analog pin void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { val = analogRead(potpin); // reads the value of the potentiometer (value between 0 and 1023) val = map(val, 0, 1023, 0, 180); // scale it for use with the servo (value between 0 and 180) myservo.write(val); // sets the servo position according to the scaled value delay(15); // waits for the servo to get there } Fritzing Circuit KiCad Schematic Video Demonstration 5.15.2 Sweep Sketch Code /* Sweep by BARRAGAN <http://barraganstudio.com> This example code is in the public domain. modified 8 Nov 2013 by Scott Fitzgerald https://www.arduino.cc/en/Tutorial/LibraryExamples/Sweep */ #include <Servo.h> Servo myservo; // create servo object to control a servo // twelve servo objects can be created on most boards int pos = 0; // variable to store the servo position void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { for (pos = 0; pos <= 180; pos += 1) { // goes from 0 degrees to 180 degrees // in steps of 1 degree myservo.write(pos); // tell servo to go to position in variable 'pos' delay(15); // waits 15 ms for the servo to reach the position } for (pos = 180; pos >= 0; pos -= 1) { // goes from 180 degrees to 0 degrees myservo.write(pos); // tell servo to go to position in variable 'pos' delay(15); // waits 15 ms for the servo to reach the position } } Fritzing Circuit KiCad Schematic Video Demonstration Section 5.16: SoftwareSerial 5.16.1 SerialEcho Sketch Code #include <SoftwareSerial.h> // Note any pin can be used for TX, but only the following pins // can be used for RX: // D0, D1, D2, D3, D8, D14, D15, A1, A2, A3, A4, A5 SoftwareSerial SoftSerial(2, 7); // Rx, Tx void setup() { Serial.begin(9600); while (!Serial) { } if (!SoftSerial.begin(115200, SERIAL_8E2)) { Serial.println(\"Failed to init soft serial\"); while (1); } Serial.println(SoftSerial); } void loop() { // run over and over while (SoftSerial.available()) { SoftSerial.write(SoftSerial.read()); } } Fritzing Circuit KiCad Schematic Video Demonstration Section 5.17: Stepper 5.17.1 MotorKnob Sketch Code /* * MotorKnob * * A stepper motor follows the turns of a potentiometer * (or other sensor) on analog input 0. * * http://www.arduino.cc/en/Reference/Stepper * This example code is in the public domain. */ #include <Stepper.h> // change this to the number of steps on your motor #define STEPS 100 // create an instance of the stepper class, specifying // the number of steps of the motor and the pins it's // attached to Stepper stepper(STEPS, 8, 9, 10, 11); // the previous reading from the analog input int previous = 0; void setup() { // set the speed of the motor to 30 RPMs stepper.setSpeed(30); } void loop() { // get the sensor value int val = analogRead(0); // move a number of steps equal to the change in the // sensor reading stepper.step(val - previous); // remember the previous value of the sensor previous = val; } Fritzing Circuit KiCad Schematic Video Demonstration 5.17.2 stepper_oneRevolution Sketch Code /* Stepper Motor Control - one revolution This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. The motor should revolve one revolution in one direction, then one revolution in the other direction. Created 11 Mar. 2007 Modified 30 Nov. 2009 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper.setSpeed(60); // initialize the serial port: Serial.begin(9600); } void loop() { // step one revolution in one direction: Serial.println(\"clockwise\"); myStepper.step(stepsPerRevolution); delay(500); // step one revolution in the other direction: Serial.println(\"counterclockwise\"); myStepper.step(-stepsPerRevolution); delay(500); } Fritzing Circuit KiCad Schematic Video Demonstration 5.17.3 stepper_oneStepAtATime Sketch Code /* Stepper Motor Control - one step at a time This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. The motor will step one step at a time, very slowly. You can use this to test that you've got the four wires of your stepper wired to the correct pins. If wired correctly, all steps should be in the same direction. Use this also to count the number of steps per revolution of your motor, if you don't know it. Then plug that number into the oneRevolution example to see if you got it right. Created 30 Nov. 2009 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); int stepCount = 0; // number of steps the motor has taken void setup() { // initialize the serial port: Serial.begin(9600); } void loop() { // step one step: myStepper.step(1); Serial.print(\"steps:\"); Serial.println(stepCount); stepCount++; delay(500); } Fritzing Circuit KiCad Schematic Video Demonstration 5.17.4 stepper_speedControl Sketch Code /* Stepper Motor Control - speed control This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. A potentiometer is connected to analog input 0. The motor will rotate in a clockwise direction. The higher the potentiometer value, the faster the motor speed. Because setSpeed() sets the delay between steps, you may notice the motor is less responsive to changes in the sensor value at low speeds. Created 30 Nov. 2009 Modified 28 Oct 2010 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); int stepCount = 0; // number of steps the motor has taken void setup() { // nothing to do inside the setup } void loop() { // read the sensor value: int sensorReading = analogRead(A0); // map it to a range from 0 to 100: int motorSpeed = map(sensorReading, 0, 1023, 0, 100); // set the motor speed: if (motorSpeed > 0) { myStepper.setSpeed(motorSpeed); // step 1/100 of a revolution: myStepper.step(stepsPerRevolution / 100); } } Fritzing Circuit KiCad Schematic Video Demonstration Section 5.18: TFT 5.18.1 TFTBitmapLogo Sketch Code /* Arduino TFT Bitmap Logo example This example reads an image file from a micro-SD card and draws it on the screen, at random locations. In this sketch, the Arduino logo is read from a micro-SD card. There is a .bmp file included with this sketch. - open the sketch folder (Ctrl-K or Cmd-K) - copy the \"arduino.bmp\" file to a micro-SD - put the SD into the SD slot of the Arduino TFT module. This example code is in the public domain. Created 19 April 2013 by Enrico Gueli http://www.arduino.cc/en/Tutorial/TFTBitmapLogo */ // include the necessary libraries #include <SPI.h> #include <SD.h> #include <TFT.h> // Arduino LCD library // pin definition for the Uno #define sd_cs 4 #define lcd_cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo //#define sd_cs 8 //#define lcd_cs 7 //#define dc 0 //#define rst 1 TFT TFTscreen = TFT(lcd_cs, dc, rst); // this variable represents the image to be drawn on screen PImage logo; void setup() { // initialize the GLCD and show a message // asking the user to open the serial line TFTscreen.begin(); TFTscreen.background(255, 255, 255); TFTscreen.stroke(0, 0, 255); TFTscreen.println(); TFTscreen.println(F(\"Arduino TFT Bitmap Example\")); TFTscreen.stroke(0, 0, 0); TFTscreen.println(F(\"Open serial monitor\")); TFTscreen.println(F(\"to run the sketch\")); // initialize the serial port: it will be used to // print some diagnostic info Serial.begin(9600); while (!Serial) { // wait for serial port to connect. Needed for native USB port only } // clear the GLCD screen before starting TFTscreen.background(255, 255, 255); // try to access the SD card. If that fails (e.g. // no card present), the setup process will stop. Serial.print(F(\"Initializing SD card...\")); if (!SD.begin(sd_cs)) { Serial.println(F(\"failed!\")); return; } Serial.println(F(\"OK!\")); // initialize and clear the GLCD screen TFTscreen.begin(); TFTscreen.background(255, 255, 255); // now that the SD card can be access, try to load the // image file. logo = TFTscreen.loadImage(\"arduino.bmp\"); if (!logo.isValid()) { Serial.println(F(\"error while loading arduino.bmp\")); } } void loop() { // don't do anything if the image wasn't loaded correctly. if (logo.isValid() == false) { return; } Serial.println(F(\"drawing image\")); // get a random location where to draw the image. // To avoid the image to be draw outside the screen, // take into account the image size. int x = random(TFTscreen.width() - logo.width()); int y = random(TFTscreen.height() - logo.height()); // draw the image to the screen TFTscreen.image(logo, x, y); // wait a little bit before drawing again delay(1500); } Fritzing Circuit KiCad Schematic Video Demonstration 5.18.2 TFTColorPicker Sketch Code /* TFT Color Picker This example for the Arduino screen reads the input of potentiometers or analog sensors attached to A0, A1, and A2 and uses the values to change the screen's color. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTColorPicker */ // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 #include <TFT.h> // Arduino LCD library #include <SPI.h> TFT TFTscreen = TFT(cs, dc, rst); void setup() { // begin serial communication Serial.begin(9600); // initialize the display TFTscreen.begin(); // set the background to white TFTscreen.background(255, 255, 255); } void loop() { // read the values from your sensors and scale them to 0-255 int redVal = map(analogRead(A0), 0, 1023, 0, 255); int greenVal = map(analogRead(A1), 0, 1023, 0, 255); int blueVal = map(analogRead(A2), 0, 1023, 0, 255); // draw the background based on the mapped values TFTscreen.background(redVal, greenVal, blueVal); // send the values to the serial monitor Serial.print(\"background(\"); Serial.print(redVal); Serial.print(\" , \"); Serial.print(greenVal); Serial.print(\" , \"); Serial.print(blueVal); Serial.println(\")\"); // wait for a moment delay(33); } Fritzing Circuit KiCad Schematic Video Demonstration 5.18.3 TFTDisplayText Sketch Code /* Arduino TFT text example This example demonstrates how to draw text on the TFT with an Arduino. The Arduino reads the value of an analog sensor attached to pin A0, and writes the value to the LCD screen, updating every quarter second. This example code is in the public domain Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTDisplayText */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 // create an instance of the library TFT TFTscreen = TFT(cs, dc, rst); // char array to print to the screen char sensorPrintout[4]; void setup() { // Put this line at the beginning of every sketch that uses the GLCD: TFTscreen.begin(); // clear the screen with a black background TFTscreen.background(0, 0, 0); // write the static text to the screen // set the font color to white TFTscreen.stroke(255, 255, 255); // set the font size TFTscreen.setTextSize(2); // write the text to the top left corner of the screen TFTscreen.text(\"Sensor Value :\\n \", 0, 0); // ste the font size very large for the loop TFTscreen.setTextSize(5); } void loop() { // Read the value of the sensor on A0 String sensorVal = String(analogRead(A0)); // convert the reading to a char array sensorVal.toCharArray(sensorPrintout, 4); // set the font color TFTscreen.stroke(255, 255, 255); // print the sensor value TFTscreen.text(sensorPrintout, 0, 20); // wait for a moment delay(250); // erase the text you just wrote TFTscreen.stroke(0, 0, 0); TFTscreen.text(sensorPrintout, 0, 20); } Fritzing Circuit KiCad Schematic Video Demonstration 5.18.4 TFTEtchAsketch Sketch Code /* TFT EtchASketch This example for the Arduino screen draws a white point on the GLCD based on the values of 2 potentiometers. To clear the screen, press a button attached to pin 2. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTEtchASketch */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // initial position of the cursor int xPos = TFTscreen.width() / 2; int yPos = TFTscreen.height() / 2; // pin the erase switch is connected to int erasePin = 2; void setup() { // declare inputs pinMode(erasePin, INPUT); // initialize the screen TFTscreen.begin(); // make the background black TFTscreen.background(0, 0, 0); } void loop() { // read the potentiometers on A0 and A1 int xValue = analogRead(A0); int yValue = analogRead(A1); // map the values and update the position xPos = xPos + (map(xValue, 0, 1023, 2, -2)); yPos = yPos + (map(yValue, 0, 1023, -2, 2)); // don't let the point go past the screen edges if (xPos > 159) { (xPos = 159); } if (xPos < 0) { (xPos = 0); } if (yPos > 127) { (yPos = 127); } if (yPos < 0) { (yPos = 0); } // draw the point TFTscreen.stroke(255, 255, 255); TFTscreen.point(xPos, yPos); // read the value of the pin, and erase the screen if pressed if (digitalRead(erasePin) == HIGH) { TFTscreen.background(0, 0, 0); } delay(33); } Fritzing Circuit KiCad Schematic Video Demonstration 5.18.5 TFTGraph Sketch Code /* TFT Graph This example for an Arduino screen reads the value of an analog sensor on A0, and graphs the values on the screen. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTGraph */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // position of the line on screen int xPos = 0; void setup() { // initialize the serial port Serial.begin(9600); // initialize the display TFTscreen.begin(); // clear the screen with a pretty color TFTscreen.background(250, 16, 200); } void loop() { // read the sensor and map it to the screen height int sensor = analogRead(A0); int drawHeight = map(sensor, 0, 1023, 0, TFTscreen.height()); // print out the height to the serial monitor Serial.println(drawHeight); // draw a line in a nice color TFTscreen.stroke(250, 180, 10); TFTscreen.line(xPos, TFTscreen.height() - drawHeight, xPos, TFTscreen.height()); // if the graph has reached the screen edge // erase the screen and start again if (xPos >= 160) { xPos = 0; TFTscreen.background(250, 16, 200); } else { // increment the horizontal position: xPos++; } delay(16); } Fritzing Circuit KiCad Schematic Video Demonstration 5.18.6 TFTPong Sketch Code /* TFT Pong This example for the Arduino screen reads the values of 2 potentiometers to move a rectangular platform on the x and y axes. The platform can intersect with a ball causing it to bounce. This example code is in the public domain. Created by Tom Igoe December 2012 Modified 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTPong */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // variables for the position of the ball and paddle int paddleX = 0; int paddleY = 0; int oldPaddleX, oldPaddleY; int ballDirectionX = 1; int ballDirectionY = 1; int ballSpeed = 10; // lower numbers are faster int ballX, ballY, oldBallX, oldBallY; void setup() { // initialize the display TFTscreen.begin(); // black background TFTscreen.background(0, 0, 0); } void loop() { // save the width and height of the screen int myWidth = TFTscreen.width(); int myHeight = TFTscreen.height(); // map the paddle's location to the position of the potentiometers paddleX = map(analogRead(A0), 512, -512, 0, myWidth) - 20 / 2; paddleY = map(analogRead(A1), 512, -512, 0, myHeight) - 5 / 2; // set the fill color to black and erase the previous // position of the paddle if different from present TFTscreen.fill(0, 0, 0); if (oldPaddleX != paddleX || oldPaddleY != paddleY) { TFTscreen.rect(oldPaddleX, oldPaddleY, 20, 5); } // draw the paddle on screen, save the current position // as the previous. TFTscreen.fill(255, 255, 255); TFTscreen.rect(paddleX, paddleY, 20, 5); oldPaddleX = paddleX; oldPaddleY = paddleY; // update the ball's position and draw it on screen if (millis() % ballSpeed < 2) { moveBall(); } } // this function determines the ball's position on screen void moveBall() { // if the ball goes offscreen, reverse the direction: if (ballX > TFTscreen.width() || ballX < 0) { ballDirectionX = -ballDirectionX; } if (ballY > TFTscreen.height() || ballY < 0) { ballDirectionY = -ballDirectionY; } // check if the ball and the paddle occupy the same space on screen if (inPaddle(ballX, ballY, paddleX, paddleY, 20, 5)) { ballDirectionX = -ballDirectionX; ballDirectionY = -ballDirectionY; } // update the ball's position ballX += ballDirectionX; ballY += ballDirectionY; // erase the ball's previous position TFTscreen.fill(0, 0, 0); if (oldBallX != ballX || oldBallY != ballY) { TFTscreen.rect(oldBallX, oldBallY, 5, 5); } // draw the ball's current position TFTscreen.fill(255, 255, 255); TFTscreen.rect(ballX, ballY, 5, 5); oldBallX = ballX; oldBallY = ballY; } // this function checks the position of the ball // to see if it intersects with the paddle boolean inPaddle(int x, int y, int rectX, int rectY, int rectWidth, int rectHeight) { boolean result = false; if ((x >= rectX && x <= (rectX + rectWidth)) && (y >= rectY && y <= (rectY + rectHeight))) { result = true; } return result; } Fritzing Circuit KiCad Schematic Video Demonstration Note Esplora is ALREADY retired . Section 5.19: WDT Note No additional circuit is required for this section 5.19 . 5.19.1 WatchdogRefresh Sketch Code /* Watchdog Refresh This sketch shows how to enable the watchdog and refresh the timer to avoid resets Watchdog intervals are limited to 7 timeout periods the library will select the best clock divisor and timeout according to the selected wdtInterval. UNO R4 min wdtInterval 1ms / max wdtInterval 5592ms Comment out Serial.print() in the setup to make it work with small intervals Portenta C33 min wdtInterval 1ms / max wdtInterval 2684ms Circuit: - Portenta C33 - UNO R4 */ #include <WDT.h> const long ledInterval = 1000; unsigned long ledMillis = 0; bool ledState = true; const long wdtInterval = 2684; unsigned long wdtMillis = 0; void setup() { Serial.begin(9600); while (!Serial); pinMode(LED_BUILTIN, OUTPUT); if(wdtInterval < 1) { Serial.println(\"Invalid watchdog interval\"); while(1){} } if(WDT.begin(wdtInterval)) { Serial.print(\"WDT interval: \"); WDT.refresh(); Serial.print(WDT.getTimeout()); WDT.refresh(); Serial.println(\" ms\"); WDT.refresh(); } else { Serial.println(\"Error initializing watchdog\"); while(1){} } } void loop() { if(millis() - ledMillis >= ledInterval) { digitalWrite(LED_BUILTIN, ledState); ledState = !ledState; ledMillis = millis(); } if(millis() - wdtMillis >= wdtInterval - 1) { WDT.refresh(); // Comment this line to stop refreshing the watchdog wdtMillis = millis(); } } Fritzing Circuit KiCad Schematic Video Demonstration Section 5.20: WiFiS3 Note No additional circuit is required for this section 5.20 . 5.20.1 AP_SimpleWebServer Sketch Code /* WiFi Web Server LED Blink A simple web server that lets you blink an LED via the web. This sketch will create a new access point (with no password). It will then launch a new server and print out the IP address to the Serial Monitor. From there, you can open that address in a web browser to turn on and off the LED on pin 13. If the IP address of your board is yourAddress: http://yourAddress/H turns the LED on http://yourAddress/L turns it off created 25 Nov 2012 by Tom Igoe adapted to WiFi AP by Adafruit Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#access-point */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int led = LED_BUILTIN; int status = WL_IDLE_STATUS; WiFiServer server(80); void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"Access Point Web Server\"); pinMode(led, OUTPUT); // set the LED pin mode // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // by default the local IP address will be 192.168.4.1 // you can override it with the following: WiFi.config(IPAddress(192,48,56,2)); // print the network name (SSID); Serial.print(\"Creating access point named: \"); Serial.println(ssid); // Create open network. Change this line if you want to create an WEP network: status = WiFi.beginAP(ssid, pass); if (status != WL_AP_LISTENING) { Serial.println(\"Creating access point failed\"); // don't continue while (true); } // wait 10 seconds for connection: delay(10000); // start the web server on port 80 server.begin(); // you're connected now, so print out the status printWiFiStatus(); } void loop() { // compare the previous status to the current status if (status != WiFi.status()) { // it has changed update the variable status = WiFi.status(); if (status == WL_AP_CONNECTED) { // a device has connected to the AP Serial.println(\"Device connected to AP\"); } else { // a device has disconnected from the AP, and we are back in listening mode Serial.println(\"Device disconnected from AP\"); } } WiFiClient client = server.available(); // listen for incoming clients if (client) { // if you get a client, Serial.println(\"new client\"); // print a message out the serial port String currentLine = \"\"; // make a String to hold incoming data from the client while (client.connected()) { // loop while the client's connected delayMicroseconds(10); // This is required for the Arduino Nano RP2040 Connect - otherwise it will loop so fast that SPI will never be served. if (client.available()) { // if there's bytes to read from the client, char c = client.read(); // read a byte, then Serial.write(c); // print it out to the serial monitor if (c == '\\n') { // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that's the end of the client HTTP request, so send a response: if (currentLine.length() == 0) { // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what's coming, then a blank line: client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-type:text/html\"); client.println(); // the content of the HTTP response follows the header: client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/H\\\">here</a> turn the LED on<br></p>\"); client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/L\\\">here</a> turn the LED off<br></p>\"); // The HTTP response ends with another blank line: client.println(); // break out of the while loop: break; } else { // if you got a newline, then clear currentLine: currentLine = \"\"; } } else if (c != '\\r') { // if you got anything else but a carriage return character, currentLine += c; // add it to the end of the currentLine } // Check to see if the client request was \"GET /H\" or \"GET /L\": if (currentLine.endsWith(\"GET /H\")) { digitalWrite(led, HIGH); // GET /H turns the LED on } if (currentLine.endsWith(\"GET /L\")) { digitalWrite(led, LOW); // GET /L turns the LED off } } } // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } void printWiFiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your WiFi shield's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print where to go in a browser: Serial.print(\"To see this page in action, open a browser to http://\"); Serial.println(ip); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Chapter 5 - Examples for Arduino UNO R4 Wifi"},{"location":"05_examples_uno_r4_wifi/#chapter-5-arduino-build-in-examples","text":"","title":"Chapter 5: Arduino Build-in Examples"},{"location":"05_examples_uno_r4_wifi/#section-51-analogwave","text":"Note All 3 examples under this section 5.1 are sharing the same Fritzing Circuit and KiCad Schematic .","title":"Section 5.1: AnalogWave"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#511-dacequaltemperedscale","text":"","title":"5.1.1 DACEqualTemperedScale"},{"location":"05_examples_uno_r4_wifi/#sketch-code","text":"/* Plays a tone in response to a potentiometer formula from https://newt.phys.unsw.edu.au/jw/notes.html and https://en.wikipedia.org/wiki/MIDI_tuning_standard: the MIDI protocol divides the notes of an equal-tempered scale into 128 possible note values. Middle A is MIDI note value 69. There is a formula for converting MIDI note numbers (0-127) to pitches. This sketch reduces that to the notes 21 - 108, which are the 88 keys found on a piano: frequency = 440 * ((noteNumber - 69) / 12.0)^2 You can see this applied in the code below. circuit: * audio amp (LM386 used for testing) input+ attached to A0 * audio amp input- attached to ground * 4-8-ohm speaker attached to amp output+ * Potentiometer connected to pin A5 created 18 Dec 2018 modified 3 Jul 2023 by Tom Igoe See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ // include the AnalogWave library: #include \"analogWave.h\" analogWave wave(DAC); // middle A is the reference frequency for an // equal-tempered scale. Set its frequency and note value: #define NOTE_A4 69 // MIDI note value for middle A #define FREQ_A4 440 // frequency for middle A const int speakerPin = A0; // the pin number for the speaker void setup() { Serial.begin(9600); wave.sine(10); } void loop() { // convert sensor reading to 21 - 108 range // which is the range of MIDI notes on an 88-key keyboard // (from A0 to C8): int sensorReading = analogRead(A5); int noteValue = map(sensorReading, 0, 1023, 21, 108); // then convert to frequency: float frequency = FREQ_A4 * pow(2, ((noteValue - NOTE_A4) / 12.0)); int freq = int(frequency); // turn the speaker on: wave.freq(freq); Serial.print(\"note value: \"+ String(noteValue) + \" freq: \"); Serial.println(freq); delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#512-dacjacques","text":"","title":"5.1.2 DACJacques"},{"location":"05_examples_uno_r4_wifi/#sketch-code_1","text":"/* DAC Melody player Generates a series of tones from MIDI note values using the Uno R4 DAC and the AnalogWave Library. The melody is \"Frere Jacques\" circuit: * audio amp (LM386 used for testing) input+ attached to A0 * audio amp input- attached to ground * 4-8-ohm speaker attached to amp output+ * Potentiometer connected to pin A5 created 13 Feb 2017 modified 3 Jul 2023 by Tom Igoe See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ #include \"analogWave.h\" analogWave wave(DAC); #define NOTE_A4 69 // MIDI note value for middle A #define FREQ_A4 440 // frequency for middle A // the tonic, or first note of the key signature for the song: int tonic = 65; // the melody sequence. Note values are relative to the tonic: int melody[] = {1, 3, 5, 1, 1, 3, 5, 1, 5, 6, 8, 5, 6, 8, 8, 10, 8, 6, 5, 1, 8, 10, 8, 6, 5, 1, 1, -4, 1, 1, -4, 1 }; // the rhythm sequence. Values are 1/note, e.g. 4 = 1/4 note: int rhythm[] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 2, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 4, 4, 4, 4, 2, 4, 4, 2 }; // which note of the melody to play: int noteCounter = 0; int bpm = 120; // beats per minute // duration of a beat in ms float beatDuration = 60.0 / bpm * 1000; void setup() { // start the sine wave generator: wave.sine(10); } void loop() { // current note is an element of the array: int currentNote = melody[noteCounter] + tonic; // play a note from the melody: // convert MIDI note number to frequency: float frequency = FREQ_A4 * pow(2, ((currentNote - NOTE_A4) / 12.0)); // all the notes in this are sixteenth notes, // which is 1/4 of a beat, so: float noteDuration = beatDuration * (4.0 / rhythm[noteCounter]); // turn the note on: wave.freq(frequency); // tone(speakerPin, frequency, noteDuration * 0.85); // keep it on for the appropriate duration: delay(noteDuration * 0.85); wave.stop(); delay(noteDuration * 0.15); // turn the note off: // noTone(speakerPin); // increment the note number for next time through the loop: noteCounter++; // keep the note in the range from 0 - 32 using modulo: noteCounter = noteCounter % 32; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_1","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#513-sinewave","text":"","title":"5.1.3 SineWave"},{"location":"05_examples_uno_r4_wifi/#sketch-code_2","text":"/* SineWave Generates a pre-generated sawtooth-waveform. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ #include \"analogWave.h\" // Include the library for analog waveform generation analogWave wave(DAC); // Create an instance of the analogWave class, using the DAC pin int freq = 10; // in hertz, change accordingly void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 wave.sine(freq); // Generate a sine wave with the initial frequency } void loop() { // Read an analog value from pin A5 and map it to a frequency range freq = map(analogRead(A5), 0, 1024, 0, 10000); // Print the updated frequency to the serial monitor Serial.println(\"Frequency is now \" + String(freq) + \" hz\"); wave.freq(freq); // Set the frequency of the waveform generator to the updated value delay(1000); // Delay for one second before repeating }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_2","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-52-arduino_can","text":"Note CAN1 is only available on Portenta C33 , which is to be ignored in this section.","title":"Section 5.2: Arduino_CAN"},{"location":"05_examples_uno_r4_wifi/#521-canread","text":"","title":"5.2.1 CANRead"},{"location":"05_examples_uno_r4_wifi/#sketch-code_3","text":"/* CANRead Receive and read CAN Bus messages See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/can */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } if (!CAN.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } void loop() { if (CAN.available()) { CanMsg const msg = CAN.read(); Serial.println(msg); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_1","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_1","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_3","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#522-canwrite","text":"","title":"5.2.2 CANWrite"},{"location":"05_examples_uno_r4_wifi/#sketch-code_4","text":"/* CANWrite Write and send CAN Bus messages See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/can */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * CONSTANTS **************************************************************************************/ static uint32_t const CAN_ID = 0x20; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } if (!CAN.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } static uint32_t msg_cnt = 0; void loop() { /* Assemble a CAN message with the format of * 0xCA 0xFE 0x00 0x00 [4 byte message counter] */ uint8_t const msg_data[] = {0xCA,0xFE,0,0,0,0,0,0}; memcpy((void *)(msg_data + 4), &msg_cnt, sizeof(msg_cnt)); CanMsg const msg(CanStandardId(CAN_ID), sizeof(msg_data), msg_data); /* Transmit the CAN message, capture and display an * error core in case of failure. */ if (int const rc = CAN.write(msg); rc < 0) { Serial.print (\"CAN.write(...) failed with error code \"); Serial.println(rc); for (;;) { } } /* Increase the message counter. */ msg_cnt++; /* Only send one message per second. */ delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_2","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_2","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_4","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-53-arduino_freertos","text":"Note No additional circuit is required for this section 5.3 .","title":"Section 5.3: Arduino_FreeRTOS"},{"location":"05_examples_uno_r4_wifi/#531-freertos-blink","text":"","title":"5.3.1 FreeRTOS-Blink"},{"location":"05_examples_uno_r4_wifi/#sketch-code_5","text":"/* The code demonstrates the usage of FreeRTOS (Real-Time Operating System) to run concurrent tasks. One task is responsible for running the loop() logic (in a thread-safe manner), while the other task blinks an LED using the built-in LED on non-Portenta boards or the RGB LED on the Portenta C33 board. */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_FreeRTOS.h> /************************************************************************************** * GLOBAL VARIABLES **************************************************************************************/ TaskHandle_t loop_task, blinky_task; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } #if defined(ARDUINO_PORTENTA_C33) /* Only the Portenta C33 has an RGB LED. */ pinMode(LEDR, OUTPUT); digitalWrite(LEDR, LOW); #endif /* Init a task that calls 'loop' * since after the call to * 'vTaskStartScheduler' we'll never * get out of setup() and therefore * would never get to loop(), as we * are leaving the default execution * flow. */ auto const rc_loop = xTaskCreate ( loop_thread_func, static_cast<const char*>(\"Loop Thread\"), 512 / 4, /* usStackDepth in words */ nullptr, /* pvParameters */ 1, /* uxPriority */ &loop_task /* pxCreatedTask */ ); if (rc_loop != pdPASS) { Serial.println(\"Failed to create 'loop' thread\"); return; } auto const rc_blinky = xTaskCreate ( blinky_thread_func, static_cast<const char*>(\"Blinky Thread\"), 512 / 4, /* usStackDepth in words */ nullptr, /* pvParameters */ 1, /* uxPriority */ &blinky_task /* pxCreatedTask */ ); if (rc_blinky != pdPASS) { Serial.println(\"Failed to create 'loop' thread\"); return; } Serial.println(\"Starting scheduler ...\"); /* Start the scheduler. */ vTaskStartScheduler(); /* We'll never get here. */ for( ;; ); } void loop() { #if defined(ARDUINO_PORTENTA_C33) /* Only the Portenta C33 has an RGB LED. */ digitalWrite(LEDR, !digitalRead(LEDR)); #else Serial.println(millis()); #endif vTaskDelay(configTICK_RATE_HZ/4); } void loop_thread_func(void *pvParameters) { for(;;) { loop(); taskYIELD(); } } void blinky_thread_func(void *pvParameters) { /* setup() */ pinMode(LED_BUILTIN, OUTPUT); digitalWrite(LED_BUILTIN, LOW); /* loop() */ for(;;) { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); vTaskDelay(configTICK_RATE_HZ); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_5","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-54-eeprom","text":"Note No additional circuit is required for this section 5.4 .","title":"Section 5.4: EEPROM"},{"location":"05_examples_uno_r4_wifi/#541-eeprom_clear","text":"","title":"5.4.1 eeprom_clear"},{"location":"05_examples_uno_r4_wifi/#sketch-code_6","text":"/* * EEPROM Clear * * Sets all of the bytes of the EEPROM to 0. * Please see eeprom_iteration for a more in depth * look at how to traverse the EEPROM. * * This example code is in the public domain. */ #include <EEPROM.h> void setup() { // initialize the LED pin as an output. pinMode(13, OUTPUT); /*** Iterate through each byte of the EEPROM storage. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ for (int i = 0 ; i < EEPROM.length() ; i++) { EEPROM.write(i, 0); } // turn the LED on when we're done digitalWrite(13, HIGH); } void loop() { /** Empty loop. **/ }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_6","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#542-eeprom_crc","text":"","title":"5.4.2 eeprom_crc"},{"location":"05_examples_uno_r4_wifi/#sketch-code_7","text":"/*** Written by Christopher Andrews. CRC algorithm generated by pycrc, MIT licence ( https://github.com/tpircher/pycrc ). A CRC is a simple way of checking whether data has changed or become corrupted. This example calculates a CRC value directly on the EEPROM values. The purpose of this example is to highlight how the EEPROM object can be used just like an array. ***/ #include <Arduino.h> #include <EEPROM.h> void setup() { //Start serial Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } //Print length of data to run CRC on. Serial.print(\"EEPROM length: \"); Serial.println(EEPROM.length()); //Print the result of calling eeprom_crc() Serial.print(\"CRC32 of EEPROM data: 0x\"); Serial.println(eeprom_crc(), HEX); Serial.print(\"\\n\\nDone!\"); } void loop() { /* Empty loop */ } unsigned long eeprom_crc(void) { const unsigned long crc_table[16] = { 0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c, 0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c }; unsigned long crc = ~0L; for (int index = 0 ; index < EEPROM.length() ; ++index) { crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4); crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4); crc = ~crc; } return crc; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_7","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#543-eeprom_get","text":"","title":"5.4.3 eeprom_get"},{"location":"05_examples_uno_r4_wifi/#sketch-code_8","text":"/*** eeprom_get example. This shows how to use the EEPROM.get() method. To pre-set the EEPROM data, run the example sketch eeprom_put. This sketch will run without it, however, the values shown will be shown from what ever is already on the EEPROM. This may cause the serial object to print out a large string of garbage if there is no null character inside one of the strings loaded. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void setup() { float f = 0.00f; //Variable to store data read from EEPROM. int eeAddress = 0; //EEPROM address to start reading from Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Read float from EEPROM: \"); //Get the float data from the EEPROM at position 'eeAddress' EEPROM.get(eeAddress, f); Serial.println(f, 3); //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float. /*** As get also returns a reference to 'f', you can use it inline. E.g: Serial.print( EEPROM.get( eeAddress, f ) ); ***/ /*** Get can be used with custom structures too. I have separated this into an extra function. ***/ secondTest(); //Run the next test. } struct MyObject { float field1; byte field2; char name[10]; }; void secondTest() { int eeAddress = sizeof(float); //Move address to the next byte after float 'f'. MyObject customVar; //Variable to store custom object read from EEPROM. EEPROM.get(eeAddress, customVar); Serial.println(\"Read custom object from EEPROM: \"); Serial.println(customVar.field1); Serial.println(customVar.field2); Serial.println(customVar.name); } void loop() { /* Empty loop */ }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_8","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#544-eeprom_iteration","text":"","title":"5.4.4 eeprom_iteration"},{"location":"05_examples_uno_r4_wifi/#sketch-code_9","text":"/*** eeprom_iteration example. A set of example snippets highlighting the simplest methods for traversing the EEPROM. Running this sketch is not necessary, this is simply highlighting certain programming methods. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void setup() { /*** Iterate the EEPROM using a for loop. ***/ for (int index = 0 ; index < EEPROM.length() ; index++) { //Add one to each cell in the EEPROM EEPROM[ index ] += 1; } /*** Iterate the EEPROM using a while loop. ***/ int index = 0; while (index < EEPROM.length()) { //Add one to each cell in the EEPROM EEPROM[ index ] += 1; index++; } /*** Iterate the EEPROM using a do-while loop. ***/ int idx = 0; //Used 'idx' to avoid name conflict with 'index' above. do { //Add one to each cell in the EEPROM EEPROM[ idx ] += 1; idx++; } while (idx < EEPROM.length()); } //End of setup function. void loop() {}","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_9","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#545-eeprom_put","text":"","title":"5.4.5 eeprom_put"},{"location":"05_examples_uno_r4_wifi/#sketch-code_10","text":"/*** eeprom_put example. This shows how to use the EEPROM.put() method. Also, this sketch will pre-set the EEPROM data for the example sketch eeprom_get. Note, unlike the single byte version EEPROM.write(), the put method will use update semantics. As in a byte will only be written to the EEPROM if the data is actually different. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> struct MyObject { float field1; byte field2; char name[10]; }; void setup() { Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } float f = 123.456f; //Variable to store in EEPROM. int eeAddress = 0; //Location we want the data to be put. //One simple call, with the address first and the object second. EEPROM.put(eeAddress, f); Serial.println(\"Written float data type!\"); /** Put is designed for use with custom structures also. **/ //Data to store. MyObject customVar = { 3.14f, 65, \"Working!\" }; eeAddress += sizeof(float); //Move address to the next byte after float 'f'. EEPROM.put(eeAddress, customVar); Serial.print(\"Written custom data type! \\n\\nView the example sketch eeprom_get to see how you can retrieve the values!\"); } void loop() { /* Empty loop */ }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_10","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#546-eeprom_read","text":"","title":"5.4.6 eeprom_read"},{"location":"05_examples_uno_r4_wifi/#sketch-code_11","text":"/* EEPROM Read Reads the value of each byte of the EEPROM and prints it to the computer. This example code is in the public domain. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom */ // Include the EEPROM library #include <EEPROM.h> // start reading from the first byte (address 0) of the EEPROM int address = 0; byte value; void setup() { // initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } } void loop() { // read a byte from the current address of the EEPROM value = EEPROM.read(address); Serial.print(address); Serial.print(\"\\t\"); Serial.print(value, DEC); Serial.println(); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM.length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM.length() - 1; ***/ delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_11","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#547-eeprom_update","text":"","title":"5.4.7 eeprom_update"},{"location":"05_examples_uno_r4_wifi/#sketch-code_12","text":"/*** EEPROM Update method Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. If a value has not changed in the EEPROM, it is not overwritten which would reduce the life span of the EEPROM unnecessarily. Released using MIT licence. ***/ #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int address = 0; void setup() { /** Empty setup **/ } void loop() { /*** need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Update the particular EEPROM cell. these values will remain there when the board is turned off. ***/ EEPROM.update(address, val); /*** The function EEPROM.update(address, val) is equivalent to the following: if( EEPROM.read(address) != val ){ EEPROM.write(address, val); } ***/ /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM.length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM.length() - 1; ***/ delay(100); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_12","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#548-eeprom_write","text":"","title":"5.4.8 eeprom_write"},{"location":"05_examples_uno_r4_wifi/#sketch-code_13","text":"/* EEPROM Write Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom */ // Include the EEPROM library #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int addr = 0; void setup() { /** Empty setup. **/ } void loop() { /*** Need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Write the value to the appropriate byte of the EEPROM. these values will remain there when the board is turned off. ***/ EEPROM.write(addr, val); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ addr = addr + 1; if (addr == EEPROM.length()) { addr = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++addr &= EEPROM.length() - 1; ***/ delay(100); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_13","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-55-ethernet","text":"Note No additional circuit is required for this section 5.5 .","title":"Section 5.5: Ethernet"},{"location":"05_examples_uno_r4_wifi/#551-advancedchatserver","text":"","title":"5.5.1 AdvancedChatServer"},{"location":"05_examples_uno_r4_wifi/#sketch-code_14","text":"/* Advanced Chat Server A more advanced server that distributes any incoming messages to all connected clients but the client the message comes from. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe redesigned to make use of operator== 25 Nov 2013 by Norbert Truchsess */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); EthernetClient clients[8]; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // initialize the Ethernet device Ethernet.begin(mac, ip, myDns, gateway, subnet); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); Serial.print(\"Chat server address:\"); Serial.println(Ethernet.localIP()); } void loop() { // check for any new client connecting, and say hello (before any incoming data) EthernetClient newClient = server.accept(); if (newClient) { for (byte i=0; i < 8; i++) { if (!clients[i]) { Serial.print(\"We have a new client #\"); Serial.println(i); newClient.print(\"Hello, client number: \"); newClient.println(i); // Once we \"accept\", the client is no longer tracked by EthernetServer // so we must store it into our list of clients clients[i] = newClient; break; } } } // check for incoming data from all clients for (byte i=0; i < 8; i++) { if (clients[i] && clients[i].available() > 0) { // read bytes from a client byte buffer[80]; int count = clients[i].read(buffer, 80); // write the bytes to all other connected clients for (byte j=0; j < 8; j++) { if (j != i && clients[j].connected()) { clients[j].write(buffer, count); } } } } // stop any clients which disconnect for (byte i=0; i < 8; i++) { if (clients[i] && !clients[i].connected()) { Serial.print(\"disconnect client #\"); Serial.println(i); clients[i].stop(); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_3","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_3","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_14","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#552-barometricpressurewebserver","text":"","title":"5.5.2 BarometricPressureWebServer"},{"location":"05_examples_uno_r4_wifi/#sketch-code_15","text":"/* SCP1000 Barometric Pressure Sensor Display Serves the output of a Barometric Pressure Sensor as a web page. Uses the SPI library. For details on the sensor, see: http://www.sparkfun.com/commerce/product_info.php?products_id=8161 This sketch adapted from Nathan Seidle's SCP1000 example for PIC: http://www.sparkfun.com/datasheets/Sensors/SCP1000-Testing.zip TODO: this hardware is long obsolete. This example program should be rewritten to use https://www.sparkfun.com/products/9721 Circuit: SCP1000 sensor attached to pins 6,7, and 11 - 13: DRDY: pin 6 CSB: pin 7 MOSI: pin 11 MISO: pin 12 SCK: pin 13 created 31 July 2010 by Tom Igoe */ #include <Ethernet.h> // the sensor communicates using SPI, so include the library: #include <SPI.h> // assign a MAC address for the Ethernet controller. // fill in your address here: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // assign an IP address for the controller: IPAddress ip(192, 168, 1, 20); // Initialize the Ethernet server library // with the IP address and port you want to use // (port 80 is default for HTTP): EthernetServer server(80); //Sensor's memory register addresses: const int PRESSURE = 0x1F; //3 most significant bits of pressure const int PRESSURE_LSB = 0x20; //16 least significant bits of pressure const int TEMPERATURE = 0x21; //16 bit temperature reading // pins used for the connection with the sensor // the others you need are controlled by the SPI library): const int dataReadyPin = 6; const int chipSelectPin = 7; float temperature = 0.0; long pressure = 0; long lastReadingTime = 0; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the SPI library: SPI.begin(); // start the Ethernet connection Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); // initialize the data ready and chip select pins: pinMode(dataReadyPin, INPUT); pinMode(chipSelectPin, OUTPUT); //Configure SCP1000 for low noise configuration: writeRegister(0x02, 0x2D); writeRegister(0x01, 0x03); writeRegister(0x03, 0x02); // give the sensor and Ethernet shield time to set up: delay(1000); //Set the sensor to high resolution mode to start readings: writeRegister(0x03, 0x0A); } void loop() { // check for a reading no more than once a second. if (millis() - lastReadingTime > 1000) { // if there's a reading ready, read it: // don't do anything until the data ready pin is high: if (digitalRead(dataReadyPin) == HIGH) { getData(); // timestamp the last time you got a reading: lastReadingTime = millis(); } } // listen for incoming Ethernet connections: listenForEthernetClients(); } void getData() { Serial.println(\"Getting reading\"); //Read the temperature data int tempData = readRegister(0x21, 2); // convert the temperature to Celsius and display it: temperature = (float)tempData / 20.0; //Read the pressure data highest 3 bits: byte pressureDataHigh = readRegister(0x1F, 1); pressureDataHigh &= 0b00000111; //you only needs bits 2 to 0 //Read the pressure data lower 16 bits: unsigned int pressureDataLow = readRegister(0x20, 2); //combine the two parts into one 19-bit number: pressure = ((pressureDataHigh << 16) | pressureDataLow) / 4; Serial.print(\"Temperature: \"); Serial.print(temperature); Serial.println(\" degrees C\"); Serial.print(\"Pressure: \" + String(pressure)); Serial.println(\" Pa\"); } void listenForEthernetClients() { // listen for incoming clients EthernetClient client = server.available(); if (client) { Serial.println(\"Got a client\"); // an HTTP request ends with a blank line bool currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(); // print the current readings, in HTML format: client.print(\"Temperature: \"); client.print(temperature); client.print(\" degrees C\"); client.println(\"<br />\"); client.print(\"Pressure: \" + String(pressure)); client.print(\" Pa\"); client.println(\"<br />\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); } } //Send a write command to SCP1000 void writeRegister(byte registerName, byte registerValue) { // SCP1000 expects the register name in the upper 6 bits // of the byte: registerName <<= 2; // command (read or write) goes in the lower two bits: registerName |= 0b00000010; //Write command // take the chip select low to select the device: digitalWrite(chipSelectPin, LOW); SPI.transfer(registerName); //Send register location SPI.transfer(registerValue); //Send value to record into register // take the chip select high to de-select: digitalWrite(chipSelectPin, HIGH); } //Read register from the SCP1000: unsigned int readRegister(byte registerName, int numBytes) { byte inByte = 0; // incoming from the SPI read unsigned int result = 0; // result to return // SCP1000 expects the register name in the upper 6 bits // of the byte: registerName <<= 2; // command (read or write) goes in the lower two bits: registerName &= 0b11111100; //Read command // take the chip select low to select the device: digitalWrite(chipSelectPin, LOW); // send the device the register you want to read: SPI.transfer(registerName); // send a value of 0 to read the first byte returned: inByte = SPI.transfer(0x00); result = inByte; // if there's more than one byte returned, // shift the first byte then get the second byte: if (numBytes > 1) { result = inByte << 8; inByte = SPI.transfer(0x00); result = result | inByte; } // take the chip select high to de-select: digitalWrite(chipSelectPin, HIGH); // return the result: return (result); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_4","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_4","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_15","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#553-chatserver","text":"","title":"5.5.3 ChatServer"},{"location":"05_examples_uno_r4_wifi/#sketch-code_16","text":"/* Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); bool alreadyConnected = false; // whether or not the client was connected previously void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // initialize the Ethernet device Ethernet.begin(mac, ip, myDns, gateway, subnet); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); Serial.print(\"Chat server address:\"); Serial.println(Ethernet.localIP()); } void loop() { // wait for a new client: EthernetClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!alreadyConnected) { // clear out the input buffer: client.flush(); Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); alreadyConnected = true; } if (client.available() > 0) { // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.write(thisChar); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_5","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_5","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_16","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#554-dhcpaddressprinter","text":"","title":"5.5.4 DhcpAddressPrinter"},{"location":"05_examples_uno_r4_wifi/#sketch-code_17","text":"/* DHCP-based IP printer This sketch uses the DHCP extensions to the Ethernet library to get an IP address via DHCP and print the address obtained. using an Arduino WIZnet Ethernet shield. Circuit: Ethernet shield attached to pins 10, 11, 12, 13 created 12 April 2011 modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); } else if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // no point in carrying on, so do nothing forevermore: while (true) { delay(1); } } // print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); } void loop() { switch (Ethernet.maintain()) { case 1: //renewed fail Serial.println(\"Error: renewed fail\"); break; case 2: //renewed success Serial.println(\"Renewed success\"); //print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); break; case 3: //rebind fail Serial.println(\"Error: rebind fail\"); break; case 4: //rebind success Serial.println(\"Rebind success\"); //print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); break; default: //nothing happened break; } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_6","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_6","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_17","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#555-dhcpchatserver","text":"","title":"5.5.5 DhcpChatServer"},{"location":"05_examples_uno_r4_wifi/#sketch-code_18","text":"/* DHCP Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. THis version attempts to get an IP address using DHCP Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 21 May 2011 modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi Based on ChatServer example by David A. Mellis */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); bool gotAMessage = false; // whether or not you got a message from the client yet void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Trying to get an IP address using DHCP\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // initialize the Ethernet device not using DHCP: Ethernet.begin(mac, ip, myDns, gateway, subnet); } // print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); // start listening for clients server.begin(); } void loop() { // wait for a new client: EthernetClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!gotAMessage) { Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); gotAMessage = true; } // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.print(thisChar); Ethernet.maintain(); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_7","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_7","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_18","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#556-linkstatus","text":"","title":"5.5.6 LinkStatus"},{"location":"05_examples_uno_r4_wifi/#sketch-code_19","text":"/* Link Status This sketch prints the Ethernet link status. When the Ethernet cable is connected the link status should go to \"ON\". NOTE: Only WIZnet W5200 and W5500 are capable of reporting the link status. W5100 will report \"Unknown\". Hardware: - Ethernet shield or equivalent board/shield with WIZnet W5200/W5500 Written by Cristian Maglie This example is public domain. */ #include <SPI.h> #include <Ethernet.h> void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet Serial.begin(9600); } void loop() { auto link = Ethernet.linkStatus(); Serial.print(\"Link status: \"); switch (link) { case Unknown: Serial.println(\"Unknown\"); break; case LinkON: Serial.println(\"ON\"); break; case LinkOFF: Serial.println(\"OFF\"); break; } delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_8","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_8","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_19","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#557-pagerserver","text":"","title":"5.5.7 PagerServer"},{"location":"05_examples_uno_r4_wifi/#sketch-code_20","text":"/* Pager Server A simple server that echoes any incoming messages to all connected clients. Connect two or more telnet sessions to see how server.available() and server.print() works. created in September 2020 for the Ethernet library by Juraj Andrassy https://github.com/jandrassy */ #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); EthernetServer server(2323); void setup() { Serial.begin(9600); while (!Serial); // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } server.begin(); IPAddress ip = Ethernet.localIP(); Serial.println(); Serial.print(\"To access the server, connect with Telnet client to \"); Serial.print(ip); Serial.println(\" 2323\"); } void loop() { EthernetClient client = server.available(); // returns first client which has data to read or a 'false' client if (client) { // client is true only if it is connected and has data to read String s = client.readStringUntil('\\n'); // read the message incoming from one of the clients s.trim(); // trim eventual \\r Serial.println(s); // print the message to Serial Monitor client.print(\"echo: \"); // this is only for the sending client server.println(s); // send the message to all connected clients #ifndef ARDUINO_ARCH_SAM server.flush(); // flush the buffers #endif /* !defined(ARDUINO_ARCH_SAM) */ } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_9","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_9","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_20","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#558-telnetclient","text":"","title":"5.5.8 TelnetClient"},{"location":"05_examples_uno_r4_wifi/#sketch-code_21","text":"/* Telnet client This sketch connects to a telnet server (http://www.google.com) using an Arduino WIZnet Ethernet shield. You'll need a telnet server to test this with. Processing's ChatServer example (part of the Network library) works well, running on port 10002. It can be found as part of the examples in the Processing application, available at https://processing.org/ Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 14 Sep 2010 modified 9 Apr 2012 by Tom Igoe */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); // Enter the IP address of the server you're connecting to: IPAddress server(1, 1, 1, 1); // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 23 is default for telnet; // if you're using Processing's ChatServer, use port 10002): EthernetClient client; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the Ethernet connection: Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } while (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); delay(500); } // give the Ethernet shield a second to initialize: delay(1000); Serial.println(\"connecting...\"); // if you get a connection, report back via serial: if (client.connect(server, 10002)) { Serial.println(\"connected\"); } else { // if you didn't get a connection to the server: Serial.println(\"connection failed\"); } } void loop() { // if there are incoming bytes available // from the server, read them and print them: if (client.available()) { char c = client.read(); Serial.print(c); } // as long as there are bytes in the serial queue, // read them and send them out the socket if it's open: while (Serial.available() > 0) { char inChar = Serial.read(); if (client.connected()) { client.print(inChar); } } // if the server's disconnected, stop the client: if (!client.connected()) { Serial.println(); Serial.println(\"disconnecting.\"); client.stop(); // do nothing: while (true) { delay(1); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_10","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_10","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_21","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#559-udpntpclient","text":"","title":"5.5.9 UdpNtpClient"},{"location":"05_examples_uno_r4_wifi/#sketch-code_22","text":"/* Udp NTP Client Get the time from a Network Time Protocol (NTP) time server Demonstrates use of UDP sendPacket and ReceivePacket For more on NTP time servers and the messages needed to communicate with them, see https://en.wikipedia.org/wiki/Network_Time_Protocol created 4 Sep 2010 by Michael Margolis modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi This code is in the public domain. */ #include <SPI.h> #include <Ethernet.h> #include <EthernetUdp.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; unsigned int localPort = 8888; // local port to listen for UDP packets const char timeServer[] = \"time.nist.gov\"; // time.nist.gov NTP server const int NTP_PACKET_SIZE = 48; // NTP time stamp is in the first 48 bytes of the message byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming and outgoing packets // A UDP instance to let us send and receive packets over UDP EthernetUDP Udp; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start Ethernet and UDP if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); } else if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // no point in carrying on, so do nothing forevermore: while (true) { delay(1); } } Udp.begin(localPort); } void loop() { sendNTPpacket(timeServer); // send an NTP packet to a time server // wait to see if a reply is available delay(1000); if (Udp.parsePacket()) { // We've received a packet, read the data from it Udp.read(packetBuffer, NTP_PACKET_SIZE); // read the packet into the buffer // the timestamp starts at byte 40 of the received packet and is four bytes, // or two words, long. First, extract the two words: unsigned long highWord = word(packetBuffer[40], packetBuffer[41]); unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]); // combine the four bytes (two words) into a long integer // this is NTP time (seconds since Jan 1 1900): unsigned long secsSince1900 = highWord << 16 | lowWord; Serial.print(\"Seconds since Jan 1 1900 = \"); Serial.println(secsSince1900); // now convert NTP time into everyday time: Serial.print(\"Unix time = \"); // Unix time starts on Jan 1 1970. In seconds, that's 2208988800: const unsigned long seventyYears = 2208988800UL; // subtract seventy years: unsigned long epoch = secsSince1900 - seventyYears; // print Unix time: Serial.println(epoch); // print the hour, minute and second: Serial.print(\"The UTC time is \"); // UTC is the time at Greenwich Meridian (GMT) Serial.print((epoch % 86400L) / 3600); // print the hour (86400 equals secs per day) Serial.print(':'); if (((epoch % 3600) / 60) < 10) { // In the first 10 minutes of each hour, we'll want a leading '0' Serial.print('0'); } Serial.print((epoch % 3600) / 60); // print the minute (3600 equals secs per minute) Serial.print(':'); if ((epoch % 60) < 10) { // In the first 10 seconds of each minute, we'll want a leading '0' Serial.print('0'); } Serial.println(epoch % 60); // print the second } // wait ten seconds before asking for the time again delay(10000); Ethernet.maintain(); } // send an NTP request to the time server at the given address void sendNTPpacket(const char * address) { // set all bytes in the buffer to 0 memset(packetBuffer, 0, NTP_PACKET_SIZE); // Initialize values needed to form NTP request // (see URL above for details on the packets) packetBuffer[0] = 0b11100011; // LI, Version, Mode packetBuffer[1] = 0; // Stratum, or type of clock packetBuffer[2] = 6; // Polling Interval packetBuffer[3] = 0xEC; // Peer Clock Precision // 8 bytes of zero for Root Delay & Root Dispersion packetBuffer[12] = 49; packetBuffer[13] = 0x4E; packetBuffer[14] = 49; packetBuffer[15] = 52; // all NTP fields have been given values, now // you can send a packet requesting a timestamp: Udp.beginPacket(address, 123); // NTP requests are to port 123 Udp.write(packetBuffer, NTP_PACKET_SIZE); Udp.endPacket(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_11","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_11","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_22","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5510-udpsendreceivestring","text":"","title":"5.5.10 UDPSendReceiveString"},{"location":"05_examples_uno_r4_wifi/#sketch-code_23","text":"/* UDPSendReceiveString This sketch receives UDP message strings, prints them to the serial port and sends an \"acknowledge\" string back to the sender A Processing sketch is included at the end of file that can be used to send and receive messages for testing with a computer. created 21 Aug 2010 by Michael Margolis This code is in the public domain. */ #include <Ethernet.h> #include <EthernetUdp.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); unsigned int localPort = 8888; // local port to listen on // buffers for receiving and sending data char packetBuffer[UDP_TX_PACKET_MAX_SIZE]; // buffer to hold incoming packet, char ReplyBuffer[] = \"acknowledged\"; // a string to send back // An EthernetUDP instance to let us send and receive packets over UDP EthernetUDP Udp; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the Ethernet Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start UDP Udp.begin(localPort); } void loop() { // if there's data available, read a packet int packetSize = Udp.parsePacket(); if (packetSize) { Serial.print(\"Received packet of size \"); Serial.println(packetSize); Serial.print(\"From \"); IPAddress remote = Udp.remoteIP(); for (int i=0; i < 4; i++) { Serial.print(remote[i], DEC); if (i < 3) { Serial.print(\".\"); } } Serial.print(\", port \"); Serial.println(Udp.remotePort()); // read the packet into packetBuffer Udp.read(packetBuffer, UDP_TX_PACKET_MAX_SIZE); Serial.println(\"Contents:\"); Serial.println(packetBuffer); // send a reply to the IP address and port that sent us the packet we received Udp.beginPacket(Udp.remoteIP(), Udp.remotePort()); Udp.write(ReplyBuffer); Udp.endPacket(); } delay(10); } /* Processing sketch to run with this example ===================================================== // Processing UDP example to send and receive string data from Arduino // press any key to send the \"Hello Arduino\" message import hypermedia.net.*; UDP udp; // define the UDP object void setup() { udp = new UDP( this, 6000 ); // create a new datagram connection on port 6000 //udp.log( true ); // <-- printout the connection activity udp.listen( true ); // and wait for incoming message } void draw() { } void keyPressed() { String ip = \"192.168.1.177\"; // the remote IP address int port = 8888; // the destination port udp.send(\"Hello World\", ip, port ); // the message to send } void receive( byte[] data ) { // <-- default handler //void receive( byte[] data, String ip, int port ) { // <-- extended handler for(int i=0; i < data.length; i++) print(char(data[i])); println(); } */","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_12","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_12","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_23","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5511-webclient","text":"","title":"5.5.11 WebClient"},{"location":"05_examples_uno_r4_wifi/#sketch-code_24","text":"/* Web client This sketch connects to a website (http://www.google.com) using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe, based on work by Adrian McEwen */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // if you don't want to use DNS (and reduce your sketch size) // use the numeric IP instead of the name for the server: //IPAddress server(74,125,232,128); // numeric IP for Google (no DNS) char server[] = \"www.google.com\"; // name address for Google (using DNS) // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); IPAddress myDns(192, 168, 0, 1); // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 80 is default for HTTP): EthernetClient client; // Variables to measure the speed unsigned long beginMicros, endMicros; unsigned long byteCount = 0; bool printWebData = true; // set to false for better speed measurement void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip, myDns); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } // give the Ethernet shield a second to initialize: delay(1000); Serial.print(\"connecting to \"); Serial.print(server); Serial.println(\"...\"); // if you get a connection, report back via serial: if (client.connect(server, 80)) { Serial.print(\"connected to \"); Serial.println(client.remoteIP()); // Make a HTTP request: client.println(\"GET /search?q=arduino HTTP/1.1\"); client.println(\"Host: www.google.com\"); client.println(\"Connection: close\"); client.println(); } else { // if you didn't get a connection to the server: Serial.println(\"connection failed\"); } beginMicros = micros(); } void loop() { // if there are incoming bytes available // from the server, read them and print them: int len = client.available(); if (len > 0) { byte buffer[80]; if (len > 80) len = 80; client.read(buffer, len); if (printWebData) { Serial.write(buffer, len); // show in the serial monitor (slows some boards) } byteCount = byteCount + len; } // if the server's disconnected, stop the client: if (!client.connected()) { endMicros = micros(); Serial.println(); Serial.println(\"disconnecting.\"); client.stop(); Serial.print(\"Received \"); Serial.print(byteCount); Serial.print(\" bytes in \"); float seconds = (float)(endMicros - beginMicros) / 1000000.0; Serial.print(seconds, 4); float rate = (float)byteCount / seconds / 1000.0; Serial.print(\", rate = \"); Serial.print(rate); Serial.print(\" kbytes/second\"); Serial.println(); // do nothing forevermore: while (true) { delay(1); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_13","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_13","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_24","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5512-webclientrepeating","text":"","title":"5.5.12 WebClientRepeating"},{"location":"05_examples_uno_r4_wifi/#sketch-code_25","text":"/* Repeating Web client This sketch connects to a web server and makes a request using a WIZnet Ethernet shield. You can use the Arduino Ethernet Shield, or the Adafruit Ethernet shield, either one will work, as long as it's got a WIZnet Ethernet module on board. This example uses DNS, by assigning the Ethernet client with a MAC address, IP address, and DNS address. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 19 Apr 2012 by Tom Igoe modified 21 Jan 2014 by Federico Vanzati https://www.arduino.cc/en/Tutorial/WebClientRepeating This code is in the public domain. */ #include <SPI.h> #include <Ethernet.h> // assign a MAC address for the Ethernet controller. // fill in your address here: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); IPAddress myDns(192, 168, 0, 1); // initialize the library instance: EthernetClient client; char server[] = \"www.arduino.cc\"; // also change the Host line in httpRequest() //IPAddress server(64,131,82,241); unsigned long lastConnectionTime = 0; // last time you connected to the server, in milliseconds const unsigned long postingInterval = 10*1000; // delay between updates, in milliseconds void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start serial port: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip, myDns); Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } // give the Ethernet shield a second to initialize: delay(1000); } void loop() { // if there's incoming data from the net connection. // send it out the serial port. This is for debugging // purposes only: if (client.available()) { char c = client.read(); Serial.write(c); } // if ten seconds have passed since your last connection, // then connect again and send data: if (millis() - lastConnectionTime > postingInterval) { httpRequest(); } } // this method makes a HTTP connection to the server: void httpRequest() { // close any connection before send a new request. // This will free the socket on the Ethernet shield client.stop(); // if there's a successful connection: if (client.connect(server, 80)) { Serial.println(\"connecting...\"); // send the HTTP GET request: client.println(\"GET /latest.txt HTTP/1.1\"); client.println(\"Host: www.arduino.cc\"); client.println(\"User-Agent: arduino-ethernet\"); client.println(\"Connection: close\"); client.println(); // note the time that the connection was made: lastConnectionTime = millis(); } else { // if you couldn't make a connection: Serial.println(\"connection failed\"); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_14","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_14","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_25","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5513-webserver","text":"","title":"5.5.13 WebServer"},{"location":"05_examples_uno_r4_wifi/#sketch-code_26","text":"/* Web Server A simple web server that shows the value of the analog input pins. using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 * Analog inputs attached to pins A0 through A5 (optional) created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); // Initialize the Ethernet server library // with the IP address and port you want to use // (port 80 is default for HTTP): EthernetServer server(80); void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"Ethernet WebServer Example\"); // start the Ethernet connection and the server: Ethernet.begin(mac, ip); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start the server server.begin(); Serial.print(\"server is at \"); Serial.println(Ethernet.localIP()); } void loop() { // listen for incoming clients EthernetClient client = server.available(); if (client) { Serial.println(\"new client\"); // an HTTP request ends with a blank line bool currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); Serial.write(c); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(\"Connection: close\"); // the connection will be closed after completion of the response client.println(\"Refresh: 5\"); // refresh the page automatically every 5 sec client.println(); client.println(\"<!DOCTYPE HTML>\"); client.println(\"<html>\"); // output the value of each analog input pin for (int analogChannel = 0; analogChannel < 6; analogChannel++) { int sensorReading = analogRead(analogChannel); client.print(\"analog input \"); client.print(analogChannel); client.print(\" is \"); client.print(sensorReading); client.println(\"<br />\"); } client.println(\"</html>\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); Serial.println(\"client disconnected\"); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_15","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_15","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_26","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-56-firmata","text":"Note No additional circuit is required for this section 5.6 .","title":"Section 5.6: Firmata"},{"location":"05_examples_uno_r4_wifi/#561-allinputsfirmata","text":"","title":"5.6.1 AllInputsFirmata"},{"location":"05_examples_uno_r4_wifi/#sketch-code_27","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* * This firmware reads all inputs and sends them as fast as it can. It was * inspired by the ease-of-use of the Arduino2Max program. * * This example code is in the public domain. */ #include <Firmata.h> byte pin; int analogValue; int previousAnalogValues[TOTAL_ANALOG_PINS]; byte portStatus[TOTAL_PORTS]; // each bit: 1=pin is digital input, 0=other/ignore byte previousPINs[TOTAL_PORTS]; /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you get long, random delays. So only read analogs every 20ms or so */ int samplingInterval = 19; // how often to run the main loop (in ms) void sendPort(byte portNumber, byte portValue) { portValue = portValue & portStatus[portNumber]; if (previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } void setup() { byte i, port, status; Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); for (pin = 0; pin < TOTAL_PINS; pin++) { if IS_PIN_DIGITAL(pin) pinMode(PIN_TO_DIGITAL(pin), INPUT); } for (port = 0; port < TOTAL_PORTS; port++) { status = 0; for (i = 0; i < 8; i++) { if (IS_PIN_DIGITAL(port * 8 + i)) status |= (1 << i); } portStatus[port] = status; } Firmata.begin(57600); } void loop() { byte i; for (i = 0; i < TOTAL_PORTS; i++) { sendPort(i, readPort(i, 0xff)); } /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you get long, random delays. So only read analogs every 20ms or so */ currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; while (Firmata.available()) { Firmata.processInput(); } for (pin = 0; pin < TOTAL_ANALOG_PINS; pin++) { analogValue = analogRead(pin); if (analogValue != previousAnalogValues[pin]) { Firmata.sendAnalog(pin, analogValue); previousAnalogValues[pin] = analogValue; } } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_27","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#562-analogfirmata","text":"","title":"5.6.2 AnalogFirmata"},{"location":"05_examples_uno_r4_wifi/#sketch-code_28","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This firmware supports as many analog ports as possible, all analog inputs, * four PWM outputs, and two with servo support. * * This example code is in the public domain. */ #include <Servo.h> #include <Firmata.h> /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* servos */ Servo servo9, servo10; // one instance per pin /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting int analogPin = 0; // counter for reading analog pins /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /*============================================================================== * FUNCTIONS *============================================================================*/ void analogWriteCallback(byte pin, int value) { switch (pin) { case 9: servo9.write(value); break; case 10: servo10.write(value); break; case 3: case 5: case 6: case 11: // PWM pins analogWrite(pin, value); break; } } // ----------------------------------------------------------------------------- // sets bits in a bit array (int) to toggle the reporting of the analogIns void reportAnalogCallback(byte pin, int value) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << pin); } else { // everything but 0 enables reporting of that pin analogInputsToReport = analogInputsToReport | (1 << pin); } // TODO: save status to EEPROM here, if changed } /*============================================================================== * SETUP() *============================================================================*/ void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); servo9.attach(9); servo10.attach(10); Firmata.begin(57600); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { while (Firmata.available()) Firmata.processInput(); currentMillis = millis(); if (currentMillis - previousMillis > 20) { previousMillis += 20; // run this every 20ms for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) { if ( analogInputsToReport & (1 << analogPin) ) Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_28","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#563-echostring","text":"","title":"5.6.3 EchoString"},{"location":"05_examples_uno_r4_wifi/#sketch-code_29","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This sketch accepts strings and raw sysex messages and echos them back. * * This example code is in the public domain. */ #include <Firmata.h> void stringCallback(char *myString) { Firmata.sendString(myString); } void sysexCallback(byte command, byte argc, byte *argv) { Firmata.sendSysex(command, argc, argv); } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(STRING_DATA, stringCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.begin(57600); } void loop() { while (Firmata.available()) { Firmata.processInput(); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_29","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#564-oldstandardfirmata","text":"","title":"5.6.4 OldStandardFirmata"},{"location":"05_examples_uno_r4_wifi/#sketch-code_30","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. */ /* * This is an old version of StandardFirmata (v2.0). It is kept here because * its the last version that works on an ATMEGA8 chip. Also, it can be used * for host software that has not been updated to a newer version of the * protocol. It also uses the old baud rate of 115200 rather than 57600. */ #include <EEPROM.h> #include <Firmata.h> /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting int analogPin = 0; // counter for reading analog pins /* digital pins */ byte reportPINs[TOTAL_PORTS]; // PIN == input port byte previousPINs[TOTAL_PORTS]; // PIN == input port byte pinStatus[TOTAL_PINS]; // store pin status, default OUTPUT byte portStatus[TOTAL_PORTS]; /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /*============================================================================== * FUNCTIONS *============================================================================*/ void outputPort(byte portNumber, byte portValue) { portValue = portValue & ~ portStatus[portNumber]; if (previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; Firmata.sendDigitalPort(portNumber, portValue); } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { byte i, tmp; for (i = 0; i < TOTAL_PORTS; i++) { if (reportPINs[i]) { switch (i) { case 0: outputPort(0, PIND & ~ B00000011); break; // ignore Rx/Tx 0/1 case 1: outputPort(1, PINB); break; case 2: outputPort(2, PINC); break; } } } } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { byte port = 0; byte offset = 0; if (pin < 8) { port = 0; offset = 0; } else if (pin < 14) { port = 1; offset = 8; } else if (pin < 22) { port = 2; offset = 14; } if (pin > 1) { // ignore RxTx (pins 0 and 1) pinStatus[pin] = mode; switch (mode) { case INPUT: pinMode(pin, INPUT); portStatus[port] = portStatus[port] & ~ (1 << (pin - offset)); break; case OUTPUT: digitalWrite(pin, LOW); // disable PWM case PWM: pinMode(pin, OUTPUT); portStatus[port] = portStatus[port] | (1 << (pin - offset)); break; //case ANALOG: // TODO figure this out default: Firmata.sendString(\"\"); } // TODO: save status to EEPROM here, if changed } } void analogWriteCallback(byte pin, int value) { setPinModeCallback(pin, PIN_MODE_PWM); analogWrite(pin, value); } void digitalWriteCallback(byte port, int value) { switch (port) { case 0: // pins 2-7 (don't change Rx/Tx, pins 0 and 1) // 0xFF03 == B1111111100000011 0x03 == B00000011 PORTD = (value & ~ 0xFF03) | (PORTD & 0x03); break; case 1: // pins 8-13 (14,15 are disabled for the crystal) PORTB = (byte)value; break; case 2: // analog pins used as digital PORTC = (byte)value; break; } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte pin, int value) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << pin); } else { // everything but 0 enables reporting of that pin analogInputsToReport = analogInputsToReport | (1 << pin); } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { reportPINs[port] = (byte)value; if (port == 2) // turn off analog reporting when used as digital analogInputsToReport = 0; } /*============================================================================== * SETUP() *============================================================================*/ void setup() { byte i; Firmata.setFirmwareVersion(2, 0); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); portStatus[0] = B00000011; // ignore Tx/RX pins portStatus[1] = B11000000; // ignore 14/15 pins portStatus[2] = B00000000; // for(i=0; i<TOTAL_PINS; ++i) { // TODO make this work with analogs for (i = 0; i < 14; ++i) { setPinModeCallback(i, OUTPUT); } // set all outputs to 0 to make sure internal pull-up resistors are off PORTB = 0; // pins 8-15 PORTC = 0; // analog port PORTD = 0; // pins 0-7 // TODO rethink the init, perhaps it should report analog on default for (i = 0; i < TOTAL_PORTS; ++i) { reportPINs[i] = false; } // TODO: load state from EEPROM here /* send digital inputs here, if enabled, to set the initial state on the * host computer, since once in the loop(), this firmware will only send * digital data on change. */ if (reportPINs[0]) outputPort(0, PIND & ~ B00000011); // ignore Rx/Tx 0/1 if (reportPINs[1]) outputPort(1, PINB); if (reportPINs[2]) outputPort(2, PINC); Firmata.begin(115200); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); currentMillis = millis(); if (currentMillis - previousMillis > 20) { previousMillis += 20; // run this every 20ms /* SERIALREAD - Serial.read() uses a 128 byte circular buffer, so handle * all serialReads at once, i.e. empty the buffer */ while (Firmata.available()) Firmata.processInput(); /* SEND FTDI WRITE BUFFER - make sure that the FTDI buffer doesn't go over * 60 bytes. use a timer to sending an event character every 4 ms to * trigger the buffer to dump. */ /* ANALOGREAD - right after the event character, do all of the * analogReads(). These only need to be done every 4ms. */ for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) { if ( analogInputsToReport & (1 << analogPin) ) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_30","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#565-servofirmata","text":"","title":"5.6.5 ServoFirmata"},{"location":"05_examples_uno_r4_wifi/#sketch-code_31","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This firmware supports as many servos as possible using the Servo library * included in Arduino 0017 * * This example code is in the public domain. */ #include <Servo.h> #include <Firmata.h> Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte servoCount = 0; void analogWriteCallback(byte pin, int value) { if (IS_PIN_DIGITAL(pin)) { servos[servoPinMap[pin]].write(value); } } void systemResetCallback() { servoCount = 0; } void setup() { byte pin; Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); Firmata.begin(57600); systemResetCallback(); // attach servos from first digital pin up to max number of // servos supported for the board for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { if (servoCount < MAX_SERVOS) { servoPinMap[pin] = servoCount; servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); servoCount++; } } } } void loop() { while (Firmata.available()) Firmata.processInput(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_31","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#566-simpleanalogfirmata","text":"","title":"5.6.6 SimpleAnalogFirmata"},{"location":"05_examples_uno_r4_wifi/#sketch-code_32","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Supports as many analog inputs and analog PWM outputs as possible. * * This example code is in the public domain. */ #include <Firmata.h> byte analogPin = 0; void analogWriteCallback(byte pin, int value) { if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_DIGITAL(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), value); } } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.begin(57600); } void loop() { while (Firmata.available()) { Firmata.processInput(); } // do one analogRead per loop, so if PC is sending a lot of // analog write messages, we will only delay 1 analogRead Firmata.sendAnalog(analogPin, analogRead(analogPin)); analogPin = analogPin + 1; if (analogPin >= TOTAL_ANALOG_PINS) analogPin = 0; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_32","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#567-simpledigitalfirmata","text":"","title":"5.6.7 SimpleDigitalFirmata"},{"location":"05_examples_uno_r4_wifi/#sketch-code_33","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Supports as many digital inputs and outputs as possible. * * This example code is in the public domain. */ #include <Firmata.h> byte previousPIN[TOTAL_PORTS]; // PIN means PORT for input byte previousPORT[TOTAL_PORTS]; void outputPort(byte portNumber, byte portValue) { // only send the data when it changes, otherwise you get too many messages! if (previousPIN[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPIN[portNumber] = portValue; } } void setPinModeCallback(byte pin, int mode) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), mode); } } void digitalWriteCallback(byte port, int value) { byte i; byte currentPinValue, previousPinValue; if (port < TOTAL_PORTS && value != previousPORT[port]) { for (i = 0; i < 8; i++) { currentPinValue = (byte) value & (1 << i); previousPinValue = previousPORT[port] & (1 << i); if (currentPinValue != previousPinValue) { digitalWrite(i + (port * 8), currentPinValue); } } previousPORT[port] = value; } } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.begin(57600); } void loop() { byte i; for (i = 0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, 0xff)); } while (Firmata.available()) { Firmata.processInput(); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_33","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#568-standardfirmatable","text":"","title":"5.6.8 StandardFirmataBLE"},{"location":"05_examples_uno_r4_wifi/#sketch-code_34","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega, // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this: // Serial1.begin(57600); // Firmata.begin(Serial1); // However do not do this if you are using SERIAL_MESSAGE Firmata.begin(57600); while (!Serial) { ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101 } systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_34","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#569-standardfirmatachipkit","text":"","title":"5.6.9 StandardFirmataChipKIT"},{"location":"05_examples_uno_r4_wifi/#sketch-code_35","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. Copyright (C) 2015 Brian Schmalz. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ #include <SoftPWMServo.h> // Gives us PWM and Servo on every pin #include <Wire.h> #include <Firmata.h> #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; SoftServo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* Sets a pin that is in Servo mode to a particular output value * (i.e. pulse width). Different boards may have different ways of * setting servo values, so putting it in a function keeps things cleaner. */ void servoWrite(byte pin, int value) { SoftPWMServoPWMWrite(PIN_TO_PWM(pin), value); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); servoWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) servoWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); /* For chipKIT Pi board, we need to use Serial1. All others just use Serial. */ #if defined(_BOARD_CHIPKIT_PI_) Serial1.begin(57600); Firmata.begin(Serial1); #else Firmata.begin(57600); #endif systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_35","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5610-standardfirmataethernet","text":"","title":"5.6.10 StandardFirmataEthernet"},{"location":"05_examples_uno_r4_wifi/#sketch-code_36","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2017 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated March 10th, 2020 */ /* README StandardFirmataEthernet is a TCP client/server implementation. You will need a Firmata client library with a network transport that can act as a TCP server or client in order to establish a connection between StandardFirmataEthernet and the Firmata client application. To use StandardFirmataEthernet you will need to have one of the following boards or shields: - Arduino Ethernet shield (or clone) - Arduino Ethernet board (or clone) - Arduino Yun Follow the instructions in the ethernetConfig.h file (ethernetConfig.h tab in Arduino IDE) to configure your particular hardware. NOTE: If you are using an Arduino Ethernet shield you cannot use the following pins on the following boards. Firmata will ignore any requests to use these pins: - Arduino Uno or other ATMega328 boards: (D4, D10, D11, D12, D13) - Arduino Mega: (D4, D10, D50, D51, D52, D53) - Arduino Leonardo: (D4, D10) - Arduino Due: (D4, D10) - Arduino Zero: (D4, D10) If you are using an ArduinoEthernet board, the following pins cannot be used (same as Uno): - D4, D10, D11, D12, D13 */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> /* * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your * connection that may help in the event of connection issues. If defined, some boards may not begin * executing this sketch until the Serial console is opened. */ //#define SERIAL_DEBUG #include \"utility/firmataDebug.h\" // follow the instructions in ethernetConfig.h to configure your particular hardware #include \"ethernetConfig.h\" #include \"utility/EthernetClientStream.h\" #include \"utility/EthernetServerStream.h\" /* * Uncomment the following include to enable interfacing with Serial devices via hardware or * software serial. * * DO NOT uncomment if you are running StandardFirmataEthernet on an Arduino Leonardo, * Arduino Micro or other ATMega32u4-based board or you will not have enough Flash and RAM * remaining to reliably run Firmata. Arduino Yun is okay because it doesn't import the Ethernet * libraries. */ // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. //#include \"utility/SerialFirmata.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #if defined remote_ip && !defined remote_host #ifdef local_ip EthernetClientStream stream(client, local_ip, remote_ip, NULL, network_port); #else EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), remote_ip, NULL, network_port); #endif #endif #if !defined remote_ip && defined remote_host #ifdef local_ip EthernetClientStream stream(client, local_ip, IPAddress(0, 0, 0, 0), remote_host, network_port ); #else EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), IPAddress(0, 0, 0, 0), remote_host, network_port); #endif #endif #if !defined remote_ip && !defined remote_host #ifdef local_ip EthernetServerStream stream(local_ip, network_port); #else EthernetServerStream stream(IPAddress(0, 0, 0, 0), network_port); #endif #endif #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous mode */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Stream output queue using Stream.write() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { // turn on/off reporting reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } #ifdef ETHERNETCLIENTSTREAM_H /* * Called when a TCP connection is either connected or disconnected. * TODO: * - report connected or reconnected state to host (to be added to protocol) * - report current state to host (to be added to protocol) */ void hostConnectionCallback(byte state) { switch (state) { case HOST_CONNECTION_CONNECTED: DEBUG_PRINTLN( \"TCP connection established\" ); break; case HOST_CONNECTION_DISCONNECTED: DEBUG_PRINTLN( \"TCP connection disconnected\" ); break; } } #endif void printEthernetStatus() { DEBUG_PRINT(\"Local IP Address: \"); IPAddress ip = Ethernet.localIP(); DEBUG_PRINTLN(ip); #ifdef remote_ip DEBUG_PRINT(\"Connecting to server at: \"); DEBUG_PRINTLN(remote_ip); #endif } /* * StandardFirmataEthernet communicates with Ethernet shields over SPI. Therefore all * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication. * Additional pins may also need to be ignored depending on the particular board or * shield in use. */ void ignorePins() { #ifdef IS_IGNORE_PIN for (byte i = 0; i < TOTAL_PINS; i++) { if (IS_IGNORE_PIN(i)) { Firmata.setPinMode(i, PIN_MODE_IGNORE); } } #endif #ifdef WIZ5100_ETHERNET // Arduino Ethernet and Arduino EthernetShield have SD SS wired to D4 pinMode(PIN_TO_DIGITAL(4), OUTPUT); // switch off SD card bypassing Firmata digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA #endif #endif // WIZ5100_ETHERNET } void initTransport() { #ifdef ETHERNETCLIENTSTREAM_H stream.attach(hostConnectionCallback); #endif #ifdef YUN_ETHERNET Bridge.begin(); #else #ifdef local_ip Ethernet.begin((uint8_t *)mac, local_ip); //start ethernet #else DEBUG_PRINTLN(\"Local IP will be requested from DHCP...\"); //start ethernet using dhcp if (Ethernet.begin((uint8_t *)mac) == 0) { DEBUG_PRINTLN(\"Failed to configure Ethernet using DHCP\"); } #endif #endif printEthernetStatus(); } void initFirmata() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); ignorePins(); // start up Network Firmata: Firmata.begin(stream); systemResetCallback(); // Initialize default configuration } void setup() { DEBUG_BEGIN(9600); initTransport(); initFirmata(); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * Stream buffer using Stream.write() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif #if !defined local_ip && !defined YUN_ETHERNET // only necessary when using DHCP, ensures local IP is updated appropriately if it changes if (Ethernet.maintain()) { stream.maintain(Ethernet.localIP()); } #endif }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_36","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5611-standardfirmataplus","text":"","title":"5.6.11 StandardFirmataPlus"},{"location":"05_examples_uno_r4_wifi/#sketch-code_37","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ /* README StandardFirmataPlus adds additional features that may exceed the Flash and RAM sizes of Arduino boards such as ATMega328p (Uno) and ATMega32u4 (Leonardo, Micro, Yun, etc). It is best to use StandardFirmataPlus with higher memory boards such as the Arduino Mega, Arduino Due, Teensy 3.0/3.1/3.2. All Firmata examples that are appended with \"Plus\" add the following features: - Ability to interface with serial devices using UART, USART, or SoftwareSerial depending on the capatilities of the board. NOTE: In order to use SoftwareSerial with the Firmata Serial feature, StandardFirmataPlus must be compiled with Arduino v1.6.6 or newer. At the time of this writing, StandardFirmataPlus will still compile and run on ATMega328p and ATMega32u4-based boards, but future versions of this sketch may not as new features are added. */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. #include \"utility/SerialFirmata.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); // Save a couple of seconds by disabling the startup blink sequence. Firmata.disableBlinkVersion(); // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega, // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this: // Serial1.begin(57600); // Firmata.begin(Serial1); // However do not do this if you are using SERIAL_MESSAGE Firmata.begin(57600); while (!Serial) { ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101 } systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_37","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5612-standardfirmatawifi","text":"","title":"5.6.12 StandardFirmataWiFi"},{"location":"05_examples_uno_r4_wifi/#sketch-code_38","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. Copyright (C) 2015-2016 Jesse Frush. All rights reserved. Copyright (C) 2016 Jens B. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ /* README StandardFirmataWiFi enables the use of Firmata over a TCP connection. It can be configured as either a TCP server or TCP client. To use StandardFirmataWiFi you will need to have one of the following boards or shields: - Arduino WiFi Shield (or clone) - Arduino WiFi Shield 101 - Arduino MKR1000 board - Arduino MKRWIFI1010 board - ESP8266 WiFi board compatible with ESP8266 Arduino core Follow the instructions in the wifiConfig.h file (wifiConfig.h tab in Arduino IDE) to configure your particular hardware. Dependencies: - WiFi Shield 101 requires version 0.7.0 or higher of the WiFi101 library (available in Arduino 1.6.8 or higher, or update the library via the Arduino Library Manager or clone from source: https://github.com/arduino-libraries/WiFi101) - ESP8266 requires the Arduino ESP8266 core v2.1.0 or higher which can be obtained here: https://github.com/esp8266/Arduino In order to use the WiFi Shield 101 with Firmata you will need a board with at least 35k of Flash memory. This means you cannot use the WiFi Shield 101 with an Arduino Uno or any other ATmega328p-based microcontroller or with an Arduino Leonardo or other ATmega32u4-based microcontroller. Some boards that will work are: - Arduino Zero - Arduino Due - Arduino 101 - Arduino Mega NOTE: If you are using an Arduino WiFi (legacy) shield you cannot use the following pins on the following boards. Firmata will ignore any requests to use these pins: - Arduino Uno or other ATMega328 boards: (D4, D7, D10, D11, D12, D13) - Arduino Mega: (D4, D7, D10, D50, D51, D52, D53) - Arduino Due, Zero or Leonardo: (D4, D7, D10) If you are using an Arduino WiFi 101 shield you cannot use the following pins on the following boards: - Arduino Due or Zero: (D5, D7, D10) - Arduino Mega: (D5, D7, D10, D50, D52, D53) */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> /* * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your * connection that may help in the event of connection issues. If defined, some boards may not begin * executing this sketch until the Serial console is opened. */ //#define SERIAL_DEBUG #include \"utility/firmataDebug.h\" /* * Uncomment the following include to enable interfacing with Serial devices via hardware or * software serial. */ // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. //#include \"utility/SerialFirmata.h\" // follow the instructions in wifiConfig.h to configure your particular hardware #include \"wifiConfig.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 #define MAX_CONN_ATTEMPTS 20 // [500 ms] -> 10 s /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif #ifdef STATIC_IP_ADDRESS IPAddress local_ip(STATIC_IP_ADDRESS); #endif #ifdef SUBNET_MASK IPAddress subnet(SUBNET_MASK); #endif #ifdef GATEWAY_IP_ADDRESS IPAddress gateway(GATEWAY_IP_ADDRESS); #endif int connectionAttempts = 0; bool streamConnected = false; /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous mode */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Stream output queue using Stream.write() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- // function forward declarations for xtensa compiler (ESP8266) void enableI2CPins(); void disableI2CPins(); void reportAnalogCallback(byte analogPin, int value); // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } /* * Called when a TCP connection is either connected or disconnected. * TODO: * - report connected or reconnected state to host (to be added to protocol) * - report current state to host (to be added to protocol) */ void hostConnectionCallback(byte state) { switch (state) { case HOST_CONNECTION_CONNECTED: DEBUG_PRINTLN( \"TCP connection established\" ); break; case HOST_CONNECTION_DISCONNECTED: DEBUG_PRINTLN( \"TCP connection disconnected\" ); break; } } /* * Print the status of the WiFi connection. This is the connection to the access point rather * than the TCP connection. */ void printWifiStatus() { if ( WiFi.status() != WL_CONNECTED ) { DEBUG_PRINT( \"WiFi connection failed. Status value: \" ); DEBUG_PRINTLN( WiFi.status() ); } else { // print the SSID of the network you're attached to: DEBUG_PRINT( \"SSID: \" ); DEBUG_PRINTLN( WiFi.SSID() ); // print your WiFi shield's IP address: DEBUG_PRINT( \"IP Address: \" ); IPAddress ip = WiFi.localIP(); DEBUG_PRINTLN( ip ); // print the received signal strength: DEBUG_PRINT( \"signal strength (RSSI): \" ); long rssi = WiFi.RSSI(); DEBUG_PRINT( rssi ); DEBUG_PRINTLN( \" dBm\" ); } } /* * StandardFirmataWiFi communicates with WiFi shields over SPI. Therefore all * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication. * Additional pins may also need to be ignored depending on the particular board or * shield in use. */ void ignorePins() { #ifdef IS_IGNORE_PIN for (byte i = 0; i < TOTAL_PINS; i++) { if (IS_IGNORE_PIN(i)) { Firmata.setPinMode(i, PIN_MODE_IGNORE); } } #endif //Set up controls for the Arduino WiFi Shield SS for the SD Card #ifdef ARDUINO_WIFI_SHIELD // Arduino WiFi Shield has SD SS wired to D4 pinMode(PIN_TO_DIGITAL(4), OUTPUT); // switch off SD card bypassing Firmata digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA #endif //defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) #endif //ARDUINO_WIFI_SHIELD } void initTransport() { // This statement will clarify how a connection is being made DEBUG_PRINT( \"StandardFirmataWiFi will attempt a WiFi connection \" ); #if defined(WIFI_101) DEBUG_PRINTLN( \"using the WiFi 101 library.\" ); #elif defined(ARDUINO_WIFI_SHIELD) DEBUG_PRINTLN( \"using the legacy WiFi library.\" ); #elif defined(ESP8266_WIFI) DEBUG_PRINTLN( \"using the ESP8266 WiFi library.\" ); #elif defined(HUZZAH_WIFI) DEBUG_PRINTLN( \"using the HUZZAH WiFi library.\" ); #elif defined(WIFI_NINA) DEBUG_PRINTLN( \"using the WiFi NINA library.\" ); //else should never happen here as error-checking in wifiConfig.h will catch this #endif //defined(WIFI_101) // Configure WiFi IP Address #ifdef STATIC_IP_ADDRESS DEBUG_PRINT( \"Using static IP: \" ); DEBUG_PRINTLN( local_ip ); #if defined(ESP8266_WIFI) || (defined(SUBNET_MASK) && defined(GATEWAY_IP_ADDRESS)) stream.config( local_ip , gateway, subnet ); #else // you can also provide a static IP in the begin() functions, but this simplifies // ifdef logic in this sketch due to support for all different encryption types. stream.config( local_ip ); #endif #else DEBUG_PRINTLN( \"IP will be requested from DHCP ...\" ); #endif stream.attach(hostConnectionCallback); // Configure WiFi security and initiate WiFi connection #if defined(WIFI_WEP_SECURITY) DEBUG_PRINT( \"Attempting to connect to WEP SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid, wep_index, wep_key); #elif defined(WIFI_WPA_SECURITY) DEBUG_PRINT( \"Attempting to connect to WPA SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid, wpa_passphrase); #else //OPEN network DEBUG_PRINTLN( \"Attempting to connect to open SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid); #endif //defined(WIFI_WEP_SECURITY) DEBUG_PRINTLN( \"WiFi setup done\" ); // Wait for connection to access point to be established. while (WiFi.status() != WL_CONNECTED && ++connectionAttempts <= MAX_CONN_ATTEMPTS) { delay(500); DEBUG_PRINT(\".\"); } printWifiStatus(); } void initFirmata() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); ignorePins(); // Initialize Firmata to use the WiFi stream object as the transport. Firmata.begin(stream); systemResetCallback(); // reset to default config } void setup() { DEBUG_BEGIN(9600); initTransport(); initFirmata(); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * Stream buffer using Stream.write() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) { Firmata.processInput(); } // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif stream.maintain(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_38","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-57-keyboard","text":"Note No additional circuit is required for this section 5.7 .","title":"Section 5.7: Keyboard"},{"location":"05_examples_uno_r4_wifi/#571-serial","text":"","title":"5.7.1 Serial"},{"location":"05_examples_uno_r4_wifi/#sketch-code_39","text":"/* Keyboard test For the Arduino Leonardo, Micro or Due Reads a byte from the serial port, sends a keystroke back. The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send A you get B, and so forth. The circuit: - none created 21 Oct 2011 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardSerial */ #include \"Keyboard.h\" void setup() { // open the serial port: Serial.begin(9600); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // check for incoming serial data: if (Serial.available() > 0) { // read incoming serial data: char inChar = Serial.read(); // Type the next ASCII value from what you received: Keyboard.write(inChar + 1); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_39","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-58-led_matrix","text":"Note No additional circuit is required for this section 5.8 .","title":"Section 5.8: LED_Matrix"},{"location":"05_examples_uno_r4_wifi/#581-displaysingleframe","text":"","title":"5.8.1 DisplaySingleFrame"},{"location":"05_examples_uno_r4_wifi/#sketch-code_40","text":"/* Single Frame Displays single frames using matrix.loadFrame See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library #include \"frames.h\" // Include a header file containing frame data ArduinoLEDMatrix matrix; // Create an instance of the ArduinoLEDMatrix class void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 matrix.begin(); // Initialize the LED matrix } void loop() { // Load and display the \"chip\" frame on the LED matrix matrix.loadFrame(chip); delay(500); // Pause for 500 milliseconds (half a second) // Load and display the \"danger\" frame on the LED matrix matrix.loadFrame(danger); delay(500); // Load and display the \"happy\" frame on the LED matrix matrix.loadFrame(happy); delay(500); // Load and display the \"heart\" frame on the LED matrix matrix.loadFrame(heart); delay(500); // Print the current value of millis() to the serial monitor Serial.println(millis()); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_40","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#582-gameoflife","text":"","title":"5.8.2 GameOfLife"},{"location":"05_examples_uno_r4_wifi/#sketch-code_41","text":"/* Game Of Life The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. Example developed starting from Toby Oxborrow's sketch https://github.com/tobyoxborrow/gameoflife-arduino/blob/master/GameOfLife.ino See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library // grid dimensions. should not be larger than 8x8 #define MAX_Y 8 #define MAX_X 12 // time to wait between turns #define TURN_DELAY 200 // how many turns per game before starting a new game // you can also use the reset button on the board #define TURNS_MAX 60 // number of patterns in predefined list #define MAX_PATTERNS 4 // how many turns to wait if there are no changes before starting a new game #define NO_CHANGES_RESET 4 int turns = 0; // counter for turns int noChanges = 0; // counter for turns without changes // game state. 0 is dead cell, 1 is live cell uint8_t grid[MAX_Y][MAX_X] = { {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, }; int currentPattern = 0; String patternNames[] = { \"Glider\", \"Light-weight spaceship\", \"R-Pentomino\", \"Diehard\" }; // custom starting grid patterns boolean cGrids[][MAX_Y][MAX_X] = { { /* Glider */ {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* Light-weight spaceship */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* R-Pentomino */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* Die hard */ {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} } }; ArduinoLEDMatrix matrix; void setup() { Serial.begin(9600); delay(1000); Serial.println(\"Conway's game of life on Arduino LED Matrix\"); matrix.begin(); resetGrid(); displayGrid(); } void loop() { delay(TURN_DELAY); playGoL(); turns++; // reset the grid if no changes have occured recently // for when the game enters a static stable state if (noChanges > NO_CHANGES_RESET) { resetGrid(); } // reset the grid if the loop has been running a long time // for when the game cycles between a few stable states if (turns > TURNS_MAX) { resetGrid(); } displayGrid(); } // play game of life void playGoL() { /* 1. Any live cell with fewer than two neighbours dies, as if by loneliness. 2. Any live cell with more than three neighbours dies, as if by overcrowding. 3. Any live cell with two or three neighbours lives, unchanged, to the next generation. 4. Any dead cell with exactly three neighbours comes to life. */ boolean newGrid[MAX_Y][MAX_X] = { {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { int neighboughs = countNeighbours(y, x); if (grid[y][x] == 1) { if ((neighboughs == 2) || (neighboughs == 3)) { newGrid[y][x] = 1; } else { newGrid[y][x] = 0; } } else { if (neighboughs == 3) { newGrid[y][x] = 1; } else { newGrid[y][x] = 0; } } } } // update the current grid from the new grid and count how many changes // occured int changes = 0; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { if (newGrid[y][x] != grid[y][x]) { changes++; } grid[y][x] = newGrid[y][x]; } } // update global counter when no changes occured if (changes == 0) { noChanges++; } } // count the number of neighbour live cells for a given cell int countNeighbours(int y, int x) { int count = 0; // -- Row above us --- if (y > 0) { // above left if (x > 0) { count += grid[y - 1][x - 1]; } // above count += grid[y - 1][x]; // above right if ((x + 1) < 8) { count += grid[y - 1][x + 1]; } } // -- Same row ------- // left if (x > 0) { count += grid[y][x - 1]; } // right if ((x + 1) < 8) { count += grid[y][x + 1]; } // -- Row below us --- if ((y + 1) < 8) { // below left if (x > 0) { count += grid[y + 1][x - 1]; } // below count += grid[y + 1][x]; // below right if ((x + 1) < 8) { count += grid[y + 1][x + 1]; } } return count; } // reset the grid void resetGrid() { Serial.print(\"Current pattern: \"); Serial.println(patternNames[currentPattern]); noChanges = 0; turns = 0; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { grid[y][x] = cGrids[currentPattern][y][x]; } } currentPattern++; if(currentPattern >= MAX_PATTERNS){ currentPattern = 0; } } // display the current grid to the LED matrix void displayGrid() { matrix.renderBitmap(grid, 8, 12); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_41","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#583-livepreview","text":"","title":"5.8.3 LivePreview"},{"location":"05_examples_uno_r4_wifi/#sketch-code_42","text":"/* This sketch allows live editing of the matrix pixels using WebSerial To test, head to https://ledmatrix-editor.arduino.cc The LED Matrix editor is part of Arduino Labs (https://labs.arduino.cc/), and is therefore considered experimental software. Don't forget to close any serial monitor already opened. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library ArduinoLEDMatrix matrix; // Create an instance of the ArduinoLEDMatrix class void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 matrix.begin(); // Initialize the LED matrix } // Define an array to hold pixel data for a single frame (4 pixels) uint32_t frame[] = { 0, 0, 0, 0xFFFF }; void loop() { // Check if there are at least 12 bytes available in the serial buffer if(Serial.available() >= 12){ // Read 4 bytes from the serial buffer and compose them into a 32-bit value for each element in the frame frame[0] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; frame[1] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; frame[2] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; // Load and display the received frame data on the LED matrix matrix.loadFrame(frame); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_42","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#584-matrixframebuffer","text":"","title":"5.8.4 MatrixFrameBuffer"},{"location":"05_examples_uno_r4_wifi/#sketch-code_43","text":"/* Matrix Frame Buffer This Arduino sketch demonstrates the creation and manipulation of a frame buffer for the LED matrix. The frame buffer is used to control the lighting of individual LEDs on the matrix, turning them randomly on and off. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ // Include the LED_Matrix library #include \"Arduino_LED_Matrix.h\" // Create an instance of the ArduinoLEDMatrix class ArduinoLEDMatrix matrix; // Define the frame array for the LED matrix with pixel values uint8_t frame[8][12] = { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 } }; // Set up time intervals and dimensions for the matrix unsigned long lastTickTime, lastGameTickTime; #define UPDATE_INTERVAL 100 #define GAME_UPDATE_INTERVAL 66 #define ROWS 8 #define COLUMNS 12 // Variables to track the current positions uint8_t pointX = 0, pointY = 0; void setup() { // Initialize serial communication and delaying for setup Serial.begin(115200); delay(1500); // Initialize the LED matrix matrix.begin(); // Initialize time tracking variables lastGameTickTime = lastTickTime = millis(); } void loop() { // Track the current time unsigned long msNow = millis(); // Update the game logic with a fixed interval if (msNow - lastGameTickTime > GAME_UPDATE_INTERVAL) { // Increment pointX and handling wraparound pointX++; if (pointX >= COLUMNS) { pointX = 0; pointY++; if (pointY >= ROWS) { pointY = 0; } } // Generate random positions and pixel value pointX = random(COLUMNS); pointY = random(ROWS); uint8_t pixelValue = random(2); // Update the frame with the new pixel value frame[pointY][pointX] = pixelValue; // Update the last game tick time lastGameTickTime = msNow; } // Render the LED matrix with the current frame at a fixed interval if (msNow - lastTickTime > UPDATE_INTERVAL) { matrix.renderBitmap(frame, 8, 12); // Update the last rendering tick time lastTickTime = msNow; } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_43","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#585-matrixintro","text":"","title":"5.8.5 MatrixIntro"},{"location":"05_examples_uno_r4_wifi/#sketch-code_44","text":"/* Heart Animation Sketch This is the default sketch that comes shipped with every UNO R4 WiFi board. After the animation (a heart) is complete, the built-in LED blinks infinitely. No additional circuit required. created 26 Jun 2023 by Martino Facchin See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ // include the LED Matrix library from the Uno R4 core: #include \"Arduino_LED_Matrix.h\" // make an instance of the library: ArduinoLEDMatrix matrix; //include the \"animation.h\" header file that stores the frames for the animation #include \"animation.h\" void setup() { Serial.begin(115200); //load frames from the animation.h file matrix.loadSequence(frames); // start the matrix matrix.begin(); // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds // matrix.autoscroll(300); //play the animation on the matrix matrix.play(true); //define LED_BUILTIN as an output pinMode(LED_BUILTIN, OUTPUT); } void loop() { //blinks the built-in LED every second digitalWrite(LED_BUILTIN, HIGH); delay(1000); digitalWrite(LED_BUILTIN, LOW); delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_44","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#586-playanimation","text":"","title":"5.8.6 PlayAnimation"},{"location":"05_examples_uno_r4_wifi/#sketch-code_45","text":"/* Play Animation Sketch shows animation defined in animation.h See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" //Include the LED_Matrix library #include \"animation.h\" //Include animation.h header file // Create an instance of the ArduinoLEDMatrix class ArduinoLEDMatrix matrix; void setup() { Serial.begin(115200); // you can also load frames at runtime, without stopping the refresh matrix.loadSequence(animation); matrix.begin(); // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds // matrix.autoscroll(300); matrix.play(true); } void loop() { delay(500); Serial.println(millis()); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_45","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#587-textwitharduinographics","text":"","title":"5.8.7 TextWithArduinoGraphics"},{"location":"05_examples_uno_r4_wifi/#sketch-code_46","text":"// To use ArduinoGraphics APIs, please include BEFORE Arduino_LED_Matrix #include \"ArduinoGraphics.h\" #include \"Arduino_LED_Matrix.h\" ArduinoLEDMatrix matrix; void setup() { Serial.begin(115200); matrix.begin(); matrix.beginDraw(); matrix.stroke(0xFFFFFFFF); // add some static text // will only show \"UNO\" (not enough space on the display) const char text[] = \"UNO r4\"; matrix.textFont(Font_4x6); matrix.beginText(0, 1, 0xFFFFFF); matrix.println(text); matrix.endText(); matrix.endDraw(); delay(2000); } void loop() { // Make it scroll! matrix.beginDraw(); matrix.stroke(0xFFFFFFFF); matrix.textScrollSpeed(50); // add the text const char text[] = \" Scrolling text! \"; matrix.textFont(Font_5x7); matrix.beginText(0, 1, 0xFFFFFF); matrix.println(text); matrix.endText(SCROLL_LEFT); matrix.endDraw(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_46","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-59-liquidcrystal","text":"","title":"Section 5.9: LiquidCrystal"},{"location":"05_examples_uno_r4_wifi/#591-autoscroll","text":"","title":"5.9.1 Autoscroll"},{"location":"05_examples_uno_r4_wifi/#sketch-code_47","text":"/* LiquidCrystal Library - Autoscroll Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch demonstrates the use of the autoscroll() and noAutoscroll() functions to make new text scroll or not. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalAutoscroll */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); } void loop() { // set the cursor to (0,0): lcd.setCursor(0, 0); // print from 0 to 9: for (int thisChar = 0; thisChar < 10; thisChar++) { lcd.print(thisChar); delay(500); } // set the cursor to (16,1): lcd.setCursor(16, 1); // set the display to automatically scroll: lcd.autoscroll(); // print from 0 to 9: for (int thisChar = 0; thisChar < 10; thisChar++) { lcd.print(thisChar); delay(500); } // turn off automatic scrolling lcd.noAutoscroll(); // clear screen for the next loop: lcd.clear(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_16","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_16","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_47","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#592-blink","text":"","title":"5.9.2 Blink"},{"location":"05_examples_uno_r4_wifi/#sketch-code_48","text":"/* LiquidCrystal Library - Blink Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and makes the cursor block blink. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalBlink */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the blinking cursor: lcd.noBlink(); delay(3000); // Turn on the blinking cursor: lcd.blink(); delay(3000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_17","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_17","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_48","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#593-cursor","text":"","title":"5.9.3 Cursor"},{"location":"05_examples_uno_r4_wifi/#sketch-code_49","text":"/* LiquidCrystal Library - Cursor Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the cursor() and noCursor() methods to turn on and off the cursor. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalCursor */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the cursor: lcd.noCursor(); delay(500); // Turn on the cursor: lcd.cursor(); delay(500); } `` #### [Fritzing] Circuit #### [KiCad] Schematic #### Video Demonstration [Fritzing]: https://fritzing.org/ [KiCad]: https://www.kicad.org/ [Arduino]: https://arduino.cc [Microcontroller]: https://en.wikipedia.org/wiki/Microcontroller ### 5.9.4 CustomCharacter #### Sketch Code ```C /* LiquidCrystal Library - Custom Characters Demonstrates how to add custom characters on an LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"I <heart> Arduino!\" and a little dancing man to the LCD. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K potentiometer: * ends to +5V and ground * wiper to LCD VO pin (pin 3) * 10K poterntiometer on pin A0 created 21 Mar 2011 by Tom Igoe modified 11 Nov 2013 by Scott Fitzgerald modified 7 Nov 2016 by Arturo Guadalupi Based on Adafruit's example at https://github.com/adafruit/SPI_VFD/blob/master/examples/createChar/createChar.pde This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalCustomCharacter Also useful: http://icontexto.com/charactercreator/ */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); // make some custom characters: byte heart[8] = { 0b00000, 0b01010, 0b11111, 0b11111, 0b11111, 0b01110, 0b00100, 0b00000 }; byte smiley[8] = { 0b00000, 0b00000, 0b01010, 0b00000, 0b00000, 0b10001, 0b01110, 0b00000 }; byte frownie[8] = { 0b00000, 0b00000, 0b01010, 0b00000, 0b00000, 0b00000, 0b01110, 0b10001 }; byte armsDown[8] = { 0b00100, 0b01010, 0b00100, 0b00100, 0b01110, 0b10101, 0b00100, 0b01010 }; byte armsUp[8] = { 0b00100, 0b01010, 0b00100, 0b10101, 0b01110, 0b00100, 0b00100, 0b01010 }; void setup() { // initialize LCD and set up the number of columns and rows: lcd.begin(16, 2); // create a new character lcd.createChar(0, heart); // create a new character lcd.createChar(1, smiley); // create a new character lcd.createChar(2, frownie); // create a new character lcd.createChar(3, armsDown); // create a new character lcd.createChar(4, armsUp); // set the cursor to the top left lcd.setCursor(0, 0); // Print a message to the lcd. lcd.print(\"I \"); lcd.write(byte(0)); // when calling lcd.write() '0' must be cast as a byte lcd.print(\" Arduino! \"); lcd.write((byte)1); } void loop() { // read the potentiometer on A0: int sensorReading = analogRead(A0); // map the result to 200 - 1000: int delayTime = map(sensorReading, 0, 1023, 200, 1000); // set the cursor to the bottom row, 5th position: lcd.setCursor(4, 1); // draw the little man, arms down: lcd.write(3); delay(delayTime); lcd.setCursor(4, 1); // draw him arms up: lcd.write(4); delay(delayTime); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_18","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_18","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_49","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#595-display","text":"","title":"5.9.5 Display"},{"location":"05_examples_uno_r4_wifi/#sketch-code_50","text":"/* LiquidCrystal Library - display() and noDisplay() Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the display() and noDisplay() functions to turn on and off the display. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalDisplay */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the display: lcd.noDisplay(); delay(500); // Turn on the display: lcd.display(); delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_19","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_19","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_50","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#596-helloworld","text":"","title":"5.9.6 HelloWorld"},{"location":"05_examples_uno_r4_wifi/#sketch-code_51","text":"/* LiquidCrystal Library - Hello World Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and shows the time. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * LCD VSS pin to ground * LCD VCC pin to 5V * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalHelloWorld */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // set the cursor to column 0, line 1 // (note: line 1 is the second row, since counting begins with 0): lcd.setCursor(0, 1); // print the number of seconds since reset: lcd.print(millis() / 1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_20","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_20","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_51","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#597-scroll","text":"","title":"5.9.7 Scroll"},{"location":"05_examples_uno_r4_wifi/#sketch-code_52","text":"/* LiquidCrystal Library - scrollDisplayLeft() and scrollDisplayRight() Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the scrollDisplayLeft() and scrollDisplayRight() methods to scroll the text. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalScroll */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); delay(1000); } void loop() { // scroll 13 positions (string length) to the left // to move it offscreen left: for (int positionCounter = 0; positionCounter < 13; positionCounter++) { // scroll one position left: lcd.scrollDisplayLeft(); // wait a bit: delay(150); } // scroll 29 positions (string length + display length) to the right // to move it offscreen right: for (int positionCounter = 0; positionCounter < 29; positionCounter++) { // scroll one position right: lcd.scrollDisplayRight(); // wait a bit: delay(150); } // scroll 16 positions (display length + string length) to the left // to move it back to center: for (int positionCounter = 0; positionCounter < 16; positionCounter++) { // scroll one position left: lcd.scrollDisplayLeft(); // wait a bit: delay(150); } // delay at the end of the full loop: delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_21","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_21","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_52","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#598-serialdisplay","text":"","title":"5.9.8 SerialDisplay"},{"location":"05_examples_uno_r4_wifi/#sketch-code_53","text":"/* LiquidCrystal Library - Serial Input Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch displays text sent over the serial port (e.g. from the Serial Monitor) on an attached LCD. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalSerialDisplay */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // initialize the serial communications: Serial.begin(9600); } void loop() { // when characters arrive over the serial port... if (Serial.available()) { // wait a bit for the entire message to arrive delay(100); // clear the screen lcd.clear(); // read all the available characters while (Serial.available() > 0) { // display each character to the LCD lcd.write(Serial.read()); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_22","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_22","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_53","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#599-setcursor","text":"","title":"5.9.9 setCursor"},{"location":"05_examples_uno_r4_wifi/#sketch-code_54","text":"/* LiquidCrystal Library - setCursor Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints to all the positions of the LCD using the setCursor() method: The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalSetCursor */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); // these constants won't change. But you can change the size of // your LCD using them: const int numRows = 2; const int numCols = 16; void setup() { // set up the LCD's number of columns and rows: lcd.begin(numCols, numRows); } void loop() { // loop from ASCII 'a' to ASCII 'z': for (int thisLetter = 'a'; thisLetter <= 'z'; thisLetter++) { // loop over the columns: for (int thisRow = 0; thisRow < numRows; thisRow++) { // loop over the rows: for (int thisCol = 0; thisCol < numCols; thisCol++) { // set the cursor position: lcd.setCursor(thisCol, thisRow); // print the letter: lcd.write(thisLetter); delay(200); } } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_23","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_23","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_54","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5910-textdirection","text":"","title":"5.9.10 TextDirection"},{"location":"05_examples_uno_r4_wifi/#sketch-code_55","text":"/* LiquidCrystal Library - TextDirection Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch demonstrates how to use leftToRight() and rightToLeft() to move the cursor. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalTextDirection */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); int thisChar = 'a'; void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // turn on the cursor: lcd.cursor(); } void loop() { // reverse directions at 'm': if (thisChar == 'm') { // go right for the next letter lcd.rightToLeft(); } // reverse again at 's': if (thisChar == 's') { // go left for the next letter lcd.leftToRight(); } // reset at 'z': if (thisChar > 'z') { // go to (0,0): lcd.home(); // start again at 0 thisChar = 'a'; } // print the character lcd.write(thisChar); // wait a second: delay(1000); // increment the letter: thisChar++; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_24","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_24","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_55","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-510-opamp","text":"Note No additional circuit is required for this section 5.10 .","title":"Section 5.10: OPAMP"},{"location":"05_examples_uno_r4_wifi/#5101-start_opamp","text":"","title":"5.10.1 start_opamp"},{"location":"05_examples_uno_r4_wifi/#sketch-code_56","text":"#include <OPAMP.h> void setup () { Serial.begin(9600); delay(2000); // serial monitor delay // activate OPAMP, default channel 0 // Plus: Analog A1 // Minus: Analog A2 // Output: Analog A3 if (!OPAMP.begin(OPAMP_SPEED_HIGHSPEED)) { Serial.println(\"Failed to start OPAMP!\"); } bool const isRunning = OPAMP.isRunning(0); if (isRunning) { Serial.println(\"OPAMP running on channel 0!\"); } else { Serial.println(\"OPAMP channel 0 is not running!\"); } } void loop() { delay(1000); // do nothing }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_56","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-511-otaupdate","text":"Note No additional circuit is required for this section 5.11 .","title":"Section 5.11: OTAUpdate"},{"location":"05_examples_uno_r4_wifi/#5111-ota","text":"","title":"5.11.1 OTA"},{"location":"05_examples_uno_r4_wifi/#sketch-code_57","text":"/* OTA This sketch demonstrates how to make an OTA Update on the UNO R4 WiFi. Upload the sketch and wait for the invasion! */ #include \"WiFiS3.h\" #include \"OTAUpdate.h\" #include \"root_ca.h\" #include \"arduino_secrets.h\" char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; OTAUpdate ota; static char const OTA_FILE_LOCATION[] = \"https://downloads.arduino.cc/ota/UNOR4WIFI_Animation.ota\"; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the Wi-Fi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with Wi-Fi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to Wi-Fi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 1 seconds for connection: delay(1000); } printWiFiStatus(); OTAUpdate::Error ret = OTAUpdate::Error::None; ret = ota.begin(\"/update.bin\"); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.begin() error: \"); Serial.println((int)ret); return; } ret = ota.setCACert(root_ca); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.setCACert() error: \"); Serial.println((int)ret); return; } int ota_size = ota.download(OTA_FILE_LOCATION, \"/update.bin\"); if(ota_size <= 0) { Serial.println(\"ota.download() error: \"); Serial.println(ota_size); return; } ret = ota.verify(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.verify() error: \"); Serial.println((int)ret); return; } ret = ota.update(\"/update.bin\"); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.update() error: \"); Serial.println((int)ret); return; } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ delay(1000); } /* -------------------------------------------------------------------------- */ void printWiFiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_57","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5112-wififirmwareota","text":"","title":"5.11.2 WiFiFirmwareOTA"},{"location":"05_examples_uno_r4_wifi/#sketch-code_58","text":"/* OTA This sketch demonstrates how to make the UNO R4 WiFi self-update its Wi-Fi module firmware via OTA. Upload the Sketch and wait for Serial detach. After the update the new Wi-Fi firmware version will be 98.98.98 WARNING: running this sketch will load a test Wi-Fi firmware version on the UNO R4 WiFi module. To restore a production firmware use the Arduino Firmware Uploader or the update packages available here: https://github.com/arduino/uno-r4-wifi-usb-bridge/releases */ #include \"WiFiS3.h\" #include \"OTAUpdate.h\" #include \"root_ca.h\" #include \"arduino_secrets.h\" char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; OTAUpdate ota; static char const OTA_FILE_LOCATION[] = \"https://downloads.arduino.cc/ota/UNOR4USBBridge.ino.ota\"; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the Wi-Fi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with Wi-Fi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } Serial.print(\"Current Wi-Fi firmware version: \"); Serial.println(fv); // attempt to connect to Wi-Fi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 1 seconds for connection: delay(1000); } printWiFiStatus(); OTAUpdate::Error ret = OTAUpdate::Error::None; ret = ota.begin(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.begin() error: \"); Serial.println((int)ret); return; } ret = ota.setCACert(root_ca); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.setCACert() error: \"); Serial.println((int)ret); return; } int ota_size = ota.download(OTA_FILE_LOCATION); if(ota_size <= 0) { Serial.println(\"ota.download() error: \"); Serial.println(ota_size); return; } ret = ota.verify(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.verify() error: \"); Serial.println((int)ret); return; } ret = ota.update(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.update() error: \"); Serial.println((int)ret); return; } ret = ota.reset(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.reset() error: \"); Serial.println((int)ret); return; } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ String fv = WiFi.firmwareVersion(); Serial.print(\"Updated Wi-Fi firmware version: \"); Serial.println(fv); delay(1000); } /* -------------------------------------------------------------------------- */ void printWiFiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_58","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-512-rtc","text":"Note No additional circuit is required for this section 5.12 .","title":"Section 5.12: RTC"},{"location":"05_examples_uno_r4_wifi/#5121-rtc_alarm","text":"","title":"5.12.1 RTC_Alarm"},{"location":"05_examples_uno_r4_wifi/#sketch-code_59","text":"/* * RTC_Alarm * * This example demonstrates how to use the alarm functionality of the RTC * (Real Time Clock) on the Portenta C33 and UNO R4 Minima / WiFi. * * It turns on the built-in LED when the alarm * is triggered, which is once every minute in this example. * In addition, inside the loop, we print the state of the alarm * continuously, which is either 0 (LOW) or 1 (HIGH). * * Note that the Portenta C33's LED is inverted and will be lit when * the state is 0 (LOW). * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ unsigned long previousMillis = 0; const long interval = 1000; bool ledState = false; // Include the RTC library #include \"RTC.h\" void setup() { //initialize Serial Communication Serial.begin(9600); //define LED as output pinMode(LED_BUILTIN, OUTPUT); // Initialize the RTC RTC.begin(); // RTC.setTime() must be called for RTC.setAlarmCallback to work, but it doesn't matter // what date and time it's set to in this example RTCTime initialTime(7, Month::JUNE, 2023, 13, 03, 00, DayOfWeek::WEDNESDAY, SaveLight::SAVING_TIME_ACTIVE); RTC.setTime(initialTime); // Trigger the alarm every time the seconds are zero RTCTime alarmTime; alarmTime.setSecond(0); // Make sure to only match on the seconds in this example - not on any other parts of the date/time AlarmMatch matchTime; matchTime.addMatchSecond(); //sets the alarm callback RTC.setAlarmCallback(alarmCallback, alarmTime, matchTime); } void loop() { // in the loop, we continuously print the alarm's current state // this is for debugging only and has no effect on the alarm whatsoever unsigned long currentMillis = millis(); if (currentMillis - previousMillis >= interval) { // save the last time you blinked the LED previousMillis = currentMillis; Serial.print(\"Alarm state: \"); Serial.println(ledState); } } // this function activates every minute // and changes the ledState boolean void alarmCallback() { if (!ledState) { digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } ledState = !ledState; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_59","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5122-rtc_automaticexample","text":"","title":"5.12.2 RTC_AutomaticExample"},{"location":"05_examples_uno_r4_wifi/#sketch-code_60","text":"/* * RTC_AutomaticExample * * This example sets the RTC (Real Time Clock) on the Portenta C33 automatically by * retrieving the date and time from the computer you upload the sketch from, at the * point when you start the upload. * * Next, it gets the current time from the RTC and prints it to the Serial Monitor. * It then sets an RTC alarm to fire every time the seconds value of the time is zero. * The alarm, which now goes off once a minute, triggers a callback that prints the * current time to the Serial Monitor. * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" DayOfWeek convertDayOfWeek(String s) { if (s == String(\"Mon\")) { return DayOfWeek::MONDAY; } if (s == String(\"Tue\")) { return DayOfWeek::TUESDAY; } if (s == String(\"Wed\")) { return DayOfWeek::WEDNESDAY; } if (s == String(\"Thu\")) { return DayOfWeek::THURSDAY; } if (s == String(\"Fri\")) { return DayOfWeek::FRIDAY; } if (s == String(\"Sat\")) { return DayOfWeek::SATURDAY; } if (s == String(\"Sun\")) { return DayOfWeek::SUNDAY; } } Month convertMonth(String s) { if (s == String(\"Jan\")) { return Month::JANUARY; } if (s == String(\"Feb\")) { return Month::FEBRUARY; } if (s == String(\"Mar\")) { return Month::MARCH; } if (s == String(\"Apr\")) { return Month::APRIL; } if (s == String(\"May\")) { return Month::MAY; } if (s == String(\"Jun\")) { return Month::JUNE; } if (s == String(\"Jul\")) { return Month::JULY; } if (s == String(\"Aug\")) { return Month::AUGUST; } if (s == String(\"Sep\")) { return Month::SEPTEMBER; } if (s == String(\"Oct\")) { return Month::OCTOBER; } if (s == String(\"Nov\")) { return Month::NOVEMBER; } if (s == String(\"Dec\")) { return Month::DECEMBER; } } RTCTime currentRTCTime() { // Get a compilation timestamp of the format: Wed May 10 08:54:31 2023 // __TIMESTAMP__ is a GNU C extension macro // We can't use the standard macros __DATE__ and __TIME__ because they don't provide the day of the week String timeStamp = __TIMESTAMP__; // Extract the day of the week int pos1 = timeStamp.indexOf(\" \"); DayOfWeek dayOfWeek = convertDayOfWeek(timeStamp.substring(0, pos1)); // Extract the month ++pos1; int pos2 = timeStamp.indexOf(\" \", pos1); Month month = convertMonth(timeStamp.substring(pos1, pos2)); // Extract the day pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int day = timeStamp.substring(pos1, pos2).toInt(); // Extract the hour pos1 = ++pos2; pos2 = timeStamp.indexOf(\":\", pos1); int hour = timeStamp.substring(pos1, pos2).toInt(); // Extract the minute pos1 = ++pos2; pos2 = timeStamp.indexOf(\":\", pos1); int minute = timeStamp.substring(pos1, pos2).toInt(); // Extract the second pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int second = timeStamp.substring(pos1, pos2).toInt(); // Extract the year pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int year = timeStamp.substring(pos1, pos2).toInt(); return RTCTime(day, month, year, hour, minute, second, dayOfWeek, SaveLight::SAVING_TIME_INACTIVE); } void alarmCallback() { Serial.println(\"An alarm was triggered at:\"); RTCTime currentTime; RTC.getTime(currentTime); Serial.print(currentTime.getYear()); Serial.print(\"-\"); Serial.print(Month2int(currentTime.getMonth())); Serial.print(\"-\"); Serial.print(currentTime.getDayOfMonth()); Serial.print(\" \"); Serial.print(currentTime.getHour()); Serial.print(\":\"); Serial.print(currentTime.getMinutes()); Serial.print(\":\"); Serial.println(currentTime.getSeconds()); } void setup() { Serial.begin(9600); while (!Serial) ; // Initialize the RTC RTC.begin(); // Get the current date and time when the sketch is uploaded and set the RTC RTCTime timeToSet = currentRTCTime(); RTC.setTime(timeToSet); // Retrieve the date and time from the RTC and print them Serial.println(\"The RTC was just set to: \"); RTCTime currentTime; RTC.getTime(currentTime); Serial.print(currentTime.getYear()); Serial.print(\"-\"); Serial.print(Month2int(currentTime.getMonth())); Serial.print(\"-\"); Serial.print(currentTime.getDayOfMonth()); Serial.print(\" \"); Serial.print(currentTime.getHour()); Serial.print(\":\"); Serial.print(currentTime.getMinutes()); Serial.print(\":\"); Serial.println(currentTime.getSeconds()); // Create an alarm time with the seconds value set to zero RTCTime alarmTime; alarmTime.setSecond(0); // Tell the RTC to only match on the seconds value AlarmMatch alarmMatch; alarmMatch.addMatchSecond(); // Set the alarm callback function RTC.setAlarmCallback(alarmCallback, alarmTime, alarmMatch); } void loop() { }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_60","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5123-rtc_ntpsync","text":"","title":"5.12.3 RTC_NTPSync"},{"location":"05_examples_uno_r4_wifi/#sketch-code_61","text":"/** * RTC_NTPSync * * This example shows how to set the RTC (Real Time Clock) on the Portenta C33 / UNO R4 WiFi * to the current date and time retrieved from an NTP server on the Internet (pool.ntp.org). * Then the current time from the RTC is printed to the Serial port. * * Instructions: * 1. Download the NTPClient library (https://github.com/arduino-libraries/NTPClient) through the Library Manager * 2. Change the WiFi credentials in the arduino_secrets.h file to match your WiFi network. * 3. Upload this sketch to Portenta C33 / UNO R4 WiFi. * 4. Open the Serial Monitor. * * Initial author: Sebastian Romero @sebromero * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" //Include the NTP library #include <NTPClient.h> #if defined(ARDUINO_PORTENTA_C33) #include <WiFiC3.h> #elif defined(ARDUINO_UNOWIFIR4) #include <WiFiS3.h> #endif #include <WiFiUdp.h> #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int wifiStatus = WL_IDLE_STATUS; WiFiUDP Udp; // A UDP instance to let us send and receive packets over UDP NTPClient timeClient(Udp); void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } void connectToWiFi(){ // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (wifiStatus != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: wifiStatus = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } Serial.println(\"Connected to WiFi\"); printWifiStatus(); } void setup(){ Serial.begin(9600); while (!Serial); connectToWiFi(); RTC.begin(); Serial.println(\"\\nStarting connection to server...\"); timeClient.begin(); timeClient.update(); // Get the current date and time from an NTP server and convert // it to UTC +2 by passing the time zone offset in hours. // You may change the time zone offset to your local one. auto timeZoneOffsetHours = 2; auto unixTime = timeClient.getEpochTime() + (timeZoneOffsetHours * 3600); Serial.print(\"Unix time = \"); Serial.println(unixTime); RTCTime timeToSet = RTCTime(unixTime); RTC.setTime(timeToSet); // Retrieve the date and time from the RTC and print them RTCTime currentTime; RTC.getTime(currentTime); Serial.println(\"The RTC was just set to: \" + String(currentTime)); } void loop(){}","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_61","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5124-rtc_periodicexample","text":"","title":"5.12.4 RTC_PeriodicExample"},{"location":"05_examples_uno_r4_wifi/#sketch-code_62","text":"/* * RTC_PeriodicExample * * This example demonstrates how to use the periodic callback functionality of the RTC * (Real Time Clock) on the Portenta C33. * * It blinks the built-in LED at progressively faster and slower rates repeatedly. * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" #define BLINK_DELAY 2000 // This is the callback function to be passed to RTC.setPeriodicCallback() void periodicCallback() { static bool ledState = false; if (ledState == true) { digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } ledState = !ledState; } void setup() { pinMode(LED_BUILTIN, OUTPUT); // Initialize the RTC RTC.begin(); // RTC.setTime() must be called for RTC.setPeriodicCallback to work, but it doesn't matter // what date and time it's set to RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE); RTC.setTime(mytime); } void loop() { RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N32_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC); delay(BLINK_DELAY); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_62","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5125-test_rtc","text":"","title":"5.12.5 Test_RTC"},{"location":"05_examples_uno_r4_wifi/#sketch-code_63","text":"/* Test RTC A test sketch showcasing all RTC showcasing various functionalities related to the RTC module, including setting the time, handling interrupts, and reading time values. Find the full UNO R4 WiFi RTC documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" // Define the interrupt pin for LED control during interrupts const int LED_ON_INTERRUPT = 22; // Callback function for periodic interrupt void periodic_cbk() { static bool clb_st = false; // Toggle the LED based on callback state if (clb_st) { digitalWrite(LED_ON_INTERRUPT, HIGH); } else { digitalWrite(LED_ON_INTERRUPT, LOW); } clb_st = !clb_st; // Toggle callback state // Print message indicating periodic interrupt Serial.println(\"PERIODIC INTERRUPT\"); } void alarm_cbk() { Serial.println(\"ALARM INTERRUPT\"); } // Callback function for alarm interrupt void setup() { // Initialize serial communication Serial.begin(9600); // Wait for serial connection while (!Serial) { } // Set LED pins as outputs pinMode(LED_BUILTIN, OUTPUT); pinMode(LED_ON_INTERRUPT, OUTPUT); // Initialize the RTC RTC.begin(); // Set a specific initial time (August 25, 2022, 14:37:00 Thursday) RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE); RTCTime savedTime; RTC.getTime(savedTime); // Set the initial time if RTC is not running if (!RTC.isRunning()) { if (savedTime.getYear() != 2000) { RTC.setTime(mytime); } else { RTC.setTime(savedTime); } } // Create an alarm time set to 35 seconds RTCTime alarmtime; alarmtime.setSecond(35); // Create an AlarmMatch object to match seconds AlarmMatch am; am.addMatchSecond(); // Set the periodic callback function to run once every 2 seconds if (!RTC.setPeriodicCallback(periodic_cbk, Period::ONCE_EVERY_2_SEC)) { Serial.println(\"ERROR: periodic callback not set\"); } // Set the alarm callback function with the alarm time and matching condition if (!RTC.setAlarmCallback(alarm_cbk, alarmtime, am)) { Serial.println(\"ERROR: alarm callback not set\"); } } void loop() { static bool status = false; RTCTime currenttime; // Check if RTC is running and print status if (status) { // Toggle LED and display RTC status if 'status' is true if (RTC.isRunning()) { Serial.println(\"RTC is running\"); } else { Serial.println(\"RTC is not running\"); } /* GET CURRENT TIME FROM RTC */ RTC.getTime(currenttime); /* PRINT CURRENT TIME on Serial */ Serial.print(\"Current time: \"); /* DATE */ Serial.print(currenttime.getDayOfMonth()); Serial.print(\"/\"); Serial.print(Month2int(currenttime.getMonth())); Serial.print(\"/\"); Serial.print(currenttime.getYear()); Serial.print(\" - \"); /* ORE:MINUTI:SECONDI */ Serial.print(currenttime.getHour()); Serial.print(\":\"); Serial.print(currenttime.getMinutes()); Serial.print(\":\"); Serial.println(currenttime.getSeconds()); digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } status = !status; delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_63","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-513-sd","text":"","title":"Section 5.13: SD"},{"location":"05_examples_uno_r4_wifi/#5131-cardinfo","text":"","title":"5.13.1 CardInfo"},{"location":"05_examples_uno_r4_wifi/#sketch-code_64","text":"/* SD card test This example shows how use the utility libraries on which the' SD library is based in order to get info about your SD card. Very useful for testing a card when you're not sure whether its working or not. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila ** CS - depends on your SD card shield or module. Pin 4 used here for consistency with other Arduino examples created 28 Mar 2011 by Limor Fried modified 9 Apr 2012 by Tom Igoe */ // include the SD library: #include <SPI.h> #include <SD.h> // set up variables using the SD utility library functions: Sd2Card card; SdVolume volume; SdFile root; // change this to match your SD shield or module; // Arduino Ethernet shield: pin 4 // Adafruit SD shields and modules: pin 10 // Sparkfun SD shield: pin 8 // MKRZero SD: SDCARD_SS_PIN const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"\\nInitializing SD card...\"); // we'll use the initialization code from the utility libraries // since we're just testing if the card is working! if (!card.init(SPI_HALF_SPEED, chipSelect)) { Serial.println(\"initialization failed. Things to check:\"); Serial.println(\"* is a card inserted?\"); Serial.println(\"* is your wiring correct?\"); Serial.println(\"* did you change the chipSelect pin to match your shield or module?\"); while (1); } else { Serial.println(\"Wiring is correct and a card is present.\"); } // print the type of card Serial.println(); Serial.print(\"Card type: \"); switch (card.type()) { case SD_CARD_TYPE_SD1: Serial.println(\"SD1\"); break; case SD_CARD_TYPE_SD2: Serial.println(\"SD2\"); break; case SD_CARD_TYPE_SDHC: Serial.println(\"SDHC\"); break; default: Serial.println(\"Unknown\"); } // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32 if (!volume.init(card)) { Serial.println(\"Could not find FAT16/FAT32 partition.\\nMake sure you've formatted the card\"); while (1); } Serial.print(\"Clusters: \"); Serial.println(volume.clusterCount()); Serial.print(\"Blocks x Cluster: \"); Serial.println(volume.blocksPerCluster()); Serial.print(\"Total Blocks: \"); Serial.println(volume.blocksPerCluster() * volume.clusterCount()); Serial.println(); // print the type and size of the first FAT-type volume uint32_t volumesize; Serial.print(\"Volume type is: FAT\"); Serial.println(volume.fatType(), DEC); volumesize = volume.blocksPerCluster(); // clusters are collections of blocks volumesize *= volume.clusterCount(); // we'll have a lot of clusters volumesize /= 2; // SD card blocks are always 512 bytes (2 blocks are 1KB) Serial.print(\"Volume size (Kb): \"); Serial.println(volumesize); Serial.print(\"Volume size (Mb): \"); volumesize /= 1024; Serial.println(volumesize); Serial.print(\"Volume size (Gb): \"); Serial.println((float)volumesize / 1024.0); Serial.println(\"\\nFiles found on the card (name, date and size in bytes): \"); root.openRoot(volume); // list all files in the card with date and size root.ls(LS_R | LS_DATE | LS_SIZE); } void loop(void) { }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_25","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_25","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_64","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5132-cardinfo","text":"","title":"5.13.2 CardInfo"},{"location":"05_examples_uno_r4_wifi/#sketch-code_65","text":"/* SD card test This example shows how use the utility libraries on which the' SD library is based in order to get info about your SD card. Very useful for testing a card when you're not sure whether its working or not. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila ** CS - depends on your SD card shield or module. Pin 4 used here for consistency with other Arduino examples created 28 Mar 2011 by Limor Fried modified 9 Apr 2012 by Tom Igoe */ // include the SD library: #include <SPI.h> #include <SD.h> // set up variables using the SD utility library functions: Sd2Card card; SdVolume volume; SdFile root; // change this to match your SD shield or module; // Arduino Ethernet shield: pin 4 // Adafruit SD shields and modules: pin 10 // Sparkfun SD shield: pin 8 // MKRZero SD: SDCARD_SS_PIN const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"\\nInitializing SD card...\"); // we'll use the initialization code from the utility libraries // since we're just testing if the card is working! if (!card.init(SPI_HALF_SPEED, chipSelect)) { Serial.println(\"initialization failed. Things to check:\"); Serial.println(\"* is a card inserted?\"); Serial.println(\"* is your wiring correct?\"); Serial.println(\"* did you change the chipSelect pin to match your shield or module?\"); while (1); } else { Serial.println(\"Wiring is correct and a card is present.\"); } // print the type of card Serial.println(); Serial.print(\"Card type: \"); switch (card.type()) { case SD_CARD_TYPE_SD1: Serial.println(\"SD1\"); break; case SD_CARD_TYPE_SD2: Serial.println(\"SD2\"); break; case SD_CARD_TYPE_SDHC: Serial.println(\"SDHC\"); break; default: Serial.println(\"Unknown\"); } // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32 if (!volume.init(card)) { Serial.println(\"Could not find FAT16/FAT32 partition.\\nMake sure you've formatted the card\"); while (1); } Serial.print(\"Clusters: \"); Serial.println(volume.clusterCount()); Serial.print(\"Blocks x Cluster: \"); Serial.println(volume.blocksPerCluster()); Serial.print(\"Total Blocks: \"); Serial.println(volume.blocksPerCluster() * volume.clusterCount()); Serial.println(); // print the type and size of the first FAT-type volume uint32_t volumesize; Serial.print(\"Volume type is: FAT\"); Serial.println(volume.fatType(), DEC); volumesize = volume.blocksPerCluster(); // clusters are collections of blocks volumesize *= volume.clusterCount(); // we'll have a lot of clusters volumesize /= 2; // SD card blocks are always 512 bytes (2 blocks are 1KB) Serial.print(\"Volume size (Kb): \"); Serial.println(volumesize); Serial.print(\"Volume size (Mb): \"); volumesize /= 1024; Serial.println(volumesize); Serial.print(\"Volume size (Gb): \"); Serial.println((float)volumesize / 1024.0); Serial.println(\"\\nFiles found on the card (name, date and size in bytes): \"); root.openRoot(volume); // list all files in the card with date and size root.ls(LS_R | LS_DATE | LS_SIZE); } void loop(void) { }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_26","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_26","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_65","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5133-datalogger","text":"","title":"5.13.3 Datalogger"},{"location":"05_examples_uno_r4_wifi/#sketch-code_66","text":"/* SD card datalogger This example shows how to log data from three analog sensors to an SD card using the SD library. The circuit: analog sensors on analog ins 0, 1, and 2 SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created 24 Nov 2010 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); // see if the card is present and can be initialized: if (!SD.begin(chipSelect)) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } Serial.println(\"card initialized.\"); } void loop() { // make a string for assembling the data to log: String dataString = \"\"; // read three sensors and append to the string: for (int analogPin = 0; analogPin < 3; analogPin++) { int sensor = analogRead(analogPin); dataString += String(sensor); if (analogPin < 2) { dataString += \",\"; } } // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. File dataFile = SD.open(\"datalog.txt\", FILE_WRITE); // if the file is available, write to it: if (dataFile) { dataFile.println(dataString); dataFile.close(); // print to the serial port too: Serial.println(dataString); } // if the file isn't open, pop up an error: else { Serial.println(\"error opening datalog.txt\"); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_27","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_27","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_66","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5134-dumpfile","text":"","title":"5.13.4 DumpFile"},{"location":"05_examples_uno_r4_wifi/#sketch-code_67","text":"/* SD card file dump This example shows how to read a file from the SD card using the SD library and send it over the serial port. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created 22 December 2010 by Limor Fried modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); // see if the card is present and can be initialized: if (!SD.begin(chipSelect)) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } Serial.println(\"card initialized.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. File dataFile = SD.open(\"datalog.txt\"); // if the file is available, write to it: if (dataFile) { while (dataFile.available()) { Serial.write(dataFile.read()); } dataFile.close(); } // if the file isn't open, pop up an error: else { Serial.println(\"error opening datalog.txt\"); } } void loop() { }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_28","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_28","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_67","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5135-files","text":"","title":"5.13.5 Files"},{"location":"05_examples_uno_r4_wifi/#sketch-code_68","text":"/* SD card basic file example This example shows how to create and destroy an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } // open a new file and immediately close it: Serial.println(\"Creating example.txt...\"); myFile = SD.open(\"example.txt\", FILE_WRITE); myFile.close(); // Check to see if the file exists: if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } // delete the file: Serial.println(\"Removing example.txt...\"); SD.remove(\"example.txt\"); if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } } void loop() { // nothing happens after setup finishes. }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_29","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_29","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_68","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5136-nonblockingwrite","text":"","title":"5.13.6 NonBlockingWrite"},{"location":"05_examples_uno_r4_wifi/#sketch-code_69","text":"/* Non-blocking Write This example demonstrates how to perform non-blocking writes to a file on a SD card. The file will contain the current millis() value every 10ms. If the SD card is busy, the data will be buffered in order to not block the sketch. NOTE: myFile.availableForWrite() will automatically sync the file contents as needed. You may lose some unsynced data still if myFile.sync() or myFile.close() is not called. The circuit: - Arduino MKR Zero board - micro SD card attached This example code is in the public domain. */ #include <SD.h> // file name to use for writing const char filename[] = \"demo.txt\"; // File object to represent file File txtFile; // string to buffer output String buffer; unsigned long lastMillis = 0; void setup() { Serial.begin(9600); while (!Serial); // reserve 1kB for String used as a buffer buffer.reserve(1024); // set LED pin to output, used to blink when writing pinMode(LED_BUILTIN, OUTPUT); // init the SD card if (!SD.begin()) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } // If you want to start from an empty file, // uncomment the next line: // SD.remove(filename); // try to open the file for writing txtFile = SD.open(filename, FILE_WRITE); if (!txtFile) { Serial.print(\"error opening \"); Serial.println(filename); while (1); } // add some new lines to start txtFile.println(); txtFile.println(\"Hello World!\"); } void loop() { // check if it's been over 10 ms since the last line added unsigned long now = millis(); if ((now - lastMillis) >= 10) { // add a new line to the buffer buffer += \"Hello \"; buffer += now; buffer += \"\\r\\n\"; lastMillis = now; } // check if the SD card is available to write data without blocking // and if the buffered data is enough for the full chunk size unsigned int chunkSize = txtFile.availableForWrite(); if (chunkSize && buffer.length() >= chunkSize) { // write to file and blink LED digitalWrite(LED_BUILTIN, HIGH); txtFile.write(buffer.c_str(), chunkSize); digitalWrite(LED_BUILTIN, LOW); // remove written data from buffer buffer.remove(0, chunkSize); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_30","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_30","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_69","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5137-readwrite","text":"","title":"5.13.7 ReadWrite"},{"location":"05_examples_uno_r4_wifi/#sketch-code_70","text":"/* SD card read/write This example shows how to read and write data to and from an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. myFile = SD.open(\"test.txt\", FILE_WRITE); // if the file opened okay, write to it: if (myFile) { Serial.print(\"Writing to test.txt...\"); myFile.println(\"testing 1, 2, 3.\"); // close the file: myFile.close(); Serial.println(\"done.\"); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } // re-open the file for reading: myFile = SD.open(\"test.txt\"); if (myFile) { Serial.println(\"test.txt:\"); // read from the file until there's nothing else in it: while (myFile.available()) { Serial.write(myFile.read()); } // close the file: myFile.close(); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } } void loop() { // nothing happens after setup } /* SD card read/write This example shows how to read and write data to and from an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. myFile = SD.open(\"test.txt\", FILE_WRITE); // if the file opened okay, write to it: if (myFile) { Serial.print(\"Writing to test.txt...\"); myFile.println(\"testing 1, 2, 3.\"); // close the file: myFile.close(); Serial.println(\"done.\"); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } // re-open the file for reading: myFile = SD.open(\"test.txt\"); if (myFile) { Serial.println(\"test.txt:\"); // read from the file until there's nothing else in it: while (myFile.available()) { Serial.write(myFile.read()); } // close the file: myFile.close(); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } } void loop() { // nothing happens after setup }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_31","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_31","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_70","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-514-sdu","text":"","title":"Section 5.14: SDU"},{"location":"05_examples_uno_r4_wifi/#5141-usage","text":"","title":"5.14.1 Usage"},{"location":"05_examples_uno_r4_wifi/#sketch-code_71","text":"/* Usage This example demonstrates how to use the UNO R4 SDU library to update a sketch on an Arduino UNO R4 (WiFi, Minima) board using an SD card. It prints out the date and time the sketch was compiled at to both Serial and Serial1. Circuit: * Arduino UNO R4 Minima or WiFi board * SD shield or breakout connected with CS pin of 4 * SD card Non-Arduino UNO R4 board are NOT supported. Steps to update sketch via SD card: 1) Upload this sketch or another sketch that includes the SDU library via #include <SDU.h> 2) Update the sketch as desired. For this example the sketch prints out the compiled date and time so no updates are needed. 3) In the IDE select: Sketch -> Export Compiled Binary 4) Copy the .bin file from the sketch's folder to the SD card and rename the file to UPDATE.bin. Eject the SD card from your PC. 5) Insert the SD card into the board, shield or breakout and press the reset button or power cycle the board. The SDU library will then update the sketch on the board with the contents of UPDATE.bin created 23 March 2017 by Sandeep Mistry */ /* Include the SDU library This will add some code to the sketch before setup() is called to check if an SD card is present and UPDATE.bin exists on the SD card. If UPDATE.bin is present, the file is used to update the sketch running on the board. After this UPDATE.bin is deleted from the SD card. */ #include <SDU.h> String message; void setup() { Serial.begin(115200); // Wait for Serial Monitor connection while (!Serial.available()) { Serial.println(\"Send any key.\"); delay(1000); } message += \"Sketch compile date and time: \"; message += __DATE__; message += \" \"; message += __TIME__; // print out the sketch compile date and time on the serial port Serial.println(message); } void loop() { // add you own code here }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_32","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_32","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_71","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-515-servo","text":"","title":"Section 5.15: Servo"},{"location":"05_examples_uno_r4_wifi/#5151-knob","text":"","title":"5.15.1 Knob"},{"location":"05_examples_uno_r4_wifi/#sketch-code_72","text":"/* Controlling a servo position using a potentiometer (variable resistor) by Michal Rinott <http://people.interaction-ivrea.it/m.rinott> modified on 8 Nov 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/Knob */ #include <Servo.h> Servo myservo; // create servo object to control a servo int potpin = A0; // analog pin used to connect the potentiometer int val; // variable to read the value from the analog pin void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { val = analogRead(potpin); // reads the value of the potentiometer (value between 0 and 1023) val = map(val, 0, 1023, 0, 180); // scale it for use with the servo (value between 0 and 180) myservo.write(val); // sets the servo position according to the scaled value delay(15); // waits for the servo to get there }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_33","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_33","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_72","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5152-sweep","text":"","title":"5.15.2 Sweep"},{"location":"05_examples_uno_r4_wifi/#sketch-code_73","text":"/* Sweep by BARRAGAN <http://barraganstudio.com> This example code is in the public domain. modified 8 Nov 2013 by Scott Fitzgerald https://www.arduino.cc/en/Tutorial/LibraryExamples/Sweep */ #include <Servo.h> Servo myservo; // create servo object to control a servo // twelve servo objects can be created on most boards int pos = 0; // variable to store the servo position void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { for (pos = 0; pos <= 180; pos += 1) { // goes from 0 degrees to 180 degrees // in steps of 1 degree myservo.write(pos); // tell servo to go to position in variable 'pos' delay(15); // waits 15 ms for the servo to reach the position } for (pos = 180; pos >= 0; pos -= 1) { // goes from 180 degrees to 0 degrees myservo.write(pos); // tell servo to go to position in variable 'pos' delay(15); // waits 15 ms for the servo to reach the position } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_34","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_34","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_73","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-516-softwareserial","text":"","title":"Section 5.16: SoftwareSerial"},{"location":"05_examples_uno_r4_wifi/#5161-serialecho","text":"","title":"5.16.1 SerialEcho"},{"location":"05_examples_uno_r4_wifi/#sketch-code_74","text":"#include <SoftwareSerial.h> // Note any pin can be used for TX, but only the following pins // can be used for RX: // D0, D1, D2, D3, D8, D14, D15, A1, A2, A3, A4, A5 SoftwareSerial SoftSerial(2, 7); // Rx, Tx void setup() { Serial.begin(9600); while (!Serial) { } if (!SoftSerial.begin(115200, SERIAL_8E2)) { Serial.println(\"Failed to init soft serial\"); while (1); } Serial.println(SoftSerial); } void loop() { // run over and over while (SoftSerial.available()) { SoftSerial.write(SoftSerial.read()); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_35","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_35","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_74","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-517-stepper","text":"","title":"Section 5.17: Stepper"},{"location":"05_examples_uno_r4_wifi/#5171-motorknob","text":"","title":"5.17.1 MotorKnob"},{"location":"05_examples_uno_r4_wifi/#sketch-code_75","text":"/* * MotorKnob * * A stepper motor follows the turns of a potentiometer * (or other sensor) on analog input 0. * * http://www.arduino.cc/en/Reference/Stepper * This example code is in the public domain. */ #include <Stepper.h> // change this to the number of steps on your motor #define STEPS 100 // create an instance of the stepper class, specifying // the number of steps of the motor and the pins it's // attached to Stepper stepper(STEPS, 8, 9, 10, 11); // the previous reading from the analog input int previous = 0; void setup() { // set the speed of the motor to 30 RPMs stepper.setSpeed(30); } void loop() { // get the sensor value int val = analogRead(0); // move a number of steps equal to the change in the // sensor reading stepper.step(val - previous); // remember the previous value of the sensor previous = val; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_36","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_36","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_75","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5172-stepper_onerevolution","text":"","title":"5.17.2 stepper_oneRevolution"},{"location":"05_examples_uno_r4_wifi/#sketch-code_76","text":"/* Stepper Motor Control - one revolution This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. The motor should revolve one revolution in one direction, then one revolution in the other direction. Created 11 Mar. 2007 Modified 30 Nov. 2009 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper.setSpeed(60); // initialize the serial port: Serial.begin(9600); } void loop() { // step one revolution in one direction: Serial.println(\"clockwise\"); myStepper.step(stepsPerRevolution); delay(500); // step one revolution in the other direction: Serial.println(\"counterclockwise\"); myStepper.step(-stepsPerRevolution); delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_37","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_37","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_76","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5173-stepper_onestepatatime","text":"","title":"5.17.3 stepper_oneStepAtATime"},{"location":"05_examples_uno_r4_wifi/#sketch-code_77","text":"/* Stepper Motor Control - one step at a time This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. The motor will step one step at a time, very slowly. You can use this to test that you've got the four wires of your stepper wired to the correct pins. If wired correctly, all steps should be in the same direction. Use this also to count the number of steps per revolution of your motor, if you don't know it. Then plug that number into the oneRevolution example to see if you got it right. Created 30 Nov. 2009 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); int stepCount = 0; // number of steps the motor has taken void setup() { // initialize the serial port: Serial.begin(9600); } void loop() { // step one step: myStepper.step(1); Serial.print(\"steps:\"); Serial.println(stepCount); stepCount++; delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_38","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_38","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_77","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5174-stepper_speedcontrol","text":"","title":"5.17.4 stepper_speedControl"},{"location":"05_examples_uno_r4_wifi/#sketch-code_78","text":"/* Stepper Motor Control - speed control This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. A potentiometer is connected to analog input 0. The motor will rotate in a clockwise direction. The higher the potentiometer value, the faster the motor speed. Because setSpeed() sets the delay between steps, you may notice the motor is less responsive to changes in the sensor value at low speeds. Created 30 Nov. 2009 Modified 28 Oct 2010 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); int stepCount = 0; // number of steps the motor has taken void setup() { // nothing to do inside the setup } void loop() { // read the sensor value: int sensorReading = analogRead(A0); // map it to a range from 0 to 100: int motorSpeed = map(sensorReading, 0, 1023, 0, 100); // set the motor speed: if (motorSpeed > 0) { myStepper.setSpeed(motorSpeed); // step 1/100 of a revolution: myStepper.step(stepsPerRevolution / 100); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_39","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_39","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_78","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-518-tft","text":"","title":"Section 5.18: TFT"},{"location":"05_examples_uno_r4_wifi/#5181-tftbitmaplogo","text":"","title":"5.18.1 TFTBitmapLogo"},{"location":"05_examples_uno_r4_wifi/#sketch-code_79","text":"/* Arduino TFT Bitmap Logo example This example reads an image file from a micro-SD card and draws it on the screen, at random locations. In this sketch, the Arduino logo is read from a micro-SD card. There is a .bmp file included with this sketch. - open the sketch folder (Ctrl-K or Cmd-K) - copy the \"arduino.bmp\" file to a micro-SD - put the SD into the SD slot of the Arduino TFT module. This example code is in the public domain. Created 19 April 2013 by Enrico Gueli http://www.arduino.cc/en/Tutorial/TFTBitmapLogo */ // include the necessary libraries #include <SPI.h> #include <SD.h> #include <TFT.h> // Arduino LCD library // pin definition for the Uno #define sd_cs 4 #define lcd_cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo //#define sd_cs 8 //#define lcd_cs 7 //#define dc 0 //#define rst 1 TFT TFTscreen = TFT(lcd_cs, dc, rst); // this variable represents the image to be drawn on screen PImage logo; void setup() { // initialize the GLCD and show a message // asking the user to open the serial line TFTscreen.begin(); TFTscreen.background(255, 255, 255); TFTscreen.stroke(0, 0, 255); TFTscreen.println(); TFTscreen.println(F(\"Arduino TFT Bitmap Example\")); TFTscreen.stroke(0, 0, 0); TFTscreen.println(F(\"Open serial monitor\")); TFTscreen.println(F(\"to run the sketch\")); // initialize the serial port: it will be used to // print some diagnostic info Serial.begin(9600); while (!Serial) { // wait for serial port to connect. Needed for native USB port only } // clear the GLCD screen before starting TFTscreen.background(255, 255, 255); // try to access the SD card. If that fails (e.g. // no card present), the setup process will stop. Serial.print(F(\"Initializing SD card...\")); if (!SD.begin(sd_cs)) { Serial.println(F(\"failed!\")); return; } Serial.println(F(\"OK!\")); // initialize and clear the GLCD screen TFTscreen.begin(); TFTscreen.background(255, 255, 255); // now that the SD card can be access, try to load the // image file. logo = TFTscreen.loadImage(\"arduino.bmp\"); if (!logo.isValid()) { Serial.println(F(\"error while loading arduino.bmp\")); } } void loop() { // don't do anything if the image wasn't loaded correctly. if (logo.isValid() == false) { return; } Serial.println(F(\"drawing image\")); // get a random location where to draw the image. // To avoid the image to be draw outside the screen, // take into account the image size. int x = random(TFTscreen.width() - logo.width()); int y = random(TFTscreen.height() - logo.height()); // draw the image to the screen TFTscreen.image(logo, x, y); // wait a little bit before drawing again delay(1500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_40","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_40","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_79","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5182-tftcolorpicker","text":"","title":"5.18.2 TFTColorPicker"},{"location":"05_examples_uno_r4_wifi/#sketch-code_80","text":"/* TFT Color Picker This example for the Arduino screen reads the input of potentiometers or analog sensors attached to A0, A1, and A2 and uses the values to change the screen's color. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTColorPicker */ // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 #include <TFT.h> // Arduino LCD library #include <SPI.h> TFT TFTscreen = TFT(cs, dc, rst); void setup() { // begin serial communication Serial.begin(9600); // initialize the display TFTscreen.begin(); // set the background to white TFTscreen.background(255, 255, 255); } void loop() { // read the values from your sensors and scale them to 0-255 int redVal = map(analogRead(A0), 0, 1023, 0, 255); int greenVal = map(analogRead(A1), 0, 1023, 0, 255); int blueVal = map(analogRead(A2), 0, 1023, 0, 255); // draw the background based on the mapped values TFTscreen.background(redVal, greenVal, blueVal); // send the values to the serial monitor Serial.print(\"background(\"); Serial.print(redVal); Serial.print(\" , \"); Serial.print(greenVal); Serial.print(\" , \"); Serial.print(blueVal); Serial.println(\")\"); // wait for a moment delay(33); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_41","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_41","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_80","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5183-tftdisplaytext","text":"","title":"5.18.3 TFTDisplayText"},{"location":"05_examples_uno_r4_wifi/#sketch-code_81","text":"/* Arduino TFT text example This example demonstrates how to draw text on the TFT with an Arduino. The Arduino reads the value of an analog sensor attached to pin A0, and writes the value to the LCD screen, updating every quarter second. This example code is in the public domain Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTDisplayText */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 // create an instance of the library TFT TFTscreen = TFT(cs, dc, rst); // char array to print to the screen char sensorPrintout[4]; void setup() { // Put this line at the beginning of every sketch that uses the GLCD: TFTscreen.begin(); // clear the screen with a black background TFTscreen.background(0, 0, 0); // write the static text to the screen // set the font color to white TFTscreen.stroke(255, 255, 255); // set the font size TFTscreen.setTextSize(2); // write the text to the top left corner of the screen TFTscreen.text(\"Sensor Value :\\n \", 0, 0); // ste the font size very large for the loop TFTscreen.setTextSize(5); } void loop() { // Read the value of the sensor on A0 String sensorVal = String(analogRead(A0)); // convert the reading to a char array sensorVal.toCharArray(sensorPrintout, 4); // set the font color TFTscreen.stroke(255, 255, 255); // print the sensor value TFTscreen.text(sensorPrintout, 0, 20); // wait for a moment delay(250); // erase the text you just wrote TFTscreen.stroke(0, 0, 0); TFTscreen.text(sensorPrintout, 0, 20); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_42","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_42","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_81","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5184-tftetchasketch","text":"","title":"5.18.4 TFTEtchAsketch"},{"location":"05_examples_uno_r4_wifi/#sketch-code_82","text":"/* TFT EtchASketch This example for the Arduino screen draws a white point on the GLCD based on the values of 2 potentiometers. To clear the screen, press a button attached to pin 2. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTEtchASketch */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // initial position of the cursor int xPos = TFTscreen.width() / 2; int yPos = TFTscreen.height() / 2; // pin the erase switch is connected to int erasePin = 2; void setup() { // declare inputs pinMode(erasePin, INPUT); // initialize the screen TFTscreen.begin(); // make the background black TFTscreen.background(0, 0, 0); } void loop() { // read the potentiometers on A0 and A1 int xValue = analogRead(A0); int yValue = analogRead(A1); // map the values and update the position xPos = xPos + (map(xValue, 0, 1023, 2, -2)); yPos = yPos + (map(yValue, 0, 1023, -2, 2)); // don't let the point go past the screen edges if (xPos > 159) { (xPos = 159); } if (xPos < 0) { (xPos = 0); } if (yPos > 127) { (yPos = 127); } if (yPos < 0) { (yPos = 0); } // draw the point TFTscreen.stroke(255, 255, 255); TFTscreen.point(xPos, yPos); // read the value of the pin, and erase the screen if pressed if (digitalRead(erasePin) == HIGH) { TFTscreen.background(0, 0, 0); } delay(33); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_43","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_43","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_82","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5185-tftgraph","text":"","title":"5.18.5 TFTGraph"},{"location":"05_examples_uno_r4_wifi/#sketch-code_83","text":"/* TFT Graph This example for an Arduino screen reads the value of an analog sensor on A0, and graphs the values on the screen. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTGraph */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // position of the line on screen int xPos = 0; void setup() { // initialize the serial port Serial.begin(9600); // initialize the display TFTscreen.begin(); // clear the screen with a pretty color TFTscreen.background(250, 16, 200); } void loop() { // read the sensor and map it to the screen height int sensor = analogRead(A0); int drawHeight = map(sensor, 0, 1023, 0, TFTscreen.height()); // print out the height to the serial monitor Serial.println(drawHeight); // draw a line in a nice color TFTscreen.stroke(250, 180, 10); TFTscreen.line(xPos, TFTscreen.height() - drawHeight, xPos, TFTscreen.height()); // if the graph has reached the screen edge // erase the screen and start again if (xPos >= 160) { xPos = 0; TFTscreen.background(250, 16, 200); } else { // increment the horizontal position: xPos++; } delay(16); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_44","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_44","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_83","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#5186-tftpong","text":"","title":"5.18.6 TFTPong"},{"location":"05_examples_uno_r4_wifi/#sketch-code_84","text":"/* TFT Pong This example for the Arduino screen reads the values of 2 potentiometers to move a rectangular platform on the x and y axes. The platform can intersect with a ball causing it to bounce. This example code is in the public domain. Created by Tom Igoe December 2012 Modified 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTPong */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // variables for the position of the ball and paddle int paddleX = 0; int paddleY = 0; int oldPaddleX, oldPaddleY; int ballDirectionX = 1; int ballDirectionY = 1; int ballSpeed = 10; // lower numbers are faster int ballX, ballY, oldBallX, oldBallY; void setup() { // initialize the display TFTscreen.begin(); // black background TFTscreen.background(0, 0, 0); } void loop() { // save the width and height of the screen int myWidth = TFTscreen.width(); int myHeight = TFTscreen.height(); // map the paddle's location to the position of the potentiometers paddleX = map(analogRead(A0), 512, -512, 0, myWidth) - 20 / 2; paddleY = map(analogRead(A1), 512, -512, 0, myHeight) - 5 / 2; // set the fill color to black and erase the previous // position of the paddle if different from present TFTscreen.fill(0, 0, 0); if (oldPaddleX != paddleX || oldPaddleY != paddleY) { TFTscreen.rect(oldPaddleX, oldPaddleY, 20, 5); } // draw the paddle on screen, save the current position // as the previous. TFTscreen.fill(255, 255, 255); TFTscreen.rect(paddleX, paddleY, 20, 5); oldPaddleX = paddleX; oldPaddleY = paddleY; // update the ball's position and draw it on screen if (millis() % ballSpeed < 2) { moveBall(); } } // this function determines the ball's position on screen void moveBall() { // if the ball goes offscreen, reverse the direction: if (ballX > TFTscreen.width() || ballX < 0) { ballDirectionX = -ballDirectionX; } if (ballY > TFTscreen.height() || ballY < 0) { ballDirectionY = -ballDirectionY; } // check if the ball and the paddle occupy the same space on screen if (inPaddle(ballX, ballY, paddleX, paddleY, 20, 5)) { ballDirectionX = -ballDirectionX; ballDirectionY = -ballDirectionY; } // update the ball's position ballX += ballDirectionX; ballY += ballDirectionY; // erase the ball's previous position TFTscreen.fill(0, 0, 0); if (oldBallX != ballX || oldBallY != ballY) { TFTscreen.rect(oldBallX, oldBallY, 5, 5); } // draw the ball's current position TFTscreen.fill(255, 255, 255); TFTscreen.rect(ballX, ballY, 5, 5); oldBallX = ballX; oldBallY = ballY; } // this function checks the position of the ball // to see if it intersects with the paddle boolean inPaddle(int x, int y, int rectX, int rectY, int rectWidth, int rectHeight) { boolean result = false; if ((x >= rectX && x <= (rectX + rectWidth)) && (y >= rectY && y <= (rectY + rectHeight))) { result = true; } return result; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_45","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_45","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_84","text":"Note Esplora is ALREADY retired .","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-519-wdt","text":"Note No additional circuit is required for this section 5.19 .","title":"Section 5.19: WDT"},{"location":"05_examples_uno_r4_wifi/#5191-watchdogrefresh","text":"","title":"5.19.1 WatchdogRefresh"},{"location":"05_examples_uno_r4_wifi/#sketch-code_85","text":"/* Watchdog Refresh This sketch shows how to enable the watchdog and refresh the timer to avoid resets Watchdog intervals are limited to 7 timeout periods the library will select the best clock divisor and timeout according to the selected wdtInterval. UNO R4 min wdtInterval 1ms / max wdtInterval 5592ms Comment out Serial.print() in the setup to make it work with small intervals Portenta C33 min wdtInterval 1ms / max wdtInterval 2684ms Circuit: - Portenta C33 - UNO R4 */ #include <WDT.h> const long ledInterval = 1000; unsigned long ledMillis = 0; bool ledState = true; const long wdtInterval = 2684; unsigned long wdtMillis = 0; void setup() { Serial.begin(9600); while (!Serial); pinMode(LED_BUILTIN, OUTPUT); if(wdtInterval < 1) { Serial.println(\"Invalid watchdog interval\"); while(1){} } if(WDT.begin(wdtInterval)) { Serial.print(\"WDT interval: \"); WDT.refresh(); Serial.print(WDT.getTimeout()); WDT.refresh(); Serial.println(\" ms\"); WDT.refresh(); } else { Serial.println(\"Error initializing watchdog\"); while(1){} } } void loop() { if(millis() - ledMillis >= ledInterval) { digitalWrite(LED_BUILTIN, ledState); ledState = !ledState; ledMillis = millis(); } if(millis() - wdtMillis >= wdtInterval - 1) { WDT.refresh(); // Comment this line to stop refreshing the watchdog wdtMillis = millis(); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_46","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_46","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_85","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/#section-520-wifis3","text":"Note No additional circuit is required for this section 5.20 .","title":"Section 5.20: WiFiS3"},{"location":"05_examples_uno_r4_wifi/#5201-ap_simplewebserver","text":"","title":"5.20.1 AP_SimpleWebServer"},{"location":"05_examples_uno_r4_wifi/#sketch-code_86","text":"/* WiFi Web Server LED Blink A simple web server that lets you blink an LED via the web. This sketch will create a new access point (with no password). It will then launch a new server and print out the IP address to the Serial Monitor. From there, you can open that address in a web browser to turn on and off the LED on pin 13. If the IP address of your board is yourAddress: http://yourAddress/H turns the LED on http://yourAddress/L turns it off created 25 Nov 2012 by Tom Igoe adapted to WiFi AP by Adafruit Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#access-point */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int led = LED_BUILTIN; int status = WL_IDLE_STATUS; WiFiServer server(80); void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"Access Point Web Server\"); pinMode(led, OUTPUT); // set the LED pin mode // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // by default the local IP address will be 192.168.4.1 // you can override it with the following: WiFi.config(IPAddress(192,48,56,2)); // print the network name (SSID); Serial.print(\"Creating access point named: \"); Serial.println(ssid); // Create open network. Change this line if you want to create an WEP network: status = WiFi.beginAP(ssid, pass); if (status != WL_AP_LISTENING) { Serial.println(\"Creating access point failed\"); // don't continue while (true); } // wait 10 seconds for connection: delay(10000); // start the web server on port 80 server.begin(); // you're connected now, so print out the status printWiFiStatus(); } void loop() { // compare the previous status to the current status if (status != WiFi.status()) { // it has changed update the variable status = WiFi.status(); if (status == WL_AP_CONNECTED) { // a device has connected to the AP Serial.println(\"Device connected to AP\"); } else { // a device has disconnected from the AP, and we are back in listening mode Serial.println(\"Device disconnected from AP\"); } } WiFiClient client = server.available(); // listen for incoming clients if (client) { // if you get a client, Serial.println(\"new client\"); // print a message out the serial port String currentLine = \"\"; // make a String to hold incoming data from the client while (client.connected()) { // loop while the client's connected delayMicroseconds(10); // This is required for the Arduino Nano RP2040 Connect - otherwise it will loop so fast that SPI will never be served. if (client.available()) { // if there's bytes to read from the client, char c = client.read(); // read a byte, then Serial.write(c); // print it out to the serial monitor if (c == '\\n') { // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that's the end of the client HTTP request, so send a response: if (currentLine.length() == 0) { // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what's coming, then a blank line: client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-type:text/html\"); client.println(); // the content of the HTTP response follows the header: client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/H\\\">here</a> turn the LED on<br></p>\"); client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/L\\\">here</a> turn the LED off<br></p>\"); // The HTTP response ends with another blank line: client.println(); // break out of the while loop: break; } else { // if you got a newline, then clear currentLine: currentLine = \"\"; } } else if (c != '\\r') { // if you got anything else but a carriage return character, currentLine += c; // add it to the end of the currentLine } // Check to see if the client request was \"GET /H\" or \"GET /L\": if (currentLine.endsWith(\"GET /H\")) { digitalWrite(led, HIGH); // GET /H turns the LED on } if (currentLine.endsWith(\"GET /L\")) { digitalWrite(led, LOW); // GET /L turns the LED off } } } // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } void printWiFiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your WiFi shield's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print where to go in a browser: Serial.print(\"To see this page in action, open a browser to http://\"); Serial.println(ip); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/#fritzing-circuit_47","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/#kicad-schematic_47","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/#video-demonstration_86","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/01.Basics/AnalogReadSerial/","text":"Sketch Code /* AnalogReadSerial Reads an analog input on pin 0, prints the result to the Serial Monitor. Graphical representation is available using Serial Plotter (Tools > Serial Plotter menu). Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogReadSerial */ // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); } // the loop routine runs over and over again forever: void loop() { // read the input on analog pin 0: int sensorValue = analogRead(A0); // print out the value you read: Serial.println(sensorValue); delay(1); // delay in between reads for stability } Fritzing Circuit KiCad Schematic Video Demonstration","title":"AnalogReadSerial"},{"location":"04_builtin_examples/01.Basics/AnalogReadSerial/#sketch-code","text":"/* AnalogReadSerial Reads an analog input on pin 0, prints the result to the Serial Monitor. Graphical representation is available using Serial Plotter (Tools > Serial Plotter menu). Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogReadSerial */ // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); } // the loop routine runs over and over again forever: void loop() { // read the input on analog pin 0: int sensorValue = analogRead(A0); // print out the value you read: Serial.println(sensorValue); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/01.Basics/AnalogReadSerial/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/01.Basics/AnalogReadSerial/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/01.Basics/AnalogReadSerial/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/01.Basics/BareMinimum/","text":"Sketch Code void setup() { // put your setup code here, to run once: } void loop() { // put your main code here, to run repeatedly: } This sketch simply shows the standard template when coding for any Arduino boards. As you can see, there are typically only 2 functions : setup(): for initialization loop(): normally, a forever loop that runs infinitely From this bare minimum template, we can easily tell Arduino is a Microcontroller with a single thread , and of course for a single user . Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration N/A","title":"BareMinimum"},{"location":"04_builtin_examples/01.Basics/BareMinimum/#sketch-code","text":"void setup() { // put your setup code here, to run once: } void loop() { // put your main code here, to run repeatedly: } This sketch simply shows the standard template when coding for any Arduino boards. As you can see, there are typically only 2 functions : setup(): for initialization loop(): normally, a forever loop that runs infinitely From this bare minimum template, we can easily tell Arduino is a Microcontroller with a single thread , and of course for a single user .","title":"Sketch Code"},{"location":"04_builtin_examples/01.Basics/BareMinimum/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/01.Basics/BareMinimum/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/01.Basics/BareMinimum/#video-demonstration","text":"N/A","title":"Video Demonstration"},{"location":"04_builtin_examples/01.Basics/Blink/","text":"Sketch Code /* Blink Turns an LED on for one second, then off for one second, repeatedly. Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products modified 8 May 2014 by Scott Fitzgerald modified 2 Sep 2016 by Arturo Guadalupi modified 8 Sep 2016 by Colby Newman This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Blink */ // the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"Blink"},{"location":"04_builtin_examples/01.Basics/Blink/#sketch-code","text":"/* Blink Turns an LED on for one second, then off for one second, repeatedly. Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products modified 8 May 2014 by Scott Fitzgerald modified 2 Sep 2016 by Arturo Guadalupi modified 8 Sep 2016 by Colby Newman This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Blink */ // the setup function runs once when you press reset or power the board void setup() { // initialize digital pin LED_BUILTIN as an output. pinMode(LED_BUILTIN, OUTPUT); } // the loop function runs over and over again forever void loop() { digitalWrite(LED_BUILTIN, HIGH); // turn the LED on (HIGH is the voltage level) delay(1000); // wait for a second digitalWrite(LED_BUILTIN, LOW); // turn the LED off by making the voltage LOW delay(1000); // wait for a second }","title":"Sketch Code"},{"location":"04_builtin_examples/01.Basics/Blink/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/01.Basics/Blink/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/01.Basics/Blink/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/01.Basics/DigitalReadSerial/","text":"Sketch Code /* DigitalReadSerial Reads a digital input on pin 2, prints the result to the Serial Monitor This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/DigitalReadSerial */ // digital pin 2 has a pushbutton attached to it. Give it a name: int pushButton = 2; // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); // make the pushbutton's pin an input: pinMode(pushButton, INPUT); } // the loop routine runs over and over again forever: void loop() { // read the input pin: int buttonState = digitalRead(pushButton); // print out the state of the button: Serial.println(buttonState); delay(1); // delay in between reads for stability } Fritzing Circuit KiCad Schematic Video Demonstration","title":"DigitalReadSerial"},{"location":"04_builtin_examples/01.Basics/DigitalReadSerial/#sketch-code","text":"/* DigitalReadSerial Reads a digital input on pin 2, prints the result to the Serial Monitor This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/DigitalReadSerial */ // digital pin 2 has a pushbutton attached to it. Give it a name: int pushButton = 2; // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); // make the pushbutton's pin an input: pinMode(pushButton, INPUT); } // the loop routine runs over and over again forever: void loop() { // read the input pin: int buttonState = digitalRead(pushButton); // print out the state of the button: Serial.println(buttonState); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/01.Basics/DigitalReadSerial/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/01.Basics/DigitalReadSerial/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/01.Basics/DigitalReadSerial/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/01.Basics/Fade/","text":"Sketch Code /* Fade This example shows how to fade an LED on pin 9 using the analogWrite() function. The analogWrite() function uses PWM, so if you want to change the pin you're using, be sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with a \"~\" sign, like ~3, ~5, ~6, ~9, ~10 and ~11. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Fade */ int led = 9; // the PWM pin the LED is attached to int brightness = 0; // how bright the LED is int fadeAmount = 5; // how many points to fade the LED by // the setup routine runs once when you press reset: void setup() { // declare pin 9 to be an output: pinMode(led, OUTPUT); } // the loop routine runs over and over again forever: void loop() { // set the brightness of pin 9: analogWrite(led, brightness); // change the brightness for next time through the loop: brightness = brightness + fadeAmount; // reverse the direction of the fading at the ends of the fade: if (brightness <= 0 || brightness >= 255) { fadeAmount = -fadeAmount; } // wait for 30 milliseconds to see the dimming effect delay(30); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Fade"},{"location":"04_builtin_examples/01.Basics/Fade/#sketch-code","text":"/* Fade This example shows how to fade an LED on pin 9 using the analogWrite() function. The analogWrite() function uses PWM, so if you want to change the pin you're using, be sure to use another PWM capable pin. On most Arduino, the PWM pins are identified with a \"~\" sign, like ~3, ~5, ~6, ~9, ~10 and ~11. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Fade */ int led = 9; // the PWM pin the LED is attached to int brightness = 0; // how bright the LED is int fadeAmount = 5; // how many points to fade the LED by // the setup routine runs once when you press reset: void setup() { // declare pin 9 to be an output: pinMode(led, OUTPUT); } // the loop routine runs over and over again forever: void loop() { // set the brightness of pin 9: analogWrite(led, brightness); // change the brightness for next time through the loop: brightness = brightness + fadeAmount; // reverse the direction of the fading at the ends of the fade: if (brightness <= 0 || brightness >= 255) { fadeAmount = -fadeAmount; } // wait for 30 milliseconds to see the dimming effect delay(30); }","title":"Sketch Code"},{"location":"04_builtin_examples/01.Basics/Fade/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/01.Basics/Fade/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/01.Basics/Fade/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/01.Basics/ReadAnalogVoltage/","text":"Sketch Code /* ReadAnalogVoltage Reads an analog input on pin 0, converts it to voltage, and prints the result to the Serial Monitor. Graphical representation is available using Serial Plotter (Tools > Serial Plotter menu). Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ReadAnalogVoltage */ // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); } // the loop routine runs over and over again forever: void loop() { // read the input on analog pin 0: int sensorValue = analogRead(A0); // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V): float voltage = sensorValue * (5.0 / 1023.0); // print out the value you read: Serial.println(voltage); } Fritzing Circuit Same as Example AnalogReadSerial KiCad Schematic Same as Example AnalogReadSerial Video Demonstration","title":"ReadAnalogVoltage"},{"location":"04_builtin_examples/01.Basics/ReadAnalogVoltage/#sketch-code","text":"/* ReadAnalogVoltage Reads an analog input on pin 0, converts it to voltage, and prints the result to the Serial Monitor. Graphical representation is available using Serial Plotter (Tools > Serial Plotter menu). Attach the center pin of a potentiometer to pin A0, and the outside pins to +5V and ground. This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ReadAnalogVoltage */ // the setup routine runs once when you press reset: void setup() { // initialize serial communication at 9600 bits per second: Serial.begin(9600); } // the loop routine runs over and over again forever: void loop() { // read the input on analog pin 0: int sensorValue = analogRead(A0); // Convert the analog reading (which goes from 0 - 1023) to a voltage (0 - 5V): float voltage = sensorValue * (5.0 / 1023.0); // print out the value you read: Serial.println(voltage); }","title":"Sketch Code"},{"location":"04_builtin_examples/01.Basics/ReadAnalogVoltage/#fritzing-circuit","text":"Same as Example AnalogReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/01.Basics/ReadAnalogVoltage/#kicad-schematic","text":"Same as Example AnalogReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/01.Basics/ReadAnalogVoltage/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/02.Digital/BlinkWithoutDelay/","text":"Sketch Code /* Blink without Delay Turns on and off a light emitting diode (LED) connected to a digital pin, without using the delay() function. This means that other code can run at the same time without being interrupted by the LED code. The circuit: - Use the onboard LED. - Note: Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products created 2005 by David A. Mellis modified 8 Feb 2010 by Paul Stoffregen modified 11 Nov 2013 by Scott Fitzgerald modified 9 Jan 2017 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/BlinkWithoutDelay */ // constants won't change. Used here to set a pin number: const int ledPin = LED_BUILTIN; // the number of the LED pin // Variables will change: int ledState = LOW; // ledState used to set the LED // Generally, you should use \"unsigned long\" for variables that hold time // The value will quickly become too large for an int to store unsigned long previousMillis = 0; // will store last time LED was updated // constants won't change: const long interval = 1000; // interval at which to blink (milliseconds) void setup() { // set the digital pin as output: pinMode(ledPin, OUTPUT); } void loop() { // here is where you'd put code that needs to be running all the time. // check to see if it's time to blink the LED; that is, if the difference // between the current time and last time you blinked the LED is bigger than // the interval at which you want to blink the LED. unsigned long currentMillis = millis(); if (currentMillis - previousMillis >= interval) { // save the last time you blinked the LED previousMillis = currentMillis; // if the LED is off turn it on and vice-versa: if (ledState == LOW) { ledState = HIGH; } else { ledState = LOW; } // set the LED with the ledState of the variable: digitalWrite(ledPin, ledState); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"BlinkWithoutDelay"},{"location":"04_builtin_examples/02.Digital/BlinkWithoutDelay/#sketch-code","text":"/* Blink without Delay Turns on and off a light emitting diode (LED) connected to a digital pin, without using the delay() function. This means that other code can run at the same time without being interrupted by the LED code. The circuit: - Use the onboard LED. - Note: Most Arduinos have an on-board LED you can control. On the UNO, MEGA and ZERO it is attached to digital pin 13, on MKR1000 on pin 6. LED_BUILTIN is set to the correct LED pin independent of which board is used. If you want to know what pin the on-board LED is connected to on your Arduino model, check the Technical Specs of your board at: https://www.arduino.cc/en/Main/Products created 2005 by David A. Mellis modified 8 Feb 2010 by Paul Stoffregen modified 11 Nov 2013 by Scott Fitzgerald modified 9 Jan 2017 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/BlinkWithoutDelay */ // constants won't change. Used here to set a pin number: const int ledPin = LED_BUILTIN; // the number of the LED pin // Variables will change: int ledState = LOW; // ledState used to set the LED // Generally, you should use \"unsigned long\" for variables that hold time // The value will quickly become too large for an int to store unsigned long previousMillis = 0; // will store last time LED was updated // constants won't change: const long interval = 1000; // interval at which to blink (milliseconds) void setup() { // set the digital pin as output: pinMode(ledPin, OUTPUT); } void loop() { // here is where you'd put code that needs to be running all the time. // check to see if it's time to blink the LED; that is, if the difference // between the current time and last time you blinked the LED is bigger than // the interval at which you want to blink the LED. unsigned long currentMillis = millis(); if (currentMillis - previousMillis >= interval) { // save the last time you blinked the LED previousMillis = currentMillis; // if the LED is off turn it on and vice-versa: if (ledState == LOW) { ledState = HIGH; } else { ledState = LOW; } // set the LED with the ledState of the variable: digitalWrite(ledPin, ledState); } }","title":"Sketch Code"},{"location":"04_builtin_examples/02.Digital/BlinkWithoutDelay/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/02.Digital/BlinkWithoutDelay/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/02.Digital/BlinkWithoutDelay/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/02.Digital/Button/","text":"Sketch Code /* Button Turns on and off a light emitting diode(LED) connected to digital pin 13, when pressing a pushbutton attached to pin 2. The circuit: - LED attached from pin 13 to ground through 220 ohm resistor - pushbutton attached to pin 2 from +5V - 10K resistor attached to pin 2 from ground - Note: on most Arduinos there is already an LED on the board attached to pin 13. created 2005 by DojoDave <http://www.0j0.org> modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Button */ // constants won't change. They're used here to set pin numbers: const int buttonPin = 2; // the number of the pushbutton pin const int ledPin = 13; // the number of the LED pin // variables will change: int buttonState = 0; // variable for reading the pushbutton status void setup() { // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); // initialize the pushbutton pin as an input: pinMode(buttonPin, INPUT); } void loop() { // read the state of the pushbutton value: buttonState = digitalRead(buttonPin); // check if the pushbutton is pressed. If it is, the buttonState is HIGH: if (buttonState == HIGH) { // turn LED on: digitalWrite(ledPin, HIGH); } else { // turn LED off: digitalWrite(ledPin, LOW); } } Fritzing Circuit Same as Example DigitalReadSerial KiCad Schematic Roughly the same as Example DigitalReadSerial Video Demonstration Same as Example DigitalReadSerial","title":"Button"},{"location":"04_builtin_examples/02.Digital/Button/#sketch-code","text":"/* Button Turns on and off a light emitting diode(LED) connected to digital pin 13, when pressing a pushbutton attached to pin 2. The circuit: - LED attached from pin 13 to ground through 220 ohm resistor - pushbutton attached to pin 2 from +5V - 10K resistor attached to pin 2 from ground - Note: on most Arduinos there is already an LED on the board attached to pin 13. created 2005 by DojoDave <http://www.0j0.org> modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Button */ // constants won't change. They're used here to set pin numbers: const int buttonPin = 2; // the number of the pushbutton pin const int ledPin = 13; // the number of the LED pin // variables will change: int buttonState = 0; // variable for reading the pushbutton status void setup() { // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); // initialize the pushbutton pin as an input: pinMode(buttonPin, INPUT); } void loop() { // read the state of the pushbutton value: buttonState = digitalRead(buttonPin); // check if the pushbutton is pressed. If it is, the buttonState is HIGH: if (buttonState == HIGH) { // turn LED on: digitalWrite(ledPin, HIGH); } else { // turn LED off: digitalWrite(ledPin, LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/02.Digital/Button/#fritzing-circuit","text":"Same as Example DigitalReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/02.Digital/Button/#kicad-schematic","text":"Roughly the same as Example DigitalReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/02.Digital/Button/#video-demonstration","text":"Same as Example DigitalReadSerial","title":"Video Demonstration"},{"location":"04_builtin_examples/02.Digital/Debounce/","text":"Sketch Code /* Debounce Each time the input pin goes from LOW to HIGH (e.g. because of a push-button press), the output pin is toggled from LOW to HIGH or HIGH to LOW. There's a minimum delay between toggles to debounce the circuit (i.e. to ignore noise). The circuit: - LED attached from pin 13 to ground through 220 ohm resistor - pushbutton attached from pin 2 to +5V - 10 kilohm resistor attached from pin 2 to ground - Note: On most Arduino boards, there is already an LED on the board connected to pin 13, so you don't need any extra components for this example. created 21 Nov 2006 by David A. Mellis modified 30 Aug 2011 by Limor Fried modified 28 Dec 2012 by Mike Walters modified 30 Aug 2016 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Debounce */ // constants won't change. They're used here to set pin numbers: const int buttonPin = 2; // the number of the pushbutton pin const int ledPin = 13; // the number of the LED pin // Variables will change: int ledState = HIGH; // the current state of the output pin int buttonState; // the current reading from the input pin int lastButtonState = LOW; // the previous reading from the input pin // the following variables are unsigned longs because the time, measured in // milliseconds, will quickly become a bigger number than can be stored in an int. unsigned long lastDebounceTime = 0; // the last time the output pin was toggled unsigned long debounceDelay = 50; // the debounce time; increase if the output flickers void setup() { pinMode(buttonPin, INPUT); pinMode(ledPin, OUTPUT); // set initial LED state digitalWrite(ledPin, ledState); } void loop() { // read the state of the switch into a local variable: int reading = digitalRead(buttonPin); // check to see if you just pressed the button // (i.e. the input went from LOW to HIGH), and you've waited long enough // since the last press to ignore any noise: // If the switch changed, due to noise or pressing: if (reading != lastButtonState) { // reset the debouncing timer lastDebounceTime = millis(); } if ((millis() - lastDebounceTime) > debounceDelay) { // whatever the reading is at, it's been there for longer than the debounce // delay, so take it as the actual current state: // if the button state has changed: if (reading != buttonState) { buttonState = reading; // only toggle the LED if the new button state is HIGH if (buttonState == HIGH) { ledState = !ledState; } } } // set the LED: digitalWrite(ledPin, ledState); // save the reading. Next time through the loop, it'll be the lastButtonState: lastButtonState = reading; } Fritzing Circuit Same as Example DigitalReadSerial KiCad Schematic Same as Example DigitalReadSerial Video Demonstration","title":"Debounce"},{"location":"04_builtin_examples/02.Digital/Debounce/#sketch-code","text":"/* Debounce Each time the input pin goes from LOW to HIGH (e.g. because of a push-button press), the output pin is toggled from LOW to HIGH or HIGH to LOW. There's a minimum delay between toggles to debounce the circuit (i.e. to ignore noise). The circuit: - LED attached from pin 13 to ground through 220 ohm resistor - pushbutton attached from pin 2 to +5V - 10 kilohm resistor attached from pin 2 to ground - Note: On most Arduino boards, there is already an LED on the board connected to pin 13, so you don't need any extra components for this example. created 21 Nov 2006 by David A. Mellis modified 30 Aug 2011 by Limor Fried modified 28 Dec 2012 by Mike Walters modified 30 Aug 2016 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Debounce */ // constants won't change. They're used here to set pin numbers: const int buttonPin = 2; // the number of the pushbutton pin const int ledPin = 13; // the number of the LED pin // Variables will change: int ledState = HIGH; // the current state of the output pin int buttonState; // the current reading from the input pin int lastButtonState = LOW; // the previous reading from the input pin // the following variables are unsigned longs because the time, measured in // milliseconds, will quickly become a bigger number than can be stored in an int. unsigned long lastDebounceTime = 0; // the last time the output pin was toggled unsigned long debounceDelay = 50; // the debounce time; increase if the output flickers void setup() { pinMode(buttonPin, INPUT); pinMode(ledPin, OUTPUT); // set initial LED state digitalWrite(ledPin, ledState); } void loop() { // read the state of the switch into a local variable: int reading = digitalRead(buttonPin); // check to see if you just pressed the button // (i.e. the input went from LOW to HIGH), and you've waited long enough // since the last press to ignore any noise: // If the switch changed, due to noise or pressing: if (reading != lastButtonState) { // reset the debouncing timer lastDebounceTime = millis(); } if ((millis() - lastDebounceTime) > debounceDelay) { // whatever the reading is at, it's been there for longer than the debounce // delay, so take it as the actual current state: // if the button state has changed: if (reading != buttonState) { buttonState = reading; // only toggle the LED if the new button state is HIGH if (buttonState == HIGH) { ledState = !ledState; } } } // set the LED: digitalWrite(ledPin, ledState); // save the reading. Next time through the loop, it'll be the lastButtonState: lastButtonState = reading; }","title":"Sketch Code"},{"location":"04_builtin_examples/02.Digital/Debounce/#fritzing-circuit","text":"Same as Example DigitalReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/02.Digital/Debounce/#kicad-schematic","text":"Same as Example DigitalReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/02.Digital/Debounce/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/02.Digital/DigitalInputPullup/","text":"Sketch Code /* Input Pull-up Serial This example demonstrates the use of pinMode(INPUT_PULLUP). It reads a digital input on pin 2 and prints the results to the Serial Monitor. The circuit: - momentary switch attached from pin 2 to ground - built-in LED on pin 13 Unlike pinMode(INPUT), there is no pull-down resistor necessary. An internal 20K-ohm resistor is pulled to 5V. This configuration causes the input to read HIGH when the switch is open, and LOW when it is closed. created 14 Mar 2012 by Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/InputPullupSerial */ void setup() { //start serial connection Serial.begin(9600); //configure pin 2 as an input and enable the internal pull-up resistor pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); } void loop() { //read the pushbutton value into a variable int sensorVal = digitalRead(2); //print out the value of the pushbutton Serial.println(sensorVal); // Keep in mind the pull-up means the pushbutton's logic is inverted. It goes // HIGH when it's open, and LOW when it's pressed. Turn on pin 13 when the // button's pressed, and off when it's not: if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"DigitalInputPullup"},{"location":"04_builtin_examples/02.Digital/DigitalInputPullup/#sketch-code","text":"/* Input Pull-up Serial This example demonstrates the use of pinMode(INPUT_PULLUP). It reads a digital input on pin 2 and prints the results to the Serial Monitor. The circuit: - momentary switch attached from pin 2 to ground - built-in LED on pin 13 Unlike pinMode(INPUT), there is no pull-down resistor necessary. An internal 20K-ohm resistor is pulled to 5V. This configuration causes the input to read HIGH when the switch is open, and LOW when it is closed. created 14 Mar 2012 by Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/InputPullupSerial */ void setup() { //start serial connection Serial.begin(9600); //configure pin 2 as an input and enable the internal pull-up resistor pinMode(2, INPUT_PULLUP); pinMode(13, OUTPUT); } void loop() { //read the pushbutton value into a variable int sensorVal = digitalRead(2); //print out the value of the pushbutton Serial.println(sensorVal); // Keep in mind the pull-up means the pushbutton's logic is inverted. It goes // HIGH when it's open, and LOW when it's pressed. Turn on pin 13 when the // button's pressed, and off when it's not: if (sensorVal == HIGH) { digitalWrite(13, LOW); } else { digitalWrite(13, HIGH); } }","title":"Sketch Code"},{"location":"04_builtin_examples/02.Digital/DigitalInputPullup/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/02.Digital/DigitalInputPullup/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/02.Digital/DigitalInputPullup/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/02.Digital/StateChangeDetection/","text":"Sketch Code /* State change detection (edge detection) Often, you don't need to know the state of a digital input all the time, but you just need to know when the input changes from one state to another. For example, you want to know when a button goes from OFF to ON. This is called state change detection, or edge detection. This example shows how to detect when a button or button changes from off to on and on to off. The circuit: - pushbutton attached to pin 2 from +5V - 10 kilohm resistor attached to pin 2 from ground - LED attached from pin 13 to ground through 220 ohm resistor (or use the built-in LED on most Arduino boards) created 27 Sep 2005 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StateChangeDetection */ // this constant won't change: const int buttonPin = 2; // the pin that the pushbutton is attached to const int ledPin = 13; // the pin that the LED is attached to // Variables will change: int buttonPushCounter = 0; // counter for the number of button presses int buttonState = 0; // current state of the button int lastButtonState = 0; // previous state of the button void setup() { // initialize the button pin as a input: pinMode(buttonPin, INPUT); // initialize the LED as an output: pinMode(ledPin, OUTPUT); // initialize serial communication: Serial.begin(9600); } void loop() { // read the pushbutton input pin: buttonState = digitalRead(buttonPin); // compare the buttonState to its previous state if (buttonState != lastButtonState) { // if the state has changed, increment the counter if (buttonState == HIGH) { // if the current state is HIGH then the button went from off to on: buttonPushCounter++; Serial.println(\"on\"); Serial.print(\"number of button pushes: \"); Serial.println(buttonPushCounter); } else { // if the current state is LOW then the button went from on to off: Serial.println(\"off\"); } // Delay a little bit to avoid bouncing delay(50); } // save the current state as the last state, for next time through the loop lastButtonState = buttonState; // turns on the LED every four button pushes by checking the modulo of the // button push counter. the modulo function gives you the remainder of the // division of two numbers: if (buttonPushCounter % 4 == 0) { digitalWrite(ledPin, HIGH); } else { digitalWrite(ledPin, LOW); } } Fritzing Circuit Same as Example DigitalReadSerial KiCad Schematic Same as Example DigitalReadSerial Video Demonstration","title":"StateChangeDetection"},{"location":"04_builtin_examples/02.Digital/StateChangeDetection/#sketch-code","text":"/* State change detection (edge detection) Often, you don't need to know the state of a digital input all the time, but you just need to know when the input changes from one state to another. For example, you want to know when a button goes from OFF to ON. This is called state change detection, or edge detection. This example shows how to detect when a button or button changes from off to on and on to off. The circuit: - pushbutton attached to pin 2 from +5V - 10 kilohm resistor attached to pin 2 from ground - LED attached from pin 13 to ground through 220 ohm resistor (or use the built-in LED on most Arduino boards) created 27 Sep 2005 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StateChangeDetection */ // this constant won't change: const int buttonPin = 2; // the pin that the pushbutton is attached to const int ledPin = 13; // the pin that the LED is attached to // Variables will change: int buttonPushCounter = 0; // counter for the number of button presses int buttonState = 0; // current state of the button int lastButtonState = 0; // previous state of the button void setup() { // initialize the button pin as a input: pinMode(buttonPin, INPUT); // initialize the LED as an output: pinMode(ledPin, OUTPUT); // initialize serial communication: Serial.begin(9600); } void loop() { // read the pushbutton input pin: buttonState = digitalRead(buttonPin); // compare the buttonState to its previous state if (buttonState != lastButtonState) { // if the state has changed, increment the counter if (buttonState == HIGH) { // if the current state is HIGH then the button went from off to on: buttonPushCounter++; Serial.println(\"on\"); Serial.print(\"number of button pushes: \"); Serial.println(buttonPushCounter); } else { // if the current state is LOW then the button went from on to off: Serial.println(\"off\"); } // Delay a little bit to avoid bouncing delay(50); } // save the current state as the last state, for next time through the loop lastButtonState = buttonState; // turns on the LED every four button pushes by checking the modulo of the // button push counter. the modulo function gives you the remainder of the // division of two numbers: if (buttonPushCounter % 4 == 0) { digitalWrite(ledPin, HIGH); } else { digitalWrite(ledPin, LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/02.Digital/StateChangeDetection/#fritzing-circuit","text":"Same as Example DigitalReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/02.Digital/StateChangeDetection/#kicad-schematic","text":"Same as Example DigitalReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/02.Digital/StateChangeDetection/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/02.Digital/toneKeyboard/","text":"Sketch Code /* Keyboard Plays a pitch that changes based on a changing analog input circuit: - three force-sensing resistors from +5V to analog in 0 through 5 - three 10 kilohm resistors from analog in 0 through 5 to ground - 8 ohm speaker on digital pin 8 created 21 Jan 2010 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneKeyboard */ #include \"pitches.h\" const int threshold = 10; // minimum reading of the sensors that generates a note // notes to play, corresponding to the 3 sensors: int notes[] = { NOTE_A4, NOTE_B4, NOTE_C3 }; void setup() { } void loop() { for (int thisSensor = 0; thisSensor < 3; thisSensor++) { // get a sensor reading: int sensorReading = analogRead(thisSensor); // if the sensor is pressed hard enough: if (sensorReading > threshold) { // play the note corresponding to this sensor: tone(8, notes[thisSensor], 20); } } } Fritzing Circuit KiCad Schematic Video Demonstration N/A","title":"toneKeyboard"},{"location":"04_builtin_examples/02.Digital/toneKeyboard/#sketch-code","text":"/* Keyboard Plays a pitch that changes based on a changing analog input circuit: - three force-sensing resistors from +5V to analog in 0 through 5 - three 10 kilohm resistors from analog in 0 through 5 to ground - 8 ohm speaker on digital pin 8 created 21 Jan 2010 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneKeyboard */ #include \"pitches.h\" const int threshold = 10; // minimum reading of the sensors that generates a note // notes to play, corresponding to the 3 sensors: int notes[] = { NOTE_A4, NOTE_B4, NOTE_C3 }; void setup() { } void loop() { for (int thisSensor = 0; thisSensor < 3; thisSensor++) { // get a sensor reading: int sensorReading = analogRead(thisSensor); // if the sensor is pressed hard enough: if (sensorReading > threshold) { // play the note corresponding to this sensor: tone(8, notes[thisSensor], 20); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/02.Digital/toneKeyboard/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/02.Digital/toneKeyboard/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/02.Digital/toneKeyboard/#video-demonstration","text":"N/A","title":"Video Demonstration"},{"location":"04_builtin_examples/02.Digital/toneMelody/","text":"Sketch Code /* Melody Plays a melody circuit: - 8 ohm speaker on digital pin 8 created 21 Jan 2010 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneMelody */ #include \"pitches.h\" // notes in the melody: int melody[] = { NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4 }; // note durations: 4 = quarter note, 8 = eighth note, etc.: int noteDurations[] = { 4, 8, 8, 4, 4, 4, 4, 4 }; void setup() { // iterate over the notes of the melody: for (int thisNote = 0; thisNote < 8; thisNote++) { // to calculate the note duration, take one second divided by the note type. //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc. int noteDuration = 1000 / noteDurations[thisNote]; tone(8, melody[thisNote], noteDuration); // to distinguish the notes, set a minimum time between them. // the note's duration + 30% seems to work well: int pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); // stop the tone playing: noTone(8); } } void loop() { // no need to repeat the melody. } Fritzing Circuit KiCad Schematic Video Demonstration","title":"toneMelody"},{"location":"04_builtin_examples/02.Digital/toneMelody/#sketch-code","text":"/* Melody Plays a melody circuit: - 8 ohm speaker on digital pin 8 created 21 Jan 2010 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneMelody */ #include \"pitches.h\" // notes in the melody: int melody[] = { NOTE_C4, NOTE_G3, NOTE_G3, NOTE_A3, NOTE_G3, 0, NOTE_B3, NOTE_C4 }; // note durations: 4 = quarter note, 8 = eighth note, etc.: int noteDurations[] = { 4, 8, 8, 4, 4, 4, 4, 4 }; void setup() { // iterate over the notes of the melody: for (int thisNote = 0; thisNote < 8; thisNote++) { // to calculate the note duration, take one second divided by the note type. //e.g. quarter note = 1000 / 4, eighth note = 1000/8, etc. int noteDuration = 1000 / noteDurations[thisNote]; tone(8, melody[thisNote], noteDuration); // to distinguish the notes, set a minimum time between them. // the note's duration + 30% seems to work well: int pauseBetweenNotes = noteDuration * 1.30; delay(pauseBetweenNotes); // stop the tone playing: noTone(8); } } void loop() { // no need to repeat the melody. }","title":"Sketch Code"},{"location":"04_builtin_examples/02.Digital/toneMelody/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/02.Digital/toneMelody/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/02.Digital/toneMelody/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/02.Digital/toneMultiple/","text":"Sketch Code /* Multiple tone player Plays multiple tones on multiple pins in sequence circuit: - three 8 ohm speakers on digital pins 6, 7, and 8 created 8 Mar 2010 by Tom Igoe based on a snippet from Greg Borenstein This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneMultiple */ void setup() { } void loop() { // turn off tone function for pin 8: noTone(8); // play a note on pin 6 for 200 ms: tone(6, 440, 200); delay(200); // turn off tone function for pin 6: noTone(6); // play a note on pin 7 for 500 ms: tone(7, 494, 500); delay(500); // turn off tone function for pin 7: noTone(7); // play a note on pin 8 for 300 ms: tone(8, 523, 300); delay(300); } Fritzing Circuit KiCad Schematic Video Demonstration N/A","title":"toneMultiple"},{"location":"04_builtin_examples/02.Digital/toneMultiple/#sketch-code","text":"/* Multiple tone player Plays multiple tones on multiple pins in sequence circuit: - three 8 ohm speakers on digital pins 6, 7, and 8 created 8 Mar 2010 by Tom Igoe based on a snippet from Greg Borenstein This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/toneMultiple */ void setup() { } void loop() { // turn off tone function for pin 8: noTone(8); // play a note on pin 6 for 200 ms: tone(6, 440, 200); delay(200); // turn off tone function for pin 6: noTone(6); // play a note on pin 7 for 500 ms: tone(7, 494, 500); delay(500); // turn off tone function for pin 7: noTone(7); // play a note on pin 8 for 300 ms: tone(8, 523, 300); delay(300); }","title":"Sketch Code"},{"location":"04_builtin_examples/02.Digital/toneMultiple/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/02.Digital/toneMultiple/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/02.Digital/toneMultiple/#video-demonstration","text":"N/A","title":"Video Demonstration"},{"location":"04_builtin_examples/02.Digital/tonePitchFollower/","text":"Sketch Code /* Pitch follower Plays a pitch that changes based on a changing analog input circuit: - 8 ohm speaker on digital pin 9 - photoresistor on analog 0 to 5V - 4.7 kilohm resistor on analog 0 to ground created 21 Jan 2010 modified 31 May 2012 by Tom Igoe, with suggestion from Michael Flynn This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/tonePitchFollower */ void setup() { // initialize serial communications (for debugging only): Serial.begin(9600); } void loop() { // read the sensor: int sensorReading = analogRead(A0); // print the sensor reading so you know its range Serial.println(sensorReading); // map the analog input range (in this case, 400 - 1000 from the photoresistor) // to the output pitch range (120 - 1500Hz) // change the minimum and maximum input numbers below depending on the range // your sensor's giving: int thisPitch = map(sensorReading, 400, 1000, 120, 1500); // play the pitch: tone(9, thisPitch, 10); delay(1); // delay in between reads for stability } Fritzing Circuit KiCad Schematic Video Demonstration N/A","title":"tonePitchFollower"},{"location":"04_builtin_examples/02.Digital/tonePitchFollower/#sketch-code","text":"/* Pitch follower Plays a pitch that changes based on a changing analog input circuit: - 8 ohm speaker on digital pin 9 - photoresistor on analog 0 to 5V - 4.7 kilohm resistor on analog 0 to ground created 21 Jan 2010 modified 31 May 2012 by Tom Igoe, with suggestion from Michael Flynn This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/tonePitchFollower */ void setup() { // initialize serial communications (for debugging only): Serial.begin(9600); } void loop() { // read the sensor: int sensorReading = analogRead(A0); // print the sensor reading so you know its range Serial.println(sensorReading); // map the analog input range (in this case, 400 - 1000 from the photoresistor) // to the output pitch range (120 - 1500Hz) // change the minimum and maximum input numbers below depending on the range // your sensor's giving: int thisPitch = map(sensorReading, 400, 1000, 120, 1500); // play the pitch: tone(9, thisPitch, 10); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/02.Digital/tonePitchFollower/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/02.Digital/tonePitchFollower/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/02.Digital/tonePitchFollower/#video-demonstration","text":"N/A","title":"Video Demonstration"},{"location":"04_builtin_examples/03.Analog/AnalogInOutSerial/","text":"Sketch Code /* Analog input, analog output, serial output Reads an analog input pin, maps the result to a range from 0 to 255 and uses the result to set the pulse width modulation (PWM) of an output pin. Also prints the results to the Serial Monitor. The circuit: - potentiometer connected to analog pin 0. Center pin of the potentiometer goes to the analog pin. side pins of the potentiometer go to +5V and ground - LED connected from digital pin 9 to ground through 220 ohm resistor created 29 Dec. 2008 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogInOutSerial */ // These constants won't change. They're used to give names to the pins used: const int analogInPin = A0; // Analog input pin that the potentiometer is attached to const int analogOutPin = 9; // Analog output pin that the LED is attached to int sensorValue = 0; // value read from the pot int outputValue = 0; // value output to the PWM (analog out) void setup() { // initialize serial communications at 9600 bps: Serial.begin(9600); } void loop() { // read the analog in value: sensorValue = analogRead(analogInPin); // map it to the range of the analog out: outputValue = map(sensorValue, 0, 1023, 0, 255); // change the analog out value: analogWrite(analogOutPin, outputValue); // print the results to the Serial Monitor: Serial.print(\"sensor = \"); Serial.print(sensorValue); Serial.print(\"\\t output = \"); Serial.println(outputValue); // wait 2 milliseconds before the next loop for the analog-to-digital // converter to settle after the last reading: delay(2); } Fritzing Circuit Same as Example AnalogReadSerial KiCad Schematic Same as Example AnalogReadSerial Video Demonstration","title":"AnalogInOutSerial"},{"location":"04_builtin_examples/03.Analog/AnalogInOutSerial/#sketch-code","text":"/* Analog input, analog output, serial output Reads an analog input pin, maps the result to a range from 0 to 255 and uses the result to set the pulse width modulation (PWM) of an output pin. Also prints the results to the Serial Monitor. The circuit: - potentiometer connected to analog pin 0. Center pin of the potentiometer goes to the analog pin. side pins of the potentiometer go to +5V and ground - LED connected from digital pin 9 to ground through 220 ohm resistor created 29 Dec. 2008 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogInOutSerial */ // These constants won't change. They're used to give names to the pins used: const int analogInPin = A0; // Analog input pin that the potentiometer is attached to const int analogOutPin = 9; // Analog output pin that the LED is attached to int sensorValue = 0; // value read from the pot int outputValue = 0; // value output to the PWM (analog out) void setup() { // initialize serial communications at 9600 bps: Serial.begin(9600); } void loop() { // read the analog in value: sensorValue = analogRead(analogInPin); // map it to the range of the analog out: outputValue = map(sensorValue, 0, 1023, 0, 255); // change the analog out value: analogWrite(analogOutPin, outputValue); // print the results to the Serial Monitor: Serial.print(\"sensor = \"); Serial.print(sensorValue); Serial.print(\"\\t output = \"); Serial.println(outputValue); // wait 2 milliseconds before the next loop for the analog-to-digital // converter to settle after the last reading: delay(2); }","title":"Sketch Code"},{"location":"04_builtin_examples/03.Analog/AnalogInOutSerial/#fritzing-circuit","text":"Same as Example AnalogReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/03.Analog/AnalogInOutSerial/#kicad-schematic","text":"Same as Example AnalogReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/03.Analog/AnalogInOutSerial/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/03.Analog/AnalogInput/","text":"Sketch Code /* Analog Input Demonstrates analog input by reading an analog sensor on analog pin 0 and turning on and off a light emitting diode(LED) connected to digital pin 13. The amount of time the LED will be on and off depends on the value obtained by analogRead(). The circuit: - potentiometer center pin of the potentiometer to the analog input 0 one side pin (either one) to ground the other side pin to +5V - LED anode (long leg) attached to digital output 13 through 220 ohm resistor cathode (short leg) attached to ground - Note: because most Arduinos have a built-in LED attached to pin 13 on the board, the LED is optional. created by David Cuartielles modified 30 Aug 2011 By Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogInput */ int sensorPin = A0; // select the input pin for the potentiometer int ledPin = 13; // select the pin for the LED int sensorValue = 0; // variable to store the value coming from the sensor void setup() { // declare the ledPin as an OUTPUT: pinMode(ledPin, OUTPUT); } void loop() { // read the value from the sensor: sensorValue = analogRead(sensorPin); // turn the ledPin on digitalWrite(ledPin, HIGH); // stop the program for <sensorValue> milliseconds: delay(sensorValue); // turn the ledPin off: digitalWrite(ledPin, LOW); // stop the program for for <sensorValue> milliseconds: delay(sensorValue); } Fritzing Circuit With Potentiometer Same as Example AnalogReadSerial With Photoresistor KiCad Schematic With Potentiometer Same as Example AnalogReadSerial With Photoresistor Video Demonstration","title":"AnalogInput"},{"location":"04_builtin_examples/03.Analog/AnalogInput/#sketch-code","text":"/* Analog Input Demonstrates analog input by reading an analog sensor on analog pin 0 and turning on and off a light emitting diode(LED) connected to digital pin 13. The amount of time the LED will be on and off depends on the value obtained by analogRead(). The circuit: - potentiometer center pin of the potentiometer to the analog input 0 one side pin (either one) to ground the other side pin to +5V - LED anode (long leg) attached to digital output 13 through 220 ohm resistor cathode (short leg) attached to ground - Note: because most Arduinos have a built-in LED attached to pin 13 on the board, the LED is optional. created by David Cuartielles modified 30 Aug 2011 By Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogInput */ int sensorPin = A0; // select the input pin for the potentiometer int ledPin = 13; // select the pin for the LED int sensorValue = 0; // variable to store the value coming from the sensor void setup() { // declare the ledPin as an OUTPUT: pinMode(ledPin, OUTPUT); } void loop() { // read the value from the sensor: sensorValue = analogRead(sensorPin); // turn the ledPin on digitalWrite(ledPin, HIGH); // stop the program for <sensorValue> milliseconds: delay(sensorValue); // turn the ledPin off: digitalWrite(ledPin, LOW); // stop the program for for <sensorValue> milliseconds: delay(sensorValue); }","title":"Sketch Code"},{"location":"04_builtin_examples/03.Analog/AnalogInput/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/03.Analog/AnalogInput/#with-potentiometer","text":"Same as Example AnalogReadSerial","title":"With Potentiometer"},{"location":"04_builtin_examples/03.Analog/AnalogInput/#with-photoresistor","text":"","title":"With Photoresistor"},{"location":"04_builtin_examples/03.Analog/AnalogInput/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/03.Analog/AnalogInput/#with-potentiometer_1","text":"Same as Example AnalogReadSerial","title":"With Potentiometer"},{"location":"04_builtin_examples/03.Analog/AnalogInput/#with-photoresistor_1","text":"","title":"With Photoresistor"},{"location":"04_builtin_examples/03.Analog/AnalogInput/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/03.Analog/AnalogWriteMega/","text":"Sketch Code /* Mega analogWrite() test This sketch fades LEDs up and down one at a time on digital pins 2 through 13. This sketch was written for the Arduino Mega, and will not work on other boards. The circuit: - LEDs attached from pins 2 through 13 to ground. created 8 Feb 2009 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogWriteMega */ // These constants won't change. They're used to give names to the pins used: const int lowestPin = 2; const int highestPin = 13; void setup() { // set pins 2 through 13 as outputs: for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // iterate over the pins: for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) { // fade the LED on thisPin from off to brightest: for (int brightness = 0; brightness < 255; brightness++) { analogWrite(thisPin, brightness); delay(2); } // fade the LED on thisPin from brightest to off: for (int brightness = 255; brightness >= 0; brightness--) { analogWrite(thisPin, brightness); delay(2); } // pause between LEDs: delay(100); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"AnalogWriteMega"},{"location":"04_builtin_examples/03.Analog/AnalogWriteMega/#sketch-code","text":"/* Mega analogWrite() test This sketch fades LEDs up and down one at a time on digital pins 2 through 13. This sketch was written for the Arduino Mega, and will not work on other boards. The circuit: - LEDs attached from pins 2 through 13 to ground. created 8 Feb 2009 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/AnalogWriteMega */ // These constants won't change. They're used to give names to the pins used: const int lowestPin = 2; const int highestPin = 13; void setup() { // set pins 2 through 13 as outputs: for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // iterate over the pins: for (int thisPin = lowestPin; thisPin <= highestPin; thisPin++) { // fade the LED on thisPin from off to brightest: for (int brightness = 0; brightness < 255; brightness++) { analogWrite(thisPin, brightness); delay(2); } // fade the LED on thisPin from brightest to off: for (int brightness = 255; brightness >= 0; brightness--) { analogWrite(thisPin, brightness); delay(2); } // pause between LEDs: delay(100); } }","title":"Sketch Code"},{"location":"04_builtin_examples/03.Analog/AnalogWriteMega/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/03.Analog/AnalogWriteMega/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/03.Analog/AnalogWriteMega/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/03.Analog/Calibration/","text":"Sketch Code /* Calibration Demonstrates one technique for calibrating sensor input. The sensor readings during the first five seconds of the sketch execution define the minimum and maximum of expected values attached to the sensor pin. The sensor minimum and maximum initial values may seem backwards. Initially, you set the minimum high and listen for anything lower, saving it as the new minimum. Likewise, you set the maximum low and listen for anything higher as the new maximum. The circuit: - analog sensor (potentiometer will do) attached to analog input 0 - LED attached from digital pin 9 to ground through 220 ohm resistor created 29 Oct 2008 by David A Mellis modified 30 Aug 2011 by Tom Igoe modified 07 Apr 2017 by Zachary J. Fields This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Calibration */ // These constants won't change: const int sensorPin = A0; // pin that the sensor is attached to const int ledPin = 9; // pin that the LED is attached to // variables: int sensorValue = 0; // the sensor value int sensorMin = 1023; // minimum sensor value int sensorMax = 0; // maximum sensor value void setup() { // turn on LED to signal the start of the calibration period: pinMode(13, OUTPUT); digitalWrite(13, HIGH); // calibrate during the first five seconds while (millis() < 5000) { sensorValue = analogRead(sensorPin); // record the maximum sensor value if (sensorValue > sensorMax) { sensorMax = sensorValue; } // record the minimum sensor value if (sensorValue < sensorMin) { sensorMin = sensorValue; } } // signal the end of the calibration period digitalWrite(13, LOW); } void loop() { // read the sensor: sensorValue = analogRead(sensorPin); // in case the sensor value is outside the range seen during calibration sensorValue = constrain(sensorValue, sensorMin, sensorMax); // apply the calibration to the sensor reading sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255); // fade the LED using the calibrated value: analogWrite(ledPin, sensorValue); } Fritzing Circuit Note There is an error from the official Arduino built-in example Calibration . Please refer to my issue asked at Is the sketch for Calibration wrong? KiCad Schematic Video Demonstration","title":"Calibration"},{"location":"04_builtin_examples/03.Analog/Calibration/#sketch-code","text":"/* Calibration Demonstrates one technique for calibrating sensor input. The sensor readings during the first five seconds of the sketch execution define the minimum and maximum of expected values attached to the sensor pin. The sensor minimum and maximum initial values may seem backwards. Initially, you set the minimum high and listen for anything lower, saving it as the new minimum. Likewise, you set the maximum low and listen for anything higher as the new maximum. The circuit: - analog sensor (potentiometer will do) attached to analog input 0 - LED attached from digital pin 9 to ground through 220 ohm resistor created 29 Oct 2008 by David A Mellis modified 30 Aug 2011 by Tom Igoe modified 07 Apr 2017 by Zachary J. Fields This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Calibration */ // These constants won't change: const int sensorPin = A0; // pin that the sensor is attached to const int ledPin = 9; // pin that the LED is attached to // variables: int sensorValue = 0; // the sensor value int sensorMin = 1023; // minimum sensor value int sensorMax = 0; // maximum sensor value void setup() { // turn on LED to signal the start of the calibration period: pinMode(13, OUTPUT); digitalWrite(13, HIGH); // calibrate during the first five seconds while (millis() < 5000) { sensorValue = analogRead(sensorPin); // record the maximum sensor value if (sensorValue > sensorMax) { sensorMax = sensorValue; } // record the minimum sensor value if (sensorValue < sensorMin) { sensorMin = sensorValue; } } // signal the end of the calibration period digitalWrite(13, LOW); } void loop() { // read the sensor: sensorValue = analogRead(sensorPin); // in case the sensor value is outside the range seen during calibration sensorValue = constrain(sensorValue, sensorMin, sensorMax); // apply the calibration to the sensor reading sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255); // fade the LED using the calibrated value: analogWrite(ledPin, sensorValue); }","title":"Sketch Code"},{"location":"04_builtin_examples/03.Analog/Calibration/#fritzing-circuit","text":"Note There is an error from the official Arduino built-in example Calibration . Please refer to my issue asked at Is the sketch for Calibration wrong?","title":"Fritzing Circuit"},{"location":"04_builtin_examples/03.Analog/Calibration/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/03.Analog/Calibration/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/03.Analog/Fading/","text":"Sketch Code /* Fading This example shows how to fade an LED using the analogWrite() function. The circuit: - LED attached from digital pin 9 to ground through 220 ohm resistor. created 1 Nov 2008 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Fading */ int ledPin = 9; // LED connected to digital pin 9 void setup() { // nothing happens in setup } void loop() { // fade in from min to max in increments of 5 points: for (int fadeValue = 0; fadeValue <= 255; fadeValue += 5) { // sets the value (range from 0 to 255): analogWrite(ledPin, fadeValue); // wait for 30 milliseconds to see the dimming effect delay(30); } // fade out from max to min in increments of 5 points: for (int fadeValue = 255; fadeValue >= 0; fadeValue -= 5) { // sets the value (range from 0 to 255): analogWrite(ledPin, fadeValue); // wait for 30 milliseconds to see the dimming effect delay(30); } } Fritzing Circuit Same as Example Fade KiCad Schematic Same as Example Fade Video Demonstration","title":"Fading"},{"location":"04_builtin_examples/03.Analog/Fading/#sketch-code","text":"/* Fading This example shows how to fade an LED using the analogWrite() function. The circuit: - LED attached from digital pin 9 to ground through 220 ohm resistor. created 1 Nov 2008 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Fading */ int ledPin = 9; // LED connected to digital pin 9 void setup() { // nothing happens in setup } void loop() { // fade in from min to max in increments of 5 points: for (int fadeValue = 0; fadeValue <= 255; fadeValue += 5) { // sets the value (range from 0 to 255): analogWrite(ledPin, fadeValue); // wait for 30 milliseconds to see the dimming effect delay(30); } // fade out from max to min in increments of 5 points: for (int fadeValue = 255; fadeValue >= 0; fadeValue -= 5) { // sets the value (range from 0 to 255): analogWrite(ledPin, fadeValue); // wait for 30 milliseconds to see the dimming effect delay(30); } }","title":"Sketch Code"},{"location":"04_builtin_examples/03.Analog/Fading/#fritzing-circuit","text":"Same as Example Fade","title":"Fritzing Circuit"},{"location":"04_builtin_examples/03.Analog/Fading/#kicad-schematic","text":"Same as Example Fade","title":"KiCad Schematic"},{"location":"04_builtin_examples/03.Analog/Fading/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/03.Analog/Smoothing/","text":"Sketch Code /* Smoothing Reads repeatedly from an analog input, calculating a running average and printing it to the computer. Keeps ten readings in an array and continually averages them. The circuit: - analog sensor (potentiometer will do) attached to analog input 0 created 22 Apr 2007 by David A. Mellis <dam@mellis.org> modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Smoothing */ // Define the number of samples to keep track of. The higher the number, the // more the readings will be smoothed, but the slower the output will respond to // the input. Using a constant rather than a normal variable lets us use this // value to determine the size of the readings array. const int numReadings = 10; int readings[numReadings]; // the readings from the analog input int readIndex = 0; // the index of the current reading int total = 0; // the running total int average = 0; // the average int inputPin = A0; void setup() { // initialize serial communication with computer: Serial.begin(9600); // initialize all the readings to 0: for (int thisReading = 0; thisReading < numReadings; thisReading++) { readings[thisReading] = 0; } } void loop() { // subtract the last reading: total = total - readings[readIndex]; // read from the sensor: readings[readIndex] = analogRead(inputPin); // add the reading to the total: total = total + readings[readIndex]; // advance to the next position in the array: readIndex = readIndex + 1; // if we're at the end of the array... if (readIndex >= numReadings) { // ...wrap around to the beginning: readIndex = 0; } // calculate the average: average = total / numReadings; // send it to the computer as ASCII digits Serial.println(average); delay(1); // delay in between reads for stability } Fritzing Circuit Same as Example AnalogReadSerial KiCad Schematic Same as Example AnalogReadSerial Video Demonstration","title":"Smoothing"},{"location":"04_builtin_examples/03.Analog/Smoothing/#sketch-code","text":"/* Smoothing Reads repeatedly from an analog input, calculating a running average and printing it to the computer. Keeps ten readings in an array and continually averages them. The circuit: - analog sensor (potentiometer will do) attached to analog input 0 created 22 Apr 2007 by David A. Mellis <dam@mellis.org> modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Smoothing */ // Define the number of samples to keep track of. The higher the number, the // more the readings will be smoothed, but the slower the output will respond to // the input. Using a constant rather than a normal variable lets us use this // value to determine the size of the readings array. const int numReadings = 10; int readings[numReadings]; // the readings from the analog input int readIndex = 0; // the index of the current reading int total = 0; // the running total int average = 0; // the average int inputPin = A0; void setup() { // initialize serial communication with computer: Serial.begin(9600); // initialize all the readings to 0: for (int thisReading = 0; thisReading < numReadings; thisReading++) { readings[thisReading] = 0; } } void loop() { // subtract the last reading: total = total - readings[readIndex]; // read from the sensor: readings[readIndex] = analogRead(inputPin); // add the reading to the total: total = total + readings[readIndex]; // advance to the next position in the array: readIndex = readIndex + 1; // if we're at the end of the array... if (readIndex >= numReadings) { // ...wrap around to the beginning: readIndex = 0; } // calculate the average: average = total / numReadings; // send it to the computer as ASCII digits Serial.println(average); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/03.Analog/Smoothing/#fritzing-circuit","text":"Same as Example AnalogReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/03.Analog/Smoothing/#kicad-schematic","text":"Same as Example AnalogReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/03.Analog/Smoothing/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/ASCIITable/","text":"Sketch Code /* ASCII table Prints out byte values in all possible formats: - as raw binary values - as ASCII-encoded decimal, hex, octal, and binary values For more on ASCII, see http://www.asciitable.com and http://en.wikipedia.org/wiki/ASCII The circuit: No external hardware needed. created 2006 by Nicholas Zambetti <http://www.zambetti.com> modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ASCIITable */ void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // prints title with ending line break Serial.println(\"ASCII Table ~ Character Map\"); } // first visible ASCIIcharacter '!' is number 33: int thisByte = 33; // you can also write ASCII characters in single quotes. // for example, '!' is the same as 33, so you could also use this: // int thisByte = '!'; void loop() { // prints value unaltered, i.e. the raw binary version of the byte. // The Serial Monitor interprets all bytes as ASCII, so 33, the first number, // will show up as '!' Serial.write(thisByte); Serial.print(\", dec: \"); // prints value as string as an ASCII-encoded decimal (base 10). // Decimal is the default format for Serial.print() and Serial.println(), // so no modifier is needed: Serial.print(thisByte); // But you can declare the modifier for decimal if you want to. // this also works if you uncomment it: // Serial.print(thisByte, DEC); Serial.print(\", hex: \"); // prints value as string in hexadecimal (base 16): Serial.print(thisByte, HEX); Serial.print(\", oct: \"); // prints value as string in octal (base 8); Serial.print(thisByte, OCT); Serial.print(\", bin: \"); // prints value as string in binary (base 2) also prints ending line break: Serial.println(thisByte, BIN); // if printed last visible character '~' or 126, stop: if (thisByte == 126) { // you could also use if (thisByte == '~') { // This loop loops forever and does nothing while (true) { continue; } } // go on to the next character thisByte++; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"ASCIITable"},{"location":"04_builtin_examples/04.Communication/ASCIITable/#sketch-code","text":"/* ASCII table Prints out byte values in all possible formats: - as raw binary values - as ASCII-encoded decimal, hex, octal, and binary values For more on ASCII, see http://www.asciitable.com and http://en.wikipedia.org/wiki/ASCII The circuit: No external hardware needed. created 2006 by Nicholas Zambetti <http://www.zambetti.com> modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ASCIITable */ void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // prints title with ending line break Serial.println(\"ASCII Table ~ Character Map\"); } // first visible ASCIIcharacter '!' is number 33: int thisByte = 33; // you can also write ASCII characters in single quotes. // for example, '!' is the same as 33, so you could also use this: // int thisByte = '!'; void loop() { // prints value unaltered, i.e. the raw binary version of the byte. // The Serial Monitor interprets all bytes as ASCII, so 33, the first number, // will show up as '!' Serial.write(thisByte); Serial.print(\", dec: \"); // prints value as string as an ASCII-encoded decimal (base 10). // Decimal is the default format for Serial.print() and Serial.println(), // so no modifier is needed: Serial.print(thisByte); // But you can declare the modifier for decimal if you want to. // this also works if you uncomment it: // Serial.print(thisByte, DEC); Serial.print(\", hex: \"); // prints value as string in hexadecimal (base 16): Serial.print(thisByte, HEX); Serial.print(\", oct: \"); // prints value as string in octal (base 8); Serial.print(thisByte, OCT); Serial.print(\", bin: \"); // prints value as string in binary (base 2) also prints ending line break: Serial.println(thisByte, BIN); // if printed last visible character '~' or 126, stop: if (thisByte == 126) { // you could also use if (thisByte == '~') { // This loop loops forever and does nothing while (true) { continue; } } // go on to the next character thisByte++; }","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/ASCIITable/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/ASCIITable/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/ASCIITable/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/Dimmer/","text":"Sketch Code /* Dimmer Demonstrates sending data from the computer to the Arduino board, in this case to control the brightness of an LED. The data is sent in individual bytes, each of which ranges from 0 to 255. Arduino reads these bytes and uses them to set the brightness of the LED. The circuit: - LED attached from digital pin 9 to ground through 220 ohm resistor. - Serial connection to Processing, Max/MSP, or another serial application created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Dimmer */ const int ledPin = 9; // the pin that the LED is attached to void setup() { // initialize the serial communication: Serial.begin(9600); // initialize the ledPin as an output: pinMode(ledPin, OUTPUT); } void loop() { byte brightness; // check if data has been sent from the computer: if (Serial.available()) { // read the most recent byte (which will be from 0 to 255): brightness = Serial.read(); // set the brightness of the LED: analogWrite(ledPin, brightness); } } /* Processing code for this example // Dimmer - sends bytes over a serial port // by David A. Mellis // This example code is in the public domain. import processing.serial.*; Serial port; void setup() { size(256, 150); println(\"Available serial ports:\"); // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // Uses the first port in this list (number 0). Change this to select the port // corresponding to your Arduino board. The last parameter (e.g. 9600) is the // speed of the communication. It has to correspond to the value passed to // Serial.begin() in your Arduino sketch. port = new Serial(this, Serial.list()[0], 9600); // If you know the name of the port used by the Arduino board, you can specify // it directly like this. //port = new Serial(this, \"COM1\", 9600); } void draw() { // draw a gradient from black to white for (int i = 0; i < 256; i++) { stroke(i); line(i, 0, i, 150); } // write the current X-position of the mouse to the serial port as // a single byte port.write(mouseX); } */ /* Max/MSP v5 patch for this example ----------begin_max5_patcher---------- 1008.3ocuXszaiaCD9r8uhA5rqAeHIa0aAMaAVf1S6hdoYQAsDiL6JQZHQ2M YWr+2KeX4vjnjXKKkKhhiGQ9MeyCNz+X9rnMp63sQvuB+MLa1OlOalSjUvrC ymEUytKuh05TKJWUWyk5nE9eSyuS6jesvHu4F4MxOuUzB6X57sPKWVzBLXiP xZtGj6q2vafaaT0.BzJfjj.p8ZPukazsQvpfcpFs8mXR3plh8BoBxURIOWyK rxspZ0YI.eTCEh5Vqp+wGtFXZMKe6CZc3yWZwTdCmYW.BBkdiby8v0r+ST.W sD9SdUkn8FYspPbqvnBNFtZWiUyLmleJWo0vuKzeuj2vpJLaWA7YiE7wREui FpDFDp1KcbAFcP5sJoVxp4NB5Jq40ougIDxJt1wo3GDZHiNocKhiIExx+owv AdOEAksDs.RRrOoww1Arc.9RvN2J9tamwjkcqknvAE0l+8WnjHqreNet8whK z6mukIK4d+Xknv3jstvJs8EirMMhxsZIusET25jXbX8xczIl5xPVxhPcTGFu xNDu9rXtUCg37g9Q8Yc+EuofIYmg8QdkPCrOnXsaHwYs3rWx9PGsO+pqueG2 uNQBqWFh1X7qQG+3.VHcHrfO1nyR2TlqpTM9MDsLKNCQVz6KO.+Sfc5j1Ykj jzkn2jwNDRP7LVb3d9LtoWBAOnvB92Le6yRmZ4UF7YpQhiFi7A5Ka8zXhKdA 4r9TRGG7V4COiSbAJKdXrWNhhF0hNUh7uBa4Mba0l7JUK+omjDMwkSn95Izr TOwkdp7W.oPRmNRQsiKeu4j3CkfVgt.NYPEYqMGvvJ48vIlPiyzrIuZskWIS xGJPcmPiWOfLodybH3wjPbMYwlbFIMNHPHFOtLBNaLSa9sGk1TxMzCX5KTa6 WIH2ocxSdngM0QPqFRxyPHFsprrhGc9Gy9xoBjz0NWdR2yW9DUa2F85jG2v9 FgTO4Q8qiC7fzzQNpmNpsY3BrYPVJBMJQ1uVmoItRhw9NrVGO3NMNzYZ+zS7 3WTvTOnUydG5kHMKLqAOjTe7fN2bGSxOZDkMrBrGQ9J1gONBEy0k4gVo8qHc cxmfxVihWz6a3yqY9NazzUYkua9UnynadOtogW.JfsVGRVNEbWF8I+eHtcwJ +wLXqZeSdWLo+FQF6731Tva0BISKTx.cLwmgJsUTTvkg1YsnXmxDge.CDR7x D6YmX6fMznaF7kdczmJXwm.XSOOrdoHhNA7GMiZYLZZR.+4lconMaJP6JOZ8 ftCs1YWHZI3o.sIXezX5ihMSuXzZtk3ai1mXRSczoCS32hAydeyXNEu5SHyS xqZqbd3ZLdera1iPqYxOm++v7SUSz -----------end_max5_patcher----------- */ Fritzing Circuit Same as Example Fade KiCad Schematic Same as Example Fade Video Demonstration","title":"Dimmer"},{"location":"04_builtin_examples/04.Communication/Dimmer/#sketch-code","text":"/* Dimmer Demonstrates sending data from the computer to the Arduino board, in this case to control the brightness of an LED. The data is sent in individual bytes, each of which ranges from 0 to 255. Arduino reads these bytes and uses them to set the brightness of the LED. The circuit: - LED attached from digital pin 9 to ground through 220 ohm resistor. - Serial connection to Processing, Max/MSP, or another serial application created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Dimmer */ const int ledPin = 9; // the pin that the LED is attached to void setup() { // initialize the serial communication: Serial.begin(9600); // initialize the ledPin as an output: pinMode(ledPin, OUTPUT); } void loop() { byte brightness; // check if data has been sent from the computer: if (Serial.available()) { // read the most recent byte (which will be from 0 to 255): brightness = Serial.read(); // set the brightness of the LED: analogWrite(ledPin, brightness); } } /* Processing code for this example // Dimmer - sends bytes over a serial port // by David A. Mellis // This example code is in the public domain. import processing.serial.*; Serial port; void setup() { size(256, 150); println(\"Available serial ports:\"); // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // Uses the first port in this list (number 0). Change this to select the port // corresponding to your Arduino board. The last parameter (e.g. 9600) is the // speed of the communication. It has to correspond to the value passed to // Serial.begin() in your Arduino sketch. port = new Serial(this, Serial.list()[0], 9600); // If you know the name of the port used by the Arduino board, you can specify // it directly like this. //port = new Serial(this, \"COM1\", 9600); } void draw() { // draw a gradient from black to white for (int i = 0; i < 256; i++) { stroke(i); line(i, 0, i, 150); } // write the current X-position of the mouse to the serial port as // a single byte port.write(mouseX); } */ /* Max/MSP v5 patch for this example ----------begin_max5_patcher---------- 1008.3ocuXszaiaCD9r8uhA5rqAeHIa0aAMaAVf1S6hdoYQAsDiL6JQZHQ2M YWr+2KeX4vjnjXKKkKhhiGQ9MeyCNz+X9rnMp63sQvuB+MLa1OlOalSjUvrC ymEUytKuh05TKJWUWyk5nE9eSyuS6jesvHu4F4MxOuUzB6X57sPKWVzBLXiP xZtGj6q2vafaaT0.BzJfjj.p8ZPukazsQvpfcpFs8mXR3plh8BoBxURIOWyK rxspZ0YI.eTCEh5Vqp+wGtFXZMKe6CZc3yWZwTdCmYW.BBkdiby8v0r+ST.W sD9SdUkn8FYspPbqvnBNFtZWiUyLmleJWo0vuKzeuj2vpJLaWA7YiE7wREui FpDFDp1KcbAFcP5sJoVxp4NB5Jq40ougIDxJt1wo3GDZHiNocKhiIExx+owv AdOEAksDs.RRrOoww1Arc.9RvN2J9tamwjkcqknvAE0l+8WnjHqreNet8whK z6mukIK4d+Xknv3jstvJs8EirMMhxsZIusET25jXbX8xczIl5xPVxhPcTGFu xNDu9rXtUCg37g9Q8Yc+EuofIYmg8QdkPCrOnXsaHwYs3rWx9PGsO+pqueG2 uNQBqWFh1X7qQG+3.VHcHrfO1nyR2TlqpTM9MDsLKNCQVz6KO.+Sfc5j1Ykj jzkn2jwNDRP7LVb3d9LtoWBAOnvB92Le6yRmZ4UF7YpQhiFi7A5Ka8zXhKdA 4r9TRGG7V4COiSbAJKdXrWNhhF0hNUh7uBa4Mba0l7JUK+omjDMwkSn95Izr TOwkdp7W.oPRmNRQsiKeu4j3CkfVgt.NYPEYqMGvvJ48vIlPiyzrIuZskWIS xGJPcmPiWOfLodybH3wjPbMYwlbFIMNHPHFOtLBNaLSa9sGk1TxMzCX5KTa6 WIH2ocxSdngM0QPqFRxyPHFsprrhGc9Gy9xoBjz0NWdR2yW9DUa2F85jG2v9 FgTO4Q8qiC7fzzQNpmNpsY3BrYPVJBMJQ1uVmoItRhw9NrVGO3NMNzYZ+zS7 3WTvTOnUydG5kHMKLqAOjTe7fN2bGSxOZDkMrBrGQ9J1gONBEy0k4gVo8qHc cxmfxVihWz6a3yqY9NazzUYkua9UnynadOtogW.JfsVGRVNEbWF8I+eHtcwJ +wLXqZeSdWLo+FQF6731Tva0BISKTx.cLwmgJsUTTvkg1YsnXmxDge.CDR7x D6YmX6fMznaF7kdczmJXwm.XSOOrdoHhNA7GMiZYLZZR.+4lconMaJP6JOZ8 ftCs1YWHZI3o.sIXezX5ihMSuXzZtk3ai1mXRSczoCS32hAydeyXNEu5SHyS xqZqbd3ZLdera1iPqYxOm++v7SUSz -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/Dimmer/#fritzing-circuit","text":"Same as Example Fade","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/Dimmer/#kicad-schematic","text":"Same as Example Fade","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/Dimmer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/Graph/","text":"Sketch Code /* Graph A simple example of communication from the Arduino board to the computer: The value of analog input 0 is sent out the serial port. We call this \"serial\" communication because the connection appears to both the Arduino and the computer as a serial port, even though it may actually use a USB cable. Bytes are sent one after another (serially) from the Arduino to the computer. You can use the Arduino Serial Monitor to view the sent data, or it can be read by Processing, PD, Max/MSP, or any other program capable of reading data from a serial port. The Processing code below graphs the data received so you can see the value of the analog input changing over time. The circuit: - any analog input sensor attached to analog in pin 0 created 2006 by David A. Mellis modified 9 Apr 2012 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Graph */ void setup() { // initialize the serial communication: Serial.begin(9600); } void loop() { // send the value of analog input 0: Serial.println(analogRead(A0)); // wait a bit for the analog-to-digital converter to stabilize after the last // reading: delay(2); } /* Processing code for this example // Graphing sketch // This program takes ASCII-encoded strings from the serial port at 9600 baud // and graphs them. It expects values in the range 0 to 1023, followed by a // newline, or newline and carriage return // created 20 Apr 2005 // updated 24 Nov 2015 // by Tom Igoe // This example code is in the public domain. import processing.serial.*; Serial myPort; // The serial port int xPos = 1; // horizontal position of the graph float inByte = 0; void setup () { // set the window size: size(400, 300); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino, so I open Serial.list()[0]. // Open whatever port is the one you're using. myPort = new Serial(this, Serial.list()[0], 9600); // don't generate a serialEvent() unless you get a newline character: myPort.bufferUntil('\\n'); // set initial background: background(0); } void draw () { // draw the line: stroke(127, 34, 255); line(xPos, height, xPos, height - inByte); // at the edge of the screen, go back to the beginning: if (xPos >= width) { xPos = 0; background(0); } else { // increment the horizontal position: xPos++; } } void serialEvent (Serial myPort) { // get the ASCII string: String inString = myPort.readStringUntil('\\n'); if (inString != null) { // trim off any whitespace: inString = trim(inString); // convert to an int and map to the screen height: inByte = float(inString); println(inByte); inByte = map(inByte, 0, 1023, 0, height); } } */ /* Max/MSP v5 patch for this example ----------begin_max5_patcher---------- 1591.3oc0YszbaaCD9r7uBL5RalQUAO3CvdyS5zVenWZxs5NcfHgjPCIfJIT RTxj+6AOHkoTDooroUs0AQPR73a+1cwtK3WtZxzEpOwqlB9YveAlL4KWMYh6 Q1GLo99ISKXeJMmU451zTUQAWpmNy+NM+SZ2y+sR1l02JuU9t0hJvFlNcMPy dOuBv.U5Rgb0LPpRpYBooM3529latArTUVvzZdFPtsXAuDrrTU.f.sBffXxL vGE50lIHkUVJXq3fRtdaoDvjYfbgjujaFJSCzq4.tLaN.bi1tJefWpqbO0uz 1IjIABoluxrJ1guxh2JfPO2B5zRNyBCLDFcqbwNvuv9fHCb8bvevyyEU2JKT YhkBSWPAfq2TZ6YhqmuMUo0feUn+rYpY4YtY+cFw3lUJdCMYAapZqzwUHX8S crjAd+SIOU6UBAwIygy.Q1+HAA1KH6EveWOFQlitUK92ehfal9kFhUxJ3tWc sgpxadigWExbt1o7Ps5dk3yttivyg20W0VcSmg1G90qtx92rAZbH4ez.ruy1 nhmaDPidE07J+5n2sg6E6oKXxUSmc20o6E3SPRDbrkXnPGUYE.i5nCNB9TxQ jG.G0kCTZtH88f07Rt0ZMMWUw8VvbKVAaTk6GyoraPdZff7rQTejBN54lgyv HE0Ft7AvIvvgvIwO23jBdUkYOuSvIFSiNcjFhiSsUBwsUCh1AgfNSBAeNDBZ DIDqY.f8.YjfjV1HAn9XDTxyNFYatVTkKx3kcK9GraZpI5jv7GOx+Z37Xh82 LSKHIDmDXaESoXRngIZQDKVkpxUkMCyXCQhcCK1z.G457gi3TzMz4RFD515F G3bIQQwcP3SOF0zlkGhiCBQ1kOHHFFlXaEBQIQnCwv9QF1LxPZ.A4jR5cyQs vbvHMJsLll01We+rE2LazX6zYmCraRrsPFwKg1ANBZFY.IAihr8Ox.aH0oAL hB8nQVw0FSJiZeunOykbT6t3r.NP8.iL+bnwNiXuVMNJH9H9YCm89CFXPBER bz422p8.O4dg6kRxdyjDqRwMIHTbT3QFLskxJ8tbmQK4tm0XGeZWF7wKKtYY aTAF.XPNFaaQBinQMJ4QLF0aNHF0JtYuHSxoUZfZY6.UU2ejJTb8lQw8Fo5k Rv6e2PI+fOM71o2ecY1VgTYdCSxxUqLokuYq9jYJi6lxPgD2NIPePLB0mwbG YA9Rgxdiu1k5xiLlSU6JVnx6wzg3sYHwTesB8Z5D7RiGZpXyvDNJY.DQX3.H hvmcUN4bP1yCkhpTle2P37jtBsKrLWcMScEmltOPv22ZfAqQAdKr9HzATQwZ q18PrUGt6Tst2XMCRUfGuhXs6ccn23YloomMqcTiC5iMGPsHsHRWhWFlaenV XcqwgCQiGGJzptyS2ZMODBz6fGza0bzmXBj7+DA94bvpR01MffAlueO7HwcI pWCwmzJdvi9ILgflLAFmyXB6O7ML0YbD26lenmcGxjVsZUN+A6pUK7AtTrPg M+eRYG0qD9j4I7eEbco8Xh6WcO.or9XDC6UCiewbXHkh6xm5LiPEkzpJDRTu mEB44Fgz4NCtJvX.SM1vo2SlTCZGAe7GZu6ahdRyzFOhYZ+mbVVSYptBw.K1 tboIkatIA7c1cTKD1u.honLYV04VkluHsXe0szv9pQCE9Ro3jaVB1o15pz2X zYoBvO5KXCAe0LCYJybE8ZODf4fV8t9qW0zYxq.YJfTosj1bv0xc.SaC0+AV 9V9L.KKyV3SyTcRtmzi6rO.O16USvts4B5xe9EymDvebK0eMfW6+NIsNlE2m eqRyJ0utRq13+RjmqYKN1e.4d61jjdsauXe3.2p6jgi9hsNIv97CoyJ01xzl c3ZhUCtSHx3UZgjoEJYqNY+hYs5zZQVFW19L3JDYaTlMLqAAt1G2yXlnFg9a 53L1FJVcv.cOX0dh7mCVGCLce7GFcQwDdH5Ta3nyAS0pQbHxegr+tGIZORgM RnMj5vGl1Fs16drnk7Tf1XOLgv1n0d2iEsCxR.eQsNOZ4FGF7whofgfI3kES 1kCeOX5L2rifbdu0A9ae2X.V33B1Z+.Bj1FrP5iFrCYCG5EUWSG.hhunHJd. HJ5hhnng3h9HPj4lud02.1bxGw. -----------end_max5_patcher----------- */ Fritzing Circuit Same as Example AnalogReadSerial KiCad Schematic Same as Example AnalogReadSerial Video Demonstration","title":"Graph"},{"location":"04_builtin_examples/04.Communication/Graph/#sketch-code","text":"/* Graph A simple example of communication from the Arduino board to the computer: The value of analog input 0 is sent out the serial port. We call this \"serial\" communication because the connection appears to both the Arduino and the computer as a serial port, even though it may actually use a USB cable. Bytes are sent one after another (serially) from the Arduino to the computer. You can use the Arduino Serial Monitor to view the sent data, or it can be read by Processing, PD, Max/MSP, or any other program capable of reading data from a serial port. The Processing code below graphs the data received so you can see the value of the analog input changing over time. The circuit: - any analog input sensor attached to analog in pin 0 created 2006 by David A. Mellis modified 9 Apr 2012 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Graph */ void setup() { // initialize the serial communication: Serial.begin(9600); } void loop() { // send the value of analog input 0: Serial.println(analogRead(A0)); // wait a bit for the analog-to-digital converter to stabilize after the last // reading: delay(2); } /* Processing code for this example // Graphing sketch // This program takes ASCII-encoded strings from the serial port at 9600 baud // and graphs them. It expects values in the range 0 to 1023, followed by a // newline, or newline and carriage return // created 20 Apr 2005 // updated 24 Nov 2015 // by Tom Igoe // This example code is in the public domain. import processing.serial.*; Serial myPort; // The serial port int xPos = 1; // horizontal position of the graph float inByte = 0; void setup () { // set the window size: size(400, 300); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino, so I open Serial.list()[0]. // Open whatever port is the one you're using. myPort = new Serial(this, Serial.list()[0], 9600); // don't generate a serialEvent() unless you get a newline character: myPort.bufferUntil('\\n'); // set initial background: background(0); } void draw () { // draw the line: stroke(127, 34, 255); line(xPos, height, xPos, height - inByte); // at the edge of the screen, go back to the beginning: if (xPos >= width) { xPos = 0; background(0); } else { // increment the horizontal position: xPos++; } } void serialEvent (Serial myPort) { // get the ASCII string: String inString = myPort.readStringUntil('\\n'); if (inString != null) { // trim off any whitespace: inString = trim(inString); // convert to an int and map to the screen height: inByte = float(inString); println(inByte); inByte = map(inByte, 0, 1023, 0, height); } } */ /* Max/MSP v5 patch for this example ----------begin_max5_patcher---------- 1591.3oc0YszbaaCD9r7uBL5RalQUAO3CvdyS5zVenWZxs5NcfHgjPCIfJIT RTxj+6AOHkoTDooroUs0AQPR73a+1cwtK3WtZxzEpOwqlB9YveAlL4KWMYh6 Q1GLo99ISKXeJMmU451zTUQAWpmNy+NM+SZ2y+sR1l02JuU9t0hJvFlNcMPy dOuBv.U5Rgb0LPpRpYBooM3529latArTUVvzZdFPtsXAuDrrTU.f.sBffXxL vGE50lIHkUVJXq3fRtdaoDvjYfbgjujaFJSCzq4.tLaN.bi1tJefWpqbO0uz 1IjIABoluxrJ1guxh2JfPO2B5zRNyBCLDFcqbwNvuv9fHCb8bvevyyEU2JKT YhkBSWPAfq2TZ6YhqmuMUo0feUn+rYpY4YtY+cFw3lUJdCMYAapZqzwUHX8S crjAd+SIOU6UBAwIygy.Q1+HAA1KH6EveWOFQlitUK92ehfal9kFhUxJ3tWc sgpxadigWExbt1o7Ps5dk3yttivyg20W0VcSmg1G90qtx92rAZbH4ez.ruy1 nhmaDPidE07J+5n2sg6E6oKXxUSmc20o6E3SPRDbrkXnPGUYE.i5nCNB9TxQ jG.G0kCTZtH88f07Rt0ZMMWUw8VvbKVAaTk6GyoraPdZff7rQTejBN54lgyv HE0Ft7AvIvvgvIwO23jBdUkYOuSvIFSiNcjFhiSsUBwsUCh1AgfNSBAeNDBZ DIDqY.f8.YjfjV1HAn9XDTxyNFYatVTkKx3kcK9GraZpI5jv7GOx+Z37Xh82 LSKHIDmDXaESoXRngIZQDKVkpxUkMCyXCQhcCK1z.G457gi3TzMz4RFD515F G3bIQQwcP3SOF0zlkGhiCBQ1kOHHFFlXaEBQIQnCwv9QF1LxPZ.A4jR5cyQs vbvHMJsLll01We+rE2LazX6zYmCraRrsPFwKg1ANBZFY.IAihr8Ox.aH0oAL hB8nQVw0FSJiZeunOykbT6t3r.NP8.iL+bnwNiXuVMNJH9H9YCm89CFXPBER bz422p8.O4dg6kRxdyjDqRwMIHTbT3QFLskxJ8tbmQK4tm0XGeZWF7wKKtYY aTAF.XPNFaaQBinQMJ4QLF0aNHF0JtYuHSxoUZfZY6.UU2ejJTb8lQw8Fo5k Rv6e2PI+fOM71o2ecY1VgTYdCSxxUqLokuYq9jYJi6lxPgD2NIPePLB0mwbG YA9Rgxdiu1k5xiLlSU6JVnx6wzg3sYHwTesB8Z5D7RiGZpXyvDNJY.DQX3.H hvmcUN4bP1yCkhpTle2P37jtBsKrLWcMScEmltOPv22ZfAqQAdKr9HzATQwZ q18PrUGt6Tst2XMCRUfGuhXs6ccn23YloomMqcTiC5iMGPsHsHRWhWFlaenV XcqwgCQiGGJzptyS2ZMODBz6fGza0bzmXBj7+DA94bvpR01MffAlueO7HwcI pWCwmzJdvi9ILgflLAFmyXB6O7ML0YbD26lenmcGxjVsZUN+A6pUK7AtTrPg M+eRYG0qD9j4I7eEbco8Xh6WcO.or9XDC6UCiewbXHkh6xm5LiPEkzpJDRTu mEB44Fgz4NCtJvX.SM1vo2SlTCZGAe7GZu6ahdRyzFOhYZ+mbVVSYptBw.K1 tboIkatIA7c1cTKD1u.honLYV04VkluHsXe0szv9pQCE9Ro3jaVB1o15pz2X zYoBvO5KXCAe0LCYJybE8ZODf4fV8t9qW0zYxq.YJfTosj1bv0xc.SaC0+AV 9V9L.KKyV3SyTcRtmzi6rO.O16USvts4B5xe9EymDvebK0eMfW6+NIsNlE2m eqRyJ0utRq13+RjmqYKN1e.4d61jjdsauXe3.2p6jgi9hsNIv97CoyJ01xzl c3ZhUCtSHx3UZgjoEJYqNY+hYs5zZQVFW19L3JDYaTlMLqAAt1G2yXlnFg9a 53L1FJVcv.cOX0dh7mCVGCLce7GFcQwDdH5Ta3nyAS0pQbHxegr+tGIZORgM RnMj5vGl1Fs16drnk7Tf1XOLgv1n0d2iEsCxR.eQsNOZ4FGF7whofgfI3kES 1kCeOX5L2rifbdu0A9ae2X.V33B1Z+.Bj1FrP5iFrCYCG5EUWSG.hhunHJd. HJ5hhnng3h9HPj4lud02.1bxGw. -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/Graph/#fritzing-circuit","text":"Same as Example AnalogReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/Graph/#kicad-schematic","text":"Same as Example AnalogReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/Graph/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/Midi/","text":"Sketch Code /* MIDI note player This sketch shows how to use the serial transmit pin (pin 1) to send MIDI note data. If this circuit is connected to a MIDI synth, it will play the notes F#-0 (0x1E) to F#-5 (0x5A) in sequence. The circuit: - digital in 1 connected to MIDI jack pin 5 - MIDI jack pin 2 connected to ground - MIDI jack pin 4 connected to +5V through 220 ohm resistor - Attach a MIDI cable to the jack, then to a MIDI synth, and play music. created 13 Jun 2006 modified 13 Aug 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Midi */ void setup() { // Set MIDI baud rate: Serial.begin(31250); } void loop() { // play notes from F#-0 (0x1E) to F#-5 (0x5A): for (int note = 0x1E; note < 0x5A; note++) { //Note on channel 1 (0x90), some note value (note), middle velocity (0x45): noteOn(0x90, note, 0x45); delay(100); //Note on channel 1 (0x90), some note value (note), silent velocity (0x00): noteOn(0x90, note, 0x00); delay(100); } } // plays a MIDI note. Doesn't check to see that cmd is greater than 127, or that // data values are less than 127: void noteOn(int cmd, int pitch, int velocity) { Serial.write(cmd); Serial.write(pitch); Serial.write(velocity); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Midi"},{"location":"04_builtin_examples/04.Communication/Midi/#sketch-code","text":"/* MIDI note player This sketch shows how to use the serial transmit pin (pin 1) to send MIDI note data. If this circuit is connected to a MIDI synth, it will play the notes F#-0 (0x1E) to F#-5 (0x5A) in sequence. The circuit: - digital in 1 connected to MIDI jack pin 5 - MIDI jack pin 2 connected to ground - MIDI jack pin 4 connected to +5V through 220 ohm resistor - Attach a MIDI cable to the jack, then to a MIDI synth, and play music. created 13 Jun 2006 modified 13 Aug 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Midi */ void setup() { // Set MIDI baud rate: Serial.begin(31250); } void loop() { // play notes from F#-0 (0x1E) to F#-5 (0x5A): for (int note = 0x1E; note < 0x5A; note++) { //Note on channel 1 (0x90), some note value (note), middle velocity (0x45): noteOn(0x90, note, 0x45); delay(100); //Note on channel 1 (0x90), some note value (note), silent velocity (0x00): noteOn(0x90, note, 0x00); delay(100); } } // plays a MIDI note. Doesn't check to see that cmd is greater than 127, or that // data values are less than 127: void noteOn(int cmd, int pitch, int velocity) { Serial.write(cmd); Serial.write(pitch); Serial.write(velocity); }","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/Midi/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/Midi/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/Midi/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/MultiSerial/","text":"Sketch Code /* Multiple Serial test Receives from the main serial port, sends to the others. Receives from serial port 1, sends to the main serial (Serial 0). This example works only with boards with more than one serial like Arduino Mega, Due, Zero etc. The circuit: - any serial device attached to Serial port 1 - Serial Monitor open on Serial port 0 created 30 Dec 2008 modified 20 May 2012 by Tom Igoe & Jed Roach modified 27 Nov 2015 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/MultiSerialMega */ void setup() { // initialize both serial ports: Serial.begin(9600); Serial1.begin(9600); } void loop() { // read from port 1, send to port 0: if (Serial1.available()) { int inByte = Serial1.read(); Serial.write(inByte); } // read from port 0, send to port 1: if (Serial.available()) { int inByte = Serial.read(); Serial1.write(inByte); } } Fritzing Circuit Note There is ONLY 1 pair of RX and TX on Arduino UNO R4 WiFi . KiCad Schematic Note There is an error from the official Arduino built-in example Use Multiple Serial Ports on the Arduino Mega . Please refer to my issue asked at RX to TX, and TX to RX? Video Demonstration","title":"MultiSerial"},{"location":"04_builtin_examples/04.Communication/MultiSerial/#sketch-code","text":"/* Multiple Serial test Receives from the main serial port, sends to the others. Receives from serial port 1, sends to the main serial (Serial 0). This example works only with boards with more than one serial like Arduino Mega, Due, Zero etc. The circuit: - any serial device attached to Serial port 1 - Serial Monitor open on Serial port 0 created 30 Dec 2008 modified 20 May 2012 by Tom Igoe & Jed Roach modified 27 Nov 2015 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/MultiSerialMega */ void setup() { // initialize both serial ports: Serial.begin(9600); Serial1.begin(9600); } void loop() { // read from port 1, send to port 0: if (Serial1.available()) { int inByte = Serial1.read(); Serial.write(inByte); } // read from port 0, send to port 1: if (Serial.available()) { int inByte = Serial.read(); Serial1.write(inByte); } }","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/MultiSerial/#fritzing-circuit","text":"Note There is ONLY 1 pair of RX and TX on Arduino UNO R4 WiFi .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/MultiSerial/#kicad-schematic","text":"Note There is an error from the official Arduino built-in example Use Multiple Serial Ports on the Arduino Mega . Please refer to my issue asked at RX to TX, and TX to RX?","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/MultiSerial/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/PhysicalPixel/","text":"Sketch Code /* Physical Pixel An example of using the Arduino board to receive data from the computer. In this case, the Arduino boards turns on an LED when it receives the character 'H', and turns off the LED when it receives the character 'L'. The data can be sent from the Arduino Serial Monitor, or another program like Processing (see code below), Flash (via a serial-net proxy), PD, or Max/MSP. The circuit: - LED connected from digital pin 13 to ground through 220 ohm resistor created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/PhysicalPixel */ const int ledPin = 13; // the pin that the LED is attached to int incomingByte; // a variable to read incoming serial data into void setup() { // initialize serial communication: Serial.begin(9600); // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); } void loop() { // see if there's incoming serial data: if (Serial.available() > 0) { // read the oldest byte in the serial buffer: incomingByte = Serial.read(); // if it's a capital H (ASCII 72), turn on the LED: if (incomingByte == 'H') { digitalWrite(ledPin, HIGH); } // if it's an L (ASCII 76) turn off the LED: if (incomingByte == 'L') { digitalWrite(ledPin, LOW); } } } /* Processing code for this example // Mouse over serial // Demonstrates how to send data to the Arduino I/O board, in order to turn ON // a light if the mouse is over a square and turn it off if the mouse is not. // created 2003-4 // based on examples by Casey Reas and Hernando Barragan // modified 30 Aug 2011 // by Tom Igoe // This example code is in the public domain. import processing.serial.*; float boxX; float boxY; int boxSize = 20; boolean mouseOverBox = false; Serial port; void setup() { size(200, 200); boxX = width / 2.0; boxY = height / 2.0; rectMode(RADIUS); // List all the available serial ports in the output pane. // You will need to choose the port that the Arduino board is connected to // from this list. The first port in the list is port #0 and the third port // in the list is port #2. // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // Open the port that the Arduino board is connected to (in this case #0) // Make sure to open the port at the same speed Arduino is using (9600bps) port = new Serial(this, Serial.list()[0], 9600); } void draw() { background(0); // Test if the cursor is over the box if (mouseX > boxX - boxSize && mouseX < boxX + boxSize && mouseY > boxY - boxSize && mouseY < boxY + boxSize) { mouseOverBox = true; // draw a line around the box and change its color: stroke(255); fill(153); // send an 'H' to indicate mouse is over square: port.write('H'); } else { // return the box to its inactive state: stroke(153); fill(153); // send an 'L' to turn the LED off: port.write('L'); mouseOverBox = false; } // Draw the box rect(boxX, boxY, boxSize, boxSize); } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 1672.3oc2ZszaaiCD9ryuBBebQVCQRYao8xhf1cQCPVfBzh8RRQ.sDsM2HSZ HQmlzh9eu7gjsjsEk7y0oWjiHoHm4aluYHGlueUmtiDuPy5B9Cv8fNc99Uc5 XZR2Pm726zcF4knDRlYXciDylQ4xtWa6SReQZZ+iSeMiEQR.ej8BM4A9C7OO kkAlSjQSAYTdbFfvA27o2c6sfO.Doqd6NfXgDHmRUCKkolg4hT06BfbQJGH3 5Qd2e8d.QJIQSow5tzebZ7BFW.FIHow8.2JAQpVIIYByxo9KIMkSjL9D0BRT sbGHZJIkDoZOSMuQT.8YZ5qpgGI3locF4IpQRzq2nDF+odZMIJkRjpEF44M3 A9nWAum7LKFbSOv+PSRXYOvmIhYiYpg.8A2LOUOxPyH+TjPJA+MS9sIzTRRr QP9rXF31IBZAHpVHkHrfaPRHLuUCzoj9GSoQRqIB52y6Z.tu8o4EX+fddfuj +MrXiwPL5+9cXwrOVvkbxLpomazHbQO7EyX7DpzXYgkFdF6algCQpkX4XUlo hA6oa7GWck9w0Gnmy6RXQOoQeCfWwlzsdnHLTq8n9PCHLv7Cxa6PAN3RCKjh ISRVZ+sSl704Tqt0kocE9R8J+P+RJOZ4ysp6gN0vppBbOTEN8qp0YCq5bq47 PUwfA5e766z7NbGMuncw7VgNRSyQhbnPMGrDsGaFSvKM5NcWoIVdZn44.eOi 9DTRUT.7jDQzSTiF4UzXLc7tLGh4T9pwaFQkGUGIiOOkpBSJUwGsBd40krHQ 9XEvwq2V6eLIhV6GuzP7uzzXBmzsXPSRYwBtVLp7s5lKVv6UN2VW7xRtYDbx 7s7wRgHYDI8YVFaTBshkP49R3rYpH3RlUhTQmK5jMadJyF3cYaTNQMGSyhRE IIUlJaOOukdhoOyhnekEKmZlqU3UkLrk7bpPrpztKBVUR1uorLddk6xIOqNt lBOroRrNVFJGLrDxudpET4kzkstNp2lzuUHVMgk5TDZx9GWumnoQTbhXsEtF tzCcM+z0QKXsngCUtTOEIN0SX2iHTTIIz968.Kf.uhfzUCUuAd3UKd.OKt.N HTynxTQyjpQD9jlwEXeKQxfHCBahUge6RprSa2V4m3aYOMyaP6gah2Yf1zbD jVwZVGFZHHxINFxpjr5CiTS9JiZn6e6nTlXQZTAFj6QCppQwzL0AxVtoi6WE QXsANkEGWMEuwNvhmKTnat7A9RqLq6pXuEwY6xM5xRraoTiurj51J1vKLzFs CvM7HI14Mpje6YRxHOSieTsJpvJORjxT1nERK6s7YTN7sr6rylNwf5zMiHI4 meZ4rTYt2PpVettZERbjJ6PjfqN2loPSrUcusH01CegsGEE5467rnCdqT1ES QxtCvFq.cvGz+BaAHXKzRSfP+2Jf.KCvj5ZLJRAhwi+SWHvPyN3vXiaPn6JR 3eoA.0TkFhTvpsDMIrL20nAkCI4EoYfSHAuiPBdmJRyd.IynYYjIzMvjOTKf 3DLvnvRLDLpWeEOYXMfAZqfQ0.qsnlUdmA33t8CNJ7MZEb.u7fiZHLYzDkJp R7CqEVLGN75U+1JXxFUY.xEEBcRCqhOEkz2bENEWnh4pbh0wY25EefbD6EmW UA6Ip8wFLyuFXx+Wrp8m6iff1B86W7bqJO9+mx8er4E3.abCLrYdA16sBuHx vKT6BlpIGQIhL55W7oicf3ayv3ixQCm4aQuY1HZUPQWY+cASx2WZ3f1fICuz vj5R5ZbM1y8gXYN4dIXaYGq4NhQvS5MmcDADy+S.j8CQ78vk7Q7gtPDX3kFh 3NGaAsYBUAO.8N1U4WKycxbQdrWxJdXd10gNIO+hkUMmm.CZwknu7JbNUYUq 0sOsTsI1QudDtjw0t+xZ85wWZd80tMCiiMADNX4UzrcSeK23su87IANqmA7j tiRzoXi2YRh67ldAk79gPmTe3YKuoY0qdEDV3X8xylCJMTN45JIakB7uY8XW uVr3PO8wWwEoTW8lsfraX7ZqzZDDXCRqNkztHsGCYpIDDAOqxDpMVUMKcOrp 942acPvx2NPocMC1wQZ8glRn3myTykVaEUNLoEeJjVaAevA4EAZnsNgkeyO+ 3rEZB7f0DTazDcQTNmdt8aACGi1QOWnMmd+.6YjMHH19OB5gKsMF877x8wsJ hN97JSnSfLUXGUoj6ujWXd6Pk1SAC+Pkogm.tZ.1lX1qL.pe6PE11DPeMMZ2 .P0K+3peBt3NskC -----------end_max5_patcher----------- */ Fritzing Circuit Same as Example Blink KiCad Schematic Same as Example Blink Video Demonstration","title":"PhysicalPixel"},{"location":"04_builtin_examples/04.Communication/PhysicalPixel/#sketch-code","text":"/* Physical Pixel An example of using the Arduino board to receive data from the computer. In this case, the Arduino boards turns on an LED when it receives the character 'H', and turns off the LED when it receives the character 'L'. The data can be sent from the Arduino Serial Monitor, or another program like Processing (see code below), Flash (via a serial-net proxy), PD, or Max/MSP. The circuit: - LED connected from digital pin 13 to ground through 220 ohm resistor created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/PhysicalPixel */ const int ledPin = 13; // the pin that the LED is attached to int incomingByte; // a variable to read incoming serial data into void setup() { // initialize serial communication: Serial.begin(9600); // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); } void loop() { // see if there's incoming serial data: if (Serial.available() > 0) { // read the oldest byte in the serial buffer: incomingByte = Serial.read(); // if it's a capital H (ASCII 72), turn on the LED: if (incomingByte == 'H') { digitalWrite(ledPin, HIGH); } // if it's an L (ASCII 76) turn off the LED: if (incomingByte == 'L') { digitalWrite(ledPin, LOW); } } } /* Processing code for this example // Mouse over serial // Demonstrates how to send data to the Arduino I/O board, in order to turn ON // a light if the mouse is over a square and turn it off if the mouse is not. // created 2003-4 // based on examples by Casey Reas and Hernando Barragan // modified 30 Aug 2011 // by Tom Igoe // This example code is in the public domain. import processing.serial.*; float boxX; float boxY; int boxSize = 20; boolean mouseOverBox = false; Serial port; void setup() { size(200, 200); boxX = width / 2.0; boxY = height / 2.0; rectMode(RADIUS); // List all the available serial ports in the output pane. // You will need to choose the port that the Arduino board is connected to // from this list. The first port in the list is port #0 and the third port // in the list is port #2. // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // Open the port that the Arduino board is connected to (in this case #0) // Make sure to open the port at the same speed Arduino is using (9600bps) port = new Serial(this, Serial.list()[0], 9600); } void draw() { background(0); // Test if the cursor is over the box if (mouseX > boxX - boxSize && mouseX < boxX + boxSize && mouseY > boxY - boxSize && mouseY < boxY + boxSize) { mouseOverBox = true; // draw a line around the box and change its color: stroke(255); fill(153); // send an 'H' to indicate mouse is over square: port.write('H'); } else { // return the box to its inactive state: stroke(153); fill(153); // send an 'L' to turn the LED off: port.write('L'); mouseOverBox = false; } // Draw the box rect(boxX, boxY, boxSize, boxSize); } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 1672.3oc2ZszaaiCD9ryuBBebQVCQRYao8xhf1cQCPVfBzh8RRQ.sDsM2HSZ HQmlzh9eu7gjsjsEk7y0oWjiHoHm4aluYHGlueUmtiDuPy5B9Cv8fNc99Uc5 XZR2Pm726zcF4knDRlYXciDylQ4xtWa6SReQZZ+iSeMiEQR.ej8BM4A9C7OO kkAlSjQSAYTdbFfvA27o2c6sfO.Doqd6NfXgDHmRUCKkolg4hT06BfbQJGH3 5Qd2e8d.QJIQSow5tzebZ7BFW.FIHow8.2JAQpVIIYByxo9KIMkSjL9D0BRT sbGHZJIkDoZOSMuQT.8YZ5qpgGI3locF4IpQRzq2nDF+odZMIJkRjpEF44M3 A9nWAum7LKFbSOv+PSRXYOvmIhYiYpg.8A2LOUOxPyH+TjPJA+MS9sIzTRRr QP9rXF31IBZAHpVHkHrfaPRHLuUCzoj9GSoQRqIB52y6Z.tu8o4EX+fddfuj +MrXiwPL5+9cXwrOVvkbxLpomazHbQO7EyX7DpzXYgkFdF6algCQpkX4XUlo hA6oa7GWck9w0Gnmy6RXQOoQeCfWwlzsdnHLTq8n9PCHLv7Cxa6PAN3RCKjh ISRVZ+sSl704Tqt0kocE9R8J+P+RJOZ4ysp6gN0vppBbOTEN8qp0YCq5bq47 PUwfA5e766z7NbGMuncw7VgNRSyQhbnPMGrDsGaFSvKM5NcWoIVdZn44.eOi 9DTRUT.7jDQzSTiF4UzXLc7tLGh4T9pwaFQkGUGIiOOkpBSJUwGsBd40krHQ 9XEvwq2V6eLIhV6GuzP7uzzXBmzsXPSRYwBtVLp7s5lKVv6UN2VW7xRtYDbx 7s7wRgHYDI8YVFaTBshkP49R3rYpH3RlUhTQmK5jMadJyF3cYaTNQMGSyhRE IIUlJaOOukdhoOyhnekEKmZlqU3UkLrk7bpPrpztKBVUR1uorLddk6xIOqNt lBOroRrNVFJGLrDxudpET4kzkstNp2lzuUHVMgk5TDZx9GWumnoQTbhXsEtF tzCcM+z0QKXsngCUtTOEIN0SX2iHTTIIz968.Kf.uhfzUCUuAd3UKd.OKt.N HTynxTQyjpQD9jlwEXeKQxfHCBahUge6RprSa2V4m3aYOMyaP6gah2Yf1zbD jVwZVGFZHHxINFxpjr5CiTS9JiZn6e6nTlXQZTAFj6QCppQwzL0AxVtoi6WE QXsANkEGWMEuwNvhmKTnat7A9RqLq6pXuEwY6xM5xRraoTiurj51J1vKLzFs CvM7HI14Mpje6YRxHOSieTsJpvJORjxT1nERK6s7YTN7sr6rylNwf5zMiHI4 meZ4rTYt2PpVettZERbjJ6PjfqN2loPSrUcusH01CegsGEE5467rnCdqT1ES QxtCvFq.cvGz+BaAHXKzRSfP+2Jf.KCvj5ZLJRAhwi+SWHvPyN3vXiaPn6JR 3eoA.0TkFhTvpsDMIrL20nAkCI4EoYfSHAuiPBdmJRyd.IynYYjIzMvjOTKf 3DLvnvRLDLpWeEOYXMfAZqfQ0.qsnlUdmA33t8CNJ7MZEb.u7fiZHLYzDkJp R7CqEVLGN75U+1JXxFUY.xEEBcRCqhOEkz2bENEWnh4pbh0wY25EefbD6EmW UA6Ip8wFLyuFXx+Wrp8m6iff1B86W7bqJO9+mx8er4E3.abCLrYdA16sBuHx vKT6BlpIGQIhL55W7oicf3ayv3ixQCm4aQuY1HZUPQWY+cASx2WZ3f1fICuz vj5R5ZbM1y8gXYN4dIXaYGq4NhQvS5MmcDADy+S.j8CQ78vk7Q7gtPDX3kFh 3NGaAsYBUAO.8N1U4WKycxbQdrWxJdXd10gNIO+hkUMmm.CZwknu7JbNUYUq 0sOsTsI1QudDtjw0t+xZ85wWZd80tMCiiMADNX4UzrcSeK23su87IANqmA7j tiRzoXi2YRh67ldAk79gPmTe3YKuoY0qdEDV3X8xylCJMTN45JIakB7uY8XW uVr3PO8wWwEoTW8lsfraX7ZqzZDDXCRqNkztHsGCYpIDDAOqxDpMVUMKcOrp 942acPvx2NPocMC1wQZ8glRn3myTykVaEUNLoEeJjVaAevA4EAZnsNgkeyO+ 3rEZB7f0DTazDcQTNmdt8aACGi1QOWnMmd+.6YjMHH19OB5gKsMF877x8wsJ hN97JSnSfLUXGUoj6ujWXd6Pk1SAC+Pkogm.tZ.1lX1qL.pe6PE11DPeMMZ2 .P0K+3peBt3NskC -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/PhysicalPixel/#fritzing-circuit","text":"Same as Example Blink","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/PhysicalPixel/#kicad-schematic","text":"Same as Example Blink","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/PhysicalPixel/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/ReadASCIIString/","text":"Sketch Code /* Reading a serial ASCII-encoded string. This sketch demonstrates the Serial parseInt() function. It looks for an ASCII string of comma-separated values. It parses them into ints, and uses those to fade an RGB LED. Circuit: Common-Cathode RGB LED wired like so: - red anode: digital pin 3 through 220 ohm resistor - green anode: digital pin 5 through 220 ohm resistor - blue anode: digital pin 6 through 220 ohm resistor - cathode: GND created 13 Apr 2012 by Tom Igoe modified 14 Mar 2016 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ReadASCIIString */ // pins for the LEDs: const int redPin = 3; const int greenPin = 5; const int bluePin = 6; void setup() { // initialize serial: Serial.begin(9600); // make the pins outputs: pinMode(redPin, OUTPUT); pinMode(greenPin, OUTPUT); pinMode(bluePin, OUTPUT); } void loop() { // if there's any serial available, read it: while (Serial.available() > 0) { // look for the next valid integer in the incoming serial stream: int red = Serial.parseInt(); // do it again: int green = Serial.parseInt(); // do it again: int blue = Serial.parseInt(); // look for the newline. That's the end of your sentence: if (Serial.read() == '\\n') { // constrain the values to 0 - 255 and invert // if you're using a common-cathode LED, just use \"constrain(color, 0, 255);\" red = 255 - constrain(red, 0, 255); green = 255 - constrain(green, 0, 255); blue = 255 - constrain(blue, 0, 255); // fade the red, green, and blue legs of the LED: analogWrite(redPin, red); analogWrite(greenPin, green); analogWrite(bluePin, blue); // print the three numbers in one string as hexadecimal: Serial.print(red, HEX); Serial.print(green, HEX); Serial.println(blue, HEX); } } } Fritzing Circuit KiCad Schematic Note There is an error from the official Arduino built-in example Read ASCII String . Video Demonstration","title":"ReadASCIIString"},{"location":"04_builtin_examples/04.Communication/ReadASCIIString/#sketch-code","text":"/* Reading a serial ASCII-encoded string. This sketch demonstrates the Serial parseInt() function. It looks for an ASCII string of comma-separated values. It parses them into ints, and uses those to fade an RGB LED. Circuit: Common-Cathode RGB LED wired like so: - red anode: digital pin 3 through 220 ohm resistor - green anode: digital pin 5 through 220 ohm resistor - blue anode: digital pin 6 through 220 ohm resistor - cathode: GND created 13 Apr 2012 by Tom Igoe modified 14 Mar 2016 by Arturo Guadalupi This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ReadASCIIString */ // pins for the LEDs: const int redPin = 3; const int greenPin = 5; const int bluePin = 6; void setup() { // initialize serial: Serial.begin(9600); // make the pins outputs: pinMode(redPin, OUTPUT); pinMode(greenPin, OUTPUT); pinMode(bluePin, OUTPUT); } void loop() { // if there's any serial available, read it: while (Serial.available() > 0) { // look for the next valid integer in the incoming serial stream: int red = Serial.parseInt(); // do it again: int green = Serial.parseInt(); // do it again: int blue = Serial.parseInt(); // look for the newline. That's the end of your sentence: if (Serial.read() == '\\n') { // constrain the values to 0 - 255 and invert // if you're using a common-cathode LED, just use \"constrain(color, 0, 255);\" red = 255 - constrain(red, 0, 255); green = 255 - constrain(green, 0, 255); blue = 255 - constrain(blue, 0, 255); // fade the red, green, and blue legs of the LED: analogWrite(redPin, red); analogWrite(greenPin, green); analogWrite(bluePin, blue); // print the three numbers in one string as hexadecimal: Serial.print(red, HEX); Serial.print(green, HEX); Serial.println(blue, HEX); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/ReadASCIIString/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/ReadASCIIString/#kicad-schematic","text":"Note There is an error from the official Arduino built-in example Read ASCII String .","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/ReadASCIIString/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/SerialCallResponse/","text":"Sketch Code /* Serial Call and Response Language: Wiring/Arduino This program sends an ASCII A (byte of value 65) on startup and repeats that until it gets some data in. Then it waits for a byte in the serial port, and sends three sensor values whenever it gets a byte in. The circuit: - potentiometers attached to analog inputs 0 and 1 - pushbutton attached to digital I/O 2 created 26 Sep 2005 by Tom Igoe modified 24 Apr 2012 by Tom Igoe and Scott Fitzgerald Thanks to Greg Shakar and Scott Fitzgerald for the improvements This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialCallResponse */ int firstSensor = 0; // first analog sensor int secondSensor = 0; // second analog sensor int thirdSensor = 0; // digital sensor int inByte = 0; // incoming serial byte void setup() { // start serial port at 9600 bps: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } pinMode(2, INPUT); // digital sensor is on digital pin 2 establishContact(); // send a byte to establish contact until receiver responds } void loop() { // if we get a valid byte, read analog ins: if (Serial.available() > 0) { // get incoming byte: inByte = Serial.read(); // read first analog input, divide by 4 to make the range 0-255: firstSensor = analogRead(A0) / 4; // delay 10ms to let the ADC recover: delay(10); // read second analog input, divide by 4 to make the range 0-255: secondSensor = analogRead(1) / 4; // read switch, map it to 0 or 255L thirdSensor = map(digitalRead(2), 0, 1, 0, 255); // send sensor values: Serial.write(firstSensor); Serial.write(secondSensor); Serial.write(thirdSensor); } } void establishContact() { while (Serial.available() <= 0) { Serial.print('A'); // send a capital A delay(300); } } /* Processing sketch to run with this example: // This example code is in the public domain. import processing.serial.*; int bgcolor; // Background color int fgcolor; // Fill color Serial myPort; // The serial port int[] serialInArray = new int[3]; // Where we'll put what we receive int serialCount = 0; // A count of how many bytes we receive int xpos, ypos; // Starting position of the ball boolean firstContact = false; // Whether we've heard from the microcontroller void setup() { size(256, 256); // Stage size noStroke(); // No border on the next thing drawn // Set the starting position of the ball (middle of the stage) xpos = width / 2; ypos = height / 2; // Print a list of the serial ports for debugging purposes // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my FTDI // adaptor, so I open Serial.list()[0]. // On Windows machines, this generally opens COM1. // Open whatever port is the one you're using. String portName = Serial.list()[0]; myPort = new Serial(this, portName, 9600); } void draw() { background(bgcolor); fill(fgcolor); // Draw the shape ellipse(xpos, ypos, 20, 20); } void serialEvent(Serial myPort) { // read a byte from the serial port: int inByte = myPort.read(); // if this is the first byte received, and it's an A, clear the serial // buffer and note that you've had first contact from the microcontroller. // Otherwise, add the incoming byte to the array: if (firstContact == false) { if (inByte == 'A') { myPort.clear(); // clear the serial port buffer firstContact = true; // you've had first contact from the microcontroller myPort.write('A'); // ask for more } } else { // Add the latest byte from the serial port to array: serialInArray[serialCount] = inByte; serialCount++; // If we have 3 bytes: if (serialCount > 2 ) { xpos = serialInArray[0]; ypos = serialInArray[1]; fgcolor = serialInArray[2]; // print the values (for debugging purposes only): println(xpos + \"\\t\" + ypos + \"\\t\" + fgcolor); // Send a capital A to request new sensor readings: myPort.write('A'); // Reset serialCount: serialCount = 0; } } } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 3908.3oc6ckziiaiE9b0+J3XjCIXpp.WzZNMURv.jCInQ5fYNjNngrDssRKK 4nkp6JA4+973hrkrsjncKu0SRiXasQ83G+dKj7QV+4qtaxzrOxKlf9Zzuft6 t+7U2cm7ThSbm936lrL3igIAExaaRJ+CYS+sI2qtTI+ikxSuBMKNojm+N3D4 Aua5KkPwpuoUAkgKhSm+tbdXo5cQXVOhuGwrohuHD4WT7iXzupen3HY4BuqG rH0kzrrzxzfkb4kdJONHo9JoUKiSS3kRgjt4jYUk0mkznPJh+CYgHewpSqty xWVwUh3jIqkEYEfmqQEMr.ETbB+YddQbVZix+tIAqV03z203QDX4ukIKHm6W ep3T0ovqOUN+435m2Rcx+5U0E+FTzVBh9xOsHXIh5YuADg1x4IYgumG0r3mj shmFmtJmWvSKCJ0um0WNhOKnJo7c6GmZe8YAg7Ne381Rc2j44wQYoBgn0SJN c8qCHH1RhQqJi7NRCVsmGt.pGUESCxE31zDdCV.PRyxRZeo0MU.WOHMdYPIu LVIrT75BMd4p73zxVuHdZ.TFKJByyRRZUTpq77dtRDzZFx+PbT4BYY0DJgaO dUcSvj0XTT7bdQY6yUFLun8YZo71jl0TIt042RYNLa4RfCTWfsznKWDWfJpl tJHrbgV6t.AZInfzWP.4INpJHA8za91u+6QN1nk7hh.PpQwonxEbTAWzpilV MimilkmsDtPbo3TPiUdY0pGa9ZShS4gYUJz1pwE1iwCpxbAgJI9DGGwWNzFT ksLf3z7M0MybG6Hj1WngsD7VEXS8j5q7Wu5U0+39ir8QJJS5GMHdtRimL4m1 0e1EVX0YsE2YssINriYRoFRyWVMoRRUGQvnkmms3pnXDYHbBKMPpIOL5i1s8 3rMPwFcRCsGRyPH780.8HBnpWz.vlEQBWJ+0CSunehJSmJxiIZRtNGhhDYrU jt3ZQyA2fHJhZDifXIQHUHH8oGYgOREI5nqHIzhFWUndPyBdB3VzHJGwUhkV rgvRl2UCVNMHcd234lf1DN16HFEIdHt99A5hrp7v5WWMSBQZgMP.Tkwoqig8 W1.Sn1f3h3nn1wLpBypPDzlJ7XinEGkLiMPloWOhrgR7dpZWJQV1faDy35Qj MThMFkWFGsJChQPqrQp8iorV6Q28HBVF4nMVDJj7f1xyYACFScisg.ruLHOW uMUS4Am4pI4PTnHi.6bi02HNzSYnDBe4cgAgKzRk1jc8PJLoH3Ydz6.Q.7K8 tfxx73oUkJq1MGuCy5TpAi.POWZ3AenidLOOIaZPhdjZVW3sdk6LXEGzHb7p Mfr7SEy3SXHyBSxJ3J2ncNNYVJsXG6Me10nj4cfCRFdTFjLo7q3SiCpjjEDM .nvra.GN39.E2CDTHWXPo8.xzfqrHCHKnf5QUYUVdoZPUjCSC7LU8.XtTUXl X8vr51GjwFGLC2AlMdLkU4RiaRrnmJuiudnDk0ZW+9p6TuKBe433JUCzp6fU iOF0SUk2UQYUPNTEkiZubvKa1tsmgL5SCTXGHnnG0CceLpkpR9Rs28IUESWl EwWNKfHlg.zj6Ee7S+nE8A+m9F7Cu40u9gMm+aRp3kYYkKd3GDOz5y+c7b96 K9gfvuIK68uNO6g2vUUL80WxihCVFD9vlB30e2SOrmxUb527RZ3nZNrljGrR 70vs1J9suWuZ3zaHVdG3RIJLgGj2Gfn6TcGcstEfvtH.hpFLlnBndjOLGQAI z98BXc6yQxghmOn6gZqj0ShPOXhynLOjzCESt+XwE8TxrCvrdXo16rqnLgvb HaFmbh29QD+K0DyNdjDwvzQL.NXpoMvoOBxkger0HwMRQbpbCh91fjjG9Idw prTH9SzaSea5a.GQEPnnh43WNefMlsOgx18n.vgUNO.tKl7tDyI3iHzafJHZ VVNedVEbGgYIY42i93prB0i7B7KT1LnnCiyAiinpBnsPV7OG.tYKfBsrJOkG UG5aq26iJw6GyJ4eM5mEgEKaNQPMEBUp.t8.krplOVTlZdJAW27bjvGK7p2p HQPgLOSJDYv4E9gQBYBjMUselRxDy+4WplIzm9JQAWOEmfb.E364B43CAwp5 uRRDEv8hWXprjADMUOYpOg9.bVQpEfhKgGCnAnk.rghBJCdTVICA3sDvAhE5 oU4hf67ea5zWPuILqrD8uiK+i477fjHIt9y.V88yy3uMsZUj7wnxGKNAdPx5 fAZMErDZOcJU4M01WFQokix.pKa+JE1WacmnKFeYd7b.0PeIzB8Kk+5WIZpB Ejt34KJeHgOCh4HK8Y3QiAkAfs8TRhhOkG7AAGQf0qxyfmQxa+PLb8Ex.2PS 4BdO5GB9Hvg+cfJCMofAIMu9Qz+UPCjckqVJlEmyA8Bf.rC6.3hAEuG8TdTU bZljQ0nr1ayIqmTwQYfyRGafZhur5vfuyMSqYNWmtAPwWHalDSuUgT0Bosh. JpAR89Y6Ez5QEfPTQO4J0DHLInIliz8BZV2JfV3Bd36qsQwAVVXbr1BGXp6s Sd5sSDruo74wofx.HxUgxQwTnMLqTXvRmiGh2PUZr5pBynKChjl6feNUjSRn hEUfRPT1GfG9Ik4TQBm.hEZZ.bc38HjAMKGzDRijEm1ifx1dbgzQyKh6FZc3 wOCkRJH+KUh0daWs6wzltWx1puXxlWW6NZWY2JiTBzzILRIANku02NourySM VI1VJTvQZff32AJr+dS9e34QAoA6EGXlGFH9yk7yyQAlVd3SR94g+TxOu1sU Flgd6ICI96LzazyPu1cgqsZ8r74SgF.65+efbMf4pGHT7lgHh30Sha3N5Ia. oqjMf7nsuMwycf7iYDybiAAVr3eC.oTMjpzEr8GDRc9bFRGHYXDrzg.Tlx+q NW8TY1IkzCfZ2IftkQstbB08HUezoDS+oFyI.cWIhWBaDiUo7qIrDO7f.L6n AXqCmyNT9act.z+Iv.GR0uES0ZXfjdz.IczAxQOUR+zvRsUTigRxmyPYeNlj yXv8Peef2ZFzuLzWPPeAE8ELzWXYlhe8WzAcUg+b1UkIoCLzIH60zwASGXau a1Dq2nUY.sox4vng+m0nACePngC9lEMLZMBPodOxf+yx5d4uMCTHm3kJvIIG jcLMedEQldkjpoBkQyjY1Hk.hmSY95Iwos8NDb9VSlIWOIntqgxryUjL6bCJ y1lli5tWWxrQ7YmqGYlc6shK1iY2dr0wtNjYxgHyzaq0OznY235awCr8zSz6 EGd1QNUKf.74dADTBbTbeotjpW95IolY0WpKYONY8M83Rx2MChx3fL+iG5Mm tXpdmvXj8uTvaAL1WjbbarQD4Z6kXBpnm6a69oKV2PY9WY174IbC3CaRQ9iK Q4sYGQpwdtZ5wFrc7n569.M83OOR5ydSB1ZcAWCxdbKuavz9LILxfD.wWO.W Nq+Zu4Es+AP6s5p9jDWH8ET+c85+XbW0.N1nDCTD7U4DGc6ohnU019fS7kQ0 o43luuOGjv5agHp0DT.CysOfgLR3xXlXTUKm16RivRsn3z0O6cl3YScAvtrb hwekGB7BZuqESUzBJWmCvK7t9HF8Ts6cUAPoFWso3aP8ApWyJ3wqOPo2pJDC BQ0NI0Pj8QCQ2r1L5vKaU5lDRYX7yRur1UYYZmJQ9iDHwN9dndB5n5ejflmm UsBwLHnDkKXWRuAkb3NeuzqRstiQGP.fCQFdHNzaE.8u58Nz9svFE9SGIE1X kv9Iwfl1BdNWjA7xcThsWCS847loyFD8pZq2E2F04lYULzBTDYhrFSDDJdjo fisN2NUN26e4xRu51zD5ZseJ4HC63WyIX6jRqsp0jangBnK.Qlo58PCpWevt ahzqK7fbKsdX6R64aao8LmWhBPh9jKVAPMzb5a2cV6opdWHneMmqMEmAGsPh ieigIjV+4gF1GgbMNXg+NH44YaRYyd..S1ThHzKhFwwGRaWVITqyj9FvPqMT d0pDuSqDrOGF.Uogf.juCFi9WAUkYR+rFPanDcPG8SbrtjyG03ZQ8m3AqC5H NcUUoXSwVrqXKVcZu.5ZnkwIfIVdXVZTwAuTTUiYuxwjZDK6ZgnRtYV8tJmP hEcuXgz2Goxyaiw35UkaWbpqtfzD02oUkkYqi.YQbZqIIWrIljFolsdmMKFR wCJ2+DTn.9QlkOld+d9Qy9IJdpLfy05Ik2b8GsG9h8rdm1ZFx1FrmmlA2snw qI9Mcdi2nr6q3Gc87nLawurbw1dda+tMyGJ9HaQmlkGwy6davisMgrkM65oz eulfYCzG46am8tSDK144xV4cEvVMTRXq9CIX8+ALNWb6sttKNkiZetnbz+lx cQnb1Nds2C0tvLNe14hwQtxYbxhqc17qHfamUcZZ3NYSWqjJuiDoizZ+ud2j naRK4k3346IIVdR1kKiQjM39adMamvc6n+Xp36Yf3SIGh3uKbquqs1JksTII kuJ7RrZSFb2Cn9j5a6DT8cMo0iczU+lsYaU8YNVh5k5uzJLU26ZcfuJE6XLY 0mcRp9NTCp+L+Ap+in7Xf3b9jFQBLtIY06PbrGhcrU6N00Qlaf9N0+QPo9nS P6qsI7aYNLSNOHpsAxis0ggnZLjYqyyFkdSqinVsPaqSDZaYBZ6c93uLCjGm iCroJVLzU45iNE.pIUfs3TWb.0FejHp9uANr0GcJPTroFDNOHpkIweLnI1QT dHl3P7LhOF3Ahd9rnvLwAMy5JSdNezGlsIsW9mW44r26js+alhxjlkdhN0YE YqiH5MTeWo6D4Qm.ieLS7OynmuVGSbmbFUlnWWhiQlhOeN+Yl35bq.tGo9JR cj8AVqdz7nSgVB9zNj.FTOU68o5d9KO5TUOGxVMw+jTO8T6wqD0hEiHsOJO5 TTOMoS.zlqN0SpZjz6GcH05ylVM0jwuidlkmAif374ih5M5QPfccr8Hqifff otN8pt3hUcaWu8nosBhwmD0Epw5KmoF.poxy4YHbnjqfPJqcM3Y2vun7nS.i f3eETiqcRX2LR.4QmhZrkoCSGwzZrqKHrVR8caari+55d2caPqmq5n.ywe8Q WrZL9fpwVXeaogMByE6y1SMdjk+gbavbN7fYvVtt1C2XwHJSzpk+tidUO25H UB9onw9mlFQ10fhpZBaDatcMTTEGcJpwzqg92qqiVtM6Cu0IRQ0ndEdfCAqV l0qYAUmPrctbxO4XCuPMa1asYzKDks1D52ZCne6Mednz9qW8+.vfqkDA -----------end_max5_patcher----------- */ Fritzing Circuit KiCad Schematic Video Demonstration","title":"SerialCallResponse"},{"location":"04_builtin_examples/04.Communication/SerialCallResponse/#sketch-code","text":"/* Serial Call and Response Language: Wiring/Arduino This program sends an ASCII A (byte of value 65) on startup and repeats that until it gets some data in. Then it waits for a byte in the serial port, and sends three sensor values whenever it gets a byte in. The circuit: - potentiometers attached to analog inputs 0 and 1 - pushbutton attached to digital I/O 2 created 26 Sep 2005 by Tom Igoe modified 24 Apr 2012 by Tom Igoe and Scott Fitzgerald Thanks to Greg Shakar and Scott Fitzgerald for the improvements This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialCallResponse */ int firstSensor = 0; // first analog sensor int secondSensor = 0; // second analog sensor int thirdSensor = 0; // digital sensor int inByte = 0; // incoming serial byte void setup() { // start serial port at 9600 bps: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } pinMode(2, INPUT); // digital sensor is on digital pin 2 establishContact(); // send a byte to establish contact until receiver responds } void loop() { // if we get a valid byte, read analog ins: if (Serial.available() > 0) { // get incoming byte: inByte = Serial.read(); // read first analog input, divide by 4 to make the range 0-255: firstSensor = analogRead(A0) / 4; // delay 10ms to let the ADC recover: delay(10); // read second analog input, divide by 4 to make the range 0-255: secondSensor = analogRead(1) / 4; // read switch, map it to 0 or 255L thirdSensor = map(digitalRead(2), 0, 1, 0, 255); // send sensor values: Serial.write(firstSensor); Serial.write(secondSensor); Serial.write(thirdSensor); } } void establishContact() { while (Serial.available() <= 0) { Serial.print('A'); // send a capital A delay(300); } } /* Processing sketch to run with this example: // This example code is in the public domain. import processing.serial.*; int bgcolor; // Background color int fgcolor; // Fill color Serial myPort; // The serial port int[] serialInArray = new int[3]; // Where we'll put what we receive int serialCount = 0; // A count of how many bytes we receive int xpos, ypos; // Starting position of the ball boolean firstContact = false; // Whether we've heard from the microcontroller void setup() { size(256, 256); // Stage size noStroke(); // No border on the next thing drawn // Set the starting position of the ball (middle of the stage) xpos = width / 2; ypos = height / 2; // Print a list of the serial ports for debugging purposes // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my FTDI // adaptor, so I open Serial.list()[0]. // On Windows machines, this generally opens COM1. // Open whatever port is the one you're using. String portName = Serial.list()[0]; myPort = new Serial(this, portName, 9600); } void draw() { background(bgcolor); fill(fgcolor); // Draw the shape ellipse(xpos, ypos, 20, 20); } void serialEvent(Serial myPort) { // read a byte from the serial port: int inByte = myPort.read(); // if this is the first byte received, and it's an A, clear the serial // buffer and note that you've had first contact from the microcontroller. // Otherwise, add the incoming byte to the array: if (firstContact == false) { if (inByte == 'A') { myPort.clear(); // clear the serial port buffer firstContact = true; // you've had first contact from the microcontroller myPort.write('A'); // ask for more } } else { // Add the latest byte from the serial port to array: serialInArray[serialCount] = inByte; serialCount++; // If we have 3 bytes: if (serialCount > 2 ) { xpos = serialInArray[0]; ypos = serialInArray[1]; fgcolor = serialInArray[2]; // print the values (for debugging purposes only): println(xpos + \"\\t\" + ypos + \"\\t\" + fgcolor); // Send a capital A to request new sensor readings: myPort.write('A'); // Reset serialCount: serialCount = 0; } } } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 3908.3oc6ckziiaiE9b0+J3XjCIXpp.WzZNMURv.jCInQ5fYNjNngrDssRKK 4nkp6JA4+973hrkrsjncKu0SRiXasQ83G+dKj7QV+4qtaxzrOxKlf9Zzuft6 t+7U2cm7ThSbm936lrL3igIAExaaRJ+CYS+sI2qtTI+ikxSuBMKNojm+N3D4 Aua5KkPwpuoUAkgKhSm+tbdXo5cQXVOhuGwrohuHD4WT7iXzupen3HY4BuqG rH0kzrrzxzfkb4kdJONHo9JoUKiSS3kRgjt4jYUk0mkznPJh+CYgHewpSqty xWVwUh3jIqkEYEfmqQEMr.ETbB+YddQbVZix+tIAqV03z203QDX4ukIKHm6W ep3T0ovqOUN+435m2Rcx+5U0E+FTzVBh9xOsHXIh5YuADg1x4IYgumG0r3mj shmFmtJmWvSKCJ0um0WNhOKnJo7c6GmZe8YAg7Ne381Rc2j44wQYoBgn0SJN c8qCHH1RhQqJi7NRCVsmGt.pGUESCxE31zDdCV.PRyxRZeo0MU.WOHMdYPIu LVIrT75BMd4p73zxVuHdZ.TFKJByyRRZUTpq77dtRDzZFx+PbT4BYY0DJgaO dUcSvj0XTT7bdQY6yUFLun8YZo71jl0TIt042RYNLa4RfCTWfsznKWDWfJpl tJHrbgV6t.AZInfzWP.4INpJHA8za91u+6QN1nk7hh.PpQwonxEbTAWzpilV MimilkmsDtPbo3TPiUdY0pGa9ZShS4gYUJz1pwE1iwCpxbAgJI9DGGwWNzFT ksLf3z7M0MybG6Hj1WngsD7VEXS8j5q7Wu5U0+39ir8QJJS5GMHdtRimL4m1 0e1EVX0YsE2YssINriYRoFRyWVMoRRUGQvnkmms3pnXDYHbBKMPpIOL5i1s8 3rMPwFcRCsGRyPH780.8HBnpWz.vlEQBWJ+0CSunehJSmJxiIZRtNGhhDYrU jt3ZQyA2fHJhZDifXIQHUHH8oGYgOREI5nqHIzhFWUndPyBdB3VzHJGwUhkV rgvRl2UCVNMHcd234lf1DN16HFEIdHt99A5hrp7v5WWMSBQZgMP.Tkwoqig8 W1.Sn1f3h3nn1wLpBypPDzlJ7XinEGkLiMPloWOhrgR7dpZWJQV1faDy35Qj MThMFkWFGsJChQPqrQp8iorV6Q28HBVF4nMVDJj7f1xyYACFScisg.ruLHOW uMUS4Am4pI4PTnHi.6bi02HNzSYnDBe4cgAgKzRk1jc8PJLoH3Ydz6.Q.7K8 tfxx73oUkJq1MGuCy5TpAi.POWZ3AenidLOOIaZPhdjZVW3sdk6LXEGzHb7p Mfr7SEy3SXHyBSxJ3J2ncNNYVJsXG6Me10nj4cfCRFdTFjLo7q3SiCpjjEDM .nvra.GN39.E2CDTHWXPo8.xzfqrHCHKnf5QUYUVdoZPUjCSC7LU8.XtTUXl X8vr51GjwFGLC2AlMdLkU4RiaRrnmJuiudnDk0ZW+9p6TuKBe433JUCzp6fU iOF0SUk2UQYUPNTEkiZubvKa1tsmgL5SCTXGHnnG0CceLpkpR9Rs28IUESWl EwWNKfHlg.zj6Ee7S+nE8A+m9F7Cu40u9gMm+aRp3kYYkKd3GDOz5y+c7b96 K9gfvuIK68uNO6g2vUUL80WxihCVFD9vlB30e2SOrmxUb527RZ3nZNrljGrR 70vs1J9suWuZ3zaHVdG3RIJLgGj2Gfn6TcGcstEfvtH.hpFLlnBndjOLGQAI z98BXc6yQxghmOn6gZqj0ShPOXhynLOjzCESt+XwE8TxrCvrdXo16rqnLgvb HaFmbh29QD+K0DyNdjDwvzQL.NXpoMvoOBxkger0HwMRQbpbCh91fjjG9Idw prTH9SzaSea5a.GQEPnnh43WNefMlsOgx18n.vgUNO.tKl7tDyI3iHzafJHZ VVNedVEbGgYIY42i93prB0i7B7KT1LnnCiyAiinpBnsPV7OG.tYKfBsrJOkG UG5aq26iJw6GyJ4eM5mEgEKaNQPMEBUp.t8.krplOVTlZdJAW27bjvGK7p2p HQPgLOSJDYv4E9gQBYBjMUselRxDy+4WplIzm9JQAWOEmfb.E364B43CAwp5 uRRDEv8hWXprjADMUOYpOg9.bVQpEfhKgGCnAnk.rghBJCdTVICA3sDvAhE5 oU4hf67ea5zWPuILqrD8uiK+i477fjHIt9y.V88yy3uMsZUj7wnxGKNAdPx5 fAZMErDZOcJU4M01WFQokix.pKa+JE1WacmnKFeYd7b.0PeIzB8Kk+5WIZpB Ejt34KJeHgOCh4HK8Y3QiAkAfs8TRhhOkG7AAGQf0qxyfmQxa+PLb8Ex.2PS 4BdO5GB9Hvg+cfJCMofAIMu9Qz+UPCjckqVJlEmyA8Bf.rC6.3hAEuG8TdTU bZljQ0nr1ayIqmTwQYfyRGafZhur5vfuyMSqYNWmtAPwWHalDSuUgT0Bosh. JpAR89Y6Ez5QEfPTQO4J0DHLInIliz8BZV2JfV3Bd36qsQwAVVXbr1BGXp6s Sd5sSDruo74wofx.HxUgxQwTnMLqTXvRmiGh2PUZr5pBynKChjl6feNUjSRn hEUfRPT1GfG9Ik4TQBm.hEZZ.bc38HjAMKGzDRijEm1ifx1dbgzQyKh6FZc3 wOCkRJH+KUh0daWs6wzltWx1puXxlWW6NZWY2JiTBzzILRIANku02NourySM VI1VJTvQZff32AJr+dS9e34QAoA6EGXlGFH9yk7yyQAlVd3SR94g+TxOu1sU Flgd6ICI96LzazyPu1cgqsZ8r74SgF.65+efbMf4pGHT7lgHh30Sha3N5Ia. oqjMf7nsuMwycf7iYDybiAAVr3eC.oTMjpzEr8GDRc9bFRGHYXDrzg.Tlx+q NW8TY1IkzCfZ2IftkQstbB08HUezoDS+oFyI.cWIhWBaDiUo7qIrDO7f.L6n AXqCmyNT9act.z+Iv.GR0uES0ZXfjdz.IczAxQOUR+zvRsUTigRxmyPYeNlj yXv8Peef2ZFzuLzWPPeAE8ELzWXYlhe8WzAcUg+b1UkIoCLzIH60zwASGXau a1Dq2nUY.sox4vng+m0nACePngC9lEMLZMBPodOxf+yx5d4uMCTHm3kJvIIG jcLMedEQldkjpoBkQyjY1Hk.hmSY95Iwos8NDb9VSlIWOIntqgxryUjL6bCJ y1lli5tWWxrQ7YmqGYlc6shK1iY2dr0wtNjYxgHyzaq0OznY235awCr8zSz6 EGd1QNUKf.74dADTBbTbeotjpW95IolY0WpKYONY8M83Rx2MChx3fL+iG5Mm tXpdmvXj8uTvaAL1WjbbarQD4Z6kXBpnm6a69oKV2PY9WY174IbC3CaRQ9iK Q4sYGQpwdtZ5wFrc7n569.M83OOR5ydSB1ZcAWCxdbKuavz9LILxfD.wWO.W Nq+Zu4Es+AP6s5p9jDWH8ET+c85+XbW0.N1nDCTD7U4DGc6ohnU019fS7kQ0 o43luuOGjv5agHp0DT.CysOfgLR3xXlXTUKm16RivRsn3z0O6cl3YScAvtrb hwekGB7BZuqESUzBJWmCvK7t9HF8Ts6cUAPoFWso3aP8ApWyJ3wqOPo2pJDC BQ0NI0Pj8QCQ2r1L5vKaU5lDRYX7yRur1UYYZmJQ9iDHwN9dndB5n5ejflmm UsBwLHnDkKXWRuAkb3NeuzqRstiQGP.fCQFdHNzaE.8u58Nz9svFE9SGIE1X kv9Iwfl1BdNWjA7xcThsWCS847loyFD8pZq2E2F04lYULzBTDYhrFSDDJdjo fisN2NUN26e4xRu51zD5ZseJ4HC63WyIX6jRqsp0jangBnK.Qlo58PCpWevt ahzqK7fbKsdX6R64aao8LmWhBPh9jKVAPMzb5a2cV6opdWHneMmqMEmAGsPh ieigIjV+4gF1GgbMNXg+NH44YaRYyd..S1ThHzKhFwwGRaWVITqyj9FvPqMT d0pDuSqDrOGF.Uogf.juCFi9WAUkYR+rFPanDcPG8SbrtjyG03ZQ8m3AqC5H NcUUoXSwVrqXKVcZu.5ZnkwIfIVdXVZTwAuTTUiYuxwjZDK6ZgnRtYV8tJmP hEcuXgz2Goxyaiw35UkaWbpqtfzD02oUkkYqi.YQbZqIIWrIljFolsdmMKFR wCJ2+DTn.9QlkOld+d9Qy9IJdpLfy05Ik2b8GsG9h8rdm1ZFx1FrmmlA2snw qI9Mcdi2nr6q3Gc87nLawurbw1dda+tMyGJ9HaQmlkGwy6davisMgrkM65oz eulfYCzG46am8tSDK144xV4cEvVMTRXq9CIX8+ALNWb6sttKNkiZetnbz+lx cQnb1Nds2C0tvLNe14hwQtxYbxhqc17qHfamUcZZ3NYSWqjJuiDoizZ+ud2j naRK4k3346IIVdR1kKiQjM39adMamvc6n+Xp36Yf3SIGh3uKbquqs1JksTII kuJ7RrZSFb2Cn9j5a6DT8cMo0iczU+lsYaU8YNVh5k5uzJLU26ZcfuJE6XLY 0mcRp9NTCp+L+Ap+in7Xf3b9jFQBLtIY06PbrGhcrU6N00Qlaf9N0+QPo9nS P6qsI7aYNLSNOHpsAxis0ggnZLjYqyyFkdSqinVsPaqSDZaYBZ6c93uLCjGm iCroJVLzU45iNE.pIUfs3TWb.0FejHp9uANr0GcJPTroFDNOHpkIweLnI1QT dHl3P7LhOF3Ahd9rnvLwAMy5JSdNezGlsIsW9mW44r26js+alhxjlkdhN0YE YqiH5MTeWo6D4Qm.ieLS7OynmuVGSbmbFUlnWWhiQlhOeN+Yl35bq.tGo9JR cj8AVqdz7nSgVB9zNj.FTOU68o5d9KO5TUOGxVMw+jTO8T6wqD0hEiHsOJO5 TTOMoS.zlqN0SpZjz6GcH05ylVM0jwuidlkmAif374ih5M5QPfccr8Hqifff otN8pt3hUcaWu8nosBhwmD0Epw5KmoF.poxy4YHbnjqfPJqcM3Y2vun7nS.i f3eETiqcRX2LR.4QmhZrkoCSGwzZrqKHrVR8caari+55d2caPqmq5n.ywe8Q WrZL9fpwVXeaogMByE6y1SMdjk+gbavbN7fYvVtt1C2XwHJSzpk+tidUO25H UB9onw9mlFQ10fhpZBaDatcMTTEGcJpwzqg92qqiVtM6Cu0IRQ0ndEdfCAqV l0qYAUmPrctbxO4XCuPMa1asYzKDks1D52ZCne6Mednz9qW8+.vfqkDA -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/SerialCallResponse/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/SerialCallResponse/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/SerialCallResponse/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/SerialCallResponseASCII/","text":"Sketch Code /* Serial Call and Response in ASCII Language: Wiring/Arduino This program sends an ASCII A (byte of value 65) on startup and repeats that until it gets some data in. Then it waits for a byte in the serial port, and sends three ASCII-encoded, comma-separated sensor values, truncated by a linefeed and carriage return, whenever it gets a byte in. The circuit: - potentiometers attached to analog inputs 0 and 1 - pushbutton attached to digital I/O 2 created 26 Sep 2005 by Tom Igoe modified 24 Apr 2012 by Tom Igoe and Scott Fitzgerald Thanks to Greg Shakar and Scott Fitzgerald for the improvements This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialCallResponseASCII */ int firstSensor = 0; // first analog sensor int secondSensor = 0; // second analog sensor int thirdSensor = 0; // digital sensor int inByte = 0; // incoming serial byte void setup() { // start serial port at 9600 bps and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } pinMode(2, INPUT); // digital sensor is on digital pin 2 establishContact(); // send a byte to establish contact until receiver responds } void loop() { // if we get a valid byte, read analog ins: if (Serial.available() > 0) { // get incoming byte: inByte = Serial.read(); // read first analog input: firstSensor = analogRead(A0); // read second analog input: secondSensor = analogRead(A1); // read switch, map it to 0 or 255 thirdSensor = map(digitalRead(2), 0, 1, 0, 255); // send sensor values: Serial.print(firstSensor); Serial.print(\",\"); Serial.print(secondSensor); Serial.print(\",\"); Serial.println(thirdSensor); } } void establishContact() { while (Serial.available() <= 0) { Serial.println(\"0,0,0\"); // send an initial string delay(300); } } /* Processing code to run with this example: // This example code is in the public domain. import processing.serial.*; // import the Processing serial library Serial myPort; // The serial port float bgcolor; // Background color float fgcolor; // Fill color float xpos, ypos; // Starting position of the ball void setup() { size(640, 480); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino board, so I open Serial.list()[0]. // Change the 0 to the appropriate number of the serial port that your // microcontroller is attached to. myPort = new Serial(this, Serial.list()[0], 9600); // read bytes into a buffer until you get a linefeed (ASCII 10): myPort.bufferUntil('\\n'); // draw with smooth edges: smooth(); } void draw() { background(bgcolor); fill(fgcolor); // Draw the shape ellipse(xpos, ypos, 20, 20); } // serialEvent method is run automatically by the Processing applet whenever // the buffer reaches the byte value set in the bufferUntil() // method in the setup(): void serialEvent(Serial myPort) { // read the serial buffer: String myString = myPort.readStringUntil('\\n'); // if you got any bytes other than the linefeed: myString = trim(myString); // split the string at the commas and convert the sections into integers: int sensors[] = int(split(myString, ',')); // print out the values you got: for (int sensorNum = 0; sensorNum < sensors.length; sensorNum++) { print(\"Sensor \" + sensorNum + \": \" + sensors[sensorNum] + \"\\t\"); } // add a linefeed after all the sensor values are printed: println(); if (sensors.length > 1) { xpos = map(sensors[0], 0, 1023, 0, width); ypos = map(sensors[1], 0, 1023, 0, height); fgcolor = sensors[2]; } // send a byte to ask for more data: myPort.write(\"A\"); } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 3640.3oc6cs0jZajE94Y9UzKkeHoVloTeSHkm1II0VkeHIthSs6C1obIjZ.E KjHRhY7jT4+9d5KBj.jTCAXfoV6x.sj5VmyWet127ed6MCFm8EQw.z2f9.5l a9yau4F0kjW3FS4aFLO3KgIAEpGaPX174hzxAC02qT7kR80mkkUHPAnBQdbP BZQVdIZRd1bT4r3BDTmkU0YQPY3r3zoeJWDVpe2ttr6cFhvXt7KhyH8W26f9 USkhiTulrw+1czQUszjrzxzf4B0sdP9dqtS5x4woIhREQiWewrkkUW0oViTD +GpFASt2Qd0+51akeLzRPIU7DPXagIFnH.4653f9WAKKyxVHRQNcfDXlih2w puvbdWHAlcTPBRKHg4x5mr74EBMINHV1+iFL.8qG.VMWTTDLUrs.TBH+zAvP nTEhvvxun9pBd6FWH38DWH6DWv6ItbX.RKBOJ7XbP5ztvDesvhBLb6VTwcOg DmiBjnXfiIrjjED0CpP490PEmtPExwQA5EGUVjK.CKQJqtcYl0nCMRAJi76D Z7dQflCCVV1i+ENiTy3AwYaghEA4.KVJx+jHMXbhntJPceO3iBpPOPKtZqtU jUoXtw28fkEimmEIlOI.3Q4iMT9wO+iLxc9O7sN28928t6Ve8uMYo.7EUN6t ePVoUW+6E4hOW7CAgeaV1meWd1cuWnYLy8mKhhClGDd25F3ce+C2si1Ud42+ bZ3IQJOXg7q96t80e50YvDjqHw7VvkRTXhHHuKEerRwmqfBFsS.g9h.HZN3X hJf5Qd+xHZHgzc.mrqeYjbn4E84evfIDUjDtjNwD2iRHV6anmGdbmsfKxTTJ dd93rjtBJ2U42foCwZDqKfYzKkrh4VgYIY4FxVRmN2646f8ck+xw7KrjzOlZ ZYAVfdZgKlaWn29FzA8nfdR2quj.3ejflBJnKr.Dwpf13cZBm85P0rPj.rOB 6fvztPFGkVI0SAPi5NKHmih7E8Ph2e35uOtYN6x6JEQtJVWpV7gRtm2dZy9W +YMCxLHrEvAknQktDVdY7v82SFosgmSGHO56BRRt6mEEKxRKDnGd+2812h9X 5GSeODOcAJ.M9YHHAfjPkyD0GIugn.Ht6bQ.7TTS8DoPtCQCQxWobX+jYPUJ hPn3zgnx7kogphieFZ2j3TwDgH5dzaUscJ77kEnIY4hoYKglVYzcH5KKxJzu qmgegxl.0MLNGBNDsr.5IUz0iAPZFE.0TtLOEdClQYrAAeORwW+XVo3aP+hb DHUBCH.mfbEKfGOPyjQhGiCAdNUUBRcQjij4X.u5MZRDzHSyTDQFbcYdHHIM AzlF1lnoLjKG8UZH5guV1vEkA4kKWbOPGPC9YgjNdJHVy+ZJQ1.Cq.FUWQpA ke.8DbUwi.YEWBUCDhPyAXCEETFbuhICg9EIRiYnGVjKyt0+io.r+9vrxRz+ Nt7OlJxCRhT35u.X0amlI9X5xEQppQwneJrLarPVU7JkGYWVHz2njevz1UoX XkoEWOkxDWO9kXYocoTwuzF611zXJyimB3F5qf9nOT9qesryJTJ1EOcV4cIh IPVWYoOBUMFTl.4sGRRzRT4AOIkRjn8h7LnNJI2mhg6OSk5JZrPJ4i9gfu.R w+NHLCcpfAMij88n+qTPPMt4UTwj3bAnY.h.aIe.RiAEeF8Pdzx3zLkLUs1Z mcmczah0FH4ZmpLcp.rVbX3d0zalKhSiKAxBZ9BU2zTP3uPobgL1Q.U0.kl+ jcBZj1AMOpzsJYjdz0n53QXsfYrqELKblH7yUFoDfPVXbrwDGXqCjwjviT7a rXZbpxOvxzXvpOnPH0GlTJMZog8l2UZJcdPjxjG7ywIYgeFULaInFDk8jpxZ apvMA4cv9X.7.vaRRGFAcPYHMR0dF2BZC7wEJ2TOKeZnCRD+HzJo.OLWSW6r qk2wfI6pGf.pdjC4rpfL2YeK8JYloVf93.ocJEvocv9wAcEiMQgBtl.lb0y9 heKnvtGRs+iHOJHM3uaZbN1jDrhED4FfwfLPCEmH8jV.BB0Z+aF.Vkqc4apU EIb9a5zAcGt5Rf3WdsNJ3R4PXDU0mouHzIca0MWO.KpQjT8oq1SIyqV3mP24 ToxfHpdyOPNqgwoK.W.fxfRNtwsiDSBVlT9ociSMu+jfPQqUtk9paFLMONJK URFMpq7xUuvOXF1HBuN6ndhzfE6nxPXQkKKFGjKQNyHtSptYYVVRyaspyBD3 CRiA0YQYrlbgHdptY77E4wZk5UWSOf9yJByyRRZzT5673NtiNrvmhiJmoZq5 fI73wKp5DFrBihhmBNxadsxfoEMuRiIbutfVcM4FWuyr.2bvrlNF5.3U+q9C sKaa5jkMt70iSd8bC2ZbEFUuAa0DWqYF0tJ91p43649br2nZ2usLGuoxrnQq 6TArNx+1CjRLPpVWf62Kj59ZFRa38Y6D0kRo8AnT8b0g0e4p8+f6.P4sBnaX TqMmPsOdOcjG+dMtOmdzcgLdIGqjX0J+FAVrmSu.L8fAX19Ky1C.e1.z+IB2 qpeCIUV+.I4fARxQGH0i.9ECVZrhZMTheMCkc4XRMsoCgbef2ZFjaF5MXzaH n2PQugYmhe0WjdcU47Z1Ukhb6CwFISy2HNtcvtaNRWdshHNVgHcNMUlopRm4 tJByyLXfI0UN6GM7eUiFTm8BMbctZQC8atOegDu6oveXrgpeaGnfaETvsBJN 6AKuNsT4n+zRVXJtQd+ciEEYKyCq.8ptRTSdBRQrLNcUd5eXcjoa7fyhihZl UrNQxBYZo5g.vpdt8klkJi1QyPvdH7UFMStbvYu8Amu1nY7ECMKGXBqnY2KH Z18Jjl4aYNnEYiQWVzrUxytWNzL0VZ14xglI6isN5kAMi2GZlbYPyNma6FqC aJRs9qEogO+ovfvYFxxjGV07cLnH3QQzm.R.BG7SAkk4wiWVpC2p9jwX23ka 0zSz4M6e1QZY.8mljMNHwLURqZ9FuzslMk8ZJXtcMPeblVut1XYDhdMCpmjZ 8BAqsU9DezKxJAa8Hmbbfi+wccuVv7c0qELrEHB+UAhHWzCfCbKPEyBki24Z clythVwfkYSmlHrPdX8tC5v1iPb5ArPuOWc8NVrRZspq24UxhE0wBcAsMyt2 2LLuqvkKZRXjEq5CM6S3tq9Zm6HD+8Prm0F+jDWn1paUe+2ZuF259kxkiR5W Qf6vzKBtMm+gFrMeuWsKW.6B61VyWOFjz0Zsmwza+.ikxQcAL3iDtbLWMTKm OtyMEFcjWM9iu0rMa81D8kUl3v2ewcHWP5B2HX6kK7t7DL5fs6JVIrO0Z1l3 bEpOP3zih9.gbspPzKDYbRVAQ7CFhtZsYzhW1ko0WEJcG3oAC0aRIyxKsUEI +iDPwOLfp0uNA68MmtSUSmRuNb8d1ttWya7sVWf5Iwf.1LQtZUnqNvT1bS6z E5o2vfqNSH5bufQbuZV09M.E04Mj8XBUiBqNGl5FSt3NGlZaGRpV6wc4kiWi q0twaaORhul1jjsIi7cMjQlJJUaQuhR495nlfRQWRJXkrgmMGXWjKM4jdGJH yovkl4HUetutzWuY5tjFHneGn77rtG3iJ92whCVJxKhBwgGtRaFIzabfNrRn WThd9q24vsZjf9JvHwOKBhprFDmtXYIZ7xISjaO1GE4OK2V9yiS.qFhvrznh 8cKyMZs7EVepT01FlCe0rIC0lUk6NX4N9syCyAE660+ovE9hyGqjaGurrLak G0YwoMlFO4YMSZjd9DcWucsjUr1Yqgy8TluCY3N9Q8.+k0JCD3ZTS0CW8Qyb s19nOxrgjw7VFU+3ooYviK66pCfimt8AAxHOOBkK+EajC2yayWtciMzgdvpM NKORj29YyGcS4wFVlql0wcZTg1yw5wvMNiTpuUzpu.Y0miRlgO0w7wpZI2Em SUBGayVM5eqU4C+rV4ZSPkvXqLJbAHlR3mKwT5ISL8+Kv0k.GWEKwpP3ewk3 7omKIN7EtDmp4ZtHk0BfatXgLhgasHgZrVYaY8AIO7fq8Pas1fFzjd4ibwpd XO4GXOeOG+lcyasNh1R+wVx2yBxeTOT+wiZFYA0P48PNyiiVjAhJlNT4Qvpb uj3aN2qYqJcBfSWhMbf+YCPcsfbNeTC2l9WNc+5eIlkST0RJgupzIn+kysgC X6GGXnYpdYfP0GP6MKQXM3N1Ih6XVvcLuym7B0B5w8v.ahqBI49qJcJ.TaX. N+xBP4NGHhhqYfkRNM9q1f3ZweqyYCQYdGCSZGQ5wBx47o.Ssw+CkcgQOmud KZic4QKzCw+7ROm8nY2LfMsEDtdfeMKSn5Ev95IQhorcqJcBrzPsQUhRNe8M 1X6lhOezC4Bidv1nKcFs8YimJ9n8RWZXiO7aSCxDRLdjd91qU5TnmXCeRvmR 9jnm7b15RmJ9rO4Kr+IgO04BfczyOpqx9npzofOsIlaR8Mo0IUMR48i0mYly lVMwlw6gbloGRezy4yKEw6BHBBWik.eRi3DNM5KDahS.SOE1EjmXl7Uyqo9T AtQAO8fG3oLX3cZFxKh0FLNSRfDaoG74gdvW.ZDU9FMGSdFMBt+IQh.6eIvw FujTkJREGKKcJ3X2WtXf7Ub1HywEqxh2tJnE.FcZhMByrcXQw1x+bOWJYjpy lv8oq55aEHLcwD8hJjxbVU5EigcNtL7Ql76KVVp69Huhcb87vpoCkRYT+96v Hd5Ay1rofMqm+FkLYvv0+GL3FkL6bLp21kL6QFNV8BNM48foWBV4zt1wXm5V 4jkNEbL45dtNw13Iltmi9sAyY0S0l8BR+3yWjVXax7eOmKrp4m0QKIal6VYo SAf5XQxSrCa5l0qk45k5kAzqEgMNgzkz9FmL5abpnu4IhNzZ+0s+OKCSg0. -----------end_max5_patcher----------- */ Fritzing Circuit Same as Example SerialCallResponse KiCad Schematic Same as Example SerialCallResponse Video Demonstration","title":"SerialCallResponseASCII"},{"location":"04_builtin_examples/04.Communication/SerialCallResponseASCII/#sketch-code","text":"/* Serial Call and Response in ASCII Language: Wiring/Arduino This program sends an ASCII A (byte of value 65) on startup and repeats that until it gets some data in. Then it waits for a byte in the serial port, and sends three ASCII-encoded, comma-separated sensor values, truncated by a linefeed and carriage return, whenever it gets a byte in. The circuit: - potentiometers attached to analog inputs 0 and 1 - pushbutton attached to digital I/O 2 created 26 Sep 2005 by Tom Igoe modified 24 Apr 2012 by Tom Igoe and Scott Fitzgerald Thanks to Greg Shakar and Scott Fitzgerald for the improvements This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialCallResponseASCII */ int firstSensor = 0; // first analog sensor int secondSensor = 0; // second analog sensor int thirdSensor = 0; // digital sensor int inByte = 0; // incoming serial byte void setup() { // start serial port at 9600 bps and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } pinMode(2, INPUT); // digital sensor is on digital pin 2 establishContact(); // send a byte to establish contact until receiver responds } void loop() { // if we get a valid byte, read analog ins: if (Serial.available() > 0) { // get incoming byte: inByte = Serial.read(); // read first analog input: firstSensor = analogRead(A0); // read second analog input: secondSensor = analogRead(A1); // read switch, map it to 0 or 255 thirdSensor = map(digitalRead(2), 0, 1, 0, 255); // send sensor values: Serial.print(firstSensor); Serial.print(\",\"); Serial.print(secondSensor); Serial.print(\",\"); Serial.println(thirdSensor); } } void establishContact() { while (Serial.available() <= 0) { Serial.println(\"0,0,0\"); // send an initial string delay(300); } } /* Processing code to run with this example: // This example code is in the public domain. import processing.serial.*; // import the Processing serial library Serial myPort; // The serial port float bgcolor; // Background color float fgcolor; // Fill color float xpos, ypos; // Starting position of the ball void setup() { size(640, 480); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino board, so I open Serial.list()[0]. // Change the 0 to the appropriate number of the serial port that your // microcontroller is attached to. myPort = new Serial(this, Serial.list()[0], 9600); // read bytes into a buffer until you get a linefeed (ASCII 10): myPort.bufferUntil('\\n'); // draw with smooth edges: smooth(); } void draw() { background(bgcolor); fill(fgcolor); // Draw the shape ellipse(xpos, ypos, 20, 20); } // serialEvent method is run automatically by the Processing applet whenever // the buffer reaches the byte value set in the bufferUntil() // method in the setup(): void serialEvent(Serial myPort) { // read the serial buffer: String myString = myPort.readStringUntil('\\n'); // if you got any bytes other than the linefeed: myString = trim(myString); // split the string at the commas and convert the sections into integers: int sensors[] = int(split(myString, ',')); // print out the values you got: for (int sensorNum = 0; sensorNum < sensors.length; sensorNum++) { print(\"Sensor \" + sensorNum + \": \" + sensors[sensorNum] + \"\\t\"); } // add a linefeed after all the sensor values are printed: println(); if (sensors.length > 1) { xpos = map(sensors[0], 0, 1023, 0, width); ypos = map(sensors[1], 0, 1023, 0, height); fgcolor = sensors[2]; } // send a byte to ask for more data: myPort.write(\"A\"); } */ /* Max/MSP version 5 patch to run with this example: ----------begin_max5_patcher---------- 3640.3oc6cs0jZajE94Y9UzKkeHoVloTeSHkm1II0VkeHIthSs6C1obIjZ.E KjHRhY7jT4+9d5KBj.jTCAXfoV6x.sj5VmyWet127ed6MCFm8EQw.z2f9.5l a9yau4F0kjW3FS4aFLO3KgIAEpGaPX174hzxAC02qT7kR80mkkUHPAnBQdbP BZQVdIZRd1bT4r3BDTmkU0YQPY3r3zoeJWDVpe2ttr6cFhvXt7KhyH8W26f9 USkhiTulrw+1czQUszjrzxzf4B0sdP9dqtS5x4woIhREQiWewrkkUW0oViTD +GpFASt2Qd0+51akeLzRPIU7DPXagIFnH.4653f9WAKKyxVHRQNcfDXlih2w puvbdWHAlcTPBRKHg4x5mr74EBMINHV1+iFL.8qG.VMWTTDLUrs.TBH+zAvP nTEhvvxun9pBd6FWH38DWH6DWv6ItbX.RKBOJ7XbP5ztvDesvhBLb6VTwcOg DmiBjnXfiIrjjED0CpP490PEmtPExwQA5EGUVjK.CKQJqtcYl0nCMRAJi76D Z7dQflCCVV1i+ENiTy3AwYaghEA4.KVJx+jHMXbhntJPceO3iBpPOPKtZqtU jUoXtw28fkEimmEIlOI.3Q4iMT9wO+iLxc9O7sN28928t6Ve8uMYo.7EUN6t ePVoUW+6E4hOW7CAgeaV1meWd1cuWnYLy8mKhhClGDd25F3ce+C2si1Ud42+ bZ3IQJOXg7q96t80e50YvDjqHw7VvkRTXhHHuKEerRwmqfBFsS.g9h.HZN3X hJf5Qd+xHZHgzc.mrqeYjbn4E84evfIDUjDtjNwD2iRHV6anmGdbmsfKxTTJ dd93rjtBJ2U42foCwZDqKfYzKkrh4VgYIY4FxVRmN2646f8ck+xw7KrjzOlZ ZYAVfdZgKlaWn29FzA8nfdR2quj.3ejflBJnKr.Dwpf13cZBm85P0rPj.rOB 6fvztPFGkVI0SAPi5NKHmih7E8Ph2e35uOtYN6x6JEQtJVWpV7gRtm2dZy9W +YMCxLHrEvAknQktDVdY7v82SFosgmSGHO56BRRt6mEEKxRKDnGd+2812h9X 5GSeODOcAJ.M9YHHAfjPkyD0GIugn.Ht6bQ.7TTS8DoPtCQCQxWobX+jYPUJ hPn3zgnx7kogphieFZ2j3TwDgH5dzaUscJ77kEnIY4hoYKglVYzcH5KKxJzu qmgegxl.0MLNGBNDsr.5IUz0iAPZFE.0TtLOEdClQYrAAeORwW+XVo3aP+hb DHUBCH.mfbEKfGOPyjQhGiCAdNUUBRcQjij4X.u5MZRDzHSyTDQFbcYdHHIM AzlF1lnoLjKG8UZH5guV1vEkA4kKWbOPGPC9YgjNdJHVy+ZJQ1.Cq.FUWQpA ke.8DbUwi.YEWBUCDhPyAXCEETFbuhICg9EIRiYnGVjKyt0+io.r+9vrxRz+ Nt7OlJxCRhT35u.X0amlI9X5xEQppQwneJrLarPVU7JkGYWVHz2njevz1UoX XkoEWOkxDWO9kXYocoTwuzF611zXJyimB3F5qf9nOT9qesryJTJ1EOcV4cIh IPVWYoOBUMFTl.4sGRRzRT4AOIkRjn8h7LnNJI2mhg6OSk5JZrPJ4i9gfu.R w+NHLCcpfAMij88n+qTPPMt4UTwj3bAnY.h.aIe.RiAEeF8Pdzx3zLkLUs1Z mcmczah0FH4ZmpLcp.rVbX3d0zalKhSiKAxBZ9BU2zTP3uPobgL1Q.U0.kl+ jcBZj1AMOpzsJYjdz0n53QXsfYrqELKblH7yUFoDfPVXbrwDGXqCjwjviT7a rXZbpxOvxzXvpOnPH0GlTJMZog8l2UZJcdPjxjG7ywIYgeFULaInFDk8jpxZ apvMA4cv9X.7.vaRRGFAcPYHMR0dF2BZC7wEJ2TOKeZnCRD+HzJo.OLWSW6r qk2wfI6pGf.pdjC4rpfL2YeK8JYloVf93.ocJEvocv9wAcEiMQgBtl.lb0y9 heKnvtGRs+iHOJHM3uaZbN1jDrhED4FfwfLPCEmH8jV.BB0Z+aF.Vkqc4apU EIb9a5zAcGt5Rf3WdsNJ3R4PXDU0mouHzIca0MWO.KpQjT8oq1SIyqV3mP24 ToxfHpdyOPNqgwoK.W.fxfRNtwsiDSBVlT9ociSMu+jfPQqUtk9paFLMONJK URFMpq7xUuvOXF1HBuN6ndhzfE6nxPXQkKKFGjKQNyHtSptYYVVRyaspyBD3 CRiA0YQYrlbgHdptY77E4wZk5UWSOf9yJByyRRZzT5673NtiNrvmhiJmoZq5 fI73wKp5DFrBihhmBNxadsxfoEMuRiIbutfVcM4FWuyr.2bvrlNF5.3U+q9C sKaa5jkMt70iSd8bC2ZbEFUuAa0DWqYF0tJ91p43649br2nZ2usLGuoxrnQq 6TArNx+1CjRLPpVWf62Kj59ZFRa38Y6D0kRo8AnT8b0g0e4p8+f6.P4sBnaX TqMmPsOdOcjG+dMtOmdzcgLdIGqjX0J+FAVrmSu.L8fAX19Ky1C.e1.z+IB2 qpeCIUV+.I4fARxQGH0i.9ECVZrhZMTheMCkc4XRMsoCgbef2ZFjaF5MXzaH n2PQugYmhe0WjdcU47Z1Ukhb6CwFISy2HNtcvtaNRWdshHNVgHcNMUlopRm4 tJByyLXfI0UN6GM7eUiFTm8BMbctZQC8atOegDu6oveXrgpeaGnfaETvsBJN 6AKuNsT4n+zRVXJtQd+ciEEYKyCq.8ptRTSdBRQrLNcUd5eXcjoa7fyhihZl UrNQxBYZo5g.vpdt8klkJi1QyPvdH7UFMStbvYu8Amu1nY7ECMKGXBqnY2KH Z18Jjl4aYNnEYiQWVzrUxytWNzL0VZ14xglI6isN5kAMi2GZlbYPyNma6FqC aJRs9qEogO+ovfvYFxxjGV07cLnH3QQzm.R.BG7SAkk4wiWVpC2p9jwX23ka 0zSz4M6e1QZY.8mljMNHwLURqZ9FuzslMk8ZJXtcMPeblVut1XYDhdMCpmjZ 8BAqsU9DezKxJAa8Hmbbfi+wccuVv7c0qELrEHB+UAhHWzCfCbKPEyBki24Z clythVwfkYSmlHrPdX8tC5v1iPb5ArPuOWc8NVrRZspq24UxhE0wBcAsMyt2 2LLuqvkKZRXjEq5CM6S3tq9Zm6HD+8Prm0F+jDWn1paUe+2ZuF259kxkiR5W Qf6vzKBtMm+gFrMeuWsKW.6B61VyWOFjz0Zsmwza+.ikxQcAL3iDtbLWMTKm OtyMEFcjWM9iu0rMa81D8kUl3v2ewcHWP5B2HX6kK7t7DL5fs6JVIrO0Z1l3 bEpOP3zih9.gbspPzKDYbRVAQ7CFhtZsYzhW1ko0WEJcG3oAC0aRIyxKsUEI +iDPwOLfp0uNA68MmtSUSmRuNb8d1ttWya7sVWf5Iwf.1LQtZUnqNvT1bS6z E5o2vfqNSH5bufQbuZV09M.E04Mj8XBUiBqNGl5FSt3NGlZaGRpV6wc4kiWi q0twaaORhul1jjsIi7cMjQlJJUaQuhR495nlfRQWRJXkrgmMGXWjKM4jdGJH yovkl4HUetutzWuY5tjFHneGn77rtG3iJ92whCVJxKhBwgGtRaFIzabfNrRn WThd9q24vsZjf9JvHwOKBhprFDmtXYIZ7xISjaO1GE4OK2V9yiS.qFhvrznh 8cKyMZs7EVepT01FlCe0rIC0lUk6NX4N9syCyAE660+ovE9hyGqjaGurrLak G0YwoMlFO4YMSZjd9DcWucsjUr1Yqgy8TluCY3N9Q8.+k0JCD3ZTS0CW8Qyb s19nOxrgjw7VFU+3ooYviK66pCfimt8AAxHOOBkK+EajC2yayWtciMzgdvpM NKORj29YyGcS4wFVlql0wcZTg1yw5wvMNiTpuUzpu.Y0miRlgO0w7wpZI2Em SUBGayVM5eqU4C+rV4ZSPkvXqLJbAHlR3mKwT5ISL8+Kv0k.GWEKwpP3ewk3 7omKIN7EtDmp4ZtHk0BfatXgLhgasHgZrVYaY8AIO7fq8Pas1fFzjd4ibwpd XO4GXOeOG+lcyasNh1R+wVx2yBxeTOT+wiZFYA0P48PNyiiVjAhJlNT4Qvpb uj3aN2qYqJcBfSWhMbf+YCPcsfbNeTC2l9WNc+5eIlkST0RJgupzIn+kysgC X6GGXnYpdYfP0GP6MKQXM3N1Ih6XVvcLuym7B0B5w8v.ahqBI49qJcJ.TaX. N+xBP4NGHhhqYfkRNM9q1f3ZweqyYCQYdGCSZGQ5wBx47o.Ssw+CkcgQOmud KZic4QKzCw+7ROm8nY2LfMsEDtdfeMKSn5Ev95IQhorcqJcBrzPsQUhRNe8M 1X6lhOezC4Bidv1nKcFs8YimJ9n8RWZXiO7aSCxDRLdjd91qU5TnmXCeRvmR 9jnm7b15RmJ9rO4Kr+IgO04BfczyOpqx9npzofOsIlaR8Mo0IUMR48i0mYly lVMwlw6gbloGRezy4yKEw6BHBBWik.eRi3DNM5KDahS.SOE1EjmXl7Uyqo9T AtQAO8fG3oLX3cZFxKh0FLNSRfDaoG74gdvW.ZDU9FMGSdFMBt+IQh.6eIvw FujTkJREGKKcJ3X2WtXf7Ub1HywEqxh2tJnE.FcZhMByrcXQw1x+bOWJYjpy lv8oq55aEHLcwD8hJjxbVU5EigcNtL7Ql76KVVp69Huhcb87vpoCkRYT+96v Hd5Ay1rofMqm+FkLYvv0+GL3FkL6bLp21kL6QFNV8BNM48foWBV4zt1wXm5V 4jkNEbL45dtNw13Iltmi9sAyY0S0l8BR+3yWjVXax7eOmKrp4m0QKIal6VYo SAf5XQxSrCa5l0qk45k5kAzqEgMNgzkz9FmL5abpnu4IhNzZ+0s+OKCSg0. -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/SerialCallResponseASCII/#fritzing-circuit","text":"Same as Example SerialCallResponse","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/SerialCallResponseASCII/#kicad-schematic","text":"Same as Example SerialCallResponse","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/SerialCallResponseASCII/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/SerialEvent/","text":"Sketch Code /* Serial Event example When new serial data arrives, this sketch adds it to a String. When a newline is received, the loop prints the string and clears it. A good test for this is to try it with a GPS receiver that sends out NMEA 0183 sentences. NOTE: The serialEvent() feature is not available on the Leonardo, Micro, or other ATmega32U4 based boards. created 9 May 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialEvent */ String inputString = \"\"; // a String to hold incoming data bool stringComplete = false; // whether the string is complete void setup() { // initialize serial: Serial.begin(9600); // reserve 200 bytes for the inputString: inputString.reserve(200); } void loop() { // print the string when a newline arrives: if (stringComplete) { Serial.println(inputString); // clear the string: inputString = \"\"; stringComplete = false; } } /* SerialEvent occurs whenever a new data comes in the hardware serial RX. This routine is run between each time loop() runs, so using delay inside loop can delay response. Multiple bytes of data may be available. */ void serialEvent() { while (Serial.available()) { // get the new byte: char inChar = (char)Serial.read(); // add it to the inputString: inputString += inChar; // if the incoming character is a newline, set a flag so the main loop can // do something about it: if (inChar == '\\n') { stringComplete = true; } } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"SerialEvent"},{"location":"04_builtin_examples/04.Communication/SerialEvent/#sketch-code","text":"/* Serial Event example When new serial data arrives, this sketch adds it to a String. When a newline is received, the loop prints the string and clears it. A good test for this is to try it with a GPS receiver that sends out NMEA 0183 sentences. NOTE: The serialEvent() feature is not available on the Leonardo, Micro, or other ATmega32U4 based boards. created 9 May 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialEvent */ String inputString = \"\"; // a String to hold incoming data bool stringComplete = false; // whether the string is complete void setup() { // initialize serial: Serial.begin(9600); // reserve 200 bytes for the inputString: inputString.reserve(200); } void loop() { // print the string when a newline arrives: if (stringComplete) { Serial.println(inputString); // clear the string: inputString = \"\"; stringComplete = false; } } /* SerialEvent occurs whenever a new data comes in the hardware serial RX. This routine is run between each time loop() runs, so using delay inside loop can delay response. Multiple bytes of data may be available. */ void serialEvent() { while (Serial.available()) { // get the new byte: char inChar = (char)Serial.read(); // add it to the inputString: inputString += inChar; // if the incoming character is a newline, set a flag so the main loop can // do something about it: if (inChar == '\\n') { stringComplete = true; } } }","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/SerialEvent/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/SerialEvent/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/SerialEvent/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/SerialPassthrough/","text":"Sketch Code /* SerialPassthrough sketch Some boards, like the Arduino 101, the MKR1000, Zero, or the Micro, have one hardware serial port attached to Digital pins 0-1, and a separate USB serial port attached to the IDE Serial Monitor. This means that the \"serial passthrough\" which is possible with the Arduino UNO (commonly used to interact with devices/shields that require configuration via serial AT commands) will not work by default. This sketch allows you to emulate the serial passthrough behaviour. Any text you type in the IDE Serial monitor will be written out to the serial port on Digital pins 0 and 1, and vice-versa. On the 101, MKR1000, Zero, and Micro, \"Serial\" refers to the USB Serial port attached to the Serial Monitor, and \"Serial1\" refers to the hardware serial port attached to pins 0 and 1. This sketch will emulate Serial passthrough using those two Serial ports on the boards mentioned above, but you can change these names to connect any two serial ports on a board that has multiple ports. created 23 May 2016 by Erik Nyquist https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialPassthrough */ void setup() { Serial.begin(9600); Serial1.begin(9600); } void loop() { if (Serial.available()) { // If anything comes in Serial (USB), Serial1.write(Serial.read()); // read it and send it out Serial1 (pins 0 & 1) } if (Serial1.available()) { // If anything comes in Serial1 (pins 0 & 1) Serial.write(Serial1.read()); // read it and send it out Serial (USB) } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"SerialPassthrough"},{"location":"04_builtin_examples/04.Communication/SerialPassthrough/#sketch-code","text":"/* SerialPassthrough sketch Some boards, like the Arduino 101, the MKR1000, Zero, or the Micro, have one hardware serial port attached to Digital pins 0-1, and a separate USB serial port attached to the IDE Serial Monitor. This means that the \"serial passthrough\" which is possible with the Arduino UNO (commonly used to interact with devices/shields that require configuration via serial AT commands) will not work by default. This sketch allows you to emulate the serial passthrough behaviour. Any text you type in the IDE Serial monitor will be written out to the serial port on Digital pins 0 and 1, and vice-versa. On the 101, MKR1000, Zero, and Micro, \"Serial\" refers to the USB Serial port attached to the Serial Monitor, and \"Serial1\" refers to the hardware serial port attached to pins 0 and 1. This sketch will emulate Serial passthrough using those two Serial ports on the boards mentioned above, but you can change these names to connect any two serial ports on a board that has multiple ports. created 23 May 2016 by Erik Nyquist https://www.arduino.cc/en/Tutorial/BuiltInExamples/SerialPassthrough */ void setup() { Serial.begin(9600); Serial1.begin(9600); } void loop() { if (Serial.available()) { // If anything comes in Serial (USB), Serial1.write(Serial.read()); // read it and send it out Serial1 (pins 0 & 1) } if (Serial1.available()) { // If anything comes in Serial1 (pins 0 & 1) Serial.write(Serial1.read()); // read it and send it out Serial (USB) } }","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/SerialPassthrough/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/SerialPassthrough/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/SerialPassthrough/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/04.Communication/VirtualColorMixer/","text":"Sketch Code /* This example reads three analog sensors (potentiometers are easiest) and sends their values serially. The Processing and Max/MSP programs at the bottom take those three values and use them to change the background color of the screen. The circuit: - potentiometers attached to analog inputs 0, 1, and 2 created 2 Dec 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/VirtualColorMixer */ const int redPin = A0; // sensor to control red color const int greenPin = A1; // sensor to control green color const int bluePin = A2; // sensor to control blue color void setup() { Serial.begin(9600); } void loop() { Serial.print(analogRead(redPin)); Serial.print(\",\"); Serial.print(analogRead(greenPin)); Serial.print(\",\"); Serial.println(analogRead(bluePin)); } /* Processing code for this example // This example code is in the public domain. import processing.serial.*; float redValue = 0; // red value float greenValue = 0; // green value float blueValue = 0; // blue value Serial myPort; void setup() { size(200, 200); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino, so I open Serial.list()[0]. // Open whatever port is the one you're using. myPort = new Serial(this, Serial.list()[0], 9600); // don't generate a serialEvent() unless you get a newline character: myPort.bufferUntil('\\n'); } void draw() { // set the background color with the color values: background(redValue, greenValue, blueValue); } void serialEvent(Serial myPort) { // get the ASCII string: String inString = myPort.readStringUntil('\\n'); if (inString != null) { // trim off any whitespace: inString = trim(inString); // split the string on the commas and convert the resulting substrings // into an integer array: float[] colors = float(split(inString, \",\")); // if the array has at least three elements, you know you got the whole // thing. Put the numbers in the color variables: if (colors.length >= 3) { // map them to the range 0-255: redValue = map(colors[0], 0, 1023, 0, 255); greenValue = map(colors[1], 0, 1023, 0, 255); blueValue = map(colors[2], 0, 1023, 0, 255); } } } */ /* Max/MSP patch for this example ----------begin_max5_patcher---------- 1512.3oc4Z00aaaCE8YmeED9ktB35xOjrj1aAsXX4g8xZQeYoXfVh1gqRjdT TsIsn+2K+PJUovVVJ1VMdCAvxThV7bO7b48dIyWtXxzkxaYkSA+J3u.Sl7kK lLwcK6MlT2dxzB5so4zRW2lJXeRt7elNy+HM6Vs61uDDzbOYkNmo02sg4euS 4BSede8S2P0o2vEq+aEKU66PPP7b3LPHDauPvyCmAvv4v6+M7L2XXF2WfCaF lURgVPKbCxzKUbZdySDUEbgABN.ia08R9mccGYGn66qGutNir27qWbg8iY+7 HDRx.Hjf+OPHCQgPdpQHoxhBlwB+QF4cbkthlCRk4REnfeKScs3ZwaugWBbj .PS+.qDPAkZkgPlY5oPS4By2A5aTLFv9pounjsgpnZVF3x27pqtBrRpJnZaa C3WxTkfUJYA.BzR.BhIy.ehquw7dSoJCsrlATLckR.nhLPNWvVwL+Vp1LHL. SjMG.tRaG7OxT5R2c8Hx9B8.wLCxVaGI6qnpj45Ug84kL+6YIM8CqUxJyycF 7bqsBRULGvwfWyRMyovElat7NvqoejaLm4f+fkmyKuVTHy3q3ldhB.WtQY6Z x0BSOeSpTqA+FW+Yy3SyybH3sFy8p0RVCmaMpTyX6HdDZ2JsPbfSogbBMueH JLd6RMBdfRMzPjZvimuWIK2XgFA.ZmtfKoh0Sm88qc6OF4bDQ3P6kEtF6xej .OkjD4H5OllyS+.3FlhY0so4xRlWqyrXErQpt+2rsnXgQNZHZgmMVzEofW7T S4zORQtgIdDbRHrObRzSMNofUVZVcbKbhQZrSOo934TqRHIN2ncr7BF8TKR1 tHDqL.PejLRRPKMR.pKFAkbtDa+UOvsYsIFH0DYsTCjqZ66T1CmGeDILLpSm myk0SdkOKh5LUr4GbWwRYdW7fm.BvDmzHnSdH3biGpSbxxDNJoGDAD1ChH7L I0DaloOTBLvkO7zPs5HJnKNoGAXbol5eytUhfyiSfnjE1uAq+Fp0a+wygGwR q3ZI8.psJpkpJnyPzwmXBj7Sh.+bNvVZxlcKAm0OYHIxcIjzEKdRChgO5UMf LkMPNN0MfiS7Ev6TYQct.F5IWcCZ4504rGsiVswGWWSYyma01QcZgmL+f+sf oU18Hn6o6dXkMkFF14TL9rIAWE+6wvGV.p.TPqz3HK5L+VxYxl4UmBKEjr.B 6zinuKI3C+D2Y7azIM6N7QL6t+jQyZxymK1ToAKqVsxjlGyjz2c1kTK3180h kJEYkacWpv6lyp2VJTjWK47wHA6fyBOWxH9pUf6jUtZkLpNKW.9EeUBH3ymY XSQlaqGrkQMGzp20adYSmIOGjIABo1xZyAWJtCX9tg6+HMuhMCPyx76ao+Us UxmzUE79H8d2ZB1m1ztbnOa1mGeAq0awyK8a9UqBUc6pZolpzurTK232e5gp aInVw8QIIcpaiNSJfY4Z+92Cs+Mc+mgg2cEsvGlLY6V+1kMuioxnB5VM+fsY 9vSu4WI1PMBGXye6KXvNuzmZTh7U9h5j6vvASdngPdgOFxycNL6ia1axUMmT JIzebXcQCn3SKMf+4QCMmOZung+6xBCPLfwO8ngcEI52YJ1y7mx3CN9xKUYU bg7Y1yXjlKW6SrZnguQdsSfOSSDItqv2jwJFjavc1vO7OigyBr2+gDYorRk1 HXZpVFfu2FxXkZtfp4RQqNkX5y2sya3YYL2iavWAOaizH+pw.Ibg8f1I9h3Z 2B79sNeOHvBOtfEalWsvyu0KMf015.AaROvZ7vv5AhnndfHLbTgjcCK1KlHv gOk5B26OqrXjcJ005.QqCHn8fVTxnxfj93SfQiJlv8YV0VT9fVUwOOhSV3uD eeqCUClbBPa.j3vWDoMZssNTzRNEnE6gYPXazZaMF921syaLWyAeBXvCESA8 ASi6Zyw8.RQi65J8ZsNx3ho93OhGWENtWpowepae4YhCFeLErOLENtXJrOSc iadi39rf4hwc8xdhHz3gn3dBI7iDRlFe8huAfIZhq -----------end_max5_patcher----------- */ Fritzing Circuit KiCad Schematic Video Demonstration","title":"VirtualColorMixer"},{"location":"04_builtin_examples/04.Communication/VirtualColorMixer/#sketch-code","text":"/* This example reads three analog sensors (potentiometers are easiest) and sends their values serially. The Processing and Max/MSP programs at the bottom take those three values and use them to change the background color of the screen. The circuit: - potentiometers attached to analog inputs 0, 1, and 2 created 2 Dec 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe and Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/VirtualColorMixer */ const int redPin = A0; // sensor to control red color const int greenPin = A1; // sensor to control green color const int bluePin = A2; // sensor to control blue color void setup() { Serial.begin(9600); } void loop() { Serial.print(analogRead(redPin)); Serial.print(\",\"); Serial.print(analogRead(greenPin)); Serial.print(\",\"); Serial.println(analogRead(bluePin)); } /* Processing code for this example // This example code is in the public domain. import processing.serial.*; float redValue = 0; // red value float greenValue = 0; // green value float blueValue = 0; // blue value Serial myPort; void setup() { size(200, 200); // List all the available serial ports // if using Processing 2.1 or later, use Serial.printArray() println(Serial.list()); // I know that the first port in the serial list on my Mac is always my // Arduino, so I open Serial.list()[0]. // Open whatever port is the one you're using. myPort = new Serial(this, Serial.list()[0], 9600); // don't generate a serialEvent() unless you get a newline character: myPort.bufferUntil('\\n'); } void draw() { // set the background color with the color values: background(redValue, greenValue, blueValue); } void serialEvent(Serial myPort) { // get the ASCII string: String inString = myPort.readStringUntil('\\n'); if (inString != null) { // trim off any whitespace: inString = trim(inString); // split the string on the commas and convert the resulting substrings // into an integer array: float[] colors = float(split(inString, \",\")); // if the array has at least three elements, you know you got the whole // thing. Put the numbers in the color variables: if (colors.length >= 3) { // map them to the range 0-255: redValue = map(colors[0], 0, 1023, 0, 255); greenValue = map(colors[1], 0, 1023, 0, 255); blueValue = map(colors[2], 0, 1023, 0, 255); } } } */ /* Max/MSP patch for this example ----------begin_max5_patcher---------- 1512.3oc4Z00aaaCE8YmeED9ktB35xOjrj1aAsXX4g8xZQeYoXfVh1gqRjdT TsIsn+2K+PJUovVVJ1VMdCAvxThV7bO7b48dIyWtXxzkxaYkSA+J3u.Sl7kK lLwcK6MlT2dxzB5so4zRW2lJXeRt7elNy+HM6Vs61uDDzbOYkNmo02sg4euS 4BSede8S2P0o2vEq+aEKU66PPP7b3LPHDauPvyCmAvv4v6+M7L2XXF2WfCaF lURgVPKbCxzKUbZdySDUEbgABN.ia08R9mccGYGn66qGutNir27qWbg8iY+7 HDRx.Hjf+OPHCQgPdpQHoxhBlwB+QF4cbkthlCRk4REnfeKScs3ZwaugWBbj .PS+.qDPAkZkgPlY5oPS4By2A5aTLFv9pounjsgpnZVF3x27pqtBrRpJnZaa C3WxTkfUJYA.BzR.BhIy.ehquw7dSoJCsrlATLckR.nhLPNWvVwL+Vp1LHL. SjMG.tRaG7OxT5R2c8Hx9B8.wLCxVaGI6qnpj45Ug84kL+6YIM8CqUxJyycF 7bqsBRULGvwfWyRMyovElat7NvqoejaLm4f+fkmyKuVTHy3q3ldhB.WtQY6Z x0BSOeSpTqA+FW+Yy3SyybH3sFy8p0RVCmaMpTyX6HdDZ2JsPbfSogbBMueH JLd6RMBdfRMzPjZvimuWIK2XgFA.ZmtfKoh0Sm88qc6OF4bDQ3P6kEtF6xej .OkjD4H5OllyS+.3FlhY0so4xRlWqyrXErQpt+2rsnXgQNZHZgmMVzEofW7T S4zORQtgIdDbRHrObRzSMNofUVZVcbKbhQZrSOo934TqRHIN2ncr7BF8TKR1 tHDqL.PejLRRPKMR.pKFAkbtDa+UOvsYsIFH0DYsTCjqZ66T1CmGeDILLpSm myk0SdkOKh5LUr4GbWwRYdW7fm.BvDmzHnSdH3biGpSbxxDNJoGDAD1ChH7L I0DaloOTBLvkO7zPs5HJnKNoGAXbol5eytUhfyiSfnjE1uAq+Fp0a+wygGwR q3ZI8.psJpkpJnyPzwmXBj7Sh.+bNvVZxlcKAm0OYHIxcIjzEKdRChgO5UMf LkMPNN0MfiS7Ev6TYQct.F5IWcCZ4504rGsiVswGWWSYyma01QcZgmL+f+sf oU18Hn6o6dXkMkFF14TL9rIAWE+6wvGV.p.TPqz3HK5L+VxYxl4UmBKEjr.B 6zinuKI3C+D2Y7azIM6N7QL6t+jQyZxymK1ToAKqVsxjlGyjz2c1kTK3180h kJEYkacWpv6lyp2VJTjWK47wHA6fyBOWxH9pUf6jUtZkLpNKW.9EeUBH3ymY XSQlaqGrkQMGzp20adYSmIOGjIABo1xZyAWJtCX9tg6+HMuhMCPyx76ao+Us UxmzUE79H8d2ZB1m1ztbnOa1mGeAq0awyK8a9UqBUc6pZolpzurTK232e5gp aInVw8QIIcpaiNSJfY4Z+92Cs+Mc+mgg2cEsvGlLY6V+1kMuioxnB5VM+fsY 9vSu4WI1PMBGXye6KXvNuzmZTh7U9h5j6vvASdngPdgOFxycNL6ia1axUMmT JIzebXcQCn3SKMf+4QCMmOZung+6xBCPLfwO8ngcEI52YJ1y7mx3CN9xKUYU bg7Y1yXjlKW6SrZnguQdsSfOSSDItqv2jwJFjavc1vO7OigyBr2+gDYorRk1 HXZpVFfu2FxXkZtfp4RQqNkX5y2sya3YYL2iavWAOaizH+pw.Ibg8f1I9h3Z 2B79sNeOHvBOtfEalWsvyu0KMf015.AaROvZ7vv5AhnndfHLbTgjcCK1KlHv gOk5B26OqrXjcJ005.QqCHn8fVTxnxfj93SfQiJlv8YV0VT9fVUwOOhSV3uD eeqCUClbBPa.j3vWDoMZssNTzRNEnE6gYPXazZaMF921syaLWyAeBXvCESA8 ASi6Zyw8.RQi65J8ZsNx3ho93OhGWENtWpowepae4YhCFeLErOLENtXJrOSc iadi39rf4hwc8xdhHz3gn3dBI7iDRlFe8huAfIZhq -----------end_max5_patcher----------- */","title":"Sketch Code"},{"location":"04_builtin_examples/04.Communication/VirtualColorMixer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/04.Communication/VirtualColorMixer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/04.Communication/VirtualColorMixer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/05.Control/Arrays/","text":"Sketch Code /* Arrays Demonstrates the use of an array to hold pin numbers in order to iterate over the pins in a sequence. Lights multiple LEDs in sequence, then in reverse. Unlike the For Loop tutorial, where the pins have to be contiguous, here the pins can be in any random order. The circuit: - LEDs from pins 2 through 7 to ground created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Arrays */ int timer = 100; // The higher the number, the slower the timing. int ledPins[] = { 2, 7, 4, 6, 5, 3 }; // an array of pin numbers to which LEDs are attached int pinCount = 6; // the number of pins (i.e. the length of the array) void setup() { // the array elements are numbered from 0 to (pinCount - 1). // use a for loop to initialize each pin as an output: for (int thisPin = 0; thisPin < pinCount; thisPin++) { pinMode(ledPins[thisPin], OUTPUT); } } void loop() { // loop from the lowest pin to the highest: for (int thisPin = 0; thisPin < pinCount; thisPin++) { // turn the pin on: digitalWrite(ledPins[thisPin], HIGH); delay(timer); // turn the pin off: digitalWrite(ledPins[thisPin], LOW); } // loop from the highest pin to the lowest: for (int thisPin = pinCount - 1; thisPin >= 0; thisPin--) { // turn the pin on: digitalWrite(ledPins[thisPin], HIGH); delay(timer); // turn the pin off: digitalWrite(ledPins[thisPin], LOW); } } Fritzing Circuit Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs. KiCad Schematic Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs. Video Demonstration","title":"Arrays"},{"location":"04_builtin_examples/05.Control/Arrays/#sketch-code","text":"/* Arrays Demonstrates the use of an array to hold pin numbers in order to iterate over the pins in a sequence. Lights multiple LEDs in sequence, then in reverse. Unlike the For Loop tutorial, where the pins have to be contiguous, here the pins can be in any random order. The circuit: - LEDs from pins 2 through 7 to ground created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Arrays */ int timer = 100; // The higher the number, the slower the timing. int ledPins[] = { 2, 7, 4, 6, 5, 3 }; // an array of pin numbers to which LEDs are attached int pinCount = 6; // the number of pins (i.e. the length of the array) void setup() { // the array elements are numbered from 0 to (pinCount - 1). // use a for loop to initialize each pin as an output: for (int thisPin = 0; thisPin < pinCount; thisPin++) { pinMode(ledPins[thisPin], OUTPUT); } } void loop() { // loop from the lowest pin to the highest: for (int thisPin = 0; thisPin < pinCount; thisPin++) { // turn the pin on: digitalWrite(ledPins[thisPin], HIGH); delay(timer); // turn the pin off: digitalWrite(ledPins[thisPin], LOW); } // loop from the highest pin to the lowest: for (int thisPin = pinCount - 1; thisPin >= 0; thisPin--) { // turn the pin on: digitalWrite(ledPins[thisPin], HIGH); delay(timer); // turn the pin off: digitalWrite(ledPins[thisPin], LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/05.Control/Arrays/#fritzing-circuit","text":"Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs.","title":"Fritzing Circuit"},{"location":"04_builtin_examples/05.Control/Arrays/#kicad-schematic","text":"Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs.","title":"KiCad Schematic"},{"location":"04_builtin_examples/05.Control/Arrays/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/05.Control/ForLoopIteration/","text":"Sketch Code /* For Loop Iteration Demonstrates the use of a for() loop. Lights multiple LEDs in sequence, then in reverse. The circuit: - LEDs from pins 2 through 7 to ground created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ForLoopIteration */ int timer = 100; // The higher the number, the slower the timing. void setup() { // use a for loop to initialize each pin as an output: for (int thisPin = 2; thisPin < 8; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // loop from the lowest pin to the highest: for (int thisPin = 2; thisPin < 8; thisPin++) { // turn the pin on: digitalWrite(thisPin, HIGH); delay(timer); // turn the pin off: digitalWrite(thisPin, LOW); } // loop from the highest pin to the lowest: for (int thisPin = 7; thisPin >= 2; thisPin--) { // turn the pin on: digitalWrite(thisPin, HIGH); delay(timer); // turn the pin off: digitalWrite(thisPin, LOW); } } Fritzing Circuit Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs. KiCad Schematic Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs. Video Demonstration","title":"ForLoopIteration"},{"location":"04_builtin_examples/05.Control/ForLoopIteration/#sketch-code","text":"/* For Loop Iteration Demonstrates the use of a for() loop. Lights multiple LEDs in sequence, then in reverse. The circuit: - LEDs from pins 2 through 7 to ground created 2006 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ForLoopIteration */ int timer = 100; // The higher the number, the slower the timing. void setup() { // use a for loop to initialize each pin as an output: for (int thisPin = 2; thisPin < 8; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // loop from the lowest pin to the highest: for (int thisPin = 2; thisPin < 8; thisPin++) { // turn the pin on: digitalWrite(thisPin, HIGH); delay(timer); // turn the pin off: digitalWrite(thisPin, LOW); } // loop from the highest pin to the lowest: for (int thisPin = 7; thisPin >= 2; thisPin--) { // turn the pin on: digitalWrite(thisPin, HIGH); delay(timer); // turn the pin off: digitalWrite(thisPin, LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/05.Control/ForLoopIteration/#fritzing-circuit","text":"Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs.","title":"Fritzing Circuit"},{"location":"04_builtin_examples/05.Control/ForLoopIteration/#kicad-schematic","text":"Similar to Example AnalogWriteMega , but use 6 LEDs rather than 12 LEDs.","title":"KiCad Schematic"},{"location":"04_builtin_examples/05.Control/ForLoopIteration/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/05.Control/IfStatementConditional/","text":"Sketch Code /* Conditionals - If statement This example demonstrates the use of if() statements. It reads the state of a potentiometer (an analog input) and turns on an LED only if the potentiometer goes above a certain threshold level. It prints the analog value regardless of the level. The circuit: - potentiometer Center pin of the potentiometer goes to analog pin 0. Side pins of the potentiometer go to +5V and ground. - LED connected from digital pin 13 to ground through 220 ohm resistor - Note: On most Arduino boards, there is already an LED on the board connected to pin 13, so you don't need any extra components for this example. created 17 Jan 2009 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/ifStatementConditional // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/ifStatementConditional */ // These constants won't change: const int analogPin = A0; // pin that the sensor is attached to const int ledPin = 13; // pin that the LED is attached to const int threshold = 400; // an arbitrary threshold level that's in the range of the analog input void setup() { // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); // initialize serial communications: Serial.begin(9600); } void loop() { // read the value of the potentiometer: int analogValue = analogRead(analogPin); // if the analog value is high enough, turn on the LED: if (analogValue > threshold) { digitalWrite(ledPin, HIGH); } else { digitalWrite(ledPin, LOW); } // print the analog value: Serial.println(analogValue); delay(1); // delay in between reads for stability } Fritzing Circuit Same as Example AnalogReadSerial . KiCad Schematic Same as Example AnalogReadSerial . Video Demonstration","title":"IfStatementConditional"},{"location":"04_builtin_examples/05.Control/IfStatementConditional/#sketch-code","text":"/* Conditionals - If statement This example demonstrates the use of if() statements. It reads the state of a potentiometer (an analog input) and turns on an LED only if the potentiometer goes above a certain threshold level. It prints the analog value regardless of the level. The circuit: - potentiometer Center pin of the potentiometer goes to analog pin 0. Side pins of the potentiometer go to +5V and ground. - LED connected from digital pin 13 to ground through 220 ohm resistor - Note: On most Arduino boards, there is already an LED on the board connected to pin 13, so you don't need any extra components for this example. created 17 Jan 2009 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/ifStatementConditional // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/ifStatementConditional */ // These constants won't change: const int analogPin = A0; // pin that the sensor is attached to const int ledPin = 13; // pin that the LED is attached to const int threshold = 400; // an arbitrary threshold level that's in the range of the analog input void setup() { // initialize the LED pin as an output: pinMode(ledPin, OUTPUT); // initialize serial communications: Serial.begin(9600); } void loop() { // read the value of the potentiometer: int analogValue = analogRead(analogPin); // if the analog value is high enough, turn on the LED: if (analogValue > threshold) { digitalWrite(ledPin, HIGH); } else { digitalWrite(ledPin, LOW); } // print the analog value: Serial.println(analogValue); delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/05.Control/IfStatementConditional/#fritzing-circuit","text":"Same as Example AnalogReadSerial .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/05.Control/IfStatementConditional/#kicad-schematic","text":"Same as Example AnalogReadSerial .","title":"KiCad Schematic"},{"location":"04_builtin_examples/05.Control/IfStatementConditional/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/05.Control/WhileStatementConditional/","text":"Sketch Code /* Conditionals - while statement This example demonstrates the use of while() statements. While the pushbutton is pressed, the sketch runs the calibration routine. The sensor readings during the while loop define the minimum and maximum of expected values from the photoresistor. This is a variation on the calibrate example. The circuit: - photoresistor connected from +5V to analog in pin 0 - 10 kilohm resistor connected from ground to analog in pin 0 - LED connected from digital pin 9 to ground through 220 ohm resistor - pushbutton attached from pin 2 to +5V - 10 kilohm resistor attached from pin 2 to ground created 17 Jan 2009 modified 30 Aug 2011 by Tom Igoe modified 20 Jan 2017 by Arturo Guadalupi This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/WhileStatementConditional // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/WhileStatementConditional */ // These constants won't change: const int sensorPin = A0; // pin that the sensor is attached to const int ledPin = 9; // pin that the LED is attached to const int indicatorLedPin = 13; // pin that the built-in LED is attached to const int buttonPin = 2; // pin that the button is attached to // These variables will change: int sensorMin = 1023; // minimum sensor value int sensorMax = 0; // maximum sensor value int sensorValue = 0; // the sensor value void setup() { // set the LED pins as outputs and the switch pin as input: pinMode(indicatorLedPin, OUTPUT); pinMode(ledPin, OUTPUT); pinMode(buttonPin, INPUT); } void loop() { // while the button is pressed, take calibration readings: while (digitalRead(buttonPin) == HIGH) { calibrate(); } // signal the end of the calibration period digitalWrite(indicatorLedPin, LOW); // read the sensor: sensorValue = analogRead(sensorPin); // apply the calibration to the sensor reading sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255); // in case the sensor value is outside the range seen during calibration sensorValue = constrain(sensorValue, 0, 255); // fade the LED using the calibrated value: analogWrite(ledPin, sensorValue); } void calibrate() { // turn on the indicator LED to indicate that calibration is happening: digitalWrite(indicatorLedPin, HIGH); // read the sensor: sensorValue = analogRead(sensorPin); // record the maximum sensor value if (sensorValue > sensorMax) { sensorMax = sensorValue; } // record the minimum sensor value if (sensorValue < sensorMin) { sensorMin = sensorValue; } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WhileStatementConditional"},{"location":"04_builtin_examples/05.Control/WhileStatementConditional/#sketch-code","text":"/* Conditionals - while statement This example demonstrates the use of while() statements. While the pushbutton is pressed, the sketch runs the calibration routine. The sensor readings during the while loop define the minimum and maximum of expected values from the photoresistor. This is a variation on the calibrate example. The circuit: - photoresistor connected from +5V to analog in pin 0 - 10 kilohm resistor connected from ground to analog in pin 0 - LED connected from digital pin 9 to ground through 220 ohm resistor - pushbutton attached from pin 2 to +5V - 10 kilohm resistor attached from pin 2 to ground created 17 Jan 2009 modified 30 Aug 2011 by Tom Igoe modified 20 Jan 2017 by Arturo Guadalupi This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/WhileStatementConditional // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/WhileStatementConditional */ // These constants won't change: const int sensorPin = A0; // pin that the sensor is attached to const int ledPin = 9; // pin that the LED is attached to const int indicatorLedPin = 13; // pin that the built-in LED is attached to const int buttonPin = 2; // pin that the button is attached to // These variables will change: int sensorMin = 1023; // minimum sensor value int sensorMax = 0; // maximum sensor value int sensorValue = 0; // the sensor value void setup() { // set the LED pins as outputs and the switch pin as input: pinMode(indicatorLedPin, OUTPUT); pinMode(ledPin, OUTPUT); pinMode(buttonPin, INPUT); } void loop() { // while the button is pressed, take calibration readings: while (digitalRead(buttonPin) == HIGH) { calibrate(); } // signal the end of the calibration period digitalWrite(indicatorLedPin, LOW); // read the sensor: sensorValue = analogRead(sensorPin); // apply the calibration to the sensor reading sensorValue = map(sensorValue, sensorMin, sensorMax, 0, 255); // in case the sensor value is outside the range seen during calibration sensorValue = constrain(sensorValue, 0, 255); // fade the LED using the calibrated value: analogWrite(ledPin, sensorValue); } void calibrate() { // turn on the indicator LED to indicate that calibration is happening: digitalWrite(indicatorLedPin, HIGH); // read the sensor: sensorValue = analogRead(sensorPin); // record the maximum sensor value if (sensorValue > sensorMax) { sensorMax = sensorValue; } // record the minimum sensor value if (sensorValue < sensorMin) { sensorMin = sensorValue; } }","title":"Sketch Code"},{"location":"04_builtin_examples/05.Control/WhileStatementConditional/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/05.Control/WhileStatementConditional/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/05.Control/WhileStatementConditional/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/05.Control/switchCase/","text":"Sketch Code /* Switch statement Demonstrates the use of a switch statement. The switch statement allows you to choose from among a set of discrete values of a variable. It's like a series of if statements. To see this sketch in action, put the board and sensor in a well-lit room, open the Serial Monitor, and move your hand gradually down over the sensor. The circuit: - photoresistor from analog in 0 to +5V - 10K resistor from analog in 0 to ground created 1 Jul 2009 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/SwitchCase // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/SwitchCase */ // these constants won't change. They are the lowest and highest readings you // get from your sensor: const int sensorMin = 0; // sensor minimum, discovered through experiment const int sensorMax = 600; // sensor maximum, discovered through experiment void setup() { // initialize serial communication: Serial.begin(9600); } void loop() { // read the sensor: int sensorReading = analogRead(A0); // map the sensor range to a range of four options: int range = map(sensorReading, sensorMin, sensorMax, 0, 3); // do something different depending on the range value: switch (range) { case 0: // your hand is on the sensor Serial.println(\"dark\"); break; case 1: // your hand is close to the sensor Serial.println(\"dim\"); break; case 2: // your hand is a few inches from the sensor Serial.println(\"medium\"); break; case 3: // your hand is nowhere near the sensor Serial.println(\"bright\"); break; } delay(1); // delay in between reads for stability } Fritzing Circuit Same as Example AnalogInput . KiCad Schematic Same as Example AnalogInput . Video Demonstration","title":"switchCase"},{"location":"04_builtin_examples/05.Control/switchCase/#sketch-code","text":"/* Switch statement Demonstrates the use of a switch statement. The switch statement allows you to choose from among a set of discrete values of a variable. It's like a series of if statements. To see this sketch in action, put the board and sensor in a well-lit room, open the Serial Monitor, and move your hand gradually down over the sensor. The circuit: - photoresistor from analog in 0 to +5V - 10K resistor from analog in 0 to ground created 1 Jul 2009 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/SwitchCase // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/SwitchCase */ // these constants won't change. They are the lowest and highest readings you // get from your sensor: const int sensorMin = 0; // sensor minimum, discovered through experiment const int sensorMax = 600; // sensor maximum, discovered through experiment void setup() { // initialize serial communication: Serial.begin(9600); } void loop() { // read the sensor: int sensorReading = analogRead(A0); // map the sensor range to a range of four options: int range = map(sensorReading, sensorMin, sensorMax, 0, 3); // do something different depending on the range value: switch (range) { case 0: // your hand is on the sensor Serial.println(\"dark\"); break; case 1: // your hand is close to the sensor Serial.println(\"dim\"); break; case 2: // your hand is a few inches from the sensor Serial.println(\"medium\"); break; case 3: // your hand is nowhere near the sensor Serial.println(\"bright\"); break; } delay(1); // delay in between reads for stability }","title":"Sketch Code"},{"location":"04_builtin_examples/05.Control/switchCase/#fritzing-circuit","text":"Same as Example AnalogInput .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/05.Control/switchCase/#kicad-schematic","text":"Same as Example AnalogInput .","title":"KiCad Schematic"},{"location":"04_builtin_examples/05.Control/switchCase/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/05.Control/switchCase2/","text":"Sketch Code /* Switch statement with serial input Demonstrates the use of a switch statement. The switch statement allows you to choose from among a set of discrete values of a variable. It's like a series of if statements. To see this sketch in action, open the Serial monitor and send any character. The characters a, b, c, d, and e, will turn on LEDs. Any other character will turn the LEDs off. The circuit: - five LEDs attached to digital pins 2 through 6 through 220 ohm resistors created 1 Jul 2009 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/SwitchCase2 // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/SwitchCase2 */ void setup() { // initialize serial communication: Serial.begin(9600); // initialize the LED pins: for (int thisPin = 2; thisPin < 7; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // read the sensor: if (Serial.available() > 0) { int inByte = Serial.read(); // do something different depending on the character received. // The switch statement expects single number values for each case; in this // example, though, you're using single quotes to tell the controller to get // the ASCII value for the character. For example 'a' = 97, 'b' = 98, // and so forth: switch (inByte) { case 'a': digitalWrite(2, HIGH); break; case 'b': digitalWrite(3, HIGH); break; case 'c': digitalWrite(4, HIGH); break; case 'd': digitalWrite(5, HIGH); break; case 'e': digitalWrite(6, HIGH); break; default: // turn all the LEDs off: for (int thisPin = 2; thisPin < 7; thisPin++) { digitalWrite(thisPin, LOW); } } } } Fritzing Circuit Similar to Example AnalogWriteMega , but use 5 LEDs rather than 12 LEDs. KiCad Schematic Similar to Example AnalogWriteMega , but use 5 LEDs rather than 12 LEDs. Video Demonstration","title":"switchCase2"},{"location":"04_builtin_examples/05.Control/switchCase2/#sketch-code","text":"/* Switch statement with serial input Demonstrates the use of a switch statement. The switch statement allows you to choose from among a set of discrete values of a variable. It's like a series of if statements. To see this sketch in action, open the Serial monitor and send any character. The characters a, b, c, d, and e, will turn on LEDs. Any other character will turn the LEDs off. The circuit: - five LEDs attached to digital pins 2 through 6 through 220 ohm resistors created 1 Jul 2009 by Tom Igoe This example code is in the public domain. https://docs.arduino.cc/built-in-examples/control-structures/SwitchCase2 // Wrong https://www.arduino.cc/en/Tutorial/BuiltInExamples/SwitchCase2 */ void setup() { // initialize serial communication: Serial.begin(9600); // initialize the LED pins: for (int thisPin = 2; thisPin < 7; thisPin++) { pinMode(thisPin, OUTPUT); } } void loop() { // read the sensor: if (Serial.available() > 0) { int inByte = Serial.read(); // do something different depending on the character received. // The switch statement expects single number values for each case; in this // example, though, you're using single quotes to tell the controller to get // the ASCII value for the character. For example 'a' = 97, 'b' = 98, // and so forth: switch (inByte) { case 'a': digitalWrite(2, HIGH); break; case 'b': digitalWrite(3, HIGH); break; case 'c': digitalWrite(4, HIGH); break; case 'd': digitalWrite(5, HIGH); break; case 'e': digitalWrite(6, HIGH); break; default: // turn all the LEDs off: for (int thisPin = 2; thisPin < 7; thisPin++) { digitalWrite(thisPin, LOW); } } } }","title":"Sketch Code"},{"location":"04_builtin_examples/05.Control/switchCase2/#fritzing-circuit","text":"Similar to Example AnalogWriteMega , but use 5 LEDs rather than 12 LEDs.","title":"Fritzing Circuit"},{"location":"04_builtin_examples/05.Control/switchCase2/#kicad-schematic","text":"Similar to Example AnalogWriteMega , but use 5 LEDs rather than 12 LEDs.","title":"KiCad Schematic"},{"location":"04_builtin_examples/05.Control/switchCase2/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/06.Sensors/ADXL3xx/","text":"Sketch Code /* ADXL3xx Reads an Analog Devices ADXL3xx accelerometer and communicates the acceleration to the computer. The pins used are designed to be easily compatible with the breakout boards from SparkFun, available from: https://www.sparkfun.com/categories/80 The circuit: - analog 0: accelerometer self test - analog 1: z-axis - analog 2: y-axis - analog 3: x-axis - analog 4: ground - analog 5: vcc created 2 Jul 2008 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ADXL3xx */ // these constants describe the pins. They won't change: const int groundpin = 18; // analog input pin 4 -- ground const int powerpin = 19; // analog input pin 5 -- voltage const int xpin = A3; // x-axis of the accelerometer const int ypin = A2; // y-axis const int zpin = A1; // z-axis (only on 3-axis models) void setup() { // initialize the serial communications: Serial.begin(9600); // Provide ground and power by using the analog inputs as normal digital pins. // This makes it possible to directly connect the breakout board to the // Arduino. If you use the normal 5V and GND pins on the Arduino, // you can remove these lines. pinMode(groundpin, OUTPUT); pinMode(powerpin, OUTPUT); digitalWrite(groundpin, LOW); digitalWrite(powerpin, HIGH); } void loop() { // print the sensor values: Serial.print(analogRead(xpin)); // print a tab between values: Serial.print(\"\\t\"); Serial.print(analogRead(ypin)); // print a tab between values: Serial.print(\"\\t\"); Serial.print(analogRead(zpin)); Serial.println(); // delay before next reading: delay(100); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"ADXL3xx"},{"location":"04_builtin_examples/06.Sensors/ADXL3xx/#sketch-code","text":"/* ADXL3xx Reads an Analog Devices ADXL3xx accelerometer and communicates the acceleration to the computer. The pins used are designed to be easily compatible with the breakout boards from SparkFun, available from: https://www.sparkfun.com/categories/80 The circuit: - analog 0: accelerometer self test - analog 1: z-axis - analog 2: y-axis - analog 3: x-axis - analog 4: ground - analog 5: vcc created 2 Jul 2008 by David A. Mellis modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ADXL3xx */ // these constants describe the pins. They won't change: const int groundpin = 18; // analog input pin 4 -- ground const int powerpin = 19; // analog input pin 5 -- voltage const int xpin = A3; // x-axis of the accelerometer const int ypin = A2; // y-axis const int zpin = A1; // z-axis (only on 3-axis models) void setup() { // initialize the serial communications: Serial.begin(9600); // Provide ground and power by using the analog inputs as normal digital pins. // This makes it possible to directly connect the breakout board to the // Arduino. If you use the normal 5V and GND pins on the Arduino, // you can remove these lines. pinMode(groundpin, OUTPUT); pinMode(powerpin, OUTPUT); digitalWrite(groundpin, LOW); digitalWrite(powerpin, HIGH); } void loop() { // print the sensor values: Serial.print(analogRead(xpin)); // print a tab between values: Serial.print(\"\\t\"); Serial.print(analogRead(ypin)); // print a tab between values: Serial.print(\"\\t\"); Serial.print(analogRead(zpin)); Serial.println(); // delay before next reading: delay(100); }","title":"Sketch Code"},{"location":"04_builtin_examples/06.Sensors/ADXL3xx/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/06.Sensors/ADXL3xx/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/06.Sensors/ADXL3xx/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/06.Sensors/Knock/","text":"Sketch Code /* Knock Sensor This sketch reads a piezo element to detect a knocking sound. It reads an analog pin and compares the result to a set threshold. If the result is greater than the threshold, it writes \"knock\" to the serial port, and toggles the LED on pin 13. The circuit: - positive connection of the piezo attached to analog in 0 - negative connection of the piezo attached to ground - 1 megohm resistor attached from analog in 0 to ground created 25 Mar 2007 by David Cuartielles <http://www.0j0.org> modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Knock */ // these constants won't change: const int ledPin = 13; // LED connected to digital pin 13 const int knockSensor = A0; // the piezo is connected to analog pin 0 const int threshold = 100; // threshold value to decide when the detected sound is a knock or not // these variables will change: int sensorReading = 0; // variable to store the value read from the sensor pin int ledState = LOW; // variable used to store the last LED status, to toggle the light void setup() { pinMode(ledPin, OUTPUT); // declare the ledPin as as OUTPUT Serial.begin(9600); // use the serial port } void loop() { // read the sensor and store it in the variable sensorReading: sensorReading = analogRead(knockSensor); // if the sensor reading is greater than the threshold: if (sensorReading >= threshold) { // toggle the status of the ledPin: ledState = !ledState; // update the LED pin itself: digitalWrite(ledPin, ledState); // send the string \"Knock!\" back to the computer, followed by newline Serial.println(\"Knock!\"); } delay(100); // delay to avoid overloading the serial port buffer } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Knock"},{"location":"04_builtin_examples/06.Sensors/Knock/#sketch-code","text":"/* Knock Sensor This sketch reads a piezo element to detect a knocking sound. It reads an analog pin and compares the result to a set threshold. If the result is greater than the threshold, it writes \"knock\" to the serial port, and toggles the LED on pin 13. The circuit: - positive connection of the piezo attached to analog in 0 - negative connection of the piezo attached to ground - 1 megohm resistor attached from analog in 0 to ground created 25 Mar 2007 by David Cuartielles <http://www.0j0.org> modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/Knock */ // these constants won't change: const int ledPin = 13; // LED connected to digital pin 13 const int knockSensor = A0; // the piezo is connected to analog pin 0 const int threshold = 100; // threshold value to decide when the detected sound is a knock or not // these variables will change: int sensorReading = 0; // variable to store the value read from the sensor pin int ledState = LOW; // variable used to store the last LED status, to toggle the light void setup() { pinMode(ledPin, OUTPUT); // declare the ledPin as as OUTPUT Serial.begin(9600); // use the serial port } void loop() { // read the sensor and store it in the variable sensorReading: sensorReading = analogRead(knockSensor); // if the sensor reading is greater than the threshold: if (sensorReading >= threshold) { // toggle the status of the ledPin: ledState = !ledState; // update the LED pin itself: digitalWrite(ledPin, ledState); // send the string \"Knock!\" back to the computer, followed by newline Serial.println(\"Knock!\"); } delay(100); // delay to avoid overloading the serial port buffer }","title":"Sketch Code"},{"location":"04_builtin_examples/06.Sensors/Knock/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/06.Sensors/Knock/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/06.Sensors/Knock/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/06.Sensors/Memsic2125/","text":"Note Ignored. Memsic 2125 is outdated and deprecated. Sketch Code Note Ignored. Memsic 2125 is outdated and deprecated. Fritzing Circuit Note Ignored. Memsic 2125 is outdated and deprecated. KiCad Schematic Note Ignored. Memsic 2125 is outdated and deprecated. Video Demonstration Note Ignored. Memsic 2125 is outdated and deprecated.","title":"Memsic2125"},{"location":"04_builtin_examples/06.Sensors/Memsic2125/#sketch-code","text":"Note Ignored. Memsic 2125 is outdated and deprecated.","title":"Sketch Code"},{"location":"04_builtin_examples/06.Sensors/Memsic2125/#fritzing-circuit","text":"Note Ignored. Memsic 2125 is outdated and deprecated.","title":"Fritzing Circuit"},{"location":"04_builtin_examples/06.Sensors/Memsic2125/#kicad-schematic","text":"Note Ignored. Memsic 2125 is outdated and deprecated.","title":"KiCad Schematic"},{"location":"04_builtin_examples/06.Sensors/Memsic2125/#video-demonstration","text":"Note Ignored. Memsic 2125 is outdated and deprecated.","title":"Video Demonstration"},{"location":"04_builtin_examples/06.Sensors/Ping/","text":"Note SEN136B5B is outdated and deprecated. We're NOT using the demo from official Arduino examples, but use HC-SR04 as a replacement of SEN136B5B . For this particular example, please refer to Ultrasonic Sensor HC-SR04 and Arduino \u2013 Complete Guide . Sketch Code /* Ultrasonic Sensor HC-SR04 and Arduino Tutorial by Dejan Nedelkovski, www.HowToMechatronics.com */ // defines pins numbers const int trigPin = 9; const int echoPin = 10; // defines variables long duration; int distance; void setup() { pinMode(trigPin, OUTPUT); // Sets the trigPin as an Output pinMode(echoPin, INPUT); // Sets the echoPin as an Input Serial.begin(9600); // Starts the serial communication } void loop() { // Clears the trigPin digitalWrite(trigPin, LOW); delayMicroseconds(2); // Sets the trigPin on HIGH state for 10 micro seconds digitalWrite(trigPin, HIGH); delayMicroseconds(10); digitalWrite(trigPin, LOW); // Reads the echoPin, returns the sound wave travel time in microseconds duration = pulseIn(echoPin, HIGH); // Calculating the distance distance = duration * 0.034 / 2; // Prints the distance on the Serial Monitor Serial.print(\"Distance: \"); Serial.println(distance); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Ping"},{"location":"04_builtin_examples/06.Sensors/Ping/#sketch-code","text":"/* Ultrasonic Sensor HC-SR04 and Arduino Tutorial by Dejan Nedelkovski, www.HowToMechatronics.com */ // defines pins numbers const int trigPin = 9; const int echoPin = 10; // defines variables long duration; int distance; void setup() { pinMode(trigPin, OUTPUT); // Sets the trigPin as an Output pinMode(echoPin, INPUT); // Sets the echoPin as an Input Serial.begin(9600); // Starts the serial communication } void loop() { // Clears the trigPin digitalWrite(trigPin, LOW); delayMicroseconds(2); // Sets the trigPin on HIGH state for 10 micro seconds digitalWrite(trigPin, HIGH); delayMicroseconds(10); digitalWrite(trigPin, LOW); // Reads the echoPin, returns the sound wave travel time in microseconds duration = pulseIn(echoPin, HIGH); // Calculating the distance distance = duration * 0.034 / 2; // Prints the distance on the Serial Monitor Serial.print(\"Distance: \"); Serial.println(distance); }","title":"Sketch Code"},{"location":"04_builtin_examples/06.Sensors/Ping/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/06.Sensors/Ping/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/06.Sensors/Ping/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/07.Display/RowColumnScanning/","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix . Sketch Code Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix . Fritzing Circuit Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix . KiCad Schematic Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix . Video Demonstration Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"RowColumnScanning"},{"location":"04_builtin_examples/07.Display/RowColumnScanning/#sketch-code","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"Sketch Code"},{"location":"04_builtin_examples/07.Display/RowColumnScanning/#fritzing-circuit","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/07.Display/RowColumnScanning/#kicad-schematic","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"KiCad Schematic"},{"location":"04_builtin_examples/07.Display/RowColumnScanning/#video-demonstration","text":"Note Please refer to Chapter 5 - Examples for Arduino UNO R4 Wifi , Section 5.8: LED_Matrix .","title":"Video Demonstration"},{"location":"04_builtin_examples/07.Display/barGraph/","text":"Sketch Code /* LED bar graph Turns on a series of LEDs based on the value of an analog sensor. This is a simple way to make a bar graph display. Though this graph uses 10 LEDs, you can use any number by changing the LED count and the pins in the array. This method can be used to control any series of digital outputs that depends on an analog input. The circuit: - LEDs from pins 2 through 11 to ground created 4 Sep 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/BarGraph */ // these constants won't change: const int analogPin = A0; // the pin that the potentiometer is attached to const int ledCount = 10; // the number of LEDs in the bar graph int ledPins[] = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }; // an array of pin numbers to which LEDs are attached void setup() { // loop over the pin array and set them all to output: for (int thisLed = 0; thisLed < ledCount; thisLed++) { pinMode(ledPins[thisLed], OUTPUT); } } void loop() { // read the potentiometer: int sensorReading = analogRead(analogPin); // map the result to a range from 0 to the number of LEDs: int ledLevel = map(sensorReading, 0, 1023, 0, ledCount); // loop over the LED array: for (int thisLed = 0; thisLed < ledCount; thisLed++) { // if the array element's index is less than ledLevel, // turn the pin for this element on: if (thisLed < ledLevel) { digitalWrite(ledPins[thisLed], HIGH); } // turn off all pins higher than the ledLevel: else { digitalWrite(ledPins[thisLed], LOW); } } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"barGraph"},{"location":"04_builtin_examples/07.Display/barGraph/#sketch-code","text":"/* LED bar graph Turns on a series of LEDs based on the value of an analog sensor. This is a simple way to make a bar graph display. Though this graph uses 10 LEDs, you can use any number by changing the LED count and the pins in the array. This method can be used to control any series of digital outputs that depends on an analog input. The circuit: - LEDs from pins 2 through 11 to ground created 4 Sep 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/BarGraph */ // these constants won't change: const int analogPin = A0; // the pin that the potentiometer is attached to const int ledCount = 10; // the number of LEDs in the bar graph int ledPins[] = { 2, 3, 4, 5, 6, 7, 8, 9, 10, 11 }; // an array of pin numbers to which LEDs are attached void setup() { // loop over the pin array and set them all to output: for (int thisLed = 0; thisLed < ledCount; thisLed++) { pinMode(ledPins[thisLed], OUTPUT); } } void loop() { // read the potentiometer: int sensorReading = analogRead(analogPin); // map the result to a range from 0 to the number of LEDs: int ledLevel = map(sensorReading, 0, 1023, 0, ledCount); // loop over the LED array: for (int thisLed = 0; thisLed < ledCount; thisLed++) { // if the array element's index is less than ledLevel, // turn the pin for this element on: if (thisLed < ledLevel) { digitalWrite(ledPins[thisLed], HIGH); } // turn off all pins higher than the ledLevel: else { digitalWrite(ledPins[thisLed], LOW); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/07.Display/barGraph/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/07.Display/barGraph/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/07.Display/barGraph/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/CharacterAnalysis/","text":"Sketch Code /* Character analysis operators Examples using the character analysis operators. Send any byte and the sketch will tell you about it. created 29 Nov 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/CharacterAnalysis */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"send any byte and I'll tell you everything I can about it\"); Serial.println(); } void loop() { // get any incoming bytes: if (Serial.available() > 0) { int thisChar = Serial.read(); // say what was sent: Serial.print(\"You sent me: \\'\"); Serial.write(thisChar); Serial.print(\"\\' ASCII Value: \"); Serial.println(thisChar); // analyze what was sent: if (isAlphaNumeric(thisChar)) { Serial.println(\"it's alphanumeric\"); } if (isAlpha(thisChar)) { Serial.println(\"it's alphabetic\"); } if (isAscii(thisChar)) { Serial.println(\"it's ASCII\"); } if (isWhitespace(thisChar)) { Serial.println(\"it's whitespace\"); } if (isControl(thisChar)) { Serial.println(\"it's a control character\"); } if (isDigit(thisChar)) { Serial.println(\"it's a numeric digit\"); } if (isGraph(thisChar)) { Serial.println(\"it's a printable character that's not whitespace\"); } if (isLowerCase(thisChar)) { Serial.println(\"it's lower case\"); } if (isPrintable(thisChar)) { Serial.println(\"it's printable\"); } if (isPunct(thisChar)) { Serial.println(\"it's punctuation\"); } if (isSpace(thisChar)) { Serial.println(\"it's a space character\"); } if (isUpperCase(thisChar)) { Serial.println(\"it's upper case\"); } if (isHexadecimalDigit(thisChar)) { Serial.println(\"it's a valid hexadecimaldigit (i.e. 0 - 9, a - F, or A - F)\"); } // add some space and ask for another byte: Serial.println(); Serial.println(\"Give me another byte:\"); Serial.println(); } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"CharacterAnalysis"},{"location":"04_builtin_examples/08.Strings/CharacterAnalysis/#sketch-code","text":"/* Character analysis operators Examples using the character analysis operators. Send any byte and the sketch will tell you about it. created 29 Nov 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/CharacterAnalysis */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"send any byte and I'll tell you everything I can about it\"); Serial.println(); } void loop() { // get any incoming bytes: if (Serial.available() > 0) { int thisChar = Serial.read(); // say what was sent: Serial.print(\"You sent me: \\'\"); Serial.write(thisChar); Serial.print(\"\\' ASCII Value: \"); Serial.println(thisChar); // analyze what was sent: if (isAlphaNumeric(thisChar)) { Serial.println(\"it's alphanumeric\"); } if (isAlpha(thisChar)) { Serial.println(\"it's alphabetic\"); } if (isAscii(thisChar)) { Serial.println(\"it's ASCII\"); } if (isWhitespace(thisChar)) { Serial.println(\"it's whitespace\"); } if (isControl(thisChar)) { Serial.println(\"it's a control character\"); } if (isDigit(thisChar)) { Serial.println(\"it's a numeric digit\"); } if (isGraph(thisChar)) { Serial.println(\"it's a printable character that's not whitespace\"); } if (isLowerCase(thisChar)) { Serial.println(\"it's lower case\"); } if (isPrintable(thisChar)) { Serial.println(\"it's printable\"); } if (isPunct(thisChar)) { Serial.println(\"it's punctuation\"); } if (isSpace(thisChar)) { Serial.println(\"it's a space character\"); } if (isUpperCase(thisChar)) { Serial.println(\"it's upper case\"); } if (isHexadecimalDigit(thisChar)) { Serial.println(\"it's a valid hexadecimaldigit (i.e. 0 - 9, a - F, or A - F)\"); } // add some space and ask for another byte: Serial.println(); Serial.println(\"Give me another byte:\"); Serial.println(); } }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/CharacterAnalysis/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/CharacterAnalysis/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/CharacterAnalysis/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringAdditionOperator/","text":"Sketch Code /* Adding Strings together Examples of how to add Strings together You can also add several different data types to String, as shown here: created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringAdditionOperator */ // declare three Strings: String stringOne, stringTwo, stringThree; void setup() { // initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"You added \"); stringTwo = String(\"this string\"); stringThree = String(); // send an intro: Serial.println(\"\\n\\nAdding Strings together (concatenation):\"); Serial.println(); } void loop() { // adding a constant integer to a String: stringThree = stringOne + 123; Serial.println(stringThree); // prints \"You added 123\" // adding a constant long integer to a String: stringThree = stringOne + 123456789; Serial.println(stringThree); // prints \"You added 123456789\" // adding a constant character to a String: stringThree = stringOne + 'A'; Serial.println(stringThree); // prints \"You added A\" // adding a constant string to a String: stringThree = stringOne + \"abc\"; Serial.println(stringThree); // prints \"You added abc\" stringThree = stringOne + stringTwo; Serial.println(stringThree); // prints \"You added this string\" // adding a variable integer to a String: int sensorValue = analogRead(A0); stringOne = \"Sensor value: \"; stringThree = stringOne + sensorValue; Serial.println(stringThree); // prints \"Sensor Value: 401\" or whatever value analogRead(A0) has // adding a variable long integer to a String: stringOne = \"millis() value: \"; stringThree = stringOne + millis(); Serial.println(stringThree); // prints \"The millis: 345345\" or whatever value millis() has // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringAdditionOperator"},{"location":"04_builtin_examples/08.Strings/StringAdditionOperator/#sketch-code","text":"/* Adding Strings together Examples of how to add Strings together You can also add several different data types to String, as shown here: created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringAdditionOperator */ // declare three Strings: String stringOne, stringTwo, stringThree; void setup() { // initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"You added \"); stringTwo = String(\"this string\"); stringThree = String(); // send an intro: Serial.println(\"\\n\\nAdding Strings together (concatenation):\"); Serial.println(); } void loop() { // adding a constant integer to a String: stringThree = stringOne + 123; Serial.println(stringThree); // prints \"You added 123\" // adding a constant long integer to a String: stringThree = stringOne + 123456789; Serial.println(stringThree); // prints \"You added 123456789\" // adding a constant character to a String: stringThree = stringOne + 'A'; Serial.println(stringThree); // prints \"You added A\" // adding a constant string to a String: stringThree = stringOne + \"abc\"; Serial.println(stringThree); // prints \"You added abc\" stringThree = stringOne + stringTwo; Serial.println(stringThree); // prints \"You added this string\" // adding a variable integer to a String: int sensorValue = analogRead(A0); stringOne = \"Sensor value: \"; stringThree = stringOne + sensorValue; Serial.println(stringThree); // prints \"Sensor Value: 401\" or whatever value analogRead(A0) has // adding a variable long integer to a String: stringOne = \"millis() value: \"; stringThree = stringOne + millis(); Serial.println(stringThree); // prints \"The millis: 345345\" or whatever value millis() has // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringAdditionOperator/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringAdditionOperator/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringAdditionOperator/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringAppendOperator/","text":"Sketch Code /* Appending to Strings using the += operator and concat() Examples of how to append different data types to Strings created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringAppendOperator */ String stringOne, stringTwo; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"Sensor \"); stringTwo = String(\"value\"); // send an intro: Serial.println(\"\\n\\nAppending to a String:\"); Serial.println(); } void loop() { Serial.println(stringOne); // prints \"Sensor \" // adding a string to a String: stringOne += stringTwo; Serial.println(stringOne); // prints \"Sensor value\" // adding a constant string to a String: stringOne += \" for input \"; Serial.println(stringOne); // prints \"Sensor value for input\" // adding a constant character to a String: stringOne += 'A'; Serial.println(stringOne); // prints \"Sensor value for input A\" // adding a constant integer to a String: stringOne += 0; Serial.println(stringOne); // prints \"Sensor value for input A0\" // adding a constant string to a String: stringOne += \": \"; Serial.println(stringOne); // prints \"Sensor value for input\" // adding a variable integer to a String: stringOne += analogRead(A0); Serial.println(stringOne); // prints \"Sensor value for input A0: 456\" or whatever analogRead(A0) is Serial.println(\"\\n\\nchanging the Strings' values\"); stringOne = \"A long integer: \"; stringTwo = \"The millis(): \"; // adding a constant long integer to a String: stringOne += 123456789; Serial.println(stringOne); // prints \"A long integer: 123456789\" // using concat() to add a long variable to a String: stringTwo.concat(millis()); Serial.println(stringTwo); // prints \"The millis(): 43534\" or whatever the value of the millis() is // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringAppendOperator"},{"location":"04_builtin_examples/08.Strings/StringAppendOperator/#sketch-code","text":"/* Appending to Strings using the += operator and concat() Examples of how to append different data types to Strings created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringAppendOperator */ String stringOne, stringTwo; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"Sensor \"); stringTwo = String(\"value\"); // send an intro: Serial.println(\"\\n\\nAppending to a String:\"); Serial.println(); } void loop() { Serial.println(stringOne); // prints \"Sensor \" // adding a string to a String: stringOne += stringTwo; Serial.println(stringOne); // prints \"Sensor value\" // adding a constant string to a String: stringOne += \" for input \"; Serial.println(stringOne); // prints \"Sensor value for input\" // adding a constant character to a String: stringOne += 'A'; Serial.println(stringOne); // prints \"Sensor value for input A\" // adding a constant integer to a String: stringOne += 0; Serial.println(stringOne); // prints \"Sensor value for input A0\" // adding a constant string to a String: stringOne += \": \"; Serial.println(stringOne); // prints \"Sensor value for input\" // adding a variable integer to a String: stringOne += analogRead(A0); Serial.println(stringOne); // prints \"Sensor value for input A0: 456\" or whatever analogRead(A0) is Serial.println(\"\\n\\nchanging the Strings' values\"); stringOne = \"A long integer: \"; stringTwo = \"The millis(): \"; // adding a constant long integer to a String: stringOne += 123456789; Serial.println(stringOne); // prints \"A long integer: 123456789\" // using concat() to add a long variable to a String: stringTwo.concat(millis()); Serial.println(stringTwo); // prints \"The millis(): 43534\" or whatever the value of the millis() is // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringAppendOperator/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringAppendOperator/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringAppendOperator/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringCaseChanges/","text":"Sketch Code /* String Case changes Examples of how to change the case of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringCaseChanges */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString case changes:\"); Serial.println(); } void loop() { // toUpperCase() changes all letters to upper case: String stringOne = \"<html><head><body>\"; Serial.println(stringOne); stringOne.toUpperCase(); Serial.println(stringOne); // toLowerCase() changes all letters to lower case: String stringTwo = \"</BODY></HTML>\"; Serial.println(stringTwo); stringTwo.toLowerCase(); Serial.println(stringTwo); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringCaseChanges"},{"location":"04_builtin_examples/08.Strings/StringCaseChanges/#sketch-code","text":"/* String Case changes Examples of how to change the case of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringCaseChanges */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString case changes:\"); Serial.println(); } void loop() { // toUpperCase() changes all letters to upper case: String stringOne = \"<html><head><body>\"; Serial.println(stringOne); stringOne.toUpperCase(); Serial.println(stringOne); // toLowerCase() changes all letters to lower case: String stringTwo = \"</BODY></HTML>\"; Serial.println(stringTwo); stringTwo.toLowerCase(); Serial.println(stringTwo); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringCaseChanges/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringCaseChanges/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringCaseChanges/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringCharacters/","text":"Sketch Code /* String charAt() and setCharAt() Examples of how to get and set characters of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringCharacters */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"\\n\\nString charAt() and setCharAt():\"); } void loop() { // make a String to report a sensor reading: String reportString = \"SensorReading: 456\"; Serial.println(reportString); // the reading's most significant digit is at position 15 in the reportString: char mostSignificantDigit = reportString.charAt(15); String message = \"Most significant digit of the sensor reading is: \"; Serial.println(message + mostSignificantDigit); // add blank space: Serial.println(); // you can also set the character of a String. Change the : to a = character reportString.setCharAt(13, '='); Serial.println(reportString); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringCharacters"},{"location":"04_builtin_examples/08.Strings/StringCharacters/#sketch-code","text":"/* String charAt() and setCharAt() Examples of how to get and set characters of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringCharacters */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"\\n\\nString charAt() and setCharAt():\"); } void loop() { // make a String to report a sensor reading: String reportString = \"SensorReading: 456\"; Serial.println(reportString); // the reading's most significant digit is at position 15 in the reportString: char mostSignificantDigit = reportString.charAt(15); String message = \"Most significant digit of the sensor reading is: \"; Serial.println(message + mostSignificantDigit); // add blank space: Serial.println(); // you can also set the character of a String. Change the : to a = character reportString.setCharAt(13, '='); Serial.println(reportString); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringCharacters/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringCharacters/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringCharacters/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringComparisonOperators/","text":"Sketch Code /* Comparing Strings Examples of how to compare Strings using the comparison operators created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringComparisonOperators */ String stringOne, stringTwo; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"this\"); stringTwo = String(\"that\"); // send an intro: Serial.println(\"\\n\\nComparing Strings:\"); Serial.println(); } void loop() { // two Strings equal: if (stringOne == \"this\") { Serial.println(\"StringOne == \\\"this\\\"\"); } // two Strings not equal: if (stringOne != stringTwo) { Serial.println(stringOne + \" =! \" + stringTwo); } // two Strings not equal (case sensitivity matters): stringOne = \"This\"; stringTwo = \"this\"; if (stringOne != stringTwo) { Serial.println(stringOne + \" =! \" + stringTwo); } // you can also use equals() to see if two Strings are the same: if (stringOne.equals(stringTwo)) { Serial.println(stringOne + \" equals \" + stringTwo); } else { Serial.println(stringOne + \" does not equal \" + stringTwo); } // or perhaps you want to ignore case: if (stringOne.equalsIgnoreCase(stringTwo)) { Serial.println(stringOne + \" equals (ignoring case) \" + stringTwo); } else { Serial.println(stringOne + \" does not equal (ignoring case) \" + stringTwo); } // a numeric String compared to the number it represents: stringOne = \"1\"; int numberOne = 1; if (stringOne.toInt() == numberOne) { Serial.println(stringOne + \" = \" + numberOne); } // two numeric Strings compared: stringOne = \"2\"; stringTwo = \"1\"; if (stringOne >= stringTwo) { Serial.println(stringOne + \" >= \" + stringTwo); } // comparison operators can be used to compare Strings for alphabetic sorting too: stringOne = String(\"Brown\"); if (stringOne < \"Charles\") { Serial.println(stringOne + \" < Charles\"); } if (stringOne > \"Adams\") { Serial.println(stringOne + \" > Adams\"); } if (stringOne <= \"Browne\") { Serial.println(stringOne + \" <= Browne\"); } if (stringOne >= \"Brow\") { Serial.println(stringOne + \" >= Brow\"); } // the compareTo() operator also allows you to compare Strings // it evaluates on the first character that's different. // if the first character of the String you're comparing to comes first in // alphanumeric order, then compareTo() is greater than 0: stringOne = \"Cucumber\"; stringTwo = \"Cucuracha\"; if (stringOne.compareTo(stringTwo) < 0) { Serial.println(stringOne + \" comes before \" + stringTwo); } else { Serial.println(stringOne + \" comes after \" + stringTwo); } delay(10000); // because the next part is a loop: // compareTo() is handy when you've got Strings with numbers in them too: while (true) { stringOne = \"Sensor: \"; stringTwo = \"Sensor: \"; stringOne += analogRead(A0); stringTwo += analogRead(A5); if (stringOne.compareTo(stringTwo) < 0) { Serial.println(stringOne + \" comes before \" + stringTwo); } else { Serial.println(stringOne + \" comes after \" + stringTwo); } } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringComparisonOperators"},{"location":"04_builtin_examples/08.Strings/StringComparisonOperators/#sketch-code","text":"/* Comparing Strings Examples of how to compare Strings using the comparison operators created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringComparisonOperators */ String stringOne, stringTwo; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } stringOne = String(\"this\"); stringTwo = String(\"that\"); // send an intro: Serial.println(\"\\n\\nComparing Strings:\"); Serial.println(); } void loop() { // two Strings equal: if (stringOne == \"this\") { Serial.println(\"StringOne == \\\"this\\\"\"); } // two Strings not equal: if (stringOne != stringTwo) { Serial.println(stringOne + \" =! \" + stringTwo); } // two Strings not equal (case sensitivity matters): stringOne = \"This\"; stringTwo = \"this\"; if (stringOne != stringTwo) { Serial.println(stringOne + \" =! \" + stringTwo); } // you can also use equals() to see if two Strings are the same: if (stringOne.equals(stringTwo)) { Serial.println(stringOne + \" equals \" + stringTwo); } else { Serial.println(stringOne + \" does not equal \" + stringTwo); } // or perhaps you want to ignore case: if (stringOne.equalsIgnoreCase(stringTwo)) { Serial.println(stringOne + \" equals (ignoring case) \" + stringTwo); } else { Serial.println(stringOne + \" does not equal (ignoring case) \" + stringTwo); } // a numeric String compared to the number it represents: stringOne = \"1\"; int numberOne = 1; if (stringOne.toInt() == numberOne) { Serial.println(stringOne + \" = \" + numberOne); } // two numeric Strings compared: stringOne = \"2\"; stringTwo = \"1\"; if (stringOne >= stringTwo) { Serial.println(stringOne + \" >= \" + stringTwo); } // comparison operators can be used to compare Strings for alphabetic sorting too: stringOne = String(\"Brown\"); if (stringOne < \"Charles\") { Serial.println(stringOne + \" < Charles\"); } if (stringOne > \"Adams\") { Serial.println(stringOne + \" > Adams\"); } if (stringOne <= \"Browne\") { Serial.println(stringOne + \" <= Browne\"); } if (stringOne >= \"Brow\") { Serial.println(stringOne + \" >= Brow\"); } // the compareTo() operator also allows you to compare Strings // it evaluates on the first character that's different. // if the first character of the String you're comparing to comes first in // alphanumeric order, then compareTo() is greater than 0: stringOne = \"Cucumber\"; stringTwo = \"Cucuracha\"; if (stringOne.compareTo(stringTwo) < 0) { Serial.println(stringOne + \" comes before \" + stringTwo); } else { Serial.println(stringOne + \" comes after \" + stringTwo); } delay(10000); // because the next part is a loop: // compareTo() is handy when you've got Strings with numbers in them too: while (true) { stringOne = \"Sensor: \"; stringTwo = \"Sensor: \"; stringOne += analogRead(A0); stringTwo += analogRead(A5); if (stringOne.compareTo(stringTwo) < 0) { Serial.println(stringOne + \" comes before \" + stringTwo); } else { Serial.println(stringOne + \" comes after \" + stringTwo); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringComparisonOperators/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringComparisonOperators/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringComparisonOperators/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringConstructors/","text":"Sketch Code /* String constructors Examples of how to create Strings from other data types created 27 Jul 2010 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringConstructors */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString Constructors:\"); Serial.println(); } void loop() { // using a constant String: String stringOne = \"Hello String\"; Serial.println(stringOne); // prints \"Hello String\" // converting a constant char into a String: stringOne = String('a'); Serial.println(stringOne); // prints \"a\" // converting a constant string into a String object: String stringTwo = String(\"This is a string\"); Serial.println(stringTwo); // prints \"This is a string\" // concatenating two strings: stringOne = String(stringTwo + \" with more\"); // prints \"This is a string with more\": Serial.println(stringOne); // using a constant integer: stringOne = String(13); Serial.println(stringOne); // prints \"13\" // using an int and a base: stringOne = String(analogRead(A0), DEC); // prints \"453\" or whatever the value of analogRead(A0) is Serial.println(stringOne); // using an int and a base (hexadecimal): stringOne = String(45, HEX); // prints \"2d\", which is the hexadecimal version of decimal 45: Serial.println(stringOne); // using an int and a base (binary) stringOne = String(255, BIN); // prints \"11111111\" which is the binary value of 255 Serial.println(stringOne); // using a long and a base: stringOne = String(millis(), DEC); // prints \"123456\" or whatever the value of millis() is: Serial.println(stringOne); // using a float and the right decimal places: stringOne = String(5.698, 3); Serial.println(stringOne); // using a float and less decimal places to use rounding: stringOne = String(5.698, 2); Serial.println(stringOne); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringConstructors"},{"location":"04_builtin_examples/08.Strings/StringConstructors/#sketch-code","text":"/* String constructors Examples of how to create Strings from other data types created 27 Jul 2010 modified 30 Aug 2011 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringConstructors */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString Constructors:\"); Serial.println(); } void loop() { // using a constant String: String stringOne = \"Hello String\"; Serial.println(stringOne); // prints \"Hello String\" // converting a constant char into a String: stringOne = String('a'); Serial.println(stringOne); // prints \"a\" // converting a constant string into a String object: String stringTwo = String(\"This is a string\"); Serial.println(stringTwo); // prints \"This is a string\" // concatenating two strings: stringOne = String(stringTwo + \" with more\"); // prints \"This is a string with more\": Serial.println(stringOne); // using a constant integer: stringOne = String(13); Serial.println(stringOne); // prints \"13\" // using an int and a base: stringOne = String(analogRead(A0), DEC); // prints \"453\" or whatever the value of analogRead(A0) is Serial.println(stringOne); // using an int and a base (hexadecimal): stringOne = String(45, HEX); // prints \"2d\", which is the hexadecimal version of decimal 45: Serial.println(stringOne); // using an int and a base (binary) stringOne = String(255, BIN); // prints \"11111111\" which is the binary value of 255 Serial.println(stringOne); // using a long and a base: stringOne = String(millis(), DEC); // prints \"123456\" or whatever the value of millis() is: Serial.println(stringOne); // using a float and the right decimal places: stringOne = String(5.698, 3); Serial.println(stringOne); // using a float and less decimal places to use rounding: stringOne = String(5.698, 2); Serial.println(stringOne); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringConstructors/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringConstructors/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringConstructors/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringIndexOf/","text":"Sketch Code /* String indexOf() and lastIndexOf() functions Examples of how to evaluate, look for, and replace characters in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringIndexOf */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString indexOf() and lastIndexOf() functions:\"); Serial.println(); } void loop() { // indexOf() returns the position (i.e. index) of a particular character in a // String. For example, if you were parsing HTML tags, you could use it: String stringOne = \"<HTML><HEAD><BODY>\"; int firstClosingBracket = stringOne.indexOf('>'); Serial.println(\"The index of > in the string \" + stringOne + \" is \" + firstClosingBracket); stringOne = \"<HTML><HEAD><BODY>\"; int secondOpeningBracket = firstClosingBracket + 1; int secondClosingBracket = stringOne.indexOf('>', secondOpeningBracket); Serial.println(\"The index of the second > in the string \" + stringOne + \" is \" + secondClosingBracket); // you can also use indexOf() to search for Strings: stringOne = \"<HTML><HEAD><BODY>\"; int bodyTag = stringOne.indexOf(\"<BODY>\"); Serial.println(\"The index of the body tag in the string \" + stringOne + \" is \" + bodyTag); stringOne = \"<UL><LI>item<LI>item<LI>item</UL>\"; int firstListItem = stringOne.indexOf(\"<LI>\"); int secondListItem = stringOne.indexOf(\"<LI>\", firstListItem + 1); Serial.println(\"The index of the second list tag in the string \" + stringOne + \" is \" + secondListItem); // lastIndexOf() gives you the last occurrence of a character or string: int lastOpeningBracket = stringOne.lastIndexOf('<'); Serial.println(\"The index of the last < in the string \" + stringOne + \" is \" + lastOpeningBracket); int lastListItem = stringOne.lastIndexOf(\"<LI>\"); Serial.println(\"The index of the last list tag in the string \" + stringOne + \" is \" + lastListItem); // lastIndexOf() can also search for a string: stringOne = \"<p>Lorem ipsum dolor sit amet</p><p>Ipsem</p><p>Quod</p>\"; int lastParagraph = stringOne.lastIndexOf(\"<p\"); int secondLastGraf = stringOne.lastIndexOf(\"<p\", lastParagraph - 1); Serial.println(\"The index of the second to last paragraph tag \" + stringOne + \" is \" + secondLastGraf); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringIndexOf"},{"location":"04_builtin_examples/08.Strings/StringIndexOf/#sketch-code","text":"/* String indexOf() and lastIndexOf() functions Examples of how to evaluate, look for, and replace characters in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringIndexOf */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString indexOf() and lastIndexOf() functions:\"); Serial.println(); } void loop() { // indexOf() returns the position (i.e. index) of a particular character in a // String. For example, if you were parsing HTML tags, you could use it: String stringOne = \"<HTML><HEAD><BODY>\"; int firstClosingBracket = stringOne.indexOf('>'); Serial.println(\"The index of > in the string \" + stringOne + \" is \" + firstClosingBracket); stringOne = \"<HTML><HEAD><BODY>\"; int secondOpeningBracket = firstClosingBracket + 1; int secondClosingBracket = stringOne.indexOf('>', secondOpeningBracket); Serial.println(\"The index of the second > in the string \" + stringOne + \" is \" + secondClosingBracket); // you can also use indexOf() to search for Strings: stringOne = \"<HTML><HEAD><BODY>\"; int bodyTag = stringOne.indexOf(\"<BODY>\"); Serial.println(\"The index of the body tag in the string \" + stringOne + \" is \" + bodyTag); stringOne = \"<UL><LI>item<LI>item<LI>item</UL>\"; int firstListItem = stringOne.indexOf(\"<LI>\"); int secondListItem = stringOne.indexOf(\"<LI>\", firstListItem + 1); Serial.println(\"The index of the second list tag in the string \" + stringOne + \" is \" + secondListItem); // lastIndexOf() gives you the last occurrence of a character or string: int lastOpeningBracket = stringOne.lastIndexOf('<'); Serial.println(\"The index of the last < in the string \" + stringOne + \" is \" + lastOpeningBracket); int lastListItem = stringOne.lastIndexOf(\"<LI>\"); Serial.println(\"The index of the last list tag in the string \" + stringOne + \" is \" + lastListItem); // lastIndexOf() can also search for a string: stringOne = \"<p>Lorem ipsum dolor sit amet</p><p>Ipsem</p><p>Quod</p>\"; int lastParagraph = stringOne.lastIndexOf(\"<p\"); int secondLastGraf = stringOne.lastIndexOf(\"<p\", lastParagraph - 1); Serial.println(\"The index of the second to last paragraph tag \" + stringOne + \" is \" + secondLastGraf); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringIndexOf/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringIndexOf/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringIndexOf/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringLength/","text":"Sketch Code /* String length() Examples of how to use length() in a String. Open the Serial Monitor and start sending characters to see the results. created 1 Aug 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringLengthTrim */ String txtMsg = \"\"; // a string for incoming text unsigned int lastStringLength = txtMsg.length(); // previous length of the String void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString length():\"); Serial.println(); } void loop() { // add any incoming characters to the String: while (Serial.available() > 0) { char inChar = Serial.read(); txtMsg += inChar; } // print the message and a notice if it's changed: if (txtMsg.length() != lastStringLength) { Serial.println(txtMsg); Serial.println(txtMsg.length()); // if the String's longer than 140 characters, complain: if (txtMsg.length() < 140) { Serial.println(\"That's a perfectly acceptable text message\"); } else { Serial.println(\"That's too long for a text message.\"); } // note the length for next time through the loop: lastStringLength = txtMsg.length(); } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringLength"},{"location":"04_builtin_examples/08.Strings/StringLength/#sketch-code","text":"/* String length() Examples of how to use length() in a String. Open the Serial Monitor and start sending characters to see the results. created 1 Aug 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringLengthTrim */ String txtMsg = \"\"; // a string for incoming text unsigned int lastStringLength = txtMsg.length(); // previous length of the String void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString length():\"); Serial.println(); } void loop() { // add any incoming characters to the String: while (Serial.available() > 0) { char inChar = Serial.read(); txtMsg += inChar; } // print the message and a notice if it's changed: if (txtMsg.length() != lastStringLength) { Serial.println(txtMsg); Serial.println(txtMsg.length()); // if the String's longer than 140 characters, complain: if (txtMsg.length() < 140) { Serial.println(\"That's a perfectly acceptable text message\"); } else { Serial.println(\"That's too long for a text message.\"); } // note the length for next time through the loop: lastStringLength = txtMsg.length(); } }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringLength/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringLength/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringLength/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringLengthTrim/","text":"Sketch Code /* String length() and trim() Examples of how to use length() and trim() in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringLengthTrim */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString length() and trim():\"); Serial.println(); } void loop() { // here's a String with empty spaces at the end (called white space): String stringOne = \"Hello! \"; Serial.print(stringOne); Serial.print(\"<--- end of string. Length: \"); Serial.println(stringOne.length()); // trim the white space off the string: stringOne.trim(); Serial.print(stringOne); Serial.print(\"<--- end of trimmed string. Length: \"); Serial.println(stringOne.length()); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringLengthTrim"},{"location":"04_builtin_examples/08.Strings/StringLengthTrim/#sketch-code","text":"/* String length() and trim() Examples of how to use length() and trim() in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringLengthTrim */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString length() and trim():\"); Serial.println(); } void loop() { // here's a String with empty spaces at the end (called white space): String stringOne = \"Hello! \"; Serial.print(stringOne); Serial.print(\"<--- end of string. Length: \"); Serial.println(stringOne.length()); // trim the white space off the string: stringOne.trim(); Serial.print(stringOne); Serial.print(\"<--- end of trimmed string. Length: \"); Serial.println(stringOne.length()); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringLengthTrim/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringLengthTrim/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringLengthTrim/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringReplace/","text":"Sketch Code /* String replace() Examples of how to replace characters or substrings of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringReplace */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString replace:\\n\"); Serial.println(); } void loop() { String stringOne = \"<html><head><body>\"; Serial.println(stringOne); // replace() changes all instances of one substring with another: // first, make a copy of the original string: String stringTwo = stringOne; // then perform the replacements: stringTwo.replace(\"<\", \"</\"); // print the original: Serial.println(\"Original string: \" + stringOne); // and print the modified string: Serial.println(\"Modified string: \" + stringTwo); // you can also use replace() on single characters: String normalString = \"bookkeeper\"; Serial.println(\"normal: \" + normalString); String leetString = normalString; leetString.replace('o', '0'); leetString.replace('e', '3'); Serial.println(\"l33tspeak: \" + leetString); // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringReplace"},{"location":"04_builtin_examples/08.Strings/StringReplace/#sketch-code","text":"/* String replace() Examples of how to replace characters or substrings of a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringReplace */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString replace:\\n\"); Serial.println(); } void loop() { String stringOne = \"<html><head><body>\"; Serial.println(stringOne); // replace() changes all instances of one substring with another: // first, make a copy of the original string: String stringTwo = stringOne; // then perform the replacements: stringTwo.replace(\"<\", \"</\"); // print the original: Serial.println(\"Original string: \" + stringOne); // and print the modified string: Serial.println(\"Modified string: \" + stringTwo); // you can also use replace() on single characters: String normalString = \"bookkeeper\"; Serial.println(\"normal: \" + normalString); String leetString = normalString; leetString.replace('o', '0'); leetString.replace('e', '3'); Serial.println(\"l33tspeak: \" + leetString); // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringReplace/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringReplace/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringReplace/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringStartsWithEndsWith/","text":"Sketch Code /* String startWith() and endsWith() Examples of how to use startsWith() and endsWith() in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringStartsWithEndsWith */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString startsWith() and endsWith():\"); Serial.println(); } void loop() { // startsWith() checks to see if a String starts with a particular substring: String stringOne = \"HTTP/1.1 200 OK\"; Serial.println(stringOne); if (stringOne.startsWith(\"HTTP/1.1\")) { Serial.println(\"Server's using http version 1.1\"); } // you can also look for startsWith() at an offset position in the string: stringOne = \"HTTP/1.1 200 OK\"; if (stringOne.startsWith(\"200 OK\", 9)) { Serial.println(\"Got an OK from the server\"); } // endsWith() checks to see if a String ends with a particular character: String sensorReading = \"sensor = \"; sensorReading += analogRead(A0); Serial.print(sensorReading); if (sensorReading.endsWith(\"0\")) { Serial.println(\". This reading is divisible by ten\"); } else { Serial.println(\". This reading is not divisible by ten\"); } // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringStartsWithEndsWith"},{"location":"04_builtin_examples/08.Strings/StringStartsWithEndsWith/#sketch-code","text":"/* String startWith() and endsWith() Examples of how to use startsWith() and endsWith() in a String created 27 Jul 2010 modified 2 Apr 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringStartsWithEndsWith */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString startsWith() and endsWith():\"); Serial.println(); } void loop() { // startsWith() checks to see if a String starts with a particular substring: String stringOne = \"HTTP/1.1 200 OK\"; Serial.println(stringOne); if (stringOne.startsWith(\"HTTP/1.1\")) { Serial.println(\"Server's using http version 1.1\"); } // you can also look for startsWith() at an offset position in the string: stringOne = \"HTTP/1.1 200 OK\"; if (stringOne.startsWith(\"200 OK\", 9)) { Serial.println(\"Got an OK from the server\"); } // endsWith() checks to see if a String ends with a particular character: String sensorReading = \"sensor = \"; sensorReading += analogRead(A0); Serial.print(sensorReading); if (sensorReading.endsWith(\"0\")) { Serial.println(\". This reading is divisible by ten\"); } else { Serial.println(\". This reading is not divisible by ten\"); } // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringStartsWithEndsWith/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringStartsWithEndsWith/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringStartsWithEndsWith/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringSubstring/","text":"Sketch Code /* String substring() Examples of how to use substring in a String created 27 Jul 2010, modified 2 Apr 2012 by Zach Eveland This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringSubstring */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString substring():\"); Serial.println(); } void loop() { // Set up a String: String stringOne = \"Content-Type: text/html\"; Serial.println(stringOne); // substring(index) looks for the substring from the index position to the end: if (stringOne.substring(19) == \"html\") { Serial.println(\"It's an html file\"); } // you can also look for a substring in the middle of a string: if (stringOne.substring(14, 18) == \"text\") { Serial.println(\"It's a text-based file\"); } // do nothing while true: while (true) ; } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringSubstring"},{"location":"04_builtin_examples/08.Strings/StringSubstring/#sketch-code","text":"/* String substring() Examples of how to use substring in a String created 27 Jul 2010, modified 2 Apr 2012 by Zach Eveland This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringSubstring */ void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString substring():\"); Serial.println(); } void loop() { // Set up a String: String stringOne = \"Content-Type: text/html\"; Serial.println(stringOne); // substring(index) looks for the substring from the index position to the end: if (stringOne.substring(19) == \"html\") { Serial.println(\"It's an html file\"); } // you can also look for a substring in the middle of a string: if (stringOne.substring(14, 18) == \"text\") { Serial.println(\"It's a text-based file\"); } // do nothing while true: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringSubstring/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringSubstring/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringSubstring/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/08.Strings/StringToint/","text":"Sketch Code /* String to Integer conversion Reads a serial input string until it sees a newline, then converts the string to a number if the characters are digits. The circuit: - No external components needed. created 29 Nov 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringToInt */ String inString = \"\"; // string to hold input void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString toInt():\"); Serial.println(); } void loop() { // Read serial input: while (Serial.available() > 0) { int inChar = Serial.read(); if (isDigit(inChar)) { // convert the incoming byte to a char and add it to the string: inString += (char)inChar; } // if you get a newline, print the string, then the string's value: if (inChar == '\\n') { Serial.print(\"Value:\"); Serial.println(inString.toInt()); Serial.print(\"String: \"); Serial.println(inString); // clear the string for new input: inString = \"\"; } } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"StringToint"},{"location":"04_builtin_examples/08.Strings/StringToint/#sketch-code","text":"/* String to Integer conversion Reads a serial input string until it sees a newline, then converts the string to a number if the characters are digits. The circuit: - No external components needed. created 29 Nov 2010 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/StringToInt */ String inString = \"\"; // string to hold input void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // send an intro: Serial.println(\"\\n\\nString toInt():\"); Serial.println(); } void loop() { // Read serial input: while (Serial.available() > 0) { int inChar = Serial.read(); if (isDigit(inChar)) { // convert the incoming byte to a char and add it to the string: inString += (char)inChar; } // if you get a newline, print the string, then the string's value: if (inChar == '\\n') { Serial.print(\"Value:\"); Serial.println(inString.toInt()); Serial.print(\"String: \"); Serial.println(inString); // clear the string for new input: inString = \"\"; } } }","title":"Sketch Code"},{"location":"04_builtin_examples/08.Strings/StringToint/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/08.Strings/StringToint/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/08.Strings/StringToint/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/09.USB/KeyboardAndMouseControl/","text":"Sketch Code /* KeyboardAndMouseControl Controls the mouse from five pushbuttons on an Arduino Leonardo, Micro or Due. Hardware: - five pushbuttons attached to D2, D3, D4, D5, D6 The mouse movement is always relative. This sketch reads four pushbuttons, and uses them to set the movement of the mouse. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the mouse commands. created 15 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardAndMouseControl */ #include \"Keyboard.h\" #include \"Mouse.h\" // set pin numbers for the five buttons: const int upButton = 2; const int downButton = 3; const int leftButton = 4; const int rightButton = 5; const int mouseButton = 6; void setup() { // initialize the buttons' inputs: pinMode(upButton, INPUT); pinMode(downButton, INPUT); pinMode(leftButton, INPUT); pinMode(rightButton, INPUT); pinMode(mouseButton, INPUT); Serial.begin(9600); // initialize mouse control: Mouse.begin(); Keyboard.begin(); } void loop() { // use serial input to control the mouse: if (Serial.available() > 0) { char inChar = Serial.read(); switch (inChar) { case 'u': // move mouse up Mouse.move(0, -40); break; case 'd': // move mouse down Mouse.move(0, 40); break; case 'l': // move mouse left Mouse.move(-40, 0); break; case 'r': // move mouse right Mouse.move(40, 0); break; case 'm': // perform mouse left click Mouse.click(MOUSE_LEFT); break; } } // use the pushbuttons to control the keyboard: if (digitalRead(upButton) == HIGH) { Keyboard.write('u'); } if (digitalRead(downButton) == HIGH) { Keyboard.write('d'); } if (digitalRead(leftButton) == HIGH) { Keyboard.write('l'); } if (digitalRead(rightButton) == HIGH) { Keyboard.write('r'); } if (digitalRead(mouseButton) == HIGH) { Keyboard.write('m'); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"KeyboardAndMouseControl"},{"location":"04_builtin_examples/09.USB/KeyboardAndMouseControl/#sketch-code","text":"/* KeyboardAndMouseControl Controls the mouse from five pushbuttons on an Arduino Leonardo, Micro or Due. Hardware: - five pushbuttons attached to D2, D3, D4, D5, D6 The mouse movement is always relative. This sketch reads four pushbuttons, and uses them to set the movement of the mouse. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the mouse commands. created 15 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardAndMouseControl */ #include \"Keyboard.h\" #include \"Mouse.h\" // set pin numbers for the five buttons: const int upButton = 2; const int downButton = 3; const int leftButton = 4; const int rightButton = 5; const int mouseButton = 6; void setup() { // initialize the buttons' inputs: pinMode(upButton, INPUT); pinMode(downButton, INPUT); pinMode(leftButton, INPUT); pinMode(rightButton, INPUT); pinMode(mouseButton, INPUT); Serial.begin(9600); // initialize mouse control: Mouse.begin(); Keyboard.begin(); } void loop() { // use serial input to control the mouse: if (Serial.available() > 0) { char inChar = Serial.read(); switch (inChar) { case 'u': // move mouse up Mouse.move(0, -40); break; case 'd': // move mouse down Mouse.move(0, 40); break; case 'l': // move mouse left Mouse.move(-40, 0); break; case 'r': // move mouse right Mouse.move(40, 0); break; case 'm': // perform mouse left click Mouse.click(MOUSE_LEFT); break; } } // use the pushbuttons to control the keyboard: if (digitalRead(upButton) == HIGH) { Keyboard.write('u'); } if (digitalRead(downButton) == HIGH) { Keyboard.write('d'); } if (digitalRead(leftButton) == HIGH) { Keyboard.write('l'); } if (digitalRead(rightButton) == HIGH) { Keyboard.write('r'); } if (digitalRead(mouseButton) == HIGH) { Keyboard.write('m'); } }","title":"Sketch Code"},{"location":"04_builtin_examples/09.USB/KeyboardAndMouseControl/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/09.USB/KeyboardAndMouseControl/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/09.USB/KeyboardAndMouseControl/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardLayout/","text":"Sketch Code /* Keyboard logout This sketch demonstrates the Keyboard library. When you connect pin 2 to ground, it performs a logout. It uses keyboard combinations to do this, as follows: On Windows, CTRL-ALT-DEL followed by ALT-l On Ubuntu, CTRL-ALT-DEL, and ENTER On OSX, CMD-SHIFT-q To wake: Spacebar. Circuit: - Arduino Leonardo or Micro - wire to connect D2 to ground created 6 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardLogout */ #define OSX 0 #define WINDOWS 1 #define UBUNTU 2 #include \"Keyboard.h\" // change this to match your platform: int platform = OSX; void setup() { // make pin 2 an input and turn on the pull-up resistor so it goes high unless // connected to ground: pinMode(2, INPUT_PULLUP); Keyboard.begin(); } void loop() { while (digitalRead(2) == HIGH) { // do nothing until pin 2 goes low delay(500); } delay(1000); switch (platform) { case OSX: Keyboard.press(KEY_LEFT_GUI); // Shift-Q logs out: Keyboard.press(KEY_LEFT_SHIFT); Keyboard.press('Q'); delay(100); Keyboard.releaseAll(); // enter: Keyboard.write(KEY_RETURN); break; case WINDOWS: // CTRL-ALT-DEL: Keyboard.press(KEY_LEFT_CTRL); Keyboard.press(KEY_LEFT_ALT); Keyboard.press(KEY_DELETE); delay(100); Keyboard.releaseAll(); // ALT-l: delay(2000); Keyboard.press(KEY_LEFT_ALT); Keyboard.press('l'); Keyboard.releaseAll(); break; case UBUNTU: // CTRL-ALT-DEL: Keyboard.press(KEY_LEFT_CTRL); Keyboard.press(KEY_LEFT_ALT); Keyboard.press(KEY_DELETE); delay(1000); Keyboard.releaseAll(); // Enter to confirm logout: Keyboard.write(KEY_RETURN); break; } // do nothing: while (true) ; } Fritzing Circuit KiCad Schematic Video Demonstration","title":"KeyboardLayout"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardLayout/#sketch-code","text":"/* Keyboard logout This sketch demonstrates the Keyboard library. When you connect pin 2 to ground, it performs a logout. It uses keyboard combinations to do this, as follows: On Windows, CTRL-ALT-DEL followed by ALT-l On Ubuntu, CTRL-ALT-DEL, and ENTER On OSX, CMD-SHIFT-q To wake: Spacebar. Circuit: - Arduino Leonardo or Micro - wire to connect D2 to ground created 6 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardLogout */ #define OSX 0 #define WINDOWS 1 #define UBUNTU 2 #include \"Keyboard.h\" // change this to match your platform: int platform = OSX; void setup() { // make pin 2 an input and turn on the pull-up resistor so it goes high unless // connected to ground: pinMode(2, INPUT_PULLUP); Keyboard.begin(); } void loop() { while (digitalRead(2) == HIGH) { // do nothing until pin 2 goes low delay(500); } delay(1000); switch (platform) { case OSX: Keyboard.press(KEY_LEFT_GUI); // Shift-Q logs out: Keyboard.press(KEY_LEFT_SHIFT); Keyboard.press('Q'); delay(100); Keyboard.releaseAll(); // enter: Keyboard.write(KEY_RETURN); break; case WINDOWS: // CTRL-ALT-DEL: Keyboard.press(KEY_LEFT_CTRL); Keyboard.press(KEY_LEFT_ALT); Keyboard.press(KEY_DELETE); delay(100); Keyboard.releaseAll(); // ALT-l: delay(2000); Keyboard.press(KEY_LEFT_ALT); Keyboard.press('l'); Keyboard.releaseAll(); break; case UBUNTU: // CTRL-ALT-DEL: Keyboard.press(KEY_LEFT_CTRL); Keyboard.press(KEY_LEFT_ALT); Keyboard.press(KEY_DELETE); delay(1000); Keyboard.releaseAll(); // Enter to confirm logout: Keyboard.write(KEY_RETURN); break; } // do nothing: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardLayout/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardLayout/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardLayout/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardMessage/","text":"Sketch Code /* Keyboard Message test For the Arduino Leonardo and Micro. Sends a text string when a button is pressed. The circuit: - pushbutton attached from pin 4 to +5V - 10 kilohm resistor attached from pin 4 to ground created 24 Oct 2011 modified 27 Mar 2012 by Tom Igoe modified 11 Nov 2013 by Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardMessage */ #include \"Keyboard.h\" const int buttonPin = 4; // input pin for pushbutton int previousButtonState = HIGH; // for checking the state of a pushButton int counter = 0; // button push counter void setup() { // make the pushButton pin an input: pinMode(buttonPin, INPUT); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // read the pushbutton: int buttonState = digitalRead(buttonPin); // if the button state has changed, if ((buttonState != previousButtonState) // and it's currently pressed: && (buttonState == HIGH)) { // increment the button counter counter++; // type out a message Keyboard.print(\"You pressed the button \"); Keyboard.print(counter); Keyboard.println(\" times.\"); } // save the current button state for comparison next time: previousButtonState = buttonState; } Fritzing Circuit Same as Example DigitalReadSerial KiCad Schematic Same as Example DigitalReadSerial Video Demonstration","title":"KeyboardMessage"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardMessage/#sketch-code","text":"/* Keyboard Message test For the Arduino Leonardo and Micro. Sends a text string when a button is pressed. The circuit: - pushbutton attached from pin 4 to +5V - 10 kilohm resistor attached from pin 4 to ground created 24 Oct 2011 modified 27 Mar 2012 by Tom Igoe modified 11 Nov 2013 by Scott Fitzgerald This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardMessage */ #include \"Keyboard.h\" const int buttonPin = 4; // input pin for pushbutton int previousButtonState = HIGH; // for checking the state of a pushButton int counter = 0; // button push counter void setup() { // make the pushButton pin an input: pinMode(buttonPin, INPUT); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // read the pushbutton: int buttonState = digitalRead(buttonPin); // if the button state has changed, if ((buttonState != previousButtonState) // and it's currently pressed: && (buttonState == HIGH)) { // increment the button counter counter++; // type out a message Keyboard.print(\"You pressed the button \"); Keyboard.print(counter); Keyboard.println(\" times.\"); } // save the current button state for comparison next time: previousButtonState = buttonState; }","title":"Sketch Code"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardMessage/#fritzing-circuit","text":"Same as Example DigitalReadSerial","title":"Fritzing Circuit"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardMessage/#kicad-schematic","text":"Same as Example DigitalReadSerial","title":"KiCad Schematic"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardMessage/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardReprogram/","text":"Sketch Code /* Arduino Programs Blink This sketch demonstrates the Keyboard library. For Leonardo and Due boards only. When you connect pin 2 to ground, it creates a new window with a key combination (CTRL-N), then types in the Blink sketch, then auto-formats the text using another key combination (CTRL-T), then uploads the sketch to the currently selected Arduino using a final key combination (CTRL-U). Circuit: - Arduino Leonardo, Micro, Due, LilyPad USB, or Y\u00fan - wire to connect D2 to ground created 5 Mar 2012 modified 29 Mar 2012 by Tom Igoe modified 3 May 2014 by Scott Fitzgerald This example is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardReprogram */ #include \"Keyboard.h\" // use this option for OSX. // Comment it out if using Windows or Linux: char ctrlKey = KEY_LEFT_GUI; // use this option for Windows and Linux. // leave commented out if using OSX: // char ctrlKey = KEY_LEFT_CTRL; void setup() { // make pin 2 an input and turn on the pull-up resistor so it goes high unless // connected to ground: pinMode(2, INPUT_PULLUP); // initialize control over the keyboard: Keyboard.begin(); } void loop() { while (digitalRead(2) == HIGH) { // do nothing until pin 2 goes low delay(500); } delay(1000); // new document: Keyboard.press(ctrlKey); Keyboard.press('n'); delay(100); Keyboard.releaseAll(); // wait for new window to open: delay(1000); // versions of the Arduino IDE after 1.5 pre-populate new sketches with // setup() and loop() functions let's clear the window before typing anything new // select all Keyboard.press(ctrlKey); Keyboard.press('a'); delay(500); Keyboard.releaseAll(); // delete the selected text Keyboard.write(KEY_BACKSPACE); delay(500); // Type out \"blink\": Keyboard.println(\"void setup() {\"); Keyboard.println(\"pinMode(13, OUTPUT);\"); Keyboard.println(\"}\"); Keyboard.println(); Keyboard.println(\"void loop() {\"); Keyboard.println(\"digitalWrite(13, HIGH);\"); Keyboard.print(\"delay(3000);\"); // 3000 ms is too long. Delete it: for (int keystrokes = 0; keystrokes < 6; keystrokes++) { delay(500); Keyboard.write(KEY_BACKSPACE); } // make it 1000 instead: Keyboard.println(\"1000);\"); Keyboard.println(\"digitalWrite(13, LOW);\"); Keyboard.println(\"delay(1000);\"); Keyboard.println(\"}\"); // tidy up: Keyboard.press(ctrlKey); Keyboard.press('t'); delay(100); Keyboard.releaseAll(); delay(3000); // upload code: Keyboard.press(ctrlKey); Keyboard.press('u'); delay(100); Keyboard.releaseAll(); // wait for the sweet oblivion of reprogramming: while (true) ; } Fritzing Circuit Same as Example KeyboardLayout KiCad Schematic Same as Example KeyboardLayout Video Demonstration","title":"KeyboardReprogram"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardReprogram/#sketch-code","text":"/* Arduino Programs Blink This sketch demonstrates the Keyboard library. For Leonardo and Due boards only. When you connect pin 2 to ground, it creates a new window with a key combination (CTRL-N), then types in the Blink sketch, then auto-formats the text using another key combination (CTRL-T), then uploads the sketch to the currently selected Arduino using a final key combination (CTRL-U). Circuit: - Arduino Leonardo, Micro, Due, LilyPad USB, or Y\u00fan - wire to connect D2 to ground created 5 Mar 2012 modified 29 Mar 2012 by Tom Igoe modified 3 May 2014 by Scott Fitzgerald This example is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardReprogram */ #include \"Keyboard.h\" // use this option for OSX. // Comment it out if using Windows or Linux: char ctrlKey = KEY_LEFT_GUI; // use this option for Windows and Linux. // leave commented out if using OSX: // char ctrlKey = KEY_LEFT_CTRL; void setup() { // make pin 2 an input and turn on the pull-up resistor so it goes high unless // connected to ground: pinMode(2, INPUT_PULLUP); // initialize control over the keyboard: Keyboard.begin(); } void loop() { while (digitalRead(2) == HIGH) { // do nothing until pin 2 goes low delay(500); } delay(1000); // new document: Keyboard.press(ctrlKey); Keyboard.press('n'); delay(100); Keyboard.releaseAll(); // wait for new window to open: delay(1000); // versions of the Arduino IDE after 1.5 pre-populate new sketches with // setup() and loop() functions let's clear the window before typing anything new // select all Keyboard.press(ctrlKey); Keyboard.press('a'); delay(500); Keyboard.releaseAll(); // delete the selected text Keyboard.write(KEY_BACKSPACE); delay(500); // Type out \"blink\": Keyboard.println(\"void setup() {\"); Keyboard.println(\"pinMode(13, OUTPUT);\"); Keyboard.println(\"}\"); Keyboard.println(); Keyboard.println(\"void loop() {\"); Keyboard.println(\"digitalWrite(13, HIGH);\"); Keyboard.print(\"delay(3000);\"); // 3000 ms is too long. Delete it: for (int keystrokes = 0; keystrokes < 6; keystrokes++) { delay(500); Keyboard.write(KEY_BACKSPACE); } // make it 1000 instead: Keyboard.println(\"1000);\"); Keyboard.println(\"digitalWrite(13, LOW);\"); Keyboard.println(\"delay(1000);\"); Keyboard.println(\"}\"); // tidy up: Keyboard.press(ctrlKey); Keyboard.press('t'); delay(100); Keyboard.releaseAll(); delay(3000); // upload code: Keyboard.press(ctrlKey); Keyboard.press('u'); delay(100); Keyboard.releaseAll(); // wait for the sweet oblivion of reprogramming: while (true) ; }","title":"Sketch Code"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardReprogram/#fritzing-circuit","text":"Same as Example KeyboardLayout","title":"Fritzing Circuit"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardReprogram/#kicad-schematic","text":"Same as Example KeyboardLayout","title":"KiCad Schematic"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardReprogram/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardSerial/","text":"Sketch Code /* Keyboard test For the Arduino Leonardo, Micro or Due Reads a byte from the serial port, sends a keystroke back. The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send A you get B, and so forth. The circuit: - none created 21 Oct 2011 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardSerial */ #include \"Keyboard.h\" void setup() { // open the serial port: Serial.begin(9600); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // check for incoming serial data: if (Serial.available() > 0) { // read incoming serial data: char inChar = Serial.read(); // Type the next ASCII value from what you received: Keyboard.write(inChar + 1); } } Fritzing Circuit N/A KiCad Schematic N/A Video Demonstration","title":"KeyboardSerial"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardSerial/#sketch-code","text":"/* Keyboard test For the Arduino Leonardo, Micro or Due Reads a byte from the serial port, sends a keystroke back. The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send A you get B, and so forth. The circuit: - none created 21 Oct 2011 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardSerial */ #include \"Keyboard.h\" void setup() { // open the serial port: Serial.begin(9600); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // check for incoming serial data: if (Serial.available() > 0) { // read incoming serial data: char inChar = Serial.read(); // Type the next ASCII value from what you received: Keyboard.write(inChar + 1); } }","title":"Sketch Code"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardSerial/#fritzing-circuit","text":"N/A","title":"Fritzing Circuit"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardSerial/#kicad-schematic","text":"N/A","title":"KiCad Schematic"},{"location":"04_builtin_examples/09.USB/Keyboard/KeyboardSerial/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/09.USB/Mouse/ButtonMouseControl/","text":"Sketch Code /* ButtonMouseControl For Leonardo and Due boards only. Controls the mouse from five pushbuttons on an Arduino Leonardo, Micro or Due. Hardware: - five pushbuttons attached to D2, D3, D4, D5, D6 The mouse movement is always relative. This sketch reads four pushbuttons, and uses them to set the movement of the mouse. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the mouse commands. created 15 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ButtonMouseControl */ #include \"Mouse.h\" // set pin numbers for the five buttons: const int upButton = 2; const int downButton = 3; const int leftButton = 4; const int rightButton = 5; const int mouseButton = 6; int range = 5; // output range of X or Y movement; affects movement speed int responseDelay = 10; // response delay of the mouse, in ms void setup() { // initialize the buttons' inputs: pinMode(upButton, INPUT); pinMode(downButton, INPUT); pinMode(leftButton, INPUT); pinMode(rightButton, INPUT); pinMode(mouseButton, INPUT); // initialize mouse control: Mouse.begin(); } void loop() { // read the buttons: int upState = digitalRead(upButton); int downState = digitalRead(downButton); int rightState = digitalRead(rightButton); int leftState = digitalRead(leftButton); int clickState = digitalRead(mouseButton); // calculate the movement distance based on the button states: int xDistance = (leftState - rightState) * range; int yDistance = (upState - downState) * range; // if X or Y is non-zero, move: if ((xDistance != 0) || (yDistance != 0)) { Mouse.move(xDistance, yDistance, 0); } // if the mouse button is pressed: if (clickState == HIGH) { // if the mouse is not pressed, press it: if (!Mouse.isPressed(MOUSE_LEFT)) { Mouse.press(MOUSE_LEFT); } } // else the mouse button is not pressed: else { // if the mouse is pressed, release it: if (Mouse.isPressed(MOUSE_LEFT)) { Mouse.release(MOUSE_LEFT); } } // a delay so the mouse doesn't move too fast: delay(responseDelay); } Fritzing Circuit Same as Example KeyboardAndMouseControl KiCad Schematic Same as Example KeyboardAndMouseControl Video Demonstration","title":"ButtonMouseControl"},{"location":"04_builtin_examples/09.USB/Mouse/ButtonMouseControl/#sketch-code","text":"/* ButtonMouseControl For Leonardo and Due boards only. Controls the mouse from five pushbuttons on an Arduino Leonardo, Micro or Due. Hardware: - five pushbuttons attached to D2, D3, D4, D5, D6 The mouse movement is always relative. This sketch reads four pushbuttons, and uses them to set the movement of the mouse. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the mouse commands. created 15 Mar 2012 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/ButtonMouseControl */ #include \"Mouse.h\" // set pin numbers for the five buttons: const int upButton = 2; const int downButton = 3; const int leftButton = 4; const int rightButton = 5; const int mouseButton = 6; int range = 5; // output range of X or Y movement; affects movement speed int responseDelay = 10; // response delay of the mouse, in ms void setup() { // initialize the buttons' inputs: pinMode(upButton, INPUT); pinMode(downButton, INPUT); pinMode(leftButton, INPUT); pinMode(rightButton, INPUT); pinMode(mouseButton, INPUT); // initialize mouse control: Mouse.begin(); } void loop() { // read the buttons: int upState = digitalRead(upButton); int downState = digitalRead(downButton); int rightState = digitalRead(rightButton); int leftState = digitalRead(leftButton); int clickState = digitalRead(mouseButton); // calculate the movement distance based on the button states: int xDistance = (leftState - rightState) * range; int yDistance = (upState - downState) * range; // if X or Y is non-zero, move: if ((xDistance != 0) || (yDistance != 0)) { Mouse.move(xDistance, yDistance, 0); } // if the mouse button is pressed: if (clickState == HIGH) { // if the mouse is not pressed, press it: if (!Mouse.isPressed(MOUSE_LEFT)) { Mouse.press(MOUSE_LEFT); } } // else the mouse button is not pressed: else { // if the mouse is pressed, release it: if (Mouse.isPressed(MOUSE_LEFT)) { Mouse.release(MOUSE_LEFT); } } // a delay so the mouse doesn't move too fast: delay(responseDelay); }","title":"Sketch Code"},{"location":"04_builtin_examples/09.USB/Mouse/ButtonMouseControl/#fritzing-circuit","text":"Same as Example KeyboardAndMouseControl","title":"Fritzing Circuit"},{"location":"04_builtin_examples/09.USB/Mouse/ButtonMouseControl/#kicad-schematic","text":"Same as Example KeyboardAndMouseControl","title":"KiCad Schematic"},{"location":"04_builtin_examples/09.USB/Mouse/ButtonMouseControl/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/09.USB/Mouse/JoystickMouseControl/","text":"Sketch Code /* JoystickMouseControl Controls the mouse from a joystick on an Arduino Leonardo, Micro or Due. Uses a pushbutton to turn on and off mouse control, and a second pushbutton to click the left mouse button. Hardware: - 2-axis joystick connected to pins A0 and A1 - pushbuttons connected to pin D2 and D3 The mouse movement is always relative. This sketch reads two analog inputs that range from 0 to 1023 (or less on either end) and translates them into ranges of -6 to 6. The sketch assumes that the joystick resting values are around the middle of the range, but that they vary within a threshold. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the command. This sketch includes a pushbutton to toggle the mouse control state, so you can turn on and off mouse control. created 15 Sep 2011 updated 28 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/JoystickMouseControl */ #include \"Mouse.h\" // set pin numbers for switch, joystick axes, and LED: const int switchPin = 2; // switch to turn on and off mouse control const int mouseButton = 3; // input pin for the mouse pushButton const int xAxis = A0; // joystick X axis const int yAxis = A1; // joystick Y axis const int ledPin = 5; // Mouse control LED // parameters for reading the joystick: int range = 12; // output range of X or Y movement int responseDelay = 5; // response delay of the mouse, in ms int threshold = range / 4; // resting threshold int center = range / 2; // resting position value bool mouseIsActive = false; // whether or not to control the mouse int lastSwitchState = LOW; // previous switch state void setup() { pinMode(switchPin, INPUT); // the switch pin pinMode(ledPin, OUTPUT); // the LED pin // take control of the mouse: Mouse.begin(); } void loop() { // read the switch: int switchState = digitalRead(switchPin); // if it's changed and it's high, toggle the mouse state: if (switchState != lastSwitchState) { if (switchState == HIGH) { mouseIsActive = !mouseIsActive; // turn on LED to indicate mouse state: digitalWrite(ledPin, mouseIsActive); } } // save switch state for next comparison: lastSwitchState = switchState; // read and scale the two axes: int xReading = readAxis(A0); int yReading = readAxis(A1); // if the mouse control state is active, move the mouse: if (mouseIsActive) { Mouse.move(xReading, yReading, 0); } // read the mouse button and click or not click: // if the mouse button is pressed: if (digitalRead(mouseButton) == HIGH) { // if the mouse is not pressed, press it: if (!Mouse.isPressed(MOUSE_LEFT)) { Mouse.press(MOUSE_LEFT); } } // else the mouse button is not pressed: else { // if the mouse is pressed, release it: if (Mouse.isPressed(MOUSE_LEFT)) { Mouse.release(MOUSE_LEFT); } } delay(responseDelay); } /* reads an axis (0 or 1 for x or y) and scales the analog input range to a range from 0 to <range> */ int readAxis(int thisAxis) { // read the analog input: int reading = analogRead(thisAxis); // map the reading from the analog input range to the output range: reading = map(reading, 0, 1023, 0, range); // if the output reading is outside from the rest position threshold, use it: int distance = reading - center; if (abs(distance) < threshold) { distance = 0; } // return the distance for this axis: return distance; } Fritzing Circuit KiCad Schematic Video Demonstration","title":"JoystickMouseControl"},{"location":"04_builtin_examples/09.USB/Mouse/JoystickMouseControl/#sketch-code","text":"/* JoystickMouseControl Controls the mouse from a joystick on an Arduino Leonardo, Micro or Due. Uses a pushbutton to turn on and off mouse control, and a second pushbutton to click the left mouse button. Hardware: - 2-axis joystick connected to pins A0 and A1 - pushbuttons connected to pin D2 and D3 The mouse movement is always relative. This sketch reads two analog inputs that range from 0 to 1023 (or less on either end) and translates them into ranges of -6 to 6. The sketch assumes that the joystick resting values are around the middle of the range, but that they vary within a threshold. WARNING: When you use the Mouse.move() command, the Arduino takes over your mouse! Make sure you have control before you use the command. This sketch includes a pushbutton to toggle the mouse control state, so you can turn on and off mouse control. created 15 Sep 2011 updated 28 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/JoystickMouseControl */ #include \"Mouse.h\" // set pin numbers for switch, joystick axes, and LED: const int switchPin = 2; // switch to turn on and off mouse control const int mouseButton = 3; // input pin for the mouse pushButton const int xAxis = A0; // joystick X axis const int yAxis = A1; // joystick Y axis const int ledPin = 5; // Mouse control LED // parameters for reading the joystick: int range = 12; // output range of X or Y movement int responseDelay = 5; // response delay of the mouse, in ms int threshold = range / 4; // resting threshold int center = range / 2; // resting position value bool mouseIsActive = false; // whether or not to control the mouse int lastSwitchState = LOW; // previous switch state void setup() { pinMode(switchPin, INPUT); // the switch pin pinMode(ledPin, OUTPUT); // the LED pin // take control of the mouse: Mouse.begin(); } void loop() { // read the switch: int switchState = digitalRead(switchPin); // if it's changed and it's high, toggle the mouse state: if (switchState != lastSwitchState) { if (switchState == HIGH) { mouseIsActive = !mouseIsActive; // turn on LED to indicate mouse state: digitalWrite(ledPin, mouseIsActive); } } // save switch state for next comparison: lastSwitchState = switchState; // read and scale the two axes: int xReading = readAxis(A0); int yReading = readAxis(A1); // if the mouse control state is active, move the mouse: if (mouseIsActive) { Mouse.move(xReading, yReading, 0); } // read the mouse button and click or not click: // if the mouse button is pressed: if (digitalRead(mouseButton) == HIGH) { // if the mouse is not pressed, press it: if (!Mouse.isPressed(MOUSE_LEFT)) { Mouse.press(MOUSE_LEFT); } } // else the mouse button is not pressed: else { // if the mouse is pressed, release it: if (Mouse.isPressed(MOUSE_LEFT)) { Mouse.release(MOUSE_LEFT); } } delay(responseDelay); } /* reads an axis (0 or 1 for x or y) and scales the analog input range to a range from 0 to <range> */ int readAxis(int thisAxis) { // read the analog input: int reading = analogRead(thisAxis); // map the reading from the analog input range to the output range: reading = map(reading, 0, 1023, 0, range); // if the output reading is outside from the rest position threshold, use it: int distance = reading - center; if (abs(distance) < threshold) { distance = 0; } // return the distance for this axis: return distance; }","title":"Sketch Code"},{"location":"04_builtin_examples/09.USB/Mouse/JoystickMouseControl/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/09.USB/Mouse/JoystickMouseControl/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/09.USB/Mouse/JoystickMouseControl/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p02_SpaceshipInterface/","text":"Sketch Code /* Arduino Starter Kit example Project 2 - Spaceship Interface This sketch is written to accompany Project 2 in the Arduino Starter Kit Parts required: - one green LED - two red LEDs - pushbutton - 10 kilohm resistor - three 220 ohm resistors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/02/29/project-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // Create a global variable to hold the state of the switch. This variable is // persistent throughout the program. Whenever you refer to switchState, you\u2019re // talking about the number it holds int switchstate = 0; void setup() { // declare the LED pins as outputs pinMode(3, OUTPUT); pinMode(4, OUTPUT); pinMode(5, OUTPUT); // declare the switch pin as an input pinMode(2, INPUT); } void loop() { // read the value of the switch // digitalRead() checks to see if there is voltage on the pin or not switchstate = digitalRead(2); // if the button is not pressed turn on the green LED and off the red LEDs if (switchstate == LOW) { digitalWrite(3, HIGH); // turn the green LED on pin 3 on digitalWrite(4, LOW); // turn the red LED on pin 4 off digitalWrite(5, LOW); // turn the red LED on pin 5 off } // this else is part of the above if() statement. // if the switch is not LOW (the button is pressed) turn off the green LED and // blink alternatively the red LEDs else { digitalWrite(3, LOW); // turn the green LED on pin 3 off digitalWrite(4, LOW); // turn the red LED on pin 4 off digitalWrite(5, HIGH); // turn the red LED on pin 5 on // wait for a quarter second before changing the light delay(250); digitalWrite(4, HIGH); // turn the red LED on pin 4 on digitalWrite(5, LOW); // turn the red LED on pin 5 off // wait for a quarter second before changing the light delay(250); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p02 SpaceshipInterface"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p02_SpaceshipInterface/#sketch-code","text":"/* Arduino Starter Kit example Project 2 - Spaceship Interface This sketch is written to accompany Project 2 in the Arduino Starter Kit Parts required: - one green LED - two red LEDs - pushbutton - 10 kilohm resistor - three 220 ohm resistors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/02/29/project-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // Create a global variable to hold the state of the switch. This variable is // persistent throughout the program. Whenever you refer to switchState, you\u2019re // talking about the number it holds int switchstate = 0; void setup() { // declare the LED pins as outputs pinMode(3, OUTPUT); pinMode(4, OUTPUT); pinMode(5, OUTPUT); // declare the switch pin as an input pinMode(2, INPUT); } void loop() { // read the value of the switch // digitalRead() checks to see if there is voltage on the pin or not switchstate = digitalRead(2); // if the button is not pressed turn on the green LED and off the red LEDs if (switchstate == LOW) { digitalWrite(3, HIGH); // turn the green LED on pin 3 on digitalWrite(4, LOW); // turn the red LED on pin 4 off digitalWrite(5, LOW); // turn the red LED on pin 5 off } // this else is part of the above if() statement. // if the switch is not LOW (the button is pressed) turn off the green LED and // blink alternatively the red LEDs else { digitalWrite(3, LOW); // turn the green LED on pin 3 off digitalWrite(4, LOW); // turn the red LED on pin 4 off digitalWrite(5, HIGH); // turn the red LED on pin 5 on // wait for a quarter second before changing the light delay(250); digitalWrite(4, HIGH); // turn the red LED on pin 4 on digitalWrite(5, LOW); // turn the red LED on pin 5 off // wait for a quarter second before changing the light delay(250); } }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p02_SpaceshipInterface/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p02_SpaceshipInterface/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p02_SpaceshipInterface/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p03_LoveOMeter/","text":"Sketch Code /* Arduino Starter Kit example Project 3 - Love-O-Meter This sketch is written to accompany Project 3 in the Arduino Starter Kit Parts required: - one TMP36 temperature sensor - three red LEDs - three 220 ohm resistors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/02/29/projecte-3/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constant for the pin the sensor is connected to const int sensorPin = A0; // room temperature in Celsius const float baselineTemp = 20.0; void setup() { // open a serial connection to display values Serial.begin(9600); // set the LED pins as outputs // the for() loop saves some extra coding for (int pinNumber = 2; pinNumber < 5; pinNumber++) { pinMode(pinNumber, OUTPUT); digitalWrite(pinNumber, LOW); } } void loop() { // read the value on AnalogIn pin 0 and store it in a variable int sensorVal = analogRead(sensorPin); // send the 10-bit sensor value out the serial port Serial.print(\"sensor Value: \"); Serial.print(sensorVal); // convert the ADC reading to voltage float voltage = (sensorVal / 1024.0) * 5.0; // Send the voltage level out the Serial port Serial.print(\", Volts: \"); Serial.print(voltage); // convert the voltage to temperature in degrees C // the sensor changes 10 mV per degree // the datasheet says there's a 500 mV offset // ((voltage - 500 mV) times 100) Serial.print(\", degrees C: \"); float temperature = (voltage - .5) * 100; Serial.println(temperature); // if the current temperature is lower than the baseline turn off all LEDs if (temperature < baselineTemp + 2) { digitalWrite(2, LOW); digitalWrite(3, LOW); digitalWrite(4, LOW); } // if the temperature rises 2-4 degrees, turn an LED on else if (temperature >= baselineTemp + 2 && temperature < baselineTemp + 4) { digitalWrite(2, HIGH); digitalWrite(3, LOW); digitalWrite(4, LOW); } // if the temperature rises 4-6 degrees, turn a second LED on else if (temperature >= baselineTemp + 4 && temperature < baselineTemp + 6) { digitalWrite(2, HIGH); digitalWrite(3, HIGH); digitalWrite(4, LOW); } // if the temperature rises more than 6 degrees, turn all LEDs on else if (temperature >= baselineTemp + 6) { digitalWrite(2, HIGH); digitalWrite(3, HIGH); digitalWrite(4, HIGH); } delay(1); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p03 LoveOMeter"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p03_LoveOMeter/#sketch-code","text":"/* Arduino Starter Kit example Project 3 - Love-O-Meter This sketch is written to accompany Project 3 in the Arduino Starter Kit Parts required: - one TMP36 temperature sensor - three red LEDs - three 220 ohm resistors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/02/29/projecte-3/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constant for the pin the sensor is connected to const int sensorPin = A0; // room temperature in Celsius const float baselineTemp = 20.0; void setup() { // open a serial connection to display values Serial.begin(9600); // set the LED pins as outputs // the for() loop saves some extra coding for (int pinNumber = 2; pinNumber < 5; pinNumber++) { pinMode(pinNumber, OUTPUT); digitalWrite(pinNumber, LOW); } } void loop() { // read the value on AnalogIn pin 0 and store it in a variable int sensorVal = analogRead(sensorPin); // send the 10-bit sensor value out the serial port Serial.print(\"sensor Value: \"); Serial.print(sensorVal); // convert the ADC reading to voltage float voltage = (sensorVal / 1024.0) * 5.0; // Send the voltage level out the Serial port Serial.print(\", Volts: \"); Serial.print(voltage); // convert the voltage to temperature in degrees C // the sensor changes 10 mV per degree // the datasheet says there's a 500 mV offset // ((voltage - 500 mV) times 100) Serial.print(\", degrees C: \"); float temperature = (voltage - .5) * 100; Serial.println(temperature); // if the current temperature is lower than the baseline turn off all LEDs if (temperature < baselineTemp + 2) { digitalWrite(2, LOW); digitalWrite(3, LOW); digitalWrite(4, LOW); } // if the temperature rises 2-4 degrees, turn an LED on else if (temperature >= baselineTemp + 2 && temperature < baselineTemp + 4) { digitalWrite(2, HIGH); digitalWrite(3, LOW); digitalWrite(4, LOW); } // if the temperature rises 4-6 degrees, turn a second LED on else if (temperature >= baselineTemp + 4 && temperature < baselineTemp + 6) { digitalWrite(2, HIGH); digitalWrite(3, HIGH); digitalWrite(4, LOW); } // if the temperature rises more than 6 degrees, turn all LEDs on else if (temperature >= baselineTemp + 6) { digitalWrite(2, HIGH); digitalWrite(3, HIGH); digitalWrite(4, HIGH); } delay(1); }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p03_LoveOMeter/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p03_LoveOMeter/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p03_LoveOMeter/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p04_ColorMixingLamp/","text":"Sketch Code /* Arduino Starter Kit example Project 4 - Color Mixing Lamp This sketch is written to accompany Project 3 in the Arduino Starter Kit Parts required: - one RGB LED - three 10 kilohm resistors - three 220 ohm resistors - three photoresistors - red green and blue colored gels created 13 Sep 2012 modified 14 Nov 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/01/project-04/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int greenLEDPin = 9; // LED connected to digital pin 9 const int redLEDPin = 10; // LED connected to digital pin 10 const int blueLEDPin = 11; // LED connected to digital pin 11 const int redSensorPin = A0; // pin with the photoresistor with the red gel const int greenSensorPin = A1; // pin with the photoresistor with the green gel const int blueSensorPin = A2; // pin with the photoresistor with the blue gel int redValue = 0; // value to write to the red LED int greenValue = 0; // value to write to the green LED int blueValue = 0; // value to write to the blue LED int redSensorValue = 0; // variable to hold the value from the red sensor int greenSensorValue = 0; // variable to hold the value from the green sensor int blueSensorValue = 0; // variable to hold the value from the blue sensor void setup() { // initialize serial communications at 9600 bps: Serial.begin(9600); // set the digital pins as outputs pinMode(greenLEDPin, OUTPUT); pinMode(redLEDPin, OUTPUT); pinMode(blueLEDPin, OUTPUT); } void loop() { // Read the sensors first: // read the value from the red-filtered photoresistor: redSensorValue = analogRead(redSensorPin); // give the ADC a moment to settle delay(5); // read the value from the green-filtered photoresistor: greenSensorValue = analogRead(greenSensorPin); // give the ADC a moment to settle delay(5); // read the value from the blue-filtered photoresistor: blueSensorValue = analogRead(blueSensorPin); // print out the values to the Serial Monitor Serial.print(\"raw sensor Values \\t red: \"); Serial.print(redSensorValue); Serial.print(\"\\t green: \"); Serial.print(greenSensorValue); Serial.print(\"\\t Blue: \"); Serial.println(blueSensorValue); /* In order to use the values from the sensor for the LED, you need to do some math. The ADC provides a 10-bit number, but analogWrite() uses 8 bits. You'll want to divide your sensor readings by 4 to keep them in range of the output. */ redValue = redSensorValue / 4; greenValue = greenSensorValue / 4; blueValue = blueSensorValue / 4; // print out the mapped values Serial.print(\"Mapped sensor Values \\t red: \"); Serial.print(redValue); Serial.print(\"\\t green: \"); Serial.print(greenValue); Serial.print(\"\\t Blue: \"); Serial.println(blueValue); /* Now that you have a usable value, it's time to PWM the LED. */ analogWrite(redLEDPin, redValue); analogWrite(greenLEDPin, greenValue); analogWrite(blueLEDPin, blueValue); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p04 ColorMixingLamp"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p04_ColorMixingLamp/#sketch-code","text":"/* Arduino Starter Kit example Project 4 - Color Mixing Lamp This sketch is written to accompany Project 3 in the Arduino Starter Kit Parts required: - one RGB LED - three 10 kilohm resistors - three 220 ohm resistors - three photoresistors - red green and blue colored gels created 13 Sep 2012 modified 14 Nov 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/01/project-04/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int greenLEDPin = 9; // LED connected to digital pin 9 const int redLEDPin = 10; // LED connected to digital pin 10 const int blueLEDPin = 11; // LED connected to digital pin 11 const int redSensorPin = A0; // pin with the photoresistor with the red gel const int greenSensorPin = A1; // pin with the photoresistor with the green gel const int blueSensorPin = A2; // pin with the photoresistor with the blue gel int redValue = 0; // value to write to the red LED int greenValue = 0; // value to write to the green LED int blueValue = 0; // value to write to the blue LED int redSensorValue = 0; // variable to hold the value from the red sensor int greenSensorValue = 0; // variable to hold the value from the green sensor int blueSensorValue = 0; // variable to hold the value from the blue sensor void setup() { // initialize serial communications at 9600 bps: Serial.begin(9600); // set the digital pins as outputs pinMode(greenLEDPin, OUTPUT); pinMode(redLEDPin, OUTPUT); pinMode(blueLEDPin, OUTPUT); } void loop() { // Read the sensors first: // read the value from the red-filtered photoresistor: redSensorValue = analogRead(redSensorPin); // give the ADC a moment to settle delay(5); // read the value from the green-filtered photoresistor: greenSensorValue = analogRead(greenSensorPin); // give the ADC a moment to settle delay(5); // read the value from the blue-filtered photoresistor: blueSensorValue = analogRead(blueSensorPin); // print out the values to the Serial Monitor Serial.print(\"raw sensor Values \\t red: \"); Serial.print(redSensorValue); Serial.print(\"\\t green: \"); Serial.print(greenSensorValue); Serial.print(\"\\t Blue: \"); Serial.println(blueSensorValue); /* In order to use the values from the sensor for the LED, you need to do some math. The ADC provides a 10-bit number, but analogWrite() uses 8 bits. You'll want to divide your sensor readings by 4 to keep them in range of the output. */ redValue = redSensorValue / 4; greenValue = greenSensorValue / 4; blueValue = blueSensorValue / 4; // print out the mapped values Serial.print(\"Mapped sensor Values \\t red: \"); Serial.print(redValue); Serial.print(\"\\t green: \"); Serial.print(greenValue); Serial.print(\"\\t Blue: \"); Serial.println(blueValue); /* Now that you have a usable value, it's time to PWM the LED. */ analogWrite(redLEDPin, redValue); analogWrite(greenLEDPin, greenValue); analogWrite(blueLEDPin, blueValue); }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p04_ColorMixingLamp/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p04_ColorMixingLamp/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p04_ColorMixingLamp/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p05_ServoMoodIndicator/","text":"Sketch Code /* Arduino Starter Kit example Project 5 - Servo Mood Indicator This sketch is written to accompany Project 5 in the Arduino Starter Kit Parts required: - servo motor - 10 kilohm potentiometer - two 100 uF electrolytic capacitors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/01/project-05/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // include the Servo library #include <Servo.h> Servo myServo; // create a servo object int const potPin = A0; // analog pin used to connect the potentiometer int potVal; // variable to read the value from the analog pin int angle; // variable to hold the angle for the servo motor void setup() { myServo.attach(9); // attaches the servo on pin 9 to the servo object Serial.begin(9600); // open a serial connection to your computer } void loop() { potVal = analogRead(potPin); // read the value of the potentiometer // print out the value to the Serial Monitor Serial.print(\"potVal: \"); Serial.print(potVal); // scale the numbers from the pot angle = map(potVal, 0, 1023, 0, 179); // print out the angle for the servo motor Serial.print(\", angle: \"); Serial.println(angle); // set the servo position myServo.write(angle); // wait for the servo to get there delay(15); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p05 ServoMoodIndicator"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p05_ServoMoodIndicator/#sketch-code","text":"/* Arduino Starter Kit example Project 5 - Servo Mood Indicator This sketch is written to accompany Project 5 in the Arduino Starter Kit Parts required: - servo motor - 10 kilohm potentiometer - two 100 uF electrolytic capacitors created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/01/project-05/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // include the Servo library #include <Servo.h> Servo myServo; // create a servo object int const potPin = A0; // analog pin used to connect the potentiometer int potVal; // variable to read the value from the analog pin int angle; // variable to hold the angle for the servo motor void setup() { myServo.attach(9); // attaches the servo on pin 9 to the servo object Serial.begin(9600); // open a serial connection to your computer } void loop() { potVal = analogRead(potPin); // read the value of the potentiometer // print out the value to the Serial Monitor Serial.print(\"potVal: \"); Serial.print(potVal); // scale the numbers from the pot angle = map(potVal, 0, 1023, 0, 179); // print out the angle for the servo motor Serial.print(\", angle: \"); Serial.println(angle); // set the servo position myServo.write(angle); // wait for the servo to get there delay(15); }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p05_ServoMoodIndicator/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p05_ServoMoodIndicator/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p05_ServoMoodIndicator/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p06_LightTheremin/","text":"Sketch Code /* Arduino Starter Kit example Project 6 - Light Theremin This sketch is written to accompany Project 6 in the Arduino Starter Kit Parts required: - photoresistor - 10 kilohm resistor - piezo created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/02/project-06/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // variable to hold sensor value int sensorValue; // variable to calibrate low value int sensorLow = 1023; // variable to calibrate high value int sensorHigh = 0; // LED pin const int ledPin = 13; void setup() { // Make the LED pin an output and turn it on pinMode(ledPin, OUTPUT); digitalWrite(ledPin, HIGH); // calibrate for the first five seconds after program runs while (millis() < 5000) { // record the maximum sensor value sensorValue = analogRead(A0); if (sensorValue > sensorHigh) { sensorHigh = sensorValue; } // record the minimum sensor value if (sensorValue < sensorLow) { sensorLow = sensorValue; } } // turn the LED off, signaling the end of the calibration period digitalWrite(ledPin, LOW); } void loop() { //read the input from A0 and store it in a variable sensorValue = analogRead(A0); // map the sensor values to a wide range of pitches int pitch = map(sensorValue, sensorLow, sensorHigh, 50, 4000); // play the tone for 20 ms on pin 8 tone(8, pitch, 20); // wait for a moment delay(10); } Fritzing Circuit Similar to Example tonePitchFollower , but use pin 8 instead of pin 9 . KiCad Schematic Similar to Example tonePitchFollower , but use pin 8 instead of pin 9 . Video Demonstration","title":"p06 LightTheremin"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p06_LightTheremin/#sketch-code","text":"/* Arduino Starter Kit example Project 6 - Light Theremin This sketch is written to accompany Project 6 in the Arduino Starter Kit Parts required: - photoresistor - 10 kilohm resistor - piezo created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/02/project-06/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // variable to hold sensor value int sensorValue; // variable to calibrate low value int sensorLow = 1023; // variable to calibrate high value int sensorHigh = 0; // LED pin const int ledPin = 13; void setup() { // Make the LED pin an output and turn it on pinMode(ledPin, OUTPUT); digitalWrite(ledPin, HIGH); // calibrate for the first five seconds after program runs while (millis() < 5000) { // record the maximum sensor value sensorValue = analogRead(A0); if (sensorValue > sensorHigh) { sensorHigh = sensorValue; } // record the minimum sensor value if (sensorValue < sensorLow) { sensorLow = sensorValue; } } // turn the LED off, signaling the end of the calibration period digitalWrite(ledPin, LOW); } void loop() { //read the input from A0 and store it in a variable sensorValue = analogRead(A0); // map the sensor values to a wide range of pitches int pitch = map(sensorValue, sensorLow, sensorHigh, 50, 4000); // play the tone for 20 ms on pin 8 tone(8, pitch, 20); // wait for a moment delay(10); }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p06_LightTheremin/#fritzing-circuit","text":"Similar to Example tonePitchFollower , but use pin 8 instead of pin 9 .","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p06_LightTheremin/#kicad-schematic","text":"Similar to Example tonePitchFollower , but use pin 8 instead of pin 9 .","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p06_LightTheremin/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p07_Keyboard/","text":"Sketch Code /* Arduino Starter Kit example Project 7 - Keyboard This sketch is written to accompany Project 7 in the Arduino Starter Kit Parts required: - two 10 kilohm resistors - 1 megohm resistor - 220 ohm resistor - four pushbuttons - piezo created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/02/project-07/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // create an array of notes // the numbers below correspond to the frequencies of middle C, D, E, and F int notes[] = { 262, 294, 330, 349 }; void setup() { //start serial communication Serial.begin(9600); } void loop() { // create a local variable to hold the input on pin A0 int keyVal = analogRead(A0); // send the value from A0 to the Serial Monitor Serial.println(keyVal); // play the note corresponding to each value on A0 if (keyVal == 1023) { // play the first frequency in the array on pin 8 tone(8, notes[0]); } else if (keyVal >= 990 && keyVal <= 1010) { // play the second frequency in the array on pin 8 tone(8, notes[1]); } else if (keyVal >= 505 && keyVal <= 515) { // play the third frequency in the array on pin 8 tone(8, notes[2]); } else if (keyVal >= 5 && keyVal <= 10) { // play the fourth frequency in the array on pin 8 tone(8, notes[3]); } else { // if the value is out of range, play no tone noTone(8); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p07 Keyboard"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p07_Keyboard/#sketch-code","text":"/* Arduino Starter Kit example Project 7 - Keyboard This sketch is written to accompany Project 7 in the Arduino Starter Kit Parts required: - two 10 kilohm resistors - 1 megohm resistor - 220 ohm resistor - four pushbuttons - piezo created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/02/project-07/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // create an array of notes // the numbers below correspond to the frequencies of middle C, D, E, and F int notes[] = { 262, 294, 330, 349 }; void setup() { //start serial communication Serial.begin(9600); } void loop() { // create a local variable to hold the input on pin A0 int keyVal = analogRead(A0); // send the value from A0 to the Serial Monitor Serial.println(keyVal); // play the note corresponding to each value on A0 if (keyVal == 1023) { // play the first frequency in the array on pin 8 tone(8, notes[0]); } else if (keyVal >= 990 && keyVal <= 1010) { // play the second frequency in the array on pin 8 tone(8, notes[1]); } else if (keyVal >= 505 && keyVal <= 515) { // play the third frequency in the array on pin 8 tone(8, notes[2]); } else if (keyVal >= 5 && keyVal <= 10) { // play the fourth frequency in the array on pin 8 tone(8, notes[3]); } else { // if the value is out of range, play no tone noTone(8); } }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p07_Keyboard/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p07_Keyboard/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p07_Keyboard/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p08_DigitalHourglass/","text":"Sketch Code /* Arduino Starter Kit example Project 8 - Digital Hourglass This sketch is written to accompany Project 8 in the Arduino Starter Kit Parts required: - 10 kilohm resistor - six 220 ohm resistors - six LEDs - tilt switch created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/03/project-08-digital-hourglass/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constant for the switch pin const int switchPin = 8; unsigned long previousTime = 0; // store the last time an LED was updated int switchState = 0; // the current switch state int prevSwitchState = 0; // the previous switch state int led = 2; // a variable to refer to the LEDs // 600000 = 10 minutes in milliseconds long interval = 600000; // interval at which to light the next LED void setup() { // set the LED pins as outputs for (int x = 2; x < 8; x++) { pinMode(x, OUTPUT); } // set the tilt switch pin as input pinMode(switchPin, INPUT); } void loop() { // store the time since the Arduino started running in a variable unsigned long currentTime = millis(); // compare the current time to the previous time an LED turned on // if it is greater than your interval, run the if statement if (currentTime - previousTime > interval) { // save the current time as the last time you changed an LED previousTime = currentTime; // Turn the LED on digitalWrite(led, HIGH); // increment the led variable // in 10 minutes the next LED will light up led++; if (led == 7) { // the hour is up } } // read the switch value switchState = digitalRead(switchPin); // if the switch has changed if (switchState != prevSwitchState) { // turn all the LEDs low for (int x = 2; x < 8; x++) { digitalWrite(x, LOW); } // reset the LED variable to the first one led = 2; //reset the timer previousTime = currentTime; } // set the previous switch state to the current state prevSwitchState = switchState; } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p08 DigitalHourglass"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p08_DigitalHourglass/#sketch-code","text":"/* Arduino Starter Kit example Project 8 - Digital Hourglass This sketch is written to accompany Project 8 in the Arduino Starter Kit Parts required: - 10 kilohm resistor - six 220 ohm resistors - six LEDs - tilt switch created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/03/project-08-digital-hourglass/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constant for the switch pin const int switchPin = 8; unsigned long previousTime = 0; // store the last time an LED was updated int switchState = 0; // the current switch state int prevSwitchState = 0; // the previous switch state int led = 2; // a variable to refer to the LEDs // 600000 = 10 minutes in milliseconds long interval = 600000; // interval at which to light the next LED void setup() { // set the LED pins as outputs for (int x = 2; x < 8; x++) { pinMode(x, OUTPUT); } // set the tilt switch pin as input pinMode(switchPin, INPUT); } void loop() { // store the time since the Arduino started running in a variable unsigned long currentTime = millis(); // compare the current time to the previous time an LED turned on // if it is greater than your interval, run the if statement if (currentTime - previousTime > interval) { // save the current time as the last time you changed an LED previousTime = currentTime; // Turn the LED on digitalWrite(led, HIGH); // increment the led variable // in 10 minutes the next LED will light up led++; if (led == 7) { // the hour is up } } // read the switch value switchState = digitalRead(switchPin); // if the switch has changed if (switchState != prevSwitchState) { // turn all the LEDs low for (int x = 2; x < 8; x++) { digitalWrite(x, LOW); } // reset the LED variable to the first one led = 2; //reset the timer previousTime = currentTime; } // set the previous switch state to the current state prevSwitchState = switchState; }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p08_DigitalHourglass/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p08_DigitalHourglass/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p08_DigitalHourglass/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p09_MotorizedPinwheel/","text":"Sketch Code /* Arduino Starter Kit example Project 9 - Motorized Pinwheel This sketch is written to accompany Project 9 in the Arduino Starter Kit Parts required: - 10 kilohm resistor - pushbutton - motor - 9V battery - IRF520 MOSFET - 1N4007 diode created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/04/project-10-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constants for the switch and motor pins const int switchPin = 2; // the number of the switch pin const int motorPin = 9; // the number of the motor pin int switchState = 0; // variable for reading the switch's status void setup() { // initialize the motor pin as an output: pinMode(motorPin, OUTPUT); // initialize the switch pin as an input: pinMode(switchPin, INPUT); } void loop() { // read the state of the switch value: switchState = digitalRead(switchPin); // check if the switch is pressed. if (switchState == HIGH) { // turn motor on: digitalWrite(motorPin, HIGH); } else { // turn motor off: digitalWrite(motorPin, LOW); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p09 MotorizedPinwheel"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p09_MotorizedPinwheel/#sketch-code","text":"/* Arduino Starter Kit example Project 9 - Motorized Pinwheel This sketch is written to accompany Project 9 in the Arduino Starter Kit Parts required: - 10 kilohm resistor - pushbutton - motor - 9V battery - IRF520 MOSFET - 1N4007 diode created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/04/project-10-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // named constants for the switch and motor pins const int switchPin = 2; // the number of the switch pin const int motorPin = 9; // the number of the motor pin int switchState = 0; // variable for reading the switch's status void setup() { // initialize the motor pin as an output: pinMode(motorPin, OUTPUT); // initialize the switch pin as an input: pinMode(switchPin, INPUT); } void loop() { // read the state of the switch value: switchState = digitalRead(switchPin); // check if the switch is pressed. if (switchState == HIGH) { // turn motor on: digitalWrite(motorPin, HIGH); } else { // turn motor off: digitalWrite(motorPin, LOW); } }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p09_MotorizedPinwheel/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p09_MotorizedPinwheel/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p09_MotorizedPinwheel/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p10_Zoetrope/","text":"Description This examples deals with H-bridge using the integrated circuit SN754410 . Some external references are recommended to read: DC Motor Control Using an H-Bridge El puente H: Invirtiendo el sentido de giro de un motor con Arduino in Spanish Sketch Code /* Arduino Starter Kit example Project 10 - Zoetrope This sketch is written to accompany Project 10 in the Arduino Starter Kit Parts required: - two 10 kilohm resistors - two momentary pushbuttons - one 10 kilohm potentiometer - motor - 9V battery - H-Bridge created 13 Sep 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/05/project-11/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int controlPin1 = 2; // connected to pin 7 on the H-bridge const int controlPin2 = 3; // connected to pin 2 on the H-bridge const int enablePin = 9; // connected to pin 1 on the H-bridge const int directionSwitchPin = 4; // connected to the switch for direction const int onOffSwitchStateSwitchPin = 5; // connected to the switch for turning the motor on and off const int potPin = A0; // connected to the potentiometer's output // create some variables to hold values from your inputs int onOffSwitchState = 0; // current state of the on/off switch int previousOnOffSwitchState = 0; // previous position of the on/off switch int directionSwitchState = 0; // current state of the direction switch int previousDirectionSwitchState = 0; // previous state of the direction switch int motorEnabled = 0; // Turns the motor on/off int motorSpeed = 0; // speed of the motor int motorDirection = 1; // current direction of the motor void setup() { // initialize the inputs and outputs pinMode(directionSwitchPin, INPUT); pinMode(onOffSwitchStateSwitchPin, INPUT); pinMode(controlPin1, OUTPUT); pinMode(controlPin2, OUTPUT); pinMode(enablePin, OUTPUT); // pull the enable pin LOW to start digitalWrite(enablePin, LOW); } void loop() { // read the value of the on/off switch onOffSwitchState = digitalRead(onOffSwitchStateSwitchPin); delay(1); // read the value of the direction switch directionSwitchState = digitalRead(directionSwitchPin); // read the value of the pot and divide by 4 to get a value that can be // used for PWM motorSpeed = analogRead(potPin) / 4; // if the on/off button changed state since the last loop() if (onOffSwitchState != previousOnOffSwitchState) { // change the value of motorEnabled if pressed if (onOffSwitchState == HIGH) { motorEnabled = !motorEnabled; } } // if the direction button changed state since the last loop() if (directionSwitchState != previousDirectionSwitchState) { // change the value of motorDirection if pressed if (directionSwitchState == HIGH) { motorDirection = !motorDirection; } } // change the direction the motor spins by talking to the control pins // on the H-Bridge if (motorDirection == 1) { digitalWrite(controlPin1, HIGH); digitalWrite(controlPin2, LOW); } else { digitalWrite(controlPin1, LOW); digitalWrite(controlPin2, HIGH); } // if the motor is supposed to be on if (motorEnabled == 1) { // PWM the enable pin to vary the speed analogWrite(enablePin, motorSpeed); } else { // if the motor is not supposed to be on //turn the motor off analogWrite(enablePin, 0); } // save the current on/off switch state as the previous previousDirectionSwitchState = directionSwitchState; // save the current switch state as the previous previousOnOffSwitchState = onOffSwitchState; } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p10 Zoetrope"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p10_Zoetrope/#description","text":"This examples deals with H-bridge using the integrated circuit SN754410 . Some external references are recommended to read: DC Motor Control Using an H-Bridge El puente H: Invirtiendo el sentido de giro de un motor con Arduino in Spanish","title":"Description"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p10_Zoetrope/#sketch-code","text":"/* Arduino Starter Kit example Project 10 - Zoetrope This sketch is written to accompany Project 10 in the Arduino Starter Kit Parts required: - two 10 kilohm resistors - two momentary pushbuttons - one 10 kilohm potentiometer - motor - 9V battery - H-Bridge created 13 Sep 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/05/project-11/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int controlPin1 = 2; // connected to pin 7 on the H-bridge const int controlPin2 = 3; // connected to pin 2 on the H-bridge const int enablePin = 9; // connected to pin 1 on the H-bridge const int directionSwitchPin = 4; // connected to the switch for direction const int onOffSwitchStateSwitchPin = 5; // connected to the switch for turning the motor on and off const int potPin = A0; // connected to the potentiometer's output // create some variables to hold values from your inputs int onOffSwitchState = 0; // current state of the on/off switch int previousOnOffSwitchState = 0; // previous position of the on/off switch int directionSwitchState = 0; // current state of the direction switch int previousDirectionSwitchState = 0; // previous state of the direction switch int motorEnabled = 0; // Turns the motor on/off int motorSpeed = 0; // speed of the motor int motorDirection = 1; // current direction of the motor void setup() { // initialize the inputs and outputs pinMode(directionSwitchPin, INPUT); pinMode(onOffSwitchStateSwitchPin, INPUT); pinMode(controlPin1, OUTPUT); pinMode(controlPin2, OUTPUT); pinMode(enablePin, OUTPUT); // pull the enable pin LOW to start digitalWrite(enablePin, LOW); } void loop() { // read the value of the on/off switch onOffSwitchState = digitalRead(onOffSwitchStateSwitchPin); delay(1); // read the value of the direction switch directionSwitchState = digitalRead(directionSwitchPin); // read the value of the pot and divide by 4 to get a value that can be // used for PWM motorSpeed = analogRead(potPin) / 4; // if the on/off button changed state since the last loop() if (onOffSwitchState != previousOnOffSwitchState) { // change the value of motorEnabled if pressed if (onOffSwitchState == HIGH) { motorEnabled = !motorEnabled; } } // if the direction button changed state since the last loop() if (directionSwitchState != previousDirectionSwitchState) { // change the value of motorDirection if pressed if (directionSwitchState == HIGH) { motorDirection = !motorDirection; } } // change the direction the motor spins by talking to the control pins // on the H-Bridge if (motorDirection == 1) { digitalWrite(controlPin1, HIGH); digitalWrite(controlPin2, LOW); } else { digitalWrite(controlPin1, LOW); digitalWrite(controlPin2, HIGH); } // if the motor is supposed to be on if (motorEnabled == 1) { // PWM the enable pin to vary the speed analogWrite(enablePin, motorSpeed); } else { // if the motor is not supposed to be on //turn the motor off analogWrite(enablePin, 0); } // save the current on/off switch state as the previous previousDirectionSwitchState = directionSwitchState; // save the current switch state as the previous previousOnOffSwitchState = onOffSwitchState; }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p10_Zoetrope/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p10_Zoetrope/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p10_Zoetrope/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p11_CrystalBall/","text":"Sketch Code /* Arduino Starter Kit example Project 11 - Crystal Ball This sketch is written to accompany Project 11 in the Arduino Starter Kit Parts required: - 220 ohm resistor - 10 kilohm resistor - 10 kilohm potentiometer - 16x2 LCD screen - tilt switch created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/05/project-12/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // include the library code: #include <LiquidCrystal.h> // initialize the library with the numbers of the interface pins LiquidCrystal lcd(12, 11, 5, 4, 3, 2); // set up a constant for the tilt switch pin const int switchPin = 6; // variable to hold the value of the switch pin int switchState = 0; // variable to hold previous value of the switch pin int prevSwitchState = 0; // a variable to choose which reply from the crystal ball int reply; void setup() { // set up the number of columns and rows on the LCD lcd.begin(16, 2); // set up the switch pin as an input pinMode(switchPin, INPUT); // Print a message to the LCD. lcd.print(\"Ask the\"); // set the cursor to column 0, line 1 // line 1 is the second row, since counting begins with 0 lcd.setCursor(0, 1); // print to the second line lcd.print(\"Crystal Ball!\"); } void loop() { // check the status of the switch switchState = digitalRead(switchPin); // compare the switchState to its previous state if (switchState != prevSwitchState) { // if the state has changed from HIGH to LOW you know that the ball has been // tilted from one direction to the other if (switchState == LOW) { // randomly chose a reply reply = random(8); // clean up the screen before printing a new reply lcd.clear(); // set the cursor to column 0, line 0 lcd.setCursor(0, 0); // print some text lcd.print(\"the ball says:\"); // move the cursor to the second line lcd.setCursor(0, 1); // choose a saying to print based on the value in reply switch (reply) { case 0: lcd.print(\"Yes\"); break; case 1: lcd.print(\"Most likely\"); break; case 2: lcd.print(\"Certainly\"); break; case 3: lcd.print(\"Outlook good\"); break; case 4: lcd.print(\"Unsure\"); break; case 5: lcd.print(\"Ask again\"); break; case 6: lcd.print(\"Doubtful\"); break; case 7: lcd.print(\"No\"); break; } } } // save the current switch state as the last state prevSwitchState = switchState; } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p11 CrystalBall"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p11_CrystalBall/#sketch-code","text":"/* Arduino Starter Kit example Project 11 - Crystal Ball This sketch is written to accompany Project 11 in the Arduino Starter Kit Parts required: - 220 ohm resistor - 10 kilohm resistor - 10 kilohm potentiometer - 16x2 LCD screen - tilt switch created 13 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/05/project-12/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // include the library code: #include <LiquidCrystal.h> // initialize the library with the numbers of the interface pins LiquidCrystal lcd(12, 11, 5, 4, 3, 2); // set up a constant for the tilt switch pin const int switchPin = 6; // variable to hold the value of the switch pin int switchState = 0; // variable to hold previous value of the switch pin int prevSwitchState = 0; // a variable to choose which reply from the crystal ball int reply; void setup() { // set up the number of columns and rows on the LCD lcd.begin(16, 2); // set up the switch pin as an input pinMode(switchPin, INPUT); // Print a message to the LCD. lcd.print(\"Ask the\"); // set the cursor to column 0, line 1 // line 1 is the second row, since counting begins with 0 lcd.setCursor(0, 1); // print to the second line lcd.print(\"Crystal Ball!\"); } void loop() { // check the status of the switch switchState = digitalRead(switchPin); // compare the switchState to its previous state if (switchState != prevSwitchState) { // if the state has changed from HIGH to LOW you know that the ball has been // tilted from one direction to the other if (switchState == LOW) { // randomly chose a reply reply = random(8); // clean up the screen before printing a new reply lcd.clear(); // set the cursor to column 0, line 0 lcd.setCursor(0, 0); // print some text lcd.print(\"the ball says:\"); // move the cursor to the second line lcd.setCursor(0, 1); // choose a saying to print based on the value in reply switch (reply) { case 0: lcd.print(\"Yes\"); break; case 1: lcd.print(\"Most likely\"); break; case 2: lcd.print(\"Certainly\"); break; case 3: lcd.print(\"Outlook good\"); break; case 4: lcd.print(\"Unsure\"); break; case 5: lcd.print(\"Ask again\"); break; case 6: lcd.print(\"Doubtful\"); break; case 7: lcd.print(\"No\"); break; } } } // save the current switch state as the last state prevSwitchState = switchState; }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p11_CrystalBall/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p11_CrystalBall/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p11_CrystalBall/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p12_KnockLock/","text":"Sketch Code /* Arduino Starter Kit example Project 12 - Knock Lock This sketch is written to accompany Project 12 in the Arduino Starter Kit Parts required: - 1 megohm resistor - 10 kilohm resistor - three 220 ohm resistors - piezo - servo motor - push button - one red LED - one yellow LED - one green LED - 100 uF capacitor created 18 Sep 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/06/project-13/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // import the library #include <Servo.h> // create an instance of the Servo library Servo myServo; const int piezo = A0; // pin the piezo is attached to const int switchPin = 2; // pin the switch is attached to const int yellowLed = 3; // pin the yellow LED is attached to const int greenLed = 4; // pin the green LED is attached to const int redLed = 5; // pin the red LED is attached to // variable for the piezo value int knockVal; // variable for the switch value int switchVal; // variables for the high and low limits of the knock value const int quietKnock = 10; const int loudKnock = 100; // variable to indicate if locked or not bool locked = false; // how many valid knocks you've received int numberOfKnocks = 0; void setup() { // attach the servo to pin 9 myServo.attach(9); // make the LED pins outputs pinMode(yellowLed, OUTPUT); pinMode(redLed, OUTPUT); pinMode(greenLed, OUTPUT); // set the switch pin as an input pinMode(switchPin, INPUT); // start serial communication for debugging Serial.begin(9600); // turn the green LED on digitalWrite(greenLed, HIGH); // move the servo to the unlocked position myServo.write(0); // print status to the Serial Monitor Serial.println(\"the box is unlocked!\"); } void loop() { // if the box is unlocked if (locked == false) { // read the value of the switch pin switchVal = digitalRead(switchPin); // if the button is pressed, lock the box if (switchVal == HIGH) { // set the locked variable to \"true\" locked = true; // change the status LEDs digitalWrite(greenLed, LOW); digitalWrite(redLed, HIGH); // move the servo to the locked position myServo.write(90); // print out status Serial.println(\"the box is locked!\"); // wait for the servo to move into position delay(1000); } } // if the box is locked if (locked == true) { // check the value of the piezo knockVal = analogRead(piezo); // if there are not enough valid knocks if (numberOfKnocks < 3 && knockVal > 0) { // check to see if the knock is in range if (checkForKnock(knockVal) == true) { // increment the number of valid knocks numberOfKnocks++; } // print status of knocks Serial.print(3 - numberOfKnocks); Serial.println(\" more knocks to go\"); } // if there are three knocks if (numberOfKnocks >= 3) { // unlock the box locked = false; // move the servo to the unlocked position myServo.write(0); // wait for it to move delay(20); // change status LEDs digitalWrite(greenLed, HIGH); digitalWrite(redLed, LOW); Serial.println(\"the box is unlocked!\"); numberOfKnocks = 0; } } } // this function checks to see if a detected knock is within max and min range bool checkForKnock(int value) { // if the value of the knock is greater than the minimum, and larger // than the maximum if (value > quietKnock && value < loudKnock) { // turn the status LED on digitalWrite(yellowLed, HIGH); delay(50); digitalWrite(yellowLed, LOW); // print out the status Serial.print(\"Valid knock of value \"); Serial.println(value); // return true return true; } // if the knock is not within range else { // print status Serial.print(\"Bad knock value \"); Serial.println(value); // return false return false; } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p12 KnockLock"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p12_KnockLock/#sketch-code","text":"/* Arduino Starter Kit example Project 12 - Knock Lock This sketch is written to accompany Project 12 in the Arduino Starter Kit Parts required: - 1 megohm resistor - 10 kilohm resistor - three 220 ohm resistors - piezo - servo motor - push button - one red LED - one yellow LED - one green LED - 100 uF capacitor created 18 Sep 2012 by Scott Fitzgerald Thanks to Federico Vanzati for improvements https://programminginarduino.wordpress.com/2016/03/06/project-13/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // import the library #include <Servo.h> // create an instance of the Servo library Servo myServo; const int piezo = A0; // pin the piezo is attached to const int switchPin = 2; // pin the switch is attached to const int yellowLed = 3; // pin the yellow LED is attached to const int greenLed = 4; // pin the green LED is attached to const int redLed = 5; // pin the red LED is attached to // variable for the piezo value int knockVal; // variable for the switch value int switchVal; // variables for the high and low limits of the knock value const int quietKnock = 10; const int loudKnock = 100; // variable to indicate if locked or not bool locked = false; // how many valid knocks you've received int numberOfKnocks = 0; void setup() { // attach the servo to pin 9 myServo.attach(9); // make the LED pins outputs pinMode(yellowLed, OUTPUT); pinMode(redLed, OUTPUT); pinMode(greenLed, OUTPUT); // set the switch pin as an input pinMode(switchPin, INPUT); // start serial communication for debugging Serial.begin(9600); // turn the green LED on digitalWrite(greenLed, HIGH); // move the servo to the unlocked position myServo.write(0); // print status to the Serial Monitor Serial.println(\"the box is unlocked!\"); } void loop() { // if the box is unlocked if (locked == false) { // read the value of the switch pin switchVal = digitalRead(switchPin); // if the button is pressed, lock the box if (switchVal == HIGH) { // set the locked variable to \"true\" locked = true; // change the status LEDs digitalWrite(greenLed, LOW); digitalWrite(redLed, HIGH); // move the servo to the locked position myServo.write(90); // print out status Serial.println(\"the box is locked!\"); // wait for the servo to move into position delay(1000); } } // if the box is locked if (locked == true) { // check the value of the piezo knockVal = analogRead(piezo); // if there are not enough valid knocks if (numberOfKnocks < 3 && knockVal > 0) { // check to see if the knock is in range if (checkForKnock(knockVal) == true) { // increment the number of valid knocks numberOfKnocks++; } // print status of knocks Serial.print(3 - numberOfKnocks); Serial.println(\" more knocks to go\"); } // if there are three knocks if (numberOfKnocks >= 3) { // unlock the box locked = false; // move the servo to the unlocked position myServo.write(0); // wait for it to move delay(20); // change status LEDs digitalWrite(greenLed, HIGH); digitalWrite(redLed, LOW); Serial.println(\"the box is unlocked!\"); numberOfKnocks = 0; } } } // this function checks to see if a detected knock is within max and min range bool checkForKnock(int value) { // if the value of the knock is greater than the minimum, and larger // than the maximum if (value > quietKnock && value < loudKnock) { // turn the status LED on digitalWrite(yellowLed, HIGH); delay(50); digitalWrite(yellowLed, LOW); // print out the status Serial.print(\"Valid knock of value \"); Serial.println(value); // return true return true; } // if the knock is not within range else { // print status Serial.print(\"Bad knock value \"); Serial.println(value); // return false return false; } }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p12_KnockLock/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p12_KnockLock/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p12_KnockLock/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p13_TouchSensorLamp/","text":"Sketch Code /* Arduino Starter Kit example Project 13 - Touch Sensor Lamp This sketch is written to accompany Project 13 in the Arduino Starter Kit Parts required: - 1 megohm resistor - metal foil or copper mesh - 220 ohm resistor - LED Software required : - CapacitiveSensor library by Paul Badger https://www.arduino.cc/reference/en/libraries/capacitivesensor/ created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/06/project-14/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // import the library (must be located in the Arduino/libraries directory) #include <CapacitiveSensor.h> // create an instance of the library // pin 4 sends electrical energy // pin 2 senses senses a change CapacitiveSensor capSensor = CapacitiveSensor(4, 2); // threshold for turning the lamp on int threshold = 1000; // pin the LED is connected to const int ledPin = 12; void setup() { // open a serial connection Serial.begin(9600); // set the LED pin as an output pinMode(ledPin, OUTPUT); } void loop() { // store the value reported by the sensor in a variable long sensorValue = capSensor.capacitiveSensor(30); // print out the sensor value Serial.println(sensorValue); // if the value is greater than the threshold if (sensorValue > threshold) { // turn the LED on digitalWrite(ledPin, HIGH); } // if it's lower than the threshold else { // turn the LED off digitalWrite(ledPin, LOW); } delay(10); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p13 TouchSensorLamp"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p13_TouchSensorLamp/#sketch-code","text":"/* Arduino Starter Kit example Project 13 - Touch Sensor Lamp This sketch is written to accompany Project 13 in the Arduino Starter Kit Parts required: - 1 megohm resistor - metal foil or copper mesh - 220 ohm resistor - LED Software required : - CapacitiveSensor library by Paul Badger https://www.arduino.cc/reference/en/libraries/capacitivesensor/ created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/06/project-14/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ // import the library (must be located in the Arduino/libraries directory) #include <CapacitiveSensor.h> // create an instance of the library // pin 4 sends electrical energy // pin 2 senses senses a change CapacitiveSensor capSensor = CapacitiveSensor(4, 2); // threshold for turning the lamp on int threshold = 1000; // pin the LED is connected to const int ledPin = 12; void setup() { // open a serial connection Serial.begin(9600); // set the LED pin as an output pinMode(ledPin, OUTPUT); } void loop() { // store the value reported by the sensor in a variable long sensorValue = capSensor.capacitiveSensor(30); // print out the sensor value Serial.println(sensorValue); // if the value is greater than the threshold if (sensorValue > threshold) { // turn the LED on digitalWrite(ledPin, HIGH); } // if it's lower than the threshold else { // turn the LED off digitalWrite(ledPin, LOW); } delay(10); }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p13_TouchSensorLamp/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p13_TouchSensorLamp/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p13_TouchSensorLamp/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p14_TweakTheArduinoLogo/","text":"Sketch Code /* Arduino Starter Kit example Project 14 - Tweak the Arduino Logo This sketch is written to accompany Project 14 in the Arduino Starter Kit Parts required: - 10 kilohm potentiometer Software required: - Processing (3.0 or newer) https://processing.org/ - Active Internet connection created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/08/project-14-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ void setup() { // initialize serial communication Serial.begin(9600); } void loop() { // read the value of A0, divide by 4 and send it as a byte over the // serial connection Serial.write(analogRead(A0) / 4); delay(1); } /* Processing code for this example // Tweak the Arduino Logo // by Scott Fitzgerald // This example code is in the public domain. // import the serial library import processing.serial.*; // create an instance of the serial library Serial myPort; // create an instance of PImage PImage logo; // a variable to hold the background color int bgcolor = 0; void setup() { size(1, 1); surface.setResizable(true); // set the color mode to Hue/Saturation/Brightness colorMode(HSB, 255); // load the Arduino logo into the PImage instance logo = loadImage(\"http://www.arduino.cc/arduino_logo.png\"); // make the window the same size as the image surface.setSize(logo.width, logo.height); // print a list of available serial ports to the Processing status window println(\"Available serial ports:\"); println(Serial.list()); // Tell the serial object the information it needs to communicate with the // Arduino. Change Serial.list()[0] to the correct port corresponding to // your Arduino board. The last parameter (e.g. 9600) is the speed of the // communication. It has to correspond to the value passed to // Serial.begin() in your Arduino sketch. myPort = new Serial(this, Serial.list()[0], 9600); // If you know the name of the port used by the Arduino board, you can // specify it directly like this. // port = new Serial(this, \"COM1\", 9600); } void draw() { // if there is information in the serial port if ( myPort.available() > 0) { // read the value and store it in a variable bgcolor = myPort.read(); // print the value to the status window println(bgcolor); } // Draw the background. the variable bgcolor contains the Hue, determined by // the value from the serial port background(bgcolor, 255, 255); // draw the Arduino logo image(logo, 0, 0); } */ Fritzing Circuit KiCad Schematic Video Demonstration","title":"p14 TweakTheArduinoLogo"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p14_TweakTheArduinoLogo/#sketch-code","text":"/* Arduino Starter Kit example Project 14 - Tweak the Arduino Logo This sketch is written to accompany Project 14 in the Arduino Starter Kit Parts required: - 10 kilohm potentiometer Software required: - Processing (3.0 or newer) https://processing.org/ - Active Internet connection created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/08/project-14-2/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ void setup() { // initialize serial communication Serial.begin(9600); } void loop() { // read the value of A0, divide by 4 and send it as a byte over the // serial connection Serial.write(analogRead(A0) / 4); delay(1); } /* Processing code for this example // Tweak the Arduino Logo // by Scott Fitzgerald // This example code is in the public domain. // import the serial library import processing.serial.*; // create an instance of the serial library Serial myPort; // create an instance of PImage PImage logo; // a variable to hold the background color int bgcolor = 0; void setup() { size(1, 1); surface.setResizable(true); // set the color mode to Hue/Saturation/Brightness colorMode(HSB, 255); // load the Arduino logo into the PImage instance logo = loadImage(\"http://www.arduino.cc/arduino_logo.png\"); // make the window the same size as the image surface.setSize(logo.width, logo.height); // print a list of available serial ports to the Processing status window println(\"Available serial ports:\"); println(Serial.list()); // Tell the serial object the information it needs to communicate with the // Arduino. Change Serial.list()[0] to the correct port corresponding to // your Arduino board. The last parameter (e.g. 9600) is the speed of the // communication. It has to correspond to the value passed to // Serial.begin() in your Arduino sketch. myPort = new Serial(this, Serial.list()[0], 9600); // If you know the name of the port used by the Arduino board, you can // specify it directly like this. // port = new Serial(this, \"COM1\", 9600); } void draw() { // if there is information in the serial port if ( myPort.available() > 0) { // read the value and store it in a variable bgcolor = myPort.read(); // print the value to the status window println(bgcolor); } // Draw the background. the variable bgcolor contains the Hue, determined by // the value from the serial port background(bgcolor, 255, 255); // draw the Arduino logo image(logo, 0, 0); } */","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p14_TweakTheArduinoLogo/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p14_TweakTheArduinoLogo/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p14_TweakTheArduinoLogo/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p15_HackingButtons/","text":"Sketch Code /* Arduino Starter Kit example Project 15 - Hacking Buttons This sketch is written to accompany Project 15 in the Arduino Starter Kit Parts required: - battery powered component - 220 ohm resistor - 4N35 optocoupler created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/08/project-15/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int optoPin = 2; // the pin the optocoupler is connected to void setup() { // make the pin with the optocoupler an output pinMode(optoPin, OUTPUT); } void loop() { digitalWrite(optoPin, HIGH); // pull pin 2 HIGH, activating the optocoupler delay(15); // give the optocoupler a moment to activate digitalWrite(optoPin, LOW); // pull pin 2 low until you're ready to activate again delay(21000); // wait for 21 seconds } Fritzing Circuit KiCad Schematic Video Demonstration","title":"p15 HackingButtons"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p15_HackingButtons/#sketch-code","text":"/* Arduino Starter Kit example Project 15 - Hacking Buttons This sketch is written to accompany Project 15 in the Arduino Starter Kit Parts required: - battery powered component - 220 ohm resistor - 4N35 optocoupler created 18 Sep 2012 by Scott Fitzgerald https://programminginarduino.wordpress.com/2016/03/08/project-15/ https://store.arduino.cc/genuino-starter-kit This example code is part of the public domain. */ const int optoPin = 2; // the pin the optocoupler is connected to void setup() { // make the pin with the optocoupler an output pinMode(optoPin, OUTPUT); } void loop() { digitalWrite(optoPin, HIGH); // pull pin 2 HIGH, activating the optocoupler delay(15); // give the optocoupler a moment to activate digitalWrite(optoPin, LOW); // pull pin 2 low until you're ready to activate again delay(21000); // wait for 21 seconds }","title":"Sketch Code"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p15_HackingButtons/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p15_HackingButtons/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/10.StarterKit_BasicKit/p15_HackingButtons/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"04_builtin_examples/11.ArduinoISP/ArduinoISP/","text":"Sketch Code // https://docs.arduino.cc/built-in-examples/arduino-isp/ArduinoISP // ArduinoISP // Copyright (c) 2008-2011 Randall Bohn // If you require a license, see // https://opensource.org/licenses/bsd-license.php // // This sketch turns the Arduino into a AVRISP using the following Arduino pins: // // Pin 10 is used to reset the target microcontroller. // // By default, the hardware SPI pins MISO, MOSI and SCK are used to communicate // with the target. On all Arduinos, these pins can be found // on the ICSP/SPI header: // // MISO \u00b0. . 5V (!) Avoid this pin on Due, Zero... // SCK . . MOSI // . . GND // // On some Arduinos (Uno,...), pins MOSI, MISO and SCK are the same pins as // digital pin 11, 12 and 13, respectively. That is why many tutorials instruct // you to hook up the target to these pins. If you find this wiring more // practical, have a define USE_OLD_STYLE_WIRING. This will work even when not // using an Uno. (On an Uno this is not needed). // // Alternatively you can use any other digital pin by configuring // software ('BitBanged') SPI and having appropriate defines for PIN_MOSI, // PIN_MISO and PIN_SCK. // // IMPORTANT: When using an Arduino that is not 5V tolerant (Due, Zero, ...) as // the programmer, make sure to not expose any of the programmer's pins to 5V. // A simple way to accomplish this is to power the complete system (programmer // and target) at 3V3. // // Put an LED (with resistor) on the following pins: // 9: Heartbeat - shows the programmer is running // 8: Error - Lights up if something goes wrong (use red if that makes sense) // 7: Programming - In communication with the target // #include \"Arduino.h\" #undef SERIAL #define PROG_FLICKER true // Configure SPI clock (in Hz). // E.g. for an ATtiny @ 128 kHz: the datasheet states that both the high and low // SPI clock pulse must be > 2 CPU cycles, so take 3 cycles i.e. divide target // f_cpu by 6: // #define SPI_CLOCK (128000/6) // // A clock slow enough for an ATtiny85 @ 1 MHz, is a reasonable default: #define SPI_CLOCK (1000000 / 6) // Select hardware or software SPI, depending on SPI clock. // Currently only for AVR, for other architectures (Due, Zero,...), hardware SPI // is probably too fast anyway. #if defined(ARDUINO_ARCH_AVR) #if SPI_CLOCK > (F_CPU / 128) #define USE_HARDWARE_SPI #endif #endif // Configure which pins to use: // The standard pin configuration. #ifndef ARDUINO_HOODLOADER2 #define RESET 10 // Use pin 10 to reset the target rather than SS #define LED_HB 9 #define LED_ERR 8 #define LED_PMODE 7 // Uncomment following line to use the old Uno style wiring // (using pin 11, 12 and 13 instead of the SPI header) on Leonardo, Due... // #define USE_OLD_STYLE_WIRING #ifdef USE_OLD_STYLE_WIRING #define PIN_MOSI 11 #define PIN_MISO 12 #define PIN_SCK 13 #endif // HOODLOADER2 means running sketches on the ATmega16U2 serial converter chips // on Uno or Mega boards. We must use pins that are broken out: #else #define RESET 4 #define LED_HB 7 #define LED_ERR 6 #define LED_PMODE 5 #endif // By default, use hardware SPI pins: #ifndef PIN_MOSI #define PIN_MOSI MOSI #endif #ifndef PIN_MISO #define PIN_MISO MISO #endif #ifndef PIN_SCK #define PIN_SCK SCK #endif // Force bitbanged SPI if not using the hardware SPI pins: #if (PIN_MISO != MISO) || (PIN_MOSI != MOSI) || (PIN_SCK != SCK) #undef USE_HARDWARE_SPI #endif // Configure the serial port to use. // // Prefer the USB virtual serial port (aka. native USB port), if the Arduino has one: // - it does not autoreset (except for the magic baud rate of 1200). // - it is more reliable because of USB handshaking. // // Leonardo and similar have an USB virtual serial port: 'Serial'. // Due and Zero have an USB virtual serial port: 'SerialUSB'. // // On the Due and Zero, 'Serial' can be used too, provided you disable autoreset. // To use 'Serial': #define SERIAL Serial #ifdef SERIAL_PORT_USBVIRTUAL #define SERIAL SERIAL_PORT_USBVIRTUAL #else #define SERIAL Serial #endif // Configure the baud rate: #define BAUDRATE 19200 // #define BAUDRATE 115200 // #define BAUDRATE 1000000 #define HWVER 2 #define SWMAJ 1 #define SWMIN 18 // STK Definitions #define STK_OK 0x10 #define STK_FAILED 0x11 #define STK_UNKNOWN 0x12 #define STK_INSYNC 0x14 #define STK_NOSYNC 0x15 #define CRC_EOP 0x20 //ok it is a space... void pulse(int pin, int times); #ifdef USE_HARDWARE_SPI #include \"SPI.h\" #else #define SPI_MODE0 0x00 #if !defined(ARDUINO_API_VERSION) || ARDUINO_API_VERSION != 10001 // A SPISettings class is declared by ArduinoCore-API 1.0.1 class SPISettings { public: // clock is in Hz SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) : clockFreq(clock) { (void)bitOrder; (void)dataMode; }; uint32_t getClockFreq() const { return clockFreq; } private: uint32_t clockFreq; }; #endif // !defined(ARDUINO_API_VERSION) class BitBangedSPI { public: void begin() { digitalWrite(PIN_SCK, LOW); digitalWrite(PIN_MOSI, LOW); pinMode(PIN_SCK, OUTPUT); pinMode(PIN_MOSI, OUTPUT); pinMode(PIN_MISO, INPUT); } void beginTransaction(SPISettings settings) { pulseWidth = (500000 + settings.getClockFreq() - 1) / settings.getClockFreq(); if (pulseWidth == 0) { pulseWidth = 1; } } void end() {} uint8_t transfer(uint8_t b) { for (unsigned int i = 0; i < 8; ++i) { digitalWrite(PIN_MOSI, (b & 0x80) ? HIGH : LOW); digitalWrite(PIN_SCK, HIGH); delayMicroseconds(pulseWidth); b = (b << 1) | digitalRead(PIN_MISO); digitalWrite(PIN_SCK, LOW); // slow pulse delayMicroseconds(pulseWidth); } return b; } private: unsigned long pulseWidth; // in microseconds }; static BitBangedSPI SPI; #endif void setup() { SERIAL.begin(BAUDRATE); pinMode(LED_PMODE, OUTPUT); pulse(LED_PMODE, 2); pinMode(LED_ERR, OUTPUT); pulse(LED_ERR, 2); pinMode(LED_HB, OUTPUT); pulse(LED_HB, 2); } int ISPError = 0; int pmode = 0; // address for reading and writing, set by 'U' command unsigned int here; uint8_t buff[256]; // global block storage #define beget16(addr) (*addr * 256 + *(addr + 1)) typedef struct param { uint8_t devicecode; uint8_t revision; uint8_t progtype; uint8_t parmode; uint8_t polling; uint8_t selftimed; uint8_t lockbytes; uint8_t fusebytes; uint8_t flashpoll; uint16_t eeprompoll; uint16_t pagesize; uint16_t eepromsize; uint32_t flashsize; } parameter; parameter param; // this provides a heartbeat on pin 9, so you can tell the software is running. uint8_t hbval = 128; int8_t hbdelta = 8; void heartbeat() { static unsigned long last_time = 0; unsigned long now = millis(); if ((now - last_time) < 40) { return; } last_time = now; if (hbval > 192) { hbdelta = -hbdelta; } if (hbval < 32) { hbdelta = -hbdelta; } hbval += hbdelta; analogWrite(LED_HB, hbval); } static bool rst_active_high; void reset_target(bool reset) { digitalWrite(RESET, ((reset && rst_active_high) || (!reset && !rst_active_high)) ? HIGH : LOW); } void loop(void) { // is pmode active? if (pmode) { digitalWrite(LED_PMODE, HIGH); } else { digitalWrite(LED_PMODE, LOW); } // is there an error? if (ISPError) { digitalWrite(LED_ERR, HIGH); } else { digitalWrite(LED_ERR, LOW); } // light the heartbeat LED heartbeat(); if (SERIAL.available()) { avrisp(); } } uint8_t getch() { while (!SERIAL.available()) ; return SERIAL.read(); } void fill(int n) { for (int x = 0; x < n; x++) { buff[x] = getch(); } } #define PTIME 30 void pulse(int pin, int times) { do { digitalWrite(pin, HIGH); delay(PTIME); digitalWrite(pin, LOW); delay(PTIME); } while (times--); } void prog_lamp(int state) { if (PROG_FLICKER) { digitalWrite(LED_PMODE, state); } } uint8_t spi_transaction(uint8_t a, uint8_t b, uint8_t c, uint8_t d) { SPI.transfer(a); SPI.transfer(b); SPI.transfer(c); return SPI.transfer(d); } void empty_reply() { if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } void breply(uint8_t b) { if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)b); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } void get_version(uint8_t c) { switch (c) { case 0x80: breply(HWVER); break; case 0x81: breply(SWMAJ); break; case 0x82: breply(SWMIN); break; case 0x93: breply('S'); // serial programmer break; default: breply(0); } } void set_parameters() { // call this after reading parameter packet into buff[] param.devicecode = buff[0]; param.revision = buff[1]; param.progtype = buff[2]; param.parmode = buff[3]; param.polling = buff[4]; param.selftimed = buff[5]; param.lockbytes = buff[6]; param.fusebytes = buff[7]; param.flashpoll = buff[8]; // ignore buff[9] (= buff[8]) // following are 16 bits (big endian) param.eeprompoll = beget16(&buff[10]); param.pagesize = beget16(&buff[12]); param.eepromsize = beget16(&buff[14]); // 32 bits flashsize (big endian) param.flashsize = buff[16] * 0x01000000 + buff[17] * 0x00010000 + buff[18] * 0x00000100 + buff[19]; // AVR devices have active low reset, AT89Sx are active high rst_active_high = (param.devicecode >= 0xe0); } void start_pmode() { // Reset target before driving PIN_SCK or PIN_MOSI // SPI.begin() will configure SS as output, so SPI master mode is selected. // We have defined RESET as pin 10, which for many Arduinos is not the SS pin. // So we have to configure RESET as output here, // (reset_target() first sets the correct level) reset_target(true); pinMode(RESET, OUTPUT); SPI.begin(); SPI.beginTransaction(SPISettings(SPI_CLOCK, MSBFIRST, SPI_MODE0)); // See AVR datasheets, chapter \"SERIAL_PRG Programming Algorithm\": // Pulse RESET after PIN_SCK is low: digitalWrite(PIN_SCK, LOW); delay(20); // discharge PIN_SCK, value arbitrarily chosen reset_target(false); // Pulse must be minimum 2 target CPU clock cycles so 100 usec is ok for CPU // speeds above 20 KHz delayMicroseconds(100); reset_target(true); // Send the enable programming command: delay(50); // datasheet: must be > 20 msec spi_transaction(0xAC, 0x53, 0x00, 0x00); pmode = 1; } void end_pmode() { SPI.end(); // We're about to take the target out of reset so configure SPI pins as input pinMode(PIN_MOSI, INPUT); pinMode(PIN_SCK, INPUT); reset_target(false); pinMode(RESET, INPUT); pmode = 0; } void universal() { uint8_t ch; fill(4); ch = spi_transaction(buff[0], buff[1], buff[2], buff[3]); breply(ch); } void flash(uint8_t hilo, unsigned int addr, uint8_t data) { spi_transaction(0x40 + 8 * hilo, addr >> 8 & 0xFF, addr & 0xFF, data); } void commit(unsigned int addr) { if (PROG_FLICKER) { prog_lamp(LOW); } spi_transaction(0x4C, (addr >> 8) & 0xFF, addr & 0xFF, 0); if (PROG_FLICKER) { delay(PTIME); prog_lamp(HIGH); } } unsigned int current_page() { if (param.pagesize == 32) { return here & 0xFFFFFFF0; } if (param.pagesize == 64) { return here & 0xFFFFFFE0; } if (param.pagesize == 128) { return here & 0xFFFFFFC0; } if (param.pagesize == 256) { return here & 0xFFFFFF80; } return here; } void write_flash(int length) { fill(length); if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)write_flash_pages(length)); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } uint8_t write_flash_pages(int length) { int x = 0; unsigned int page = current_page(); while (x < length) { if (page != current_page()) { commit(page); page = current_page(); } flash(LOW, here, buff[x++]); flash(HIGH, here, buff[x++]); here++; } commit(page); return STK_OK; } #define EECHUNK (32) uint8_t write_eeprom(unsigned int length) { // here is a word address, get the byte address unsigned int start = here * 2; unsigned int remaining = length; if (length > param.eepromsize) { ISPError++; return STK_FAILED; } while (remaining > EECHUNK) { write_eeprom_chunk(start, EECHUNK); start += EECHUNK; remaining -= EECHUNK; } write_eeprom_chunk(start, remaining); return STK_OK; } // write (length) bytes, (start) is a byte address uint8_t write_eeprom_chunk(unsigned int start, unsigned int length) { // this writes byte-by-byte, page writing may be faster (4 bytes at a time) fill(length); prog_lamp(LOW); for (unsigned int x = 0; x < length; x++) { unsigned int addr = start + x; spi_transaction(0xC0, (addr >> 8) & 0xFF, addr & 0xFF, buff[x]); delay(45); } prog_lamp(HIGH); return STK_OK; } void program_page() { char result = (char)STK_FAILED; unsigned int length = 256 * getch(); length += getch(); char memtype = getch(); // flash memory @here, (length) bytes if (memtype == 'F') { write_flash(length); return; } if (memtype == 'E') { result = (char)write_eeprom(length); if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print(result); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } return; } SERIAL.print((char)STK_FAILED); return; } uint8_t flash_read(uint8_t hilo, unsigned int addr) { return spi_transaction(0x20 + hilo * 8, (addr >> 8) & 0xFF, addr & 0xFF, 0); } char flash_read_page(int length) { for (int x = 0; x < length; x += 2) { uint8_t low = flash_read(LOW, here); SERIAL.print((char)low); uint8_t high = flash_read(HIGH, here); SERIAL.print((char)high); here++; } return STK_OK; } char eeprom_read_page(int length) { // here again we have a word address int start = here * 2; for (int x = 0; x < length; x++) { int addr = start + x; uint8_t ee = spi_transaction(0xA0, (addr >> 8) & 0xFF, addr & 0xFF, 0xFF); SERIAL.print((char)ee); } return STK_OK; } void read_page() { char result = (char)STK_FAILED; int length = 256 * getch(); length += getch(); char memtype = getch(); if (CRC_EOP != getch()) { ISPError++; SERIAL.print((char)STK_NOSYNC); return; } SERIAL.print((char)STK_INSYNC); if (memtype == 'F') { result = flash_read_page(length); } if (memtype == 'E') { result = eeprom_read_page(length); } SERIAL.print(result); } void read_signature() { if (CRC_EOP != getch()) { ISPError++; SERIAL.print((char)STK_NOSYNC); return; } SERIAL.print((char)STK_INSYNC); uint8_t high = spi_transaction(0x30, 0x00, 0x00, 0x00); SERIAL.print((char)high); uint8_t middle = spi_transaction(0x30, 0x00, 0x01, 0x00); SERIAL.print((char)middle); uint8_t low = spi_transaction(0x30, 0x00, 0x02, 0x00); SERIAL.print((char)low); SERIAL.print((char)STK_OK); } ////////////////////////////////////////// ////////////////////////////////////////// //////////////////////////////////// //////////////////////////////////// void avrisp() { uint8_t ch = getch(); switch (ch) { case '0': // signon ISPError = 0; empty_reply(); break; case '1': if (getch() == CRC_EOP) { SERIAL.print((char)STK_INSYNC); SERIAL.print(\"AVR ISP\"); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } break; case 'A': get_version(getch()); break; case 'B': fill(20); set_parameters(); empty_reply(); break; case 'E': // extended parameters - ignore for now fill(5); empty_reply(); break; case 'P': if (!pmode) { start_pmode(); } empty_reply(); break; case 'U': // set address (word) here = getch(); here += 256 * getch(); empty_reply(); break; case 0x60: //STK_PROG_FLASH getch(); // low addr getch(); // high addr empty_reply(); break; case 0x61: //STK_PROG_DATA getch(); // data empty_reply(); break; case 0x64: //STK_PROG_PAGE program_page(); break; case 0x74: //STK_READ_PAGE 't' read_page(); break; case 'V': //0x56 universal(); break; case 'Q': //0x51 ISPError = 0; end_pmode(); empty_reply(); break; case 0x75: //STK_READ_SIGN 'u' read_signature(); break; // expecting a command, not CRC_EOP // this is how we can get back in sync case CRC_EOP: ISPError++; SERIAL.print((char)STK_NOSYNC); break; // anything else we will return STK_UNKNOWN default: ISPError++; if (CRC_EOP == getch()) { SERIAL.print((char)STK_UNKNOWN); } else { SERIAL.print((char)STK_NOSYNC); } } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"ArduinoISP"},{"location":"04_builtin_examples/11.ArduinoISP/ArduinoISP/#sketch-code","text":"// https://docs.arduino.cc/built-in-examples/arduino-isp/ArduinoISP // ArduinoISP // Copyright (c) 2008-2011 Randall Bohn // If you require a license, see // https://opensource.org/licenses/bsd-license.php // // This sketch turns the Arduino into a AVRISP using the following Arduino pins: // // Pin 10 is used to reset the target microcontroller. // // By default, the hardware SPI pins MISO, MOSI and SCK are used to communicate // with the target. On all Arduinos, these pins can be found // on the ICSP/SPI header: // // MISO \u00b0. . 5V (!) Avoid this pin on Due, Zero... // SCK . . MOSI // . . GND // // On some Arduinos (Uno,...), pins MOSI, MISO and SCK are the same pins as // digital pin 11, 12 and 13, respectively. That is why many tutorials instruct // you to hook up the target to these pins. If you find this wiring more // practical, have a define USE_OLD_STYLE_WIRING. This will work even when not // using an Uno. (On an Uno this is not needed). // // Alternatively you can use any other digital pin by configuring // software ('BitBanged') SPI and having appropriate defines for PIN_MOSI, // PIN_MISO and PIN_SCK. // // IMPORTANT: When using an Arduino that is not 5V tolerant (Due, Zero, ...) as // the programmer, make sure to not expose any of the programmer's pins to 5V. // A simple way to accomplish this is to power the complete system (programmer // and target) at 3V3. // // Put an LED (with resistor) on the following pins: // 9: Heartbeat - shows the programmer is running // 8: Error - Lights up if something goes wrong (use red if that makes sense) // 7: Programming - In communication with the target // #include \"Arduino.h\" #undef SERIAL #define PROG_FLICKER true // Configure SPI clock (in Hz). // E.g. for an ATtiny @ 128 kHz: the datasheet states that both the high and low // SPI clock pulse must be > 2 CPU cycles, so take 3 cycles i.e. divide target // f_cpu by 6: // #define SPI_CLOCK (128000/6) // // A clock slow enough for an ATtiny85 @ 1 MHz, is a reasonable default: #define SPI_CLOCK (1000000 / 6) // Select hardware or software SPI, depending on SPI clock. // Currently only for AVR, for other architectures (Due, Zero,...), hardware SPI // is probably too fast anyway. #if defined(ARDUINO_ARCH_AVR) #if SPI_CLOCK > (F_CPU / 128) #define USE_HARDWARE_SPI #endif #endif // Configure which pins to use: // The standard pin configuration. #ifndef ARDUINO_HOODLOADER2 #define RESET 10 // Use pin 10 to reset the target rather than SS #define LED_HB 9 #define LED_ERR 8 #define LED_PMODE 7 // Uncomment following line to use the old Uno style wiring // (using pin 11, 12 and 13 instead of the SPI header) on Leonardo, Due... // #define USE_OLD_STYLE_WIRING #ifdef USE_OLD_STYLE_WIRING #define PIN_MOSI 11 #define PIN_MISO 12 #define PIN_SCK 13 #endif // HOODLOADER2 means running sketches on the ATmega16U2 serial converter chips // on Uno or Mega boards. We must use pins that are broken out: #else #define RESET 4 #define LED_HB 7 #define LED_ERR 6 #define LED_PMODE 5 #endif // By default, use hardware SPI pins: #ifndef PIN_MOSI #define PIN_MOSI MOSI #endif #ifndef PIN_MISO #define PIN_MISO MISO #endif #ifndef PIN_SCK #define PIN_SCK SCK #endif // Force bitbanged SPI if not using the hardware SPI pins: #if (PIN_MISO != MISO) || (PIN_MOSI != MOSI) || (PIN_SCK != SCK) #undef USE_HARDWARE_SPI #endif // Configure the serial port to use. // // Prefer the USB virtual serial port (aka. native USB port), if the Arduino has one: // - it does not autoreset (except for the magic baud rate of 1200). // - it is more reliable because of USB handshaking. // // Leonardo and similar have an USB virtual serial port: 'Serial'. // Due and Zero have an USB virtual serial port: 'SerialUSB'. // // On the Due and Zero, 'Serial' can be used too, provided you disable autoreset. // To use 'Serial': #define SERIAL Serial #ifdef SERIAL_PORT_USBVIRTUAL #define SERIAL SERIAL_PORT_USBVIRTUAL #else #define SERIAL Serial #endif // Configure the baud rate: #define BAUDRATE 19200 // #define BAUDRATE 115200 // #define BAUDRATE 1000000 #define HWVER 2 #define SWMAJ 1 #define SWMIN 18 // STK Definitions #define STK_OK 0x10 #define STK_FAILED 0x11 #define STK_UNKNOWN 0x12 #define STK_INSYNC 0x14 #define STK_NOSYNC 0x15 #define CRC_EOP 0x20 //ok it is a space... void pulse(int pin, int times); #ifdef USE_HARDWARE_SPI #include \"SPI.h\" #else #define SPI_MODE0 0x00 #if !defined(ARDUINO_API_VERSION) || ARDUINO_API_VERSION != 10001 // A SPISettings class is declared by ArduinoCore-API 1.0.1 class SPISettings { public: // clock is in Hz SPISettings(uint32_t clock, uint8_t bitOrder, uint8_t dataMode) : clockFreq(clock) { (void)bitOrder; (void)dataMode; }; uint32_t getClockFreq() const { return clockFreq; } private: uint32_t clockFreq; }; #endif // !defined(ARDUINO_API_VERSION) class BitBangedSPI { public: void begin() { digitalWrite(PIN_SCK, LOW); digitalWrite(PIN_MOSI, LOW); pinMode(PIN_SCK, OUTPUT); pinMode(PIN_MOSI, OUTPUT); pinMode(PIN_MISO, INPUT); } void beginTransaction(SPISettings settings) { pulseWidth = (500000 + settings.getClockFreq() - 1) / settings.getClockFreq(); if (pulseWidth == 0) { pulseWidth = 1; } } void end() {} uint8_t transfer(uint8_t b) { for (unsigned int i = 0; i < 8; ++i) { digitalWrite(PIN_MOSI, (b & 0x80) ? HIGH : LOW); digitalWrite(PIN_SCK, HIGH); delayMicroseconds(pulseWidth); b = (b << 1) | digitalRead(PIN_MISO); digitalWrite(PIN_SCK, LOW); // slow pulse delayMicroseconds(pulseWidth); } return b; } private: unsigned long pulseWidth; // in microseconds }; static BitBangedSPI SPI; #endif void setup() { SERIAL.begin(BAUDRATE); pinMode(LED_PMODE, OUTPUT); pulse(LED_PMODE, 2); pinMode(LED_ERR, OUTPUT); pulse(LED_ERR, 2); pinMode(LED_HB, OUTPUT); pulse(LED_HB, 2); } int ISPError = 0; int pmode = 0; // address for reading and writing, set by 'U' command unsigned int here; uint8_t buff[256]; // global block storage #define beget16(addr) (*addr * 256 + *(addr + 1)) typedef struct param { uint8_t devicecode; uint8_t revision; uint8_t progtype; uint8_t parmode; uint8_t polling; uint8_t selftimed; uint8_t lockbytes; uint8_t fusebytes; uint8_t flashpoll; uint16_t eeprompoll; uint16_t pagesize; uint16_t eepromsize; uint32_t flashsize; } parameter; parameter param; // this provides a heartbeat on pin 9, so you can tell the software is running. uint8_t hbval = 128; int8_t hbdelta = 8; void heartbeat() { static unsigned long last_time = 0; unsigned long now = millis(); if ((now - last_time) < 40) { return; } last_time = now; if (hbval > 192) { hbdelta = -hbdelta; } if (hbval < 32) { hbdelta = -hbdelta; } hbval += hbdelta; analogWrite(LED_HB, hbval); } static bool rst_active_high; void reset_target(bool reset) { digitalWrite(RESET, ((reset && rst_active_high) || (!reset && !rst_active_high)) ? HIGH : LOW); } void loop(void) { // is pmode active? if (pmode) { digitalWrite(LED_PMODE, HIGH); } else { digitalWrite(LED_PMODE, LOW); } // is there an error? if (ISPError) { digitalWrite(LED_ERR, HIGH); } else { digitalWrite(LED_ERR, LOW); } // light the heartbeat LED heartbeat(); if (SERIAL.available()) { avrisp(); } } uint8_t getch() { while (!SERIAL.available()) ; return SERIAL.read(); } void fill(int n) { for (int x = 0; x < n; x++) { buff[x] = getch(); } } #define PTIME 30 void pulse(int pin, int times) { do { digitalWrite(pin, HIGH); delay(PTIME); digitalWrite(pin, LOW); delay(PTIME); } while (times--); } void prog_lamp(int state) { if (PROG_FLICKER) { digitalWrite(LED_PMODE, state); } } uint8_t spi_transaction(uint8_t a, uint8_t b, uint8_t c, uint8_t d) { SPI.transfer(a); SPI.transfer(b); SPI.transfer(c); return SPI.transfer(d); } void empty_reply() { if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } void breply(uint8_t b) { if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)b); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } void get_version(uint8_t c) { switch (c) { case 0x80: breply(HWVER); break; case 0x81: breply(SWMAJ); break; case 0x82: breply(SWMIN); break; case 0x93: breply('S'); // serial programmer break; default: breply(0); } } void set_parameters() { // call this after reading parameter packet into buff[] param.devicecode = buff[0]; param.revision = buff[1]; param.progtype = buff[2]; param.parmode = buff[3]; param.polling = buff[4]; param.selftimed = buff[5]; param.lockbytes = buff[6]; param.fusebytes = buff[7]; param.flashpoll = buff[8]; // ignore buff[9] (= buff[8]) // following are 16 bits (big endian) param.eeprompoll = beget16(&buff[10]); param.pagesize = beget16(&buff[12]); param.eepromsize = beget16(&buff[14]); // 32 bits flashsize (big endian) param.flashsize = buff[16] * 0x01000000 + buff[17] * 0x00010000 + buff[18] * 0x00000100 + buff[19]; // AVR devices have active low reset, AT89Sx are active high rst_active_high = (param.devicecode >= 0xe0); } void start_pmode() { // Reset target before driving PIN_SCK or PIN_MOSI // SPI.begin() will configure SS as output, so SPI master mode is selected. // We have defined RESET as pin 10, which for many Arduinos is not the SS pin. // So we have to configure RESET as output here, // (reset_target() first sets the correct level) reset_target(true); pinMode(RESET, OUTPUT); SPI.begin(); SPI.beginTransaction(SPISettings(SPI_CLOCK, MSBFIRST, SPI_MODE0)); // See AVR datasheets, chapter \"SERIAL_PRG Programming Algorithm\": // Pulse RESET after PIN_SCK is low: digitalWrite(PIN_SCK, LOW); delay(20); // discharge PIN_SCK, value arbitrarily chosen reset_target(false); // Pulse must be minimum 2 target CPU clock cycles so 100 usec is ok for CPU // speeds above 20 KHz delayMicroseconds(100); reset_target(true); // Send the enable programming command: delay(50); // datasheet: must be > 20 msec spi_transaction(0xAC, 0x53, 0x00, 0x00); pmode = 1; } void end_pmode() { SPI.end(); // We're about to take the target out of reset so configure SPI pins as input pinMode(PIN_MOSI, INPUT); pinMode(PIN_SCK, INPUT); reset_target(false); pinMode(RESET, INPUT); pmode = 0; } void universal() { uint8_t ch; fill(4); ch = spi_transaction(buff[0], buff[1], buff[2], buff[3]); breply(ch); } void flash(uint8_t hilo, unsigned int addr, uint8_t data) { spi_transaction(0x40 + 8 * hilo, addr >> 8 & 0xFF, addr & 0xFF, data); } void commit(unsigned int addr) { if (PROG_FLICKER) { prog_lamp(LOW); } spi_transaction(0x4C, (addr >> 8) & 0xFF, addr & 0xFF, 0); if (PROG_FLICKER) { delay(PTIME); prog_lamp(HIGH); } } unsigned int current_page() { if (param.pagesize == 32) { return here & 0xFFFFFFF0; } if (param.pagesize == 64) { return here & 0xFFFFFFE0; } if (param.pagesize == 128) { return here & 0xFFFFFFC0; } if (param.pagesize == 256) { return here & 0xFFFFFF80; } return here; } void write_flash(int length) { fill(length); if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print((char)write_flash_pages(length)); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } } uint8_t write_flash_pages(int length) { int x = 0; unsigned int page = current_page(); while (x < length) { if (page != current_page()) { commit(page); page = current_page(); } flash(LOW, here, buff[x++]); flash(HIGH, here, buff[x++]); here++; } commit(page); return STK_OK; } #define EECHUNK (32) uint8_t write_eeprom(unsigned int length) { // here is a word address, get the byte address unsigned int start = here * 2; unsigned int remaining = length; if (length > param.eepromsize) { ISPError++; return STK_FAILED; } while (remaining > EECHUNK) { write_eeprom_chunk(start, EECHUNK); start += EECHUNK; remaining -= EECHUNK; } write_eeprom_chunk(start, remaining); return STK_OK; } // write (length) bytes, (start) is a byte address uint8_t write_eeprom_chunk(unsigned int start, unsigned int length) { // this writes byte-by-byte, page writing may be faster (4 bytes at a time) fill(length); prog_lamp(LOW); for (unsigned int x = 0; x < length; x++) { unsigned int addr = start + x; spi_transaction(0xC0, (addr >> 8) & 0xFF, addr & 0xFF, buff[x]); delay(45); } prog_lamp(HIGH); return STK_OK; } void program_page() { char result = (char)STK_FAILED; unsigned int length = 256 * getch(); length += getch(); char memtype = getch(); // flash memory @here, (length) bytes if (memtype == 'F') { write_flash(length); return; } if (memtype == 'E') { result = (char)write_eeprom(length); if (CRC_EOP == getch()) { SERIAL.print((char)STK_INSYNC); SERIAL.print(result); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } return; } SERIAL.print((char)STK_FAILED); return; } uint8_t flash_read(uint8_t hilo, unsigned int addr) { return spi_transaction(0x20 + hilo * 8, (addr >> 8) & 0xFF, addr & 0xFF, 0); } char flash_read_page(int length) { for (int x = 0; x < length; x += 2) { uint8_t low = flash_read(LOW, here); SERIAL.print((char)low); uint8_t high = flash_read(HIGH, here); SERIAL.print((char)high); here++; } return STK_OK; } char eeprom_read_page(int length) { // here again we have a word address int start = here * 2; for (int x = 0; x < length; x++) { int addr = start + x; uint8_t ee = spi_transaction(0xA0, (addr >> 8) & 0xFF, addr & 0xFF, 0xFF); SERIAL.print((char)ee); } return STK_OK; } void read_page() { char result = (char)STK_FAILED; int length = 256 * getch(); length += getch(); char memtype = getch(); if (CRC_EOP != getch()) { ISPError++; SERIAL.print((char)STK_NOSYNC); return; } SERIAL.print((char)STK_INSYNC); if (memtype == 'F') { result = flash_read_page(length); } if (memtype == 'E') { result = eeprom_read_page(length); } SERIAL.print(result); } void read_signature() { if (CRC_EOP != getch()) { ISPError++; SERIAL.print((char)STK_NOSYNC); return; } SERIAL.print((char)STK_INSYNC); uint8_t high = spi_transaction(0x30, 0x00, 0x00, 0x00); SERIAL.print((char)high); uint8_t middle = spi_transaction(0x30, 0x00, 0x01, 0x00); SERIAL.print((char)middle); uint8_t low = spi_transaction(0x30, 0x00, 0x02, 0x00); SERIAL.print((char)low); SERIAL.print((char)STK_OK); } ////////////////////////////////////////// ////////////////////////////////////////// //////////////////////////////////// //////////////////////////////////// void avrisp() { uint8_t ch = getch(); switch (ch) { case '0': // signon ISPError = 0; empty_reply(); break; case '1': if (getch() == CRC_EOP) { SERIAL.print((char)STK_INSYNC); SERIAL.print(\"AVR ISP\"); SERIAL.print((char)STK_OK); } else { ISPError++; SERIAL.print((char)STK_NOSYNC); } break; case 'A': get_version(getch()); break; case 'B': fill(20); set_parameters(); empty_reply(); break; case 'E': // extended parameters - ignore for now fill(5); empty_reply(); break; case 'P': if (!pmode) { start_pmode(); } empty_reply(); break; case 'U': // set address (word) here = getch(); here += 256 * getch(); empty_reply(); break; case 0x60: //STK_PROG_FLASH getch(); // low addr getch(); // high addr empty_reply(); break; case 0x61: //STK_PROG_DATA getch(); // data empty_reply(); break; case 0x64: //STK_PROG_PAGE program_page(); break; case 0x74: //STK_READ_PAGE 't' read_page(); break; case 'V': //0x56 universal(); break; case 'Q': //0x51 ISPError = 0; end_pmode(); empty_reply(); break; case 0x75: //STK_READ_SIGN 'u' read_signature(); break; // expecting a command, not CRC_EOP // this is how we can get back in sync case CRC_EOP: ISPError++; SERIAL.print((char)STK_NOSYNC); break; // anything else we will return STK_UNKNOWN default: ISPError++; if (CRC_EOP == getch()) { SERIAL.print((char)STK_UNKNOWN); } else { SERIAL.print((char)STK_NOSYNC); } } }","title":"Sketch Code"},{"location":"04_builtin_examples/11.ArduinoISP/ArduinoISP/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"04_builtin_examples/11.ArduinoISP/ArduinoISP/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"04_builtin_examples/11.ArduinoISP/ArduinoISP/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/AnalogWave/DACEqualTemperedScale/","text":"Sketch Code /* Plays a tone in response to a potentiometer formula from https://newt.phys.unsw.edu.au/jw/notes.html and https://en.wikipedia.org/wiki/MIDI_tuning_standard: the MIDI protocol divides the notes of an equal-tempered scale into 128 possible note values. Middle A is MIDI note value 69. There is a formula for converting MIDI note numbers (0-127) to pitches. This sketch reduces that to the notes 21 - 108, which are the 88 keys found on a piano: frequency = 440 * ((noteNumber - 69) / 12.0)^2 You can see this applied in the code below. circuit: * audio amp (LM386 used for testing) input+ attached to A0 * audio amp input- attached to ground * 4-8-ohm speaker attached to amp output+ * Potentiometer connected to pin A5 created 18 Dec 2018 modified 3 Jul 2023 by Tom Igoe See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ // include the AnalogWave library: #include \"analogWave.h\" analogWave wave(DAC); // middle A is the reference frequency for an // equal-tempered scale. Set its frequency and note value: #define NOTE_A4 69 // MIDI note value for middle A #define FREQ_A4 440 // frequency for middle A const int speakerPin = A0; // the pin number for the speaker void setup() { Serial.begin(9600); wave.sine(10); } void loop() { // convert sensor reading to 21 - 108 range // which is the range of MIDI notes on an 88-key keyboard // (from A0 to C8): int sensorReading = analogRead(A5); int noteValue = map(sensorReading, 0, 1023, 21, 108); // then convert to frequency: float frequency = FREQ_A4 * pow(2, ((noteValue - NOTE_A4) / 12.0)); int freq = int(frequency); // turn the speaker on: wave.freq(freq); Serial.print(\"note value: \"+ String(noteValue) + \" freq: \"); Serial.println(freq); delay(500); } Video Demonstration","title":"DACEqualTemperedScale"},{"location":"05_examples_uno_r4_wifi/AnalogWave/DACEqualTemperedScale/#sketch-code","text":"/* Plays a tone in response to a potentiometer formula from https://newt.phys.unsw.edu.au/jw/notes.html and https://en.wikipedia.org/wiki/MIDI_tuning_standard: the MIDI protocol divides the notes of an equal-tempered scale into 128 possible note values. Middle A is MIDI note value 69. There is a formula for converting MIDI note numbers (0-127) to pitches. This sketch reduces that to the notes 21 - 108, which are the 88 keys found on a piano: frequency = 440 * ((noteNumber - 69) / 12.0)^2 You can see this applied in the code below. circuit: * audio amp (LM386 used for testing) input+ attached to A0 * audio amp input- attached to ground * 4-8-ohm speaker attached to amp output+ * Potentiometer connected to pin A5 created 18 Dec 2018 modified 3 Jul 2023 by Tom Igoe See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ // include the AnalogWave library: #include \"analogWave.h\" analogWave wave(DAC); // middle A is the reference frequency for an // equal-tempered scale. Set its frequency and note value: #define NOTE_A4 69 // MIDI note value for middle A #define FREQ_A4 440 // frequency for middle A const int speakerPin = A0; // the pin number for the speaker void setup() { Serial.begin(9600); wave.sine(10); } void loop() { // convert sensor reading to 21 - 108 range // which is the range of MIDI notes on an 88-key keyboard // (from A0 to C8): int sensorReading = analogRead(A5); int noteValue = map(sensorReading, 0, 1023, 21, 108); // then convert to frequency: float frequency = FREQ_A4 * pow(2, ((noteValue - NOTE_A4) / 12.0)); int freq = int(frequency); // turn the speaker on: wave.freq(freq); Serial.print(\"note value: \"+ String(noteValue) + \" freq: \"); Serial.println(freq); delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/AnalogWave/DACEqualTemperedScale/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/AnalogWave/DACJacques/","text":"Sketch Code /* DAC Melody player Generates a series of tones from MIDI note values using the Uno R4 DAC and the AnalogWave Library. The melody is \"Frere Jacques\" circuit: * audio amp (LM386 used for testing) input+ attached to A0 * audio amp input- attached to ground * 4-8-ohm speaker attached to amp output+ * Potentiometer connected to pin A5 created 13 Feb 2017 modified 3 Jul 2023 by Tom Igoe See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ #include \"analogWave.h\" analogWave wave(DAC); #define NOTE_A4 69 // MIDI note value for middle A #define FREQ_A4 440 // frequency for middle A // the tonic, or first note of the key signature for the song: int tonic = 65; // the melody sequence. Note values are relative to the tonic: int melody[] = {1, 3, 5, 1, 1, 3, 5, 1, 5, 6, 8, 5, 6, 8, 8, 10, 8, 6, 5, 1, 8, 10, 8, 6, 5, 1, 1, -4, 1, 1, -4, 1 }; // the rhythm sequence. Values are 1/note, e.g. 4 = 1/4 note: int rhythm[] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 2, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 4, 4, 4, 4, 2, 4, 4, 2 }; // which note of the melody to play: int noteCounter = 0; int bpm = 120; // beats per minute // duration of a beat in ms float beatDuration = 60.0 / bpm * 1000; void setup() { // start the sine wave generator: wave.sine(10); } void loop() { // current note is an element of the array: int currentNote = melody[noteCounter] + tonic; // play a note from the melody: // convert MIDI note number to frequency: float frequency = FREQ_A4 * pow(2, ((currentNote - NOTE_A4) / 12.0)); // all the notes in this are sixteenth notes, // which is 1/4 of a beat, so: float noteDuration = beatDuration * (4.0 / rhythm[noteCounter]); // turn the note on: wave.freq(frequency); // tone(speakerPin, frequency, noteDuration * 0.85); // keep it on for the appropriate duration: delay(noteDuration * 0.85); wave.stop(); delay(noteDuration * 0.15); // turn the note off: // noTone(speakerPin); // increment the note number for next time through the loop: noteCounter++; // keep the note in the range from 0 - 32 using modulo: noteCounter = noteCounter % 32; } Video Demonstration","title":"DACJacques"},{"location":"05_examples_uno_r4_wifi/AnalogWave/DACJacques/#sketch-code","text":"/* DAC Melody player Generates a series of tones from MIDI note values using the Uno R4 DAC and the AnalogWave Library. The melody is \"Frere Jacques\" circuit: * audio amp (LM386 used for testing) input+ attached to A0 * audio amp input- attached to ground * 4-8-ohm speaker attached to amp output+ * Potentiometer connected to pin A5 created 13 Feb 2017 modified 3 Jul 2023 by Tom Igoe See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ #include \"analogWave.h\" analogWave wave(DAC); #define NOTE_A4 69 // MIDI note value for middle A #define FREQ_A4 440 // frequency for middle A // the tonic, or first note of the key signature for the song: int tonic = 65; // the melody sequence. Note values are relative to the tonic: int melody[] = {1, 3, 5, 1, 1, 3, 5, 1, 5, 6, 8, 5, 6, 8, 8, 10, 8, 6, 5, 1, 8, 10, 8, 6, 5, 1, 1, -4, 1, 1, -4, 1 }; // the rhythm sequence. Values are 1/note, e.g. 4 = 1/4 note: int rhythm[] = {4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 2, 4, 4, 2, 8, 8, 8, 8, 4, 4, 8, 8, 8, 8, 4, 4, 4, 4, 2, 4, 4, 2 }; // which note of the melody to play: int noteCounter = 0; int bpm = 120; // beats per minute // duration of a beat in ms float beatDuration = 60.0 / bpm * 1000; void setup() { // start the sine wave generator: wave.sine(10); } void loop() { // current note is an element of the array: int currentNote = melody[noteCounter] + tonic; // play a note from the melody: // convert MIDI note number to frequency: float frequency = FREQ_A4 * pow(2, ((currentNote - NOTE_A4) / 12.0)); // all the notes in this are sixteenth notes, // which is 1/4 of a beat, so: float noteDuration = beatDuration * (4.0 / rhythm[noteCounter]); // turn the note on: wave.freq(frequency); // tone(speakerPin, frequency, noteDuration * 0.85); // keep it on for the appropriate duration: delay(noteDuration * 0.85); wave.stop(); delay(noteDuration * 0.15); // turn the note off: // noTone(speakerPin); // increment the note number for next time through the loop: noteCounter++; // keep the note in the range from 0 - 32 using modulo: noteCounter = noteCounter % 32; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/AnalogWave/DACJacques/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/AnalogWave/SineWave/","text":"Sketch Code /* SineWave Generates a pre-generated sawtooth-waveform. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ #include \"analogWave.h\" // Include the library for analog waveform generation analogWave wave(DAC); // Create an instance of the analogWave class, using the DAC pin int freq = 10; // in hertz, change accordingly void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 wave.sine(freq); // Generate a sine wave with the initial frequency } void loop() { // Read an analog value from pin A5 and map it to a frequency range freq = map(analogRead(A5), 0, 1024, 0, 10000); // Print the updated frequency to the serial monitor Serial.println(\"Frequency is now \" + String(freq) + \" hz\"); wave.freq(freq); // Set the frequency of the waveform generator to the updated value delay(1000); // Delay for one second before repeating } Video Demonstration","title":"SineWave"},{"location":"05_examples_uno_r4_wifi/AnalogWave/SineWave/#sketch-code","text":"/* SineWave Generates a pre-generated sawtooth-waveform. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/dac */ #include \"analogWave.h\" // Include the library for analog waveform generation analogWave wave(DAC); // Create an instance of the analogWave class, using the DAC pin int freq = 10; // in hertz, change accordingly void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 wave.sine(freq); // Generate a sine wave with the initial frequency } void loop() { // Read an analog value from pin A5 and map it to a frequency range freq = map(analogRead(A5), 0, 1024, 0, 10000); // Print the updated frequency to the serial monitor Serial.println(\"Frequency is now \" + String(freq) + \" hz\"); wave.freq(freq); // Set the frequency of the waveform generator to the updated value delay(1000); // Delay for one second before repeating }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/AnalogWave/SineWave/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Read/","text":"Arduino UNO R4 WiFi CAN Bus Sketch Code /************************************************************************************** * COMPILE TIME CHECKS **************************************************************************************/ #ifndef ARDUINO_PORTENTA_C33 # error \"CAN1 is only available on Portenta C33.\" #endif /* ARDUINO_PORTENTA_C33 */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } /* You need to enable the CAN transceiver * by commenting in below code when using * a Portenta H33 on a Portenta Max Carrier. * Note: Only CAN1 is available on the Portenta * Max Carrier's RJ10 CAN connector. */ #if (PIN_CAN1_STBY >= 0) pinMode(PIN_CAN1_STBY, OUTPUT); digitalWrite(PIN_CAN1_STBY, LOW); #endif if (!CAN1.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } void loop() { if (CAN1.available()) { CanMsg const msg = CAN1.read(); Serial.println(msg); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"CAN1Read"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Read/#_1","text":"Arduino UNO R4 WiFi CAN Bus","title":""},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Read/#sketch-code","text":"/************************************************************************************** * COMPILE TIME CHECKS **************************************************************************************/ #ifndef ARDUINO_PORTENTA_C33 # error \"CAN1 is only available on Portenta C33.\" #endif /* ARDUINO_PORTENTA_C33 */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } /* You need to enable the CAN transceiver * by commenting in below code when using * a Portenta H33 on a Portenta Max Carrier. * Note: Only CAN1 is available on the Portenta * Max Carrier's RJ10 CAN connector. */ #if (PIN_CAN1_STBY >= 0) pinMode(PIN_CAN1_STBY, OUTPUT); digitalWrite(PIN_CAN1_STBY, LOW); #endif if (!CAN1.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } void loop() { if (CAN1.available()) { CanMsg const msg = CAN1.read(); Serial.println(msg); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Read/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Read/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Read/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Write/","text":"Sketch Code /************************************************************************************** * COMPILE TIME CHECKS **************************************************************************************/ #ifndef ARDUINO_PORTENTA_C33 # error \"CAN1 is only available on Portenta C33.\" #endif /* ARDUINO_PORTENTA_C33 */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * CONSTANTS **************************************************************************************/ static uint32_t const CAN_ID = 0x20; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } /* You need to enable the CAN transceiver * by commenting in below code when using * a Portenta H33 on a Portenta Max Carrier. * Note: Only CAN1 is available on the Portenta * Max Carrier's RJ10 CAN connector. */ #if (PIN_CAN1_STBY >= 0) pinMode(PIN_CAN1_STBY, OUTPUT); digitalWrite(PIN_CAN1_STBY, LOW); #endif if (!CAN1.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } static uint32_t msg_cnt = 0; void loop() { /* Assemble a CAN message with the format of * 0xCA 0xFE 0x00 0x00 [4 byte message counter] */ uint8_t const msg_data[] = {0xCA,0xFE,0,0,0,0,0,0}; memcpy((void *)(msg_data + 4), &msg_cnt, sizeof(msg_cnt)); CanMsg const msg(CanStandardId(CAN_ID), sizeof(msg_data), msg_data); /* Transmit the CAN message, capture and display an * error core in case of failure. */ if (int const rc = CAN1.write(msg); rc < 0) { Serial.print (\"CAN.write(...) failed with error code \"); Serial.println(rc); for (;;) { } } /* Increase the message counter. */ msg_cnt++; /* Only send one message per second. */ delay(1000); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"CAN1Write"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Write/#sketch-code","text":"/************************************************************************************** * COMPILE TIME CHECKS **************************************************************************************/ #ifndef ARDUINO_PORTENTA_C33 # error \"CAN1 is only available on Portenta C33.\" #endif /* ARDUINO_PORTENTA_C33 */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * CONSTANTS **************************************************************************************/ static uint32_t const CAN_ID = 0x20; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } /* You need to enable the CAN transceiver * by commenting in below code when using * a Portenta H33 on a Portenta Max Carrier. * Note: Only CAN1 is available on the Portenta * Max Carrier's RJ10 CAN connector. */ #if (PIN_CAN1_STBY >= 0) pinMode(PIN_CAN1_STBY, OUTPUT); digitalWrite(PIN_CAN1_STBY, LOW); #endif if (!CAN1.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } static uint32_t msg_cnt = 0; void loop() { /* Assemble a CAN message with the format of * 0xCA 0xFE 0x00 0x00 [4 byte message counter] */ uint8_t const msg_data[] = {0xCA,0xFE,0,0,0,0,0,0}; memcpy((void *)(msg_data + 4), &msg_cnt, sizeof(msg_cnt)); CanMsg const msg(CanStandardId(CAN_ID), sizeof(msg_data), msg_data); /* Transmit the CAN message, capture and display an * error core in case of failure. */ if (int const rc = CAN1.write(msg); rc < 0) { Serial.print (\"CAN.write(...) failed with error code \"); Serial.println(rc); for (;;) { } } /* Increase the message counter. */ msg_cnt++; /* Only send one message per second. */ delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Write/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Write/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CAN1Write/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANRead/","text":"Sketch Code /* CANRead Receive and read CAN Bus messages See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/can */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } if (!CAN.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } void loop() { if (CAN.available()) { CanMsg const msg = CAN.read(); Serial.println(msg); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"CANRead"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANRead/#sketch-code","text":"/* CANRead Receive and read CAN Bus messages See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/can */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } if (!CAN.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } void loop() { if (CAN.available()) { CanMsg const msg = CAN.read(); Serial.println(msg); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANRead/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANRead/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANRead/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANWrite/","text":"Sketch Code /* CANWrite Write and send CAN Bus messages See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/can */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * CONSTANTS **************************************************************************************/ static uint32_t const CAN_ID = 0x20; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } if (!CAN.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } static uint32_t msg_cnt = 0; void loop() { /* Assemble a CAN message with the format of * 0xCA 0xFE 0x00 0x00 [4 byte message counter] */ uint8_t const msg_data[] = {0xCA,0xFE,0,0,0,0,0,0}; memcpy((void *)(msg_data + 4), &msg_cnt, sizeof(msg_cnt)); CanMsg const msg(CanStandardId(CAN_ID), sizeof(msg_data), msg_data); /* Transmit the CAN message, capture and display an * error core in case of failure. */ if (int const rc = CAN.write(msg); rc < 0) { Serial.print (\"CAN.write(...) failed with error code \"); Serial.println(rc); for (;;) { } } /* Increase the message counter. */ msg_cnt++; /* Only send one message per second. */ delay(1000); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"CANWrite"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANWrite/#sketch-code","text":"/* CANWrite Write and send CAN Bus messages See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/can */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_CAN.h> /************************************************************************************** * CONSTANTS **************************************************************************************/ static uint32_t const CAN_ID = 0x20; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } if (!CAN.begin(CanBitRate::BR_250k)) { Serial.println(\"CAN.begin(...) failed.\"); for (;;) {} } } static uint32_t msg_cnt = 0; void loop() { /* Assemble a CAN message with the format of * 0xCA 0xFE 0x00 0x00 [4 byte message counter] */ uint8_t const msg_data[] = {0xCA,0xFE,0,0,0,0,0,0}; memcpy((void *)(msg_data + 4), &msg_cnt, sizeof(msg_cnt)); CanMsg const msg(CanStandardId(CAN_ID), sizeof(msg_data), msg_data); /* Transmit the CAN message, capture and display an * error core in case of failure. */ if (int const rc = CAN.write(msg); rc < 0) { Serial.print (\"CAN.write(...) failed with error code \"); Serial.println(rc); for (;;) { } } /* Increase the message counter. */ msg_cnt++; /* Only send one message per second. */ delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANWrite/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANWrite/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Arduino_CAN/CANWrite/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Arduino_FreeRTOS/FreeRTOS-Blink/","text":"Sketch Code /* The code demonstrates the usage of FreeRTOS (Real-Time Operating System) to run concurrent tasks. One task is responsible for running the loop() logic (in a thread-safe manner), while the other task blinks an LED using the built-in LED on non-Portenta boards or the RGB LED on the Portenta C33 board. */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_FreeRTOS.h> /************************************************************************************** * GLOBAL VARIABLES **************************************************************************************/ TaskHandle_t loop_task, blinky_task; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } #if defined(ARDUINO_PORTENTA_C33) /* Only the Portenta C33 has an RGB LED. */ pinMode(LEDR, OUTPUT); digitalWrite(LEDR, LOW); #endif /* Init a task that calls 'loop' * since after the call to * 'vTaskStartScheduler' we'll never * get out of setup() and therefore * would never get to loop(), as we * are leaving the default execution * flow. */ auto const rc_loop = xTaskCreate ( loop_thread_func, static_cast<const char*>(\"Loop Thread\"), 512 / 4, /* usStackDepth in words */ nullptr, /* pvParameters */ 1, /* uxPriority */ &loop_task /* pxCreatedTask */ ); if (rc_loop != pdPASS) { Serial.println(\"Failed to create 'loop' thread\"); return; } auto const rc_blinky = xTaskCreate ( blinky_thread_func, static_cast<const char*>(\"Blinky Thread\"), 512 / 4, /* usStackDepth in words */ nullptr, /* pvParameters */ 1, /* uxPriority */ &blinky_task /* pxCreatedTask */ ); if (rc_blinky != pdPASS) { Serial.println(\"Failed to create 'loop' thread\"); return; } Serial.println(\"Starting scheduler ...\"); /* Start the scheduler. */ vTaskStartScheduler(); /* We'll never get here. */ for( ;; ); } void loop() { #if defined(ARDUINO_PORTENTA_C33) /* Only the Portenta C33 has an RGB LED. */ digitalWrite(LEDR, !digitalRead(LEDR)); #else Serial.println(millis()); #endif vTaskDelay(configTICK_RATE_HZ/4); } void loop_thread_func(void *pvParameters) { for(;;) { loop(); taskYIELD(); } } void blinky_thread_func(void *pvParameters) { /* setup() */ pinMode(LED_BUILTIN, OUTPUT); digitalWrite(LED_BUILTIN, LOW); /* loop() */ for(;;) { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); vTaskDelay(configTICK_RATE_HZ); } } Video Demonstration","title":"FreeRTOS Blink"},{"location":"05_examples_uno_r4_wifi/Arduino_FreeRTOS/FreeRTOS-Blink/#sketch-code","text":"/* The code demonstrates the usage of FreeRTOS (Real-Time Operating System) to run concurrent tasks. One task is responsible for running the loop() logic (in a thread-safe manner), while the other task blinks an LED using the built-in LED on non-Portenta boards or the RGB LED on the Portenta C33 board. */ /************************************************************************************** * INCLUDE **************************************************************************************/ #include <Arduino_FreeRTOS.h> /************************************************************************************** * GLOBAL VARIABLES **************************************************************************************/ TaskHandle_t loop_task, blinky_task; /************************************************************************************** * SETUP/LOOP **************************************************************************************/ void setup() { Serial.begin(115200); while (!Serial) { } #if defined(ARDUINO_PORTENTA_C33) /* Only the Portenta C33 has an RGB LED. */ pinMode(LEDR, OUTPUT); digitalWrite(LEDR, LOW); #endif /* Init a task that calls 'loop' * since after the call to * 'vTaskStartScheduler' we'll never * get out of setup() and therefore * would never get to loop(), as we * are leaving the default execution * flow. */ auto const rc_loop = xTaskCreate ( loop_thread_func, static_cast<const char*>(\"Loop Thread\"), 512 / 4, /* usStackDepth in words */ nullptr, /* pvParameters */ 1, /* uxPriority */ &loop_task /* pxCreatedTask */ ); if (rc_loop != pdPASS) { Serial.println(\"Failed to create 'loop' thread\"); return; } auto const rc_blinky = xTaskCreate ( blinky_thread_func, static_cast<const char*>(\"Blinky Thread\"), 512 / 4, /* usStackDepth in words */ nullptr, /* pvParameters */ 1, /* uxPriority */ &blinky_task /* pxCreatedTask */ ); if (rc_blinky != pdPASS) { Serial.println(\"Failed to create 'loop' thread\"); return; } Serial.println(\"Starting scheduler ...\"); /* Start the scheduler. */ vTaskStartScheduler(); /* We'll never get here. */ for( ;; ); } void loop() { #if defined(ARDUINO_PORTENTA_C33) /* Only the Portenta C33 has an RGB LED. */ digitalWrite(LEDR, !digitalRead(LEDR)); #else Serial.println(millis()); #endif vTaskDelay(configTICK_RATE_HZ/4); } void loop_thread_func(void *pvParameters) { for(;;) { loop(); taskYIELD(); } } void blinky_thread_func(void *pvParameters) { /* setup() */ pinMode(LED_BUILTIN, OUTPUT); digitalWrite(LED_BUILTIN, LOW); /* loop() */ for(;;) { digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN)); vTaskDelay(configTICK_RATE_HZ); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Arduino_FreeRTOS/FreeRTOS-Blink/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_clear/","text":"Sketch Code /* * EEPROM Clear * * Sets all of the bytes of the EEPROM to 0. * Please see eeprom_iteration for a more in depth * look at how to traverse the EEPROM. * * This example code is in the public domain. */ #include <EEPROM.h> void setup() { // initialize the LED pin as an output. pinMode(13, OUTPUT); /*** Iterate through each byte of the EEPROM storage. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ for (int i = 0 ; i < EEPROM.length() ; i++) { EEPROM.write(i, 0); } // turn the LED on when we're done digitalWrite(13, HIGH); } void loop() { /** Empty loop. **/ } Video Demonstration","title":"Eeprom clear"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_clear/#sketch-code","text":"/* * EEPROM Clear * * Sets all of the bytes of the EEPROM to 0. * Please see eeprom_iteration for a more in depth * look at how to traverse the EEPROM. * * This example code is in the public domain. */ #include <EEPROM.h> void setup() { // initialize the LED pin as an output. pinMode(13, OUTPUT); /*** Iterate through each byte of the EEPROM storage. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ for (int i = 0 ; i < EEPROM.length() ; i++) { EEPROM.write(i, 0); } // turn the LED on when we're done digitalWrite(13, HIGH); } void loop() { /** Empty loop. **/ }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_clear/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_crc/","text":"Sketch Code /*** Written by Christopher Andrews. CRC algorithm generated by pycrc, MIT licence ( https://github.com/tpircher/pycrc ). A CRC is a simple way of checking whether data has changed or become corrupted. This example calculates a CRC value directly on the EEPROM values. The purpose of this example is to highlight how the EEPROM object can be used just like an array. ***/ #include <Arduino.h> #include <EEPROM.h> void setup() { //Start serial Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } //Print length of data to run CRC on. Serial.print(\"EEPROM length: \"); Serial.println(EEPROM.length()); //Print the result of calling eeprom_crc() Serial.print(\"CRC32 of EEPROM data: 0x\"); Serial.println(eeprom_crc(), HEX); Serial.print(\"\\n\\nDone!\"); } void loop() { /* Empty loop */ } unsigned long eeprom_crc(void) { const unsigned long crc_table[16] = { 0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c, 0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c }; unsigned long crc = ~0L; for (int index = 0 ; index < EEPROM.length() ; ++index) { crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4); crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4); crc = ~crc; } return crc; } Video Demonstration","title":"Eeprom crc"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_crc/#sketch-code","text":"/*** Written by Christopher Andrews. CRC algorithm generated by pycrc, MIT licence ( https://github.com/tpircher/pycrc ). A CRC is a simple way of checking whether data has changed or become corrupted. This example calculates a CRC value directly on the EEPROM values. The purpose of this example is to highlight how the EEPROM object can be used just like an array. ***/ #include <Arduino.h> #include <EEPROM.h> void setup() { //Start serial Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } //Print length of data to run CRC on. Serial.print(\"EEPROM length: \"); Serial.println(EEPROM.length()); //Print the result of calling eeprom_crc() Serial.print(\"CRC32 of EEPROM data: 0x\"); Serial.println(eeprom_crc(), HEX); Serial.print(\"\\n\\nDone!\"); } void loop() { /* Empty loop */ } unsigned long eeprom_crc(void) { const unsigned long crc_table[16] = { 0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac, 0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c, 0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c, 0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c }; unsigned long crc = ~0L; for (int index = 0 ; index < EEPROM.length() ; ++index) { crc = crc_table[(crc ^ EEPROM[index]) & 0x0f] ^ (crc >> 4); crc = crc_table[(crc ^ (EEPROM[index] >> 4)) & 0x0f] ^ (crc >> 4); crc = ~crc; } return crc; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_crc/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_get/","text":"Sketch Code /*** eeprom_get example. This shows how to use the EEPROM.get() method. To pre-set the EEPROM data, run the example sketch eeprom_put. This sketch will run without it, however, the values shown will be shown from what ever is already on the EEPROM. This may cause the serial object to print out a large string of garbage if there is no null character inside one of the strings loaded. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void setup() { float f = 0.00f; //Variable to store data read from EEPROM. int eeAddress = 0; //EEPROM address to start reading from Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Read float from EEPROM: \"); //Get the float data from the EEPROM at position 'eeAddress' EEPROM.get(eeAddress, f); Serial.println(f, 3); //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float. /*** As get also returns a reference to 'f', you can use it inline. E.g: Serial.print( EEPROM.get( eeAddress, f ) ); ***/ /*** Get can be used with custom structures too. I have separated this into an extra function. ***/ secondTest(); //Run the next test. } struct MyObject { float field1; byte field2; char name[10]; }; void secondTest() { int eeAddress = sizeof(float); //Move address to the next byte after float 'f'. MyObject customVar; //Variable to store custom object read from EEPROM. EEPROM.get(eeAddress, customVar); Serial.println(\"Read custom object from EEPROM: \"); Serial.println(customVar.field1); Serial.println(customVar.field2); Serial.println(customVar.name); } void loop() { /* Empty loop */ } Video Demonstration","title":"Eeprom get"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_get/#sketch-code","text":"/*** eeprom_get example. This shows how to use the EEPROM.get() method. To pre-set the EEPROM data, run the example sketch eeprom_put. This sketch will run without it, however, the values shown will be shown from what ever is already on the EEPROM. This may cause the serial object to print out a large string of garbage if there is no null character inside one of the strings loaded. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void setup() { float f = 0.00f; //Variable to store data read from EEPROM. int eeAddress = 0; //EEPROM address to start reading from Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Read float from EEPROM: \"); //Get the float data from the EEPROM at position 'eeAddress' EEPROM.get(eeAddress, f); Serial.println(f, 3); //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float. /*** As get also returns a reference to 'f', you can use it inline. E.g: Serial.print( EEPROM.get( eeAddress, f ) ); ***/ /*** Get can be used with custom structures too. I have separated this into an extra function. ***/ secondTest(); //Run the next test. } struct MyObject { float field1; byte field2; char name[10]; }; void secondTest() { int eeAddress = sizeof(float); //Move address to the next byte after float 'f'. MyObject customVar; //Variable to store custom object read from EEPROM. EEPROM.get(eeAddress, customVar); Serial.println(\"Read custom object from EEPROM: \"); Serial.println(customVar.field1); Serial.println(customVar.field2); Serial.println(customVar.name); } void loop() { /* Empty loop */ }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_get/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_iteration/","text":"Sketch Code /*** eeprom_iteration example. A set of example snippets highlighting the simplest methods for traversing the EEPROM. Running this sketch is not necessary, this is simply highlighting certain programming methods. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void setup() { /*** Iterate the EEPROM using a for loop. ***/ for (int index = 0 ; index < EEPROM.length() ; index++) { //Add one to each cell in the EEPROM EEPROM[ index ] += 1; } /*** Iterate the EEPROM using a while loop. ***/ int index = 0; while (index < EEPROM.length()) { //Add one to each cell in the EEPROM EEPROM[ index ] += 1; index++; } /*** Iterate the EEPROM using a do-while loop. ***/ int idx = 0; //Used 'idx' to avoid name conflict with 'index' above. do { //Add one to each cell in the EEPROM EEPROM[ idx ] += 1; idx++; } while (idx < EEPROM.length()); } //End of setup function. void loop() {} Video Demonstration","title":"Eeprom iteration"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_iteration/#sketch-code","text":"/*** eeprom_iteration example. A set of example snippets highlighting the simplest methods for traversing the EEPROM. Running this sketch is not necessary, this is simply highlighting certain programming methods. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> void setup() { /*** Iterate the EEPROM using a for loop. ***/ for (int index = 0 ; index < EEPROM.length() ; index++) { //Add one to each cell in the EEPROM EEPROM[ index ] += 1; } /*** Iterate the EEPROM using a while loop. ***/ int index = 0; while (index < EEPROM.length()) { //Add one to each cell in the EEPROM EEPROM[ index ] += 1; index++; } /*** Iterate the EEPROM using a do-while loop. ***/ int idx = 0; //Used 'idx' to avoid name conflict with 'index' above. do { //Add one to each cell in the EEPROM EEPROM[ idx ] += 1; idx++; } while (idx < EEPROM.length()); } //End of setup function. void loop() {}","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_iteration/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_put/","text":"Sketch Code /*** eeprom_put example. This shows how to use the EEPROM.put() method. Also, this sketch will pre-set the EEPROM data for the example sketch eeprom_get. Note, unlike the single byte version EEPROM.write(), the put method will use update semantics. As in a byte will only be written to the EEPROM if the data is actually different. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> struct MyObject { float field1; byte field2; char name[10]; }; void setup() { Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } float f = 123.456f; //Variable to store in EEPROM. int eeAddress = 0; //Location we want the data to be put. //One simple call, with the address first and the object second. EEPROM.put(eeAddress, f); Serial.println(\"Written float data type!\"); /** Put is designed for use with custom structures also. **/ //Data to store. MyObject customVar = { 3.14f, 65, \"Working!\" }; eeAddress += sizeof(float); //Move address to the next byte after float 'f'. EEPROM.put(eeAddress, customVar); Serial.print(\"Written custom data type! \\n\\nView the example sketch eeprom_get to see how you can retrieve the values!\"); } void loop() { /* Empty loop */ } Video Demonstration","title":"Eeprom put"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_put/#sketch-code","text":"/*** eeprom_put example. This shows how to use the EEPROM.put() method. Also, this sketch will pre-set the EEPROM data for the example sketch eeprom_get. Note, unlike the single byte version EEPROM.write(), the put method will use update semantics. As in a byte will only be written to the EEPROM if the data is actually different. Written by Christopher Andrews 2015 Released under MIT licence. ***/ #include <EEPROM.h> struct MyObject { float field1; byte field2; char name[10]; }; void setup() { Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } float f = 123.456f; //Variable to store in EEPROM. int eeAddress = 0; //Location we want the data to be put. //One simple call, with the address first and the object second. EEPROM.put(eeAddress, f); Serial.println(\"Written float data type!\"); /** Put is designed for use with custom structures also. **/ //Data to store. MyObject customVar = { 3.14f, 65, \"Working!\" }; eeAddress += sizeof(float); //Move address to the next byte after float 'f'. EEPROM.put(eeAddress, customVar); Serial.print(\"Written custom data type! \\n\\nView the example sketch eeprom_get to see how you can retrieve the values!\"); } void loop() { /* Empty loop */ }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_put/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_read/","text":"Sketch Code /* EEPROM Read Reads the value of each byte of the EEPROM and prints it to the computer. This example code is in the public domain. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom */ // Include the EEPROM library #include <EEPROM.h> // start reading from the first byte (address 0) of the EEPROM int address = 0; byte value; void setup() { // initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } } void loop() { // read a byte from the current address of the EEPROM value = EEPROM.read(address); Serial.print(address); Serial.print(\"\\t\"); Serial.print(value, DEC); Serial.println(); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM.length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM.length() - 1; ***/ delay(500); } Video Demonstration","title":"Eeprom read"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_read/#sketch-code","text":"/* EEPROM Read Reads the value of each byte of the EEPROM and prints it to the computer. This example code is in the public domain. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom */ // Include the EEPROM library #include <EEPROM.h> // start reading from the first byte (address 0) of the EEPROM int address = 0; byte value; void setup() { // initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } } void loop() { // read a byte from the current address of the EEPROM value = EEPROM.read(address); Serial.print(address); Serial.print(\"\\t\"); Serial.print(value, DEC); Serial.println(); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM.length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM.length() - 1; ***/ delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_read/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_update/","text":"Sketch Code /*** EEPROM Update method Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. If a value has not changed in the EEPROM, it is not overwritten which would reduce the life span of the EEPROM unnecessarily. Released using MIT licence. ***/ #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int address = 0; void setup() { /** Empty setup **/ } void loop() { /*** need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Update the particular EEPROM cell. these values will remain there when the board is turned off. ***/ EEPROM.update(address, val); /*** The function EEPROM.update(address, val) is equivalent to the following: if( EEPROM.read(address) != val ){ EEPROM.write(address, val); } ***/ /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM.length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM.length() - 1; ***/ delay(100); } Video Demonstration","title":"Eeprom update"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_update/#sketch-code","text":"/*** EEPROM Update method Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. If a value has not changed in the EEPROM, it is not overwritten which would reduce the life span of the EEPROM unnecessarily. Released using MIT licence. ***/ #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int address = 0; void setup() { /** Empty setup **/ } void loop() { /*** need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Update the particular EEPROM cell. these values will remain there when the board is turned off. ***/ EEPROM.update(address, val); /*** The function EEPROM.update(address, val) is equivalent to the following: if( EEPROM.read(address) != val ){ EEPROM.write(address, val); } ***/ /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ address = address + 1; if (address == EEPROM.length()) { address = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++address &= EEPROM.length() - 1; ***/ delay(100); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_update/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_write/","text":"Sketch Code /* EEPROM Write Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom */ // Include the EEPROM library #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int addr = 0; void setup() { /** Empty setup. **/ } void loop() { /*** Need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Write the value to the appropriate byte of the EEPROM. these values will remain there when the board is turned off. ***/ EEPROM.write(addr, val); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ addr = addr + 1; if (addr == EEPROM.length()) { addr = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++addr &= EEPROM.length() - 1; ***/ delay(100); } Video Demonstration","title":"Eeprom write"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_write/#sketch-code","text":"/* EEPROM Write Stores values read from analog input 0 into the EEPROM. These values will stay in the EEPROM when the board is turned off and may be retrieved later by another sketch. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom */ // Include the EEPROM library #include <EEPROM.h> /** the current address in the EEPROM (i.e. which byte we're going to write to next) **/ int addr = 0; void setup() { /** Empty setup. **/ } void loop() { /*** Need to divide by 4 because analog inputs range from 0 to 1023 and each byte of the EEPROM can only hold a value from 0 to 255. ***/ int val = analogRead(0) / 4; /*** Write the value to the appropriate byte of the EEPROM. these values will remain there when the board is turned off. ***/ EEPROM.write(addr, val); /*** Advance to the next address, when at the end restart at the beginning. Larger AVR processors have larger EEPROM sizes, E.g: - Arduino Duemilanove: 512 B EEPROM storage. - Arduino Uno: 1 kB EEPROM storage. - Arduino Mega: 4 kB EEPROM storage. Rather than hard-coding the length, you should use the pre-provided length function. This will make your code portable to all AVR processors. ***/ addr = addr + 1; if (addr == EEPROM.length()) { addr = 0; } /*** As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an EEPROM address is also doable by a bitwise and of the length - 1. ++addr &= EEPROM.length() - 1; ***/ delay(100); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/EEPROM/eeprom_write/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/AdvancedChatServer/","text":"Sketch Code /* Advanced Chat Server A more advanced server that distributes any incoming messages to all connected clients but the client the message comes from. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe redesigned to make use of operator== 25 Nov 2013 by Norbert Truchsess */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); EthernetClient clients[8]; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // initialize the Ethernet device Ethernet.begin(mac, ip, myDns, gateway, subnet); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); Serial.print(\"Chat server address:\"); Serial.println(Ethernet.localIP()); } void loop() { // check for any new client connecting, and say hello (before any incoming data) EthernetClient newClient = server.accept(); if (newClient) { for (byte i=0; i < 8; i++) { if (!clients[i]) { Serial.print(\"We have a new client #\"); Serial.println(i); newClient.print(\"Hello, client number: \"); newClient.println(i); // Once we \"accept\", the client is no longer tracked by EthernetServer // so we must store it into our list of clients clients[i] = newClient; break; } } } // check for incoming data from all clients for (byte i=0; i < 8; i++) { if (clients[i] && clients[i].available() > 0) { // read bytes from a client byte buffer[80]; int count = clients[i].read(buffer, 80); // write the bytes to all other connected clients for (byte j=0; j < 8; j++) { if (j != i && clients[j].connected()) { clients[j].write(buffer, count); } } } } // stop any clients which disconnect for (byte i=0; i < 8; i++) { if (clients[i] && !clients[i].connected()) { Serial.print(\"disconnect client #\"); Serial.println(i); clients[i].stop(); } } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"AdvancedChatServer"},{"location":"05_examples_uno_r4_wifi/Ethernet/AdvancedChatServer/#sketch-code","text":"/* Advanced Chat Server A more advanced server that distributes any incoming messages to all connected clients but the client the message comes from. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe redesigned to make use of operator== 25 Nov 2013 by Norbert Truchsess */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); EthernetClient clients[8]; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // initialize the Ethernet device Ethernet.begin(mac, ip, myDns, gateway, subnet); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); Serial.print(\"Chat server address:\"); Serial.println(Ethernet.localIP()); } void loop() { // check for any new client connecting, and say hello (before any incoming data) EthernetClient newClient = server.accept(); if (newClient) { for (byte i=0; i < 8; i++) { if (!clients[i]) { Serial.print(\"We have a new client #\"); Serial.println(i); newClient.print(\"Hello, client number: \"); newClient.println(i); // Once we \"accept\", the client is no longer tracked by EthernetServer // so we must store it into our list of clients clients[i] = newClient; break; } } } // check for incoming data from all clients for (byte i=0; i < 8; i++) { if (clients[i] && clients[i].available() > 0) { // read bytes from a client byte buffer[80]; int count = clients[i].read(buffer, 80); // write the bytes to all other connected clients for (byte j=0; j < 8; j++) { if (j != i && clients[j].connected()) { clients[j].write(buffer, count); } } } } // stop any clients which disconnect for (byte i=0; i < 8; i++) { if (clients[i] && !clients[i].connected()) { Serial.print(\"disconnect client #\"); Serial.println(i); clients[i].stop(); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/AdvancedChatServer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/AdvancedChatServer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/AdvancedChatServer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/BarometricPressureWebServer/","text":"Sketch Code /* SCP1000 Barometric Pressure Sensor Display Serves the output of a Barometric Pressure Sensor as a web page. Uses the SPI library. For details on the sensor, see: http://www.sparkfun.com/commerce/product_info.php?products_id=8161 This sketch adapted from Nathan Seidle's SCP1000 example for PIC: http://www.sparkfun.com/datasheets/Sensors/SCP1000-Testing.zip TODO: this hardware is long obsolete. This example program should be rewritten to use https://www.sparkfun.com/products/9721 Circuit: SCP1000 sensor attached to pins 6,7, and 11 - 13: DRDY: pin 6 CSB: pin 7 MOSI: pin 11 MISO: pin 12 SCK: pin 13 created 31 July 2010 by Tom Igoe */ #include <Ethernet.h> // the sensor communicates using SPI, so include the library: #include <SPI.h> // assign a MAC address for the Ethernet controller. // fill in your address here: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // assign an IP address for the controller: IPAddress ip(192, 168, 1, 20); // Initialize the Ethernet server library // with the IP address and port you want to use // (port 80 is default for HTTP): EthernetServer server(80); //Sensor's memory register addresses: const int PRESSURE = 0x1F; //3 most significant bits of pressure const int PRESSURE_LSB = 0x20; //16 least significant bits of pressure const int TEMPERATURE = 0x21; //16 bit temperature reading // pins used for the connection with the sensor // the others you need are controlled by the SPI library): const int dataReadyPin = 6; const int chipSelectPin = 7; float temperature = 0.0; long pressure = 0; long lastReadingTime = 0; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the SPI library: SPI.begin(); // start the Ethernet connection Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); // initialize the data ready and chip select pins: pinMode(dataReadyPin, INPUT); pinMode(chipSelectPin, OUTPUT); //Configure SCP1000 for low noise configuration: writeRegister(0x02, 0x2D); writeRegister(0x01, 0x03); writeRegister(0x03, 0x02); // give the sensor and Ethernet shield time to set up: delay(1000); //Set the sensor to high resolution mode to start readings: writeRegister(0x03, 0x0A); } void loop() { // check for a reading no more than once a second. if (millis() - lastReadingTime > 1000) { // if there's a reading ready, read it: // don't do anything until the data ready pin is high: if (digitalRead(dataReadyPin) == HIGH) { getData(); // timestamp the last time you got a reading: lastReadingTime = millis(); } } // listen for incoming Ethernet connections: listenForEthernetClients(); } void getData() { Serial.println(\"Getting reading\"); //Read the temperature data int tempData = readRegister(0x21, 2); // convert the temperature to Celsius and display it: temperature = (float)tempData / 20.0; //Read the pressure data highest 3 bits: byte pressureDataHigh = readRegister(0x1F, 1); pressureDataHigh &= 0b00000111; //you only needs bits 2 to 0 //Read the pressure data lower 16 bits: unsigned int pressureDataLow = readRegister(0x20, 2); //combine the two parts into one 19-bit number: pressure = ((pressureDataHigh << 16) | pressureDataLow) / 4; Serial.print(\"Temperature: \"); Serial.print(temperature); Serial.println(\" degrees C\"); Serial.print(\"Pressure: \" + String(pressure)); Serial.println(\" Pa\"); } void listenForEthernetClients() { // listen for incoming clients EthernetClient client = server.available(); if (client) { Serial.println(\"Got a client\"); // an HTTP request ends with a blank line bool currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(); // print the current readings, in HTML format: client.print(\"Temperature: \"); client.print(temperature); client.print(\" degrees C\"); client.println(\"<br />\"); client.print(\"Pressure: \" + String(pressure)); client.print(\" Pa\"); client.println(\"<br />\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); } } //Send a write command to SCP1000 void writeRegister(byte registerName, byte registerValue) { // SCP1000 expects the register name in the upper 6 bits // of the byte: registerName <<= 2; // command (read or write) goes in the lower two bits: registerName |= 0b00000010; //Write command // take the chip select low to select the device: digitalWrite(chipSelectPin, LOW); SPI.transfer(registerName); //Send register location SPI.transfer(registerValue); //Send value to record into register // take the chip select high to de-select: digitalWrite(chipSelectPin, HIGH); } //Read register from the SCP1000: unsigned int readRegister(byte registerName, int numBytes) { byte inByte = 0; // incoming from the SPI read unsigned int result = 0; // result to return // SCP1000 expects the register name in the upper 6 bits // of the byte: registerName <<= 2; // command (read or write) goes in the lower two bits: registerName &= 0b11111100; //Read command // take the chip select low to select the device: digitalWrite(chipSelectPin, LOW); // send the device the register you want to read: SPI.transfer(registerName); // send a value of 0 to read the first byte returned: inByte = SPI.transfer(0x00); result = inByte; // if there's more than one byte returned, // shift the first byte then get the second byte: if (numBytes > 1) { result = inByte << 8; inByte = SPI.transfer(0x00); result = result | inByte; } // take the chip select high to de-select: digitalWrite(chipSelectPin, HIGH); // return the result: return (result); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"BarometricPressureWebServer"},{"location":"05_examples_uno_r4_wifi/Ethernet/BarometricPressureWebServer/#sketch-code","text":"/* SCP1000 Barometric Pressure Sensor Display Serves the output of a Barometric Pressure Sensor as a web page. Uses the SPI library. For details on the sensor, see: http://www.sparkfun.com/commerce/product_info.php?products_id=8161 This sketch adapted from Nathan Seidle's SCP1000 example for PIC: http://www.sparkfun.com/datasheets/Sensors/SCP1000-Testing.zip TODO: this hardware is long obsolete. This example program should be rewritten to use https://www.sparkfun.com/products/9721 Circuit: SCP1000 sensor attached to pins 6,7, and 11 - 13: DRDY: pin 6 CSB: pin 7 MOSI: pin 11 MISO: pin 12 SCK: pin 13 created 31 July 2010 by Tom Igoe */ #include <Ethernet.h> // the sensor communicates using SPI, so include the library: #include <SPI.h> // assign a MAC address for the Ethernet controller. // fill in your address here: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // assign an IP address for the controller: IPAddress ip(192, 168, 1, 20); // Initialize the Ethernet server library // with the IP address and port you want to use // (port 80 is default for HTTP): EthernetServer server(80); //Sensor's memory register addresses: const int PRESSURE = 0x1F; //3 most significant bits of pressure const int PRESSURE_LSB = 0x20; //16 least significant bits of pressure const int TEMPERATURE = 0x21; //16 bit temperature reading // pins used for the connection with the sensor // the others you need are controlled by the SPI library): const int dataReadyPin = 6; const int chipSelectPin = 7; float temperature = 0.0; long pressure = 0; long lastReadingTime = 0; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the SPI library: SPI.begin(); // start the Ethernet connection Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); // initialize the data ready and chip select pins: pinMode(dataReadyPin, INPUT); pinMode(chipSelectPin, OUTPUT); //Configure SCP1000 for low noise configuration: writeRegister(0x02, 0x2D); writeRegister(0x01, 0x03); writeRegister(0x03, 0x02); // give the sensor and Ethernet shield time to set up: delay(1000); //Set the sensor to high resolution mode to start readings: writeRegister(0x03, 0x0A); } void loop() { // check for a reading no more than once a second. if (millis() - lastReadingTime > 1000) { // if there's a reading ready, read it: // don't do anything until the data ready pin is high: if (digitalRead(dataReadyPin) == HIGH) { getData(); // timestamp the last time you got a reading: lastReadingTime = millis(); } } // listen for incoming Ethernet connections: listenForEthernetClients(); } void getData() { Serial.println(\"Getting reading\"); //Read the temperature data int tempData = readRegister(0x21, 2); // convert the temperature to Celsius and display it: temperature = (float)tempData / 20.0; //Read the pressure data highest 3 bits: byte pressureDataHigh = readRegister(0x1F, 1); pressureDataHigh &= 0b00000111; //you only needs bits 2 to 0 //Read the pressure data lower 16 bits: unsigned int pressureDataLow = readRegister(0x20, 2); //combine the two parts into one 19-bit number: pressure = ((pressureDataHigh << 16) | pressureDataLow) / 4; Serial.print(\"Temperature: \"); Serial.print(temperature); Serial.println(\" degrees C\"); Serial.print(\"Pressure: \" + String(pressure)); Serial.println(\" Pa\"); } void listenForEthernetClients() { // listen for incoming clients EthernetClient client = server.available(); if (client) { Serial.println(\"Got a client\"); // an HTTP request ends with a blank line bool currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(); // print the current readings, in HTML format: client.print(\"Temperature: \"); client.print(temperature); client.print(\" degrees C\"); client.println(\"<br />\"); client.print(\"Pressure: \" + String(pressure)); client.print(\" Pa\"); client.println(\"<br />\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); } } //Send a write command to SCP1000 void writeRegister(byte registerName, byte registerValue) { // SCP1000 expects the register name in the upper 6 bits // of the byte: registerName <<= 2; // command (read or write) goes in the lower two bits: registerName |= 0b00000010; //Write command // take the chip select low to select the device: digitalWrite(chipSelectPin, LOW); SPI.transfer(registerName); //Send register location SPI.transfer(registerValue); //Send value to record into register // take the chip select high to de-select: digitalWrite(chipSelectPin, HIGH); } //Read register from the SCP1000: unsigned int readRegister(byte registerName, int numBytes) { byte inByte = 0; // incoming from the SPI read unsigned int result = 0; // result to return // SCP1000 expects the register name in the upper 6 bits // of the byte: registerName <<= 2; // command (read or write) goes in the lower two bits: registerName &= 0b11111100; //Read command // take the chip select low to select the device: digitalWrite(chipSelectPin, LOW); // send the device the register you want to read: SPI.transfer(registerName); // send a value of 0 to read the first byte returned: inByte = SPI.transfer(0x00); result = inByte; // if there's more than one byte returned, // shift the first byte then get the second byte: if (numBytes > 1) { result = inByte << 8; inByte = SPI.transfer(0x00); result = result | inByte; } // take the chip select high to de-select: digitalWrite(chipSelectPin, HIGH); // return the result: return (result); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/BarometricPressureWebServer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/BarometricPressureWebServer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/BarometricPressureWebServer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/ChatServer/","text":"Sketch Code /* Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); bool alreadyConnected = false; // whether or not the client was connected previously void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // initialize the Ethernet device Ethernet.begin(mac, ip, myDns, gateway, subnet); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); Serial.print(\"Chat server address:\"); Serial.println(Ethernet.localIP()); } void loop() { // wait for a new client: EthernetClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!alreadyConnected) { // clear out the input buffer: client.flush(); Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); alreadyConnected = true; } if (client.available() > 0) { // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.write(thisChar); } } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"ChatServer"},{"location":"05_examples_uno_r4_wifi/Ethernet/ChatServer/#sketch-code","text":"/* Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); bool alreadyConnected = false; // whether or not the client was connected previously void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // initialize the Ethernet device Ethernet.begin(mac, ip, myDns, gateway, subnet); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start listening for clients server.begin(); Serial.print(\"Chat server address:\"); Serial.println(Ethernet.localIP()); } void loop() { // wait for a new client: EthernetClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!alreadyConnected) { // clear out the input buffer: client.flush(); Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); alreadyConnected = true; } if (client.available() > 0) { // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.write(thisChar); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/ChatServer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/ChatServer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/ChatServer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpAddressPrinter/","text":"Sketch Code /* DHCP-based IP printer This sketch uses the DHCP extensions to the Ethernet library to get an IP address via DHCP and print the address obtained. using an Arduino WIZnet Ethernet shield. Circuit: Ethernet shield attached to pins 10, 11, 12, 13 created 12 April 2011 modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); } else if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // no point in carrying on, so do nothing forevermore: while (true) { delay(1); } } // print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); } void loop() { switch (Ethernet.maintain()) { case 1: //renewed fail Serial.println(\"Error: renewed fail\"); break; case 2: //renewed success Serial.println(\"Renewed success\"); //print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); break; case 3: //rebind fail Serial.println(\"Error: rebind fail\"); break; case 4: //rebind success Serial.println(\"Rebind success\"); //print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); break; default: //nothing happened break; } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"DhcpAddressPrinter"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpAddressPrinter/#sketch-code","text":"/* DHCP-based IP printer This sketch uses the DHCP extensions to the Ethernet library to get an IP address via DHCP and print the address obtained. using an Arduino WIZnet Ethernet shield. Circuit: Ethernet shield attached to pins 10, 11, 12, 13 created 12 April 2011 modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); } else if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // no point in carrying on, so do nothing forevermore: while (true) { delay(1); } } // print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); } void loop() { switch (Ethernet.maintain()) { case 1: //renewed fail Serial.println(\"Error: renewed fail\"); break; case 2: //renewed success Serial.println(\"Renewed success\"); //print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); break; case 3: //rebind fail Serial.println(\"Error: rebind fail\"); break; case 4: //rebind success Serial.println(\"Rebind success\"); //print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); break; default: //nothing happened break; } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpAddressPrinter/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpAddressPrinter/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpAddressPrinter/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpChatServer/","text":"Sketch Code /* DHCP Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. THis version attempts to get an IP address using DHCP Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 21 May 2011 modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi Based on ChatServer example by David A. Mellis */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); bool gotAMessage = false; // whether or not you got a message from the client yet void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Trying to get an IP address using DHCP\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // initialize the Ethernet device not using DHCP: Ethernet.begin(mac, ip, myDns, gateway, subnet); } // print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); // start listening for clients server.begin(); } void loop() { // wait for a new client: EthernetClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!gotAMessage) { Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); gotAMessage = true; } // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.print(thisChar); Ethernet.maintain(); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"DhcpChatServer"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpChatServer/#sketch-code","text":"/* DHCP Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. Using an Arduino WIZnet Ethernet shield. THis version attempts to get an IP address using DHCP Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 21 May 2011 modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi Based on ChatServer example by David A. Mellis */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network. // gateway and subnet are optional: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); IPAddress myDns(192, 168, 1, 1); IPAddress gateway(192, 168, 1, 1); IPAddress subnet(255, 255, 0, 0); // telnet defaults to port 23 EthernetServer server(23); bool gotAMessage = false; // whether or not you got a message from the client yet void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Trying to get an IP address using DHCP\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // initialize the Ethernet device not using DHCP: Ethernet.begin(mac, ip, myDns, gateway, subnet); } // print your local IP address: Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); // start listening for clients server.begin(); } void loop() { // wait for a new client: EthernetClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!gotAMessage) { Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); gotAMessage = true; } // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.print(thisChar); Ethernet.maintain(); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpChatServer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpChatServer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/DhcpChatServer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/LinkStatus/","text":"Sketch Code /* Link Status This sketch prints the Ethernet link status. When the Ethernet cable is connected the link status should go to \"ON\". NOTE: Only WIZnet W5200 and W5500 are capable of reporting the link status. W5100 will report \"Unknown\". Hardware: - Ethernet shield or equivalent board/shield with WIZnet W5200/W5500 Written by Cristian Maglie This example is public domain. */ #include <SPI.h> #include <Ethernet.h> void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet Serial.begin(9600); } void loop() { auto link = Ethernet.linkStatus(); Serial.print(\"Link status: \"); switch (link) { case Unknown: Serial.println(\"Unknown\"); break; case LinkON: Serial.println(\"ON\"); break; case LinkOFF: Serial.println(\"OFF\"); break; } delay(1000); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"LinkStatus"},{"location":"05_examples_uno_r4_wifi/Ethernet/LinkStatus/#sketch-code","text":"/* Link Status This sketch prints the Ethernet link status. When the Ethernet cable is connected the link status should go to \"ON\". NOTE: Only WIZnet W5200 and W5500 are capable of reporting the link status. W5100 will report \"Unknown\". Hardware: - Ethernet shield or equivalent board/shield with WIZnet W5200/W5500 Written by Cristian Maglie This example is public domain. */ #include <SPI.h> #include <Ethernet.h> void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet Serial.begin(9600); } void loop() { auto link = Ethernet.linkStatus(); Serial.print(\"Link status: \"); switch (link) { case Unknown: Serial.println(\"Unknown\"); break; case LinkON: Serial.println(\"ON\"); break; case LinkOFF: Serial.println(\"OFF\"); break; } delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/LinkStatus/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/LinkStatus/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/LinkStatus/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/PagerServer/","text":"Sketch Code /* Pager Server A simple server that echoes any incoming messages to all connected clients. Connect two or more telnet sessions to see how server.available() and server.print() works. created in September 2020 for the Ethernet library by Juraj Andrassy https://github.com/jandrassy */ #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); EthernetServer server(2323); void setup() { Serial.begin(9600); while (!Serial); // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } server.begin(); IPAddress ip = Ethernet.localIP(); Serial.println(); Serial.print(\"To access the server, connect with Telnet client to \"); Serial.print(ip); Serial.println(\" 2323\"); } void loop() { EthernetClient client = server.available(); // returns first client which has data to read or a 'false' client if (client) { // client is true only if it is connected and has data to read String s = client.readStringUntil('\\n'); // read the message incoming from one of the clients s.trim(); // trim eventual \\r Serial.println(s); // print the message to Serial Monitor client.print(\"echo: \"); // this is only for the sending client server.println(s); // send the message to all connected clients #ifndef ARDUINO_ARCH_SAM server.flush(); // flush the buffers #endif /* !defined(ARDUINO_ARCH_SAM) */ } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"PagerServer"},{"location":"05_examples_uno_r4_wifi/Ethernet/PagerServer/#sketch-code","text":"/* Pager Server A simple server that echoes any incoming messages to all connected clients. Connect two or more telnet sessions to see how server.available() and server.print() works. created in September 2020 for the Ethernet library by Juraj Andrassy https://github.com/jandrassy */ #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); EthernetServer server(2323); void setup() { Serial.begin(9600); while (!Serial); // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } server.begin(); IPAddress ip = Ethernet.localIP(); Serial.println(); Serial.print(\"To access the server, connect with Telnet client to \"); Serial.print(ip); Serial.println(\" 2323\"); } void loop() { EthernetClient client = server.available(); // returns first client which has data to read or a 'false' client if (client) { // client is true only if it is connected and has data to read String s = client.readStringUntil('\\n'); // read the message incoming from one of the clients s.trim(); // trim eventual \\r Serial.println(s); // print the message to Serial Monitor client.print(\"echo: \"); // this is only for the sending client server.println(s); // send the message to all connected clients #ifndef ARDUINO_ARCH_SAM server.flush(); // flush the buffers #endif /* !defined(ARDUINO_ARCH_SAM) */ } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/PagerServer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/PagerServer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/PagerServer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/TelnetClient/","text":"Sketch Code /* Telnet client This sketch connects to a telnet server (http://www.google.com) using an Arduino WIZnet Ethernet shield. You'll need a telnet server to test this with. Processing's ChatServer example (part of the Network library) works well, running on port 10002. It can be found as part of the examples in the Processing application, available at https://processing.org/ Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 14 Sep 2010 modified 9 Apr 2012 by Tom Igoe */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); // Enter the IP address of the server you're connecting to: IPAddress server(1, 1, 1, 1); // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 23 is default for telnet; // if you're using Processing's ChatServer, use port 10002): EthernetClient client; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the Ethernet connection: Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } while (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); delay(500); } // give the Ethernet shield a second to initialize: delay(1000); Serial.println(\"connecting...\"); // if you get a connection, report back via serial: if (client.connect(server, 10002)) { Serial.println(\"connected\"); } else { // if you didn't get a connection to the server: Serial.println(\"connection failed\"); } } void loop() { // if there are incoming bytes available // from the server, read them and print them: if (client.available()) { char c = client.read(); Serial.print(c); } // as long as there are bytes in the serial queue, // read them and send them out the socket if it's open: while (Serial.available() > 0) { char inChar = Serial.read(); if (client.connected()) { client.print(inChar); } } // if the server's disconnected, stop the client: if (!client.connected()) { Serial.println(); Serial.println(\"disconnecting.\"); client.stop(); // do nothing: while (true) { delay(1); } } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"TelnetClient"},{"location":"05_examples_uno_r4_wifi/Ethernet/TelnetClient/#sketch-code","text":"/* Telnet client This sketch connects to a telnet server (http://www.google.com) using an Arduino WIZnet Ethernet shield. You'll need a telnet server to test this with. Processing's ChatServer example (part of the Network library) works well, running on port 10002. It can be found as part of the examples in the Processing application, available at https://processing.org/ Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 14 Sep 2010 modified 9 Apr 2012 by Tom Igoe */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); // Enter the IP address of the server you're connecting to: IPAddress server(1, 1, 1, 1); // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 23 is default for telnet; // if you're using Processing's ChatServer, use port 10002): EthernetClient client; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the Ethernet connection: Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } while (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); delay(500); } // give the Ethernet shield a second to initialize: delay(1000); Serial.println(\"connecting...\"); // if you get a connection, report back via serial: if (client.connect(server, 10002)) { Serial.println(\"connected\"); } else { // if you didn't get a connection to the server: Serial.println(\"connection failed\"); } } void loop() { // if there are incoming bytes available // from the server, read them and print them: if (client.available()) { char c = client.read(); Serial.print(c); } // as long as there are bytes in the serial queue, // read them and send them out the socket if it's open: while (Serial.available() > 0) { char inChar = Serial.read(); if (client.connected()) { client.print(inChar); } } // if the server's disconnected, stop the client: if (!client.connected()) { Serial.println(); Serial.println(\"disconnecting.\"); client.stop(); // do nothing: while (true) { delay(1); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/TelnetClient/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/TelnetClient/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/TelnetClient/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/UDPSendReceiveString/","text":"Sketch Code /* UDPSendReceiveString This sketch receives UDP message strings, prints them to the serial port and sends an \"acknowledge\" string back to the sender A Processing sketch is included at the end of file that can be used to send and receive messages for testing with a computer. created 21 Aug 2010 by Michael Margolis This code is in the public domain. */ #include <Ethernet.h> #include <EthernetUdp.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); unsigned int localPort = 8888; // local port to listen on // buffers for receiving and sending data char packetBuffer[UDP_TX_PACKET_MAX_SIZE]; // buffer to hold incoming packet, char ReplyBuffer[] = \"acknowledged\"; // a string to send back // An EthernetUDP instance to let us send and receive packets over UDP EthernetUDP Udp; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the Ethernet Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start UDP Udp.begin(localPort); } void loop() { // if there's data available, read a packet int packetSize = Udp.parsePacket(); if (packetSize) { Serial.print(\"Received packet of size \"); Serial.println(packetSize); Serial.print(\"From \"); IPAddress remote = Udp.remoteIP(); for (int i=0; i < 4; i++) { Serial.print(remote[i], DEC); if (i < 3) { Serial.print(\".\"); } } Serial.print(\", port \"); Serial.println(Udp.remotePort()); // read the packet into packetBuffer Udp.read(packetBuffer, UDP_TX_PACKET_MAX_SIZE); Serial.println(\"Contents:\"); Serial.println(packetBuffer); // send a reply to the IP address and port that sent us the packet we received Udp.beginPacket(Udp.remoteIP(), Udp.remotePort()); Udp.write(ReplyBuffer); Udp.endPacket(); } delay(10); } /* Processing sketch to run with this example ===================================================== // Processing UDP example to send and receive string data from Arduino // press any key to send the \"Hello Arduino\" message import hypermedia.net.*; UDP udp; // define the UDP object void setup() { udp = new UDP( this, 6000 ); // create a new datagram connection on port 6000 //udp.log( true ); // <-- printout the connection activity udp.listen( true ); // and wait for incoming message } void draw() { } void keyPressed() { String ip = \"192.168.1.177\"; // the remote IP address int port = 8888; // the destination port udp.send(\"Hello World\", ip, port ); // the message to send } void receive( byte[] data ) { // <-- default handler //void receive( byte[] data, String ip, int port ) { // <-- extended handler for(int i=0; i < data.length; i++) print(char(data[i])); println(); } */ Fritzing Circuit KiCad Schematic Video Demonstration","title":"UDPSendReceiveString"},{"location":"05_examples_uno_r4_wifi/Ethernet/UDPSendReceiveString/#sketch-code","text":"/* UDPSendReceiveString This sketch receives UDP message strings, prints them to the serial port and sends an \"acknowledge\" string back to the sender A Processing sketch is included at the end of file that can be used to send and receive messages for testing with a computer. created 21 Aug 2010 by Michael Margolis This code is in the public domain. */ #include <Ethernet.h> #include <EthernetUdp.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); unsigned int localPort = 8888; // local port to listen on // buffers for receiving and sending data char packetBuffer[UDP_TX_PACKET_MAX_SIZE]; // buffer to hold incoming packet, char ReplyBuffer[] = \"acknowledged\"; // a string to send back // An EthernetUDP instance to let us send and receive packets over UDP EthernetUDP Udp; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start the Ethernet Ethernet.begin(mac, ip); // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start UDP Udp.begin(localPort); } void loop() { // if there's data available, read a packet int packetSize = Udp.parsePacket(); if (packetSize) { Serial.print(\"Received packet of size \"); Serial.println(packetSize); Serial.print(\"From \"); IPAddress remote = Udp.remoteIP(); for (int i=0; i < 4; i++) { Serial.print(remote[i], DEC); if (i < 3) { Serial.print(\".\"); } } Serial.print(\", port \"); Serial.println(Udp.remotePort()); // read the packet into packetBuffer Udp.read(packetBuffer, UDP_TX_PACKET_MAX_SIZE); Serial.println(\"Contents:\"); Serial.println(packetBuffer); // send a reply to the IP address and port that sent us the packet we received Udp.beginPacket(Udp.remoteIP(), Udp.remotePort()); Udp.write(ReplyBuffer); Udp.endPacket(); } delay(10); } /* Processing sketch to run with this example ===================================================== // Processing UDP example to send and receive string data from Arduino // press any key to send the \"Hello Arduino\" message import hypermedia.net.*; UDP udp; // define the UDP object void setup() { udp = new UDP( this, 6000 ); // create a new datagram connection on port 6000 //udp.log( true ); // <-- printout the connection activity udp.listen( true ); // and wait for incoming message } void draw() { } void keyPressed() { String ip = \"192.168.1.177\"; // the remote IP address int port = 8888; // the destination port udp.send(\"Hello World\", ip, port ); // the message to send } void receive( byte[] data ) { // <-- default handler //void receive( byte[] data, String ip, int port ) { // <-- extended handler for(int i=0; i < data.length; i++) print(char(data[i])); println(); } */","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/UDPSendReceiveString/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/UDPSendReceiveString/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/UDPSendReceiveString/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/UdpNtpClient/","text":"Sketch Code /* Udp NTP Client Get the time from a Network Time Protocol (NTP) time server Demonstrates use of UDP sendPacket and ReceivePacket For more on NTP time servers and the messages needed to communicate with them, see https://en.wikipedia.org/wiki/Network_Time_Protocol created 4 Sep 2010 by Michael Margolis modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi This code is in the public domain. */ #include <SPI.h> #include <Ethernet.h> #include <EthernetUdp.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; unsigned int localPort = 8888; // local port to listen for UDP packets const char timeServer[] = \"time.nist.gov\"; // time.nist.gov NTP server const int NTP_PACKET_SIZE = 48; // NTP time stamp is in the first 48 bytes of the message byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming and outgoing packets // A UDP instance to let us send and receive packets over UDP EthernetUDP Udp; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start Ethernet and UDP if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); } else if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // no point in carrying on, so do nothing forevermore: while (true) { delay(1); } } Udp.begin(localPort); } void loop() { sendNTPpacket(timeServer); // send an NTP packet to a time server // wait to see if a reply is available delay(1000); if (Udp.parsePacket()) { // We've received a packet, read the data from it Udp.read(packetBuffer, NTP_PACKET_SIZE); // read the packet into the buffer // the timestamp starts at byte 40 of the received packet and is four bytes, // or two words, long. First, extract the two words: unsigned long highWord = word(packetBuffer[40], packetBuffer[41]); unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]); // combine the four bytes (two words) into a long integer // this is NTP time (seconds since Jan 1 1900): unsigned long secsSince1900 = highWord << 16 | lowWord; Serial.print(\"Seconds since Jan 1 1900 = \"); Serial.println(secsSince1900); // now convert NTP time into everyday time: Serial.print(\"Unix time = \"); // Unix time starts on Jan 1 1970. In seconds, that's 2208988800: const unsigned long seventyYears = 2208988800UL; // subtract seventy years: unsigned long epoch = secsSince1900 - seventyYears; // print Unix time: Serial.println(epoch); // print the hour, minute and second: Serial.print(\"The UTC time is \"); // UTC is the time at Greenwich Meridian (GMT) Serial.print((epoch % 86400L) / 3600); // print the hour (86400 equals secs per day) Serial.print(':'); if (((epoch % 3600) / 60) < 10) { // In the first 10 minutes of each hour, we'll want a leading '0' Serial.print('0'); } Serial.print((epoch % 3600) / 60); // print the minute (3600 equals secs per minute) Serial.print(':'); if ((epoch % 60) < 10) { // In the first 10 seconds of each minute, we'll want a leading '0' Serial.print('0'); } Serial.println(epoch % 60); // print the second } // wait ten seconds before asking for the time again delay(10000); Ethernet.maintain(); } // send an NTP request to the time server at the given address void sendNTPpacket(const char * address) { // set all bytes in the buffer to 0 memset(packetBuffer, 0, NTP_PACKET_SIZE); // Initialize values needed to form NTP request // (see URL above for details on the packets) packetBuffer[0] = 0b11100011; // LI, Version, Mode packetBuffer[1] = 0; // Stratum, or type of clock packetBuffer[2] = 6; // Polling Interval packetBuffer[3] = 0xEC; // Peer Clock Precision // 8 bytes of zero for Root Delay & Root Dispersion packetBuffer[12] = 49; packetBuffer[13] = 0x4E; packetBuffer[14] = 49; packetBuffer[15] = 52; // all NTP fields have been given values, now // you can send a packet requesting a timestamp: Udp.beginPacket(address, 123); // NTP requests are to port 123 Udp.write(packetBuffer, NTP_PACKET_SIZE); Udp.endPacket(); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"UdpNtpClient"},{"location":"05_examples_uno_r4_wifi/Ethernet/UdpNtpClient/#sketch-code","text":"/* Udp NTP Client Get the time from a Network Time Protocol (NTP) time server Demonstrates use of UDP sendPacket and ReceivePacket For more on NTP time servers and the messages needed to communicate with them, see https://en.wikipedia.org/wiki/Network_Time_Protocol created 4 Sep 2010 by Michael Margolis modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi This code is in the public domain. */ #include <SPI.h> #include <Ethernet.h> #include <EthernetUdp.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; unsigned int localPort = 8888; // local port to listen for UDP packets const char timeServer[] = \"time.nist.gov\"; // time.nist.gov NTP server const int NTP_PACKET_SIZE = 48; // NTP time stamp is in the first 48 bytes of the message byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming and outgoing packets // A UDP instance to let us send and receive packets over UDP EthernetUDP Udp; void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start Ethernet and UDP if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); } else if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // no point in carrying on, so do nothing forevermore: while (true) { delay(1); } } Udp.begin(localPort); } void loop() { sendNTPpacket(timeServer); // send an NTP packet to a time server // wait to see if a reply is available delay(1000); if (Udp.parsePacket()) { // We've received a packet, read the data from it Udp.read(packetBuffer, NTP_PACKET_SIZE); // read the packet into the buffer // the timestamp starts at byte 40 of the received packet and is four bytes, // or two words, long. First, extract the two words: unsigned long highWord = word(packetBuffer[40], packetBuffer[41]); unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]); // combine the four bytes (two words) into a long integer // this is NTP time (seconds since Jan 1 1900): unsigned long secsSince1900 = highWord << 16 | lowWord; Serial.print(\"Seconds since Jan 1 1900 = \"); Serial.println(secsSince1900); // now convert NTP time into everyday time: Serial.print(\"Unix time = \"); // Unix time starts on Jan 1 1970. In seconds, that's 2208988800: const unsigned long seventyYears = 2208988800UL; // subtract seventy years: unsigned long epoch = secsSince1900 - seventyYears; // print Unix time: Serial.println(epoch); // print the hour, minute and second: Serial.print(\"The UTC time is \"); // UTC is the time at Greenwich Meridian (GMT) Serial.print((epoch % 86400L) / 3600); // print the hour (86400 equals secs per day) Serial.print(':'); if (((epoch % 3600) / 60) < 10) { // In the first 10 minutes of each hour, we'll want a leading '0' Serial.print('0'); } Serial.print((epoch % 3600) / 60); // print the minute (3600 equals secs per minute) Serial.print(':'); if ((epoch % 60) < 10) { // In the first 10 seconds of each minute, we'll want a leading '0' Serial.print('0'); } Serial.println(epoch % 60); // print the second } // wait ten seconds before asking for the time again delay(10000); Ethernet.maintain(); } // send an NTP request to the time server at the given address void sendNTPpacket(const char * address) { // set all bytes in the buffer to 0 memset(packetBuffer, 0, NTP_PACKET_SIZE); // Initialize values needed to form NTP request // (see URL above for details on the packets) packetBuffer[0] = 0b11100011; // LI, Version, Mode packetBuffer[1] = 0; // Stratum, or type of clock packetBuffer[2] = 6; // Polling Interval packetBuffer[3] = 0xEC; // Peer Clock Precision // 8 bytes of zero for Root Delay & Root Dispersion packetBuffer[12] = 49; packetBuffer[13] = 0x4E; packetBuffer[14] = 49; packetBuffer[15] = 52; // all NTP fields have been given values, now // you can send a packet requesting a timestamp: Udp.beginPacket(address, 123); // NTP requests are to port 123 Udp.write(packetBuffer, NTP_PACKET_SIZE); Udp.endPacket(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/UdpNtpClient/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/UdpNtpClient/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/UdpNtpClient/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClient/","text":"Sketch Code /* Web client This sketch connects to a website (http://www.google.com) using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe, based on work by Adrian McEwen */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // if you don't want to use DNS (and reduce your sketch size) // use the numeric IP instead of the name for the server: //IPAddress server(74,125,232,128); // numeric IP for Google (no DNS) char server[] = \"www.google.com\"; // name address for Google (using DNS) // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); IPAddress myDns(192, 168, 0, 1); // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 80 is default for HTTP): EthernetClient client; // Variables to measure the speed unsigned long beginMicros, endMicros; unsigned long byteCount = 0; bool printWebData = true; // set to false for better speed measurement void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip, myDns); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } // give the Ethernet shield a second to initialize: delay(1000); Serial.print(\"connecting to \"); Serial.print(server); Serial.println(\"...\"); // if you get a connection, report back via serial: if (client.connect(server, 80)) { Serial.print(\"connected to \"); Serial.println(client.remoteIP()); // Make a HTTP request: client.println(\"GET /search?q=arduino HTTP/1.1\"); client.println(\"Host: www.google.com\"); client.println(\"Connection: close\"); client.println(); } else { // if you didn't get a connection to the server: Serial.println(\"connection failed\"); } beginMicros = micros(); } void loop() { // if there are incoming bytes available // from the server, read them and print them: int len = client.available(); if (len > 0) { byte buffer[80]; if (len > 80) len = 80; client.read(buffer, len); if (printWebData) { Serial.write(buffer, len); // show in the serial monitor (slows some boards) } byteCount = byteCount + len; } // if the server's disconnected, stop the client: if (!client.connected()) { endMicros = micros(); Serial.println(); Serial.println(\"disconnecting.\"); client.stop(); Serial.print(\"Received \"); Serial.print(byteCount); Serial.print(\" bytes in \"); float seconds = (float)(endMicros - beginMicros) / 1000000.0; Serial.print(seconds, 4); float rate = (float)byteCount / seconds / 1000.0; Serial.print(\", rate = \"); Serial.print(rate); Serial.print(\" kbytes/second\"); Serial.println(); // do nothing forevermore: while (true) { delay(1); } } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WebClient"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClient/#sketch-code","text":"/* Web client This sketch connects to a website (http://www.google.com) using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe, based on work by Adrian McEwen */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address for your controller below. // Newer Ethernet shields have a MAC address printed on a sticker on the shield byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // if you don't want to use DNS (and reduce your sketch size) // use the numeric IP instead of the name for the server: //IPAddress server(74,125,232,128); // numeric IP for Google (no DNS) char server[] = \"www.google.com\"; // name address for Google (using DNS) // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); IPAddress myDns(192, 168, 0, 1); // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 80 is default for HTTP): EthernetClient client; // Variables to measure the speed unsigned long beginMicros, endMicros; unsigned long byteCount = 0; bool printWebData = true; // set to false for better speed measurement void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip, myDns); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } // give the Ethernet shield a second to initialize: delay(1000); Serial.print(\"connecting to \"); Serial.print(server); Serial.println(\"...\"); // if you get a connection, report back via serial: if (client.connect(server, 80)) { Serial.print(\"connected to \"); Serial.println(client.remoteIP()); // Make a HTTP request: client.println(\"GET /search?q=arduino HTTP/1.1\"); client.println(\"Host: www.google.com\"); client.println(\"Connection: close\"); client.println(); } else { // if you didn't get a connection to the server: Serial.println(\"connection failed\"); } beginMicros = micros(); } void loop() { // if there are incoming bytes available // from the server, read them and print them: int len = client.available(); if (len > 0) { byte buffer[80]; if (len > 80) len = 80; client.read(buffer, len); if (printWebData) { Serial.write(buffer, len); // show in the serial monitor (slows some boards) } byteCount = byteCount + len; } // if the server's disconnected, stop the client: if (!client.connected()) { endMicros = micros(); Serial.println(); Serial.println(\"disconnecting.\"); client.stop(); Serial.print(\"Received \"); Serial.print(byteCount); Serial.print(\" bytes in \"); float seconds = (float)(endMicros - beginMicros) / 1000000.0; Serial.print(seconds, 4); float rate = (float)byteCount / seconds / 1000.0; Serial.print(\", rate = \"); Serial.print(rate); Serial.print(\" kbytes/second\"); Serial.println(); // do nothing forevermore: while (true) { delay(1); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClient/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClient/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClient/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClientRepeating/","text":"Sketch Code /* Repeating Web client This sketch connects to a web server and makes a request using a WIZnet Ethernet shield. You can use the Arduino Ethernet Shield, or the Adafruit Ethernet shield, either one will work, as long as it's got a WIZnet Ethernet module on board. This example uses DNS, by assigning the Ethernet client with a MAC address, IP address, and DNS address. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 19 Apr 2012 by Tom Igoe modified 21 Jan 2014 by Federico Vanzati https://www.arduino.cc/en/Tutorial/WebClientRepeating This code is in the public domain. */ #include <SPI.h> #include <Ethernet.h> // assign a MAC address for the Ethernet controller. // fill in your address here: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); IPAddress myDns(192, 168, 0, 1); // initialize the library instance: EthernetClient client; char server[] = \"www.arduino.cc\"; // also change the Host line in httpRequest() //IPAddress server(64,131,82,241); unsigned long lastConnectionTime = 0; // last time you connected to the server, in milliseconds const unsigned long postingInterval = 10*1000; // delay between updates, in milliseconds void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start serial port: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip, myDns); Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } // give the Ethernet shield a second to initialize: delay(1000); } void loop() { // if there's incoming data from the net connection. // send it out the serial port. This is for debugging // purposes only: if (client.available()) { char c = client.read(); Serial.write(c); } // if ten seconds have passed since your last connection, // then connect again and send data: if (millis() - lastConnectionTime > postingInterval) { httpRequest(); } } // this method makes a HTTP connection to the server: void httpRequest() { // close any connection before send a new request. // This will free the socket on the Ethernet shield client.stop(); // if there's a successful connection: if (client.connect(server, 80)) { Serial.println(\"connecting...\"); // send the HTTP GET request: client.println(\"GET /latest.txt HTTP/1.1\"); client.println(\"Host: www.arduino.cc\"); client.println(\"User-Agent: arduino-ethernet\"); client.println(\"Connection: close\"); client.println(); // note the time that the connection was made: lastConnectionTime = millis(); } else { // if you couldn't make a connection: Serial.println(\"connection failed\"); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WebClientRepeating"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClientRepeating/#sketch-code","text":"/* Repeating Web client This sketch connects to a web server and makes a request using a WIZnet Ethernet shield. You can use the Arduino Ethernet Shield, or the Adafruit Ethernet shield, either one will work, as long as it's got a WIZnet Ethernet module on board. This example uses DNS, by assigning the Ethernet client with a MAC address, IP address, and DNS address. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 created 19 Apr 2012 by Tom Igoe modified 21 Jan 2014 by Federico Vanzati https://www.arduino.cc/en/Tutorial/WebClientRepeating This code is in the public domain. */ #include <SPI.h> #include <Ethernet.h> // assign a MAC address for the Ethernet controller. // fill in your address here: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; // Set the static IP address to use if the DHCP fails to assign IPAddress ip(192, 168, 0, 177); IPAddress myDns(192, 168, 0, 1); // initialize the library instance: EthernetClient client; char server[] = \"www.arduino.cc\"; // also change the Host line in httpRequest() //IPAddress server(64,131,82,241); unsigned long lastConnectionTime = 0; // last time you connected to the server, in milliseconds const unsigned long postingInterval = 10*1000; // delay between updates, in milliseconds void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // start serial port: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // start the Ethernet connection: Serial.println(\"Initialize Ethernet with DHCP:\"); if (Ethernet.begin(mac) == 0) { Serial.println(\"Failed to configure Ethernet using DHCP\"); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // try to configure using IP address instead of DHCP: Ethernet.begin(mac, ip, myDns); Serial.print(\"My IP address: \"); Serial.println(Ethernet.localIP()); } else { Serial.print(\" DHCP assigned IP \"); Serial.println(Ethernet.localIP()); } // give the Ethernet shield a second to initialize: delay(1000); } void loop() { // if there's incoming data from the net connection. // send it out the serial port. This is for debugging // purposes only: if (client.available()) { char c = client.read(); Serial.write(c); } // if ten seconds have passed since your last connection, // then connect again and send data: if (millis() - lastConnectionTime > postingInterval) { httpRequest(); } } // this method makes a HTTP connection to the server: void httpRequest() { // close any connection before send a new request. // This will free the socket on the Ethernet shield client.stop(); // if there's a successful connection: if (client.connect(server, 80)) { Serial.println(\"connecting...\"); // send the HTTP GET request: client.println(\"GET /latest.txt HTTP/1.1\"); client.println(\"Host: www.arduino.cc\"); client.println(\"User-Agent: arduino-ethernet\"); client.println(\"Connection: close\"); client.println(); // note the time that the connection was made: lastConnectionTime = millis(); } else { // if you couldn't make a connection: Serial.println(\"connection failed\"); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClientRepeating/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClientRepeating/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebClientRepeating/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebServer/","text":"Sketch Code /* Web Server A simple web server that shows the value of the analog input pins. using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 * Analog inputs attached to pins A0 through A5 (optional) created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); // Initialize the Ethernet server library // with the IP address and port you want to use // (port 80 is default for HTTP): EthernetServer server(80); void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"Ethernet WebServer Example\"); // start the Ethernet connection and the server: Ethernet.begin(mac, ip); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start the server server.begin(); Serial.print(\"server is at \"); Serial.println(Ethernet.localIP()); } void loop() { // listen for incoming clients EthernetClient client = server.available(); if (client) { Serial.println(\"new client\"); // an HTTP request ends with a blank line bool currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); Serial.write(c); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(\"Connection: close\"); // the connection will be closed after completion of the response client.println(\"Refresh: 5\"); // refresh the page automatically every 5 sec client.println(); client.println(\"<!DOCTYPE HTML>\"); client.println(\"<html>\"); // output the value of each analog input pin for (int analogChannel = 0; analogChannel < 6; analogChannel++) { int sensorReading = analogRead(analogChannel); client.print(\"analog input \"); client.print(analogChannel); client.print(\" is \"); client.print(sensorReading); client.println(\"<br />\"); } client.println(\"</html>\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WebServer"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebServer/#sketch-code","text":"/* Web Server A simple web server that shows the value of the analog input pins. using an Arduino WIZnet Ethernet shield. Circuit: * Ethernet shield attached to pins 10, 11, 12, 13 * Analog inputs attached to pins A0 through A5 (optional) created 18 Dec 2009 by David A. Mellis modified 9 Apr 2012 by Tom Igoe modified 02 Sept 2015 by Arturo Guadalupi */ #include <SPI.h> #include <Ethernet.h> // Enter a MAC address and IP address for your controller below. // The IP address will be dependent on your local network: byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED }; IPAddress ip(192, 168, 1, 177); // Initialize the Ethernet server library // with the IP address and port you want to use // (port 80 is default for HTTP): EthernetServer server(80); void setup() { // You can use Ethernet.init(pin) to configure the CS pin //Ethernet.init(10); // Most Arduino shields //Ethernet.init(5); // MKR ETH Shield //Ethernet.init(0); // Teensy 2.0 //Ethernet.init(20); // Teensy++ 2.0 //Ethernet.init(15); // ESP8266 with Adafruit FeatherWing Ethernet //Ethernet.init(33); // ESP32 with Adafruit FeatherWing Ethernet // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"Ethernet WebServer Example\"); // start the Ethernet connection and the server: Ethernet.begin(mac, ip); // Check for Ethernet hardware present if (Ethernet.hardwareStatus() == EthernetNoHardware) { Serial.println(\"Ethernet shield was not found. Sorry, can't run without hardware. :(\"); while (true) { delay(1); // do nothing, no point running without Ethernet hardware } } if (Ethernet.linkStatus() == LinkOFF) { Serial.println(\"Ethernet cable is not connected.\"); } // start the server server.begin(); Serial.print(\"server is at \"); Serial.println(Ethernet.localIP()); } void loop() { // listen for incoming clients EthernetClient client = server.available(); if (client) { Serial.println(\"new client\"); // an HTTP request ends with a blank line bool currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); Serial.write(c); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(\"Connection: close\"); // the connection will be closed after completion of the response client.println(\"Refresh: 5\"); // refresh the page automatically every 5 sec client.println(); client.println(\"<!DOCTYPE HTML>\"); client.println(\"<html>\"); // output the value of each analog input pin for (int analogChannel = 0; analogChannel < 6; analogChannel++) { int sensorReading = analogRead(analogChannel); client.print(\"analog input \"); client.print(analogChannel); client.print(\" is \"); client.print(sensorReading); client.println(\"<br />\"); } client.println(\"</html>\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); Serial.println(\"client disconnected\"); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebServer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebServer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Ethernet/WebServer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/AllInputsFirmata/","text":"Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* * This firmware reads all inputs and sends them as fast as it can. It was * inspired by the ease-of-use of the Arduino2Max program. * * This example code is in the public domain. */ #include <Firmata.h> byte pin; int analogValue; int previousAnalogValues[TOTAL_ANALOG_PINS]; byte portStatus[TOTAL_PORTS]; // each bit: 1=pin is digital input, 0=other/ignore byte previousPINs[TOTAL_PORTS]; /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you get long, random delays. So only read analogs every 20ms or so */ int samplingInterval = 19; // how often to run the main loop (in ms) void sendPort(byte portNumber, byte portValue) { portValue = portValue & portStatus[portNumber]; if (previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } void setup() { byte i, port, status; Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); for (pin = 0; pin < TOTAL_PINS; pin++) { if IS_PIN_DIGITAL(pin) pinMode(PIN_TO_DIGITAL(pin), INPUT); } for (port = 0; port < TOTAL_PORTS; port++) { status = 0; for (i = 0; i < 8; i++) { if (IS_PIN_DIGITAL(port * 8 + i)) status |= (1 << i); } portStatus[port] = status; } Firmata.begin(57600); } void loop() { byte i; for (i = 0; i < TOTAL_PORTS; i++) { sendPort(i, readPort(i, 0xff)); } /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you get long, random delays. So only read analogs every 20ms or so */ currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; while (Firmata.available()) { Firmata.processInput(); } for (pin = 0; pin < TOTAL_ANALOG_PINS; pin++) { analogValue = analogRead(pin); if (analogValue != previousAnalogValues[pin]) { Firmata.sendAnalog(pin, analogValue); previousAnalogValues[pin] = analogValue; } } } } Video Demonstration","title":"AllInputsFirmata"},{"location":"05_examples_uno_r4_wifi/Firmata/AllInputsFirmata/#sketch-code","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* * This firmware reads all inputs and sends them as fast as it can. It was * inspired by the ease-of-use of the Arduino2Max program. * * This example code is in the public domain. */ #include <Firmata.h> byte pin; int analogValue; int previousAnalogValues[TOTAL_ANALOG_PINS]; byte portStatus[TOTAL_PORTS]; // each bit: 1=pin is digital input, 0=other/ignore byte previousPINs[TOTAL_PORTS]; /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you get long, random delays. So only read analogs every 20ms or so */ int samplingInterval = 19; // how often to run the main loop (in ms) void sendPort(byte portNumber, byte portValue) { portValue = portValue & portStatus[portNumber]; if (previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } void setup() { byte i, port, status; Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); for (pin = 0; pin < TOTAL_PINS; pin++) { if IS_PIN_DIGITAL(pin) pinMode(PIN_TO_DIGITAL(pin), INPUT); } for (port = 0; port < TOTAL_PORTS; port++) { status = 0; for (i = 0; i < 8; i++) { if (IS_PIN_DIGITAL(port * 8 + i)) status |= (1 << i); } portStatus[port] = status; } Firmata.begin(57600); } void loop() { byte i; for (i = 0; i < TOTAL_PORTS; i++) { sendPort(i, readPort(i, 0xff)); } /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you get long, random delays. So only read analogs every 20ms or so */ currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; while (Firmata.available()) { Firmata.processInput(); } for (pin = 0; pin < TOTAL_ANALOG_PINS; pin++) { analogValue = analogRead(pin); if (analogValue != previousAnalogValues[pin]) { Firmata.sendAnalog(pin, analogValue); previousAnalogValues[pin] = analogValue; } } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/AllInputsFirmata/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/AnalogFirmata/","text":"Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This firmware supports as many analog ports as possible, all analog inputs, * four PWM outputs, and two with servo support. * * This example code is in the public domain. */ #include <Servo.h> #include <Firmata.h> /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* servos */ Servo servo9, servo10; // one instance per pin /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting int analogPin = 0; // counter for reading analog pins /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /*============================================================================== * FUNCTIONS *============================================================================*/ void analogWriteCallback(byte pin, int value) { switch (pin) { case 9: servo9.write(value); break; case 10: servo10.write(value); break; case 3: case 5: case 6: case 11: // PWM pins analogWrite(pin, value); break; } } // ----------------------------------------------------------------------------- // sets bits in a bit array (int) to toggle the reporting of the analogIns void reportAnalogCallback(byte pin, int value) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << pin); } else { // everything but 0 enables reporting of that pin analogInputsToReport = analogInputsToReport | (1 << pin); } // TODO: save status to EEPROM here, if changed } /*============================================================================== * SETUP() *============================================================================*/ void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); servo9.attach(9); servo10.attach(10); Firmata.begin(57600); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { while (Firmata.available()) Firmata.processInput(); currentMillis = millis(); if (currentMillis - previousMillis > 20) { previousMillis += 20; // run this every 20ms for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) { if ( analogInputsToReport & (1 << analogPin) ) Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } Video Demonstration","title":"AnalogFirmata"},{"location":"05_examples_uno_r4_wifi/Firmata/AnalogFirmata/#sketch-code","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This firmware supports as many analog ports as possible, all analog inputs, * four PWM outputs, and two with servo support. * * This example code is in the public domain. */ #include <Servo.h> #include <Firmata.h> /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* servos */ Servo servo9, servo10; // one instance per pin /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting int analogPin = 0; // counter for reading analog pins /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /*============================================================================== * FUNCTIONS *============================================================================*/ void analogWriteCallback(byte pin, int value) { switch (pin) { case 9: servo9.write(value); break; case 10: servo10.write(value); break; case 3: case 5: case 6: case 11: // PWM pins analogWrite(pin, value); break; } } // ----------------------------------------------------------------------------- // sets bits in a bit array (int) to toggle the reporting of the analogIns void reportAnalogCallback(byte pin, int value) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << pin); } else { // everything but 0 enables reporting of that pin analogInputsToReport = analogInputsToReport | (1 << pin); } // TODO: save status to EEPROM here, if changed } /*============================================================================== * SETUP() *============================================================================*/ void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); servo9.attach(9); servo10.attach(10); Firmata.begin(57600); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { while (Firmata.available()) Firmata.processInput(); currentMillis = millis(); if (currentMillis - previousMillis > 20) { previousMillis += 20; // run this every 20ms for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) { if ( analogInputsToReport & (1 << analogPin) ) Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/AnalogFirmata/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/EchoString/","text":"Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This sketch accepts strings and raw sysex messages and echos them back. * * This example code is in the public domain. */ #include <Firmata.h> void stringCallback(char *myString) { Firmata.sendString(myString); } void sysexCallback(byte command, byte argc, byte *argv) { Firmata.sendSysex(command, argc, argv); } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(STRING_DATA, stringCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.begin(57600); } void loop() { while (Firmata.available()) { Firmata.processInput(); } } Video Demonstration","title":"EchoString"},{"location":"05_examples_uno_r4_wifi/Firmata/EchoString/#sketch-code","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This sketch accepts strings and raw sysex messages and echos them back. * * This example code is in the public domain. */ #include <Firmata.h> void stringCallback(char *myString) { Firmata.sendString(myString); } void sysexCallback(byte command, byte argc, byte *argv) { Firmata.sendSysex(command, argc, argv); } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(STRING_DATA, stringCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.begin(57600); } void loop() { while (Firmata.available()) { Firmata.processInput(); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/EchoString/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/OldStandardFirmata/","text":"Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. */ /* * This is an old version of StandardFirmata (v2.0). It is kept here because * its the last version that works on an ATMEGA8 chip. Also, it can be used * for host software that has not been updated to a newer version of the * protocol. It also uses the old baud rate of 115200 rather than 57600. */ #include <EEPROM.h> #include <Firmata.h> /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting int analogPin = 0; // counter for reading analog pins /* digital pins */ byte reportPINs[TOTAL_PORTS]; // PIN == input port byte previousPINs[TOTAL_PORTS]; // PIN == input port byte pinStatus[TOTAL_PINS]; // store pin status, default OUTPUT byte portStatus[TOTAL_PORTS]; /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /*============================================================================== * FUNCTIONS *============================================================================*/ void outputPort(byte portNumber, byte portValue) { portValue = portValue & ~ portStatus[portNumber]; if (previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; Firmata.sendDigitalPort(portNumber, portValue); } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { byte i, tmp; for (i = 0; i < TOTAL_PORTS; i++) { if (reportPINs[i]) { switch (i) { case 0: outputPort(0, PIND & ~ B00000011); break; // ignore Rx/Tx 0/1 case 1: outputPort(1, PINB); break; case 2: outputPort(2, PINC); break; } } } } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { byte port = 0; byte offset = 0; if (pin < 8) { port = 0; offset = 0; } else if (pin < 14) { port = 1; offset = 8; } else if (pin < 22) { port = 2; offset = 14; } if (pin > 1) { // ignore RxTx (pins 0 and 1) pinStatus[pin] = mode; switch (mode) { case INPUT: pinMode(pin, INPUT); portStatus[port] = portStatus[port] & ~ (1 << (pin - offset)); break; case OUTPUT: digitalWrite(pin, LOW); // disable PWM case PWM: pinMode(pin, OUTPUT); portStatus[port] = portStatus[port] | (1 << (pin - offset)); break; //case ANALOG: // TODO figure this out default: Firmata.sendString(\"\"); } // TODO: save status to EEPROM here, if changed } } void analogWriteCallback(byte pin, int value) { setPinModeCallback(pin, PIN_MODE_PWM); analogWrite(pin, value); } void digitalWriteCallback(byte port, int value) { switch (port) { case 0: // pins 2-7 (don't change Rx/Tx, pins 0 and 1) // 0xFF03 == B1111111100000011 0x03 == B00000011 PORTD = (value & ~ 0xFF03) | (PORTD & 0x03); break; case 1: // pins 8-13 (14,15 are disabled for the crystal) PORTB = (byte)value; break; case 2: // analog pins used as digital PORTC = (byte)value; break; } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte pin, int value) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << pin); } else { // everything but 0 enables reporting of that pin analogInputsToReport = analogInputsToReport | (1 << pin); } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { reportPINs[port] = (byte)value; if (port == 2) // turn off analog reporting when used as digital analogInputsToReport = 0; } /*============================================================================== * SETUP() *============================================================================*/ void setup() { byte i; Firmata.setFirmwareVersion(2, 0); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); portStatus[0] = B00000011; // ignore Tx/RX pins portStatus[1] = B11000000; // ignore 14/15 pins portStatus[2] = B00000000; // for(i=0; i<TOTAL_PINS; ++i) { // TODO make this work with analogs for (i = 0; i < 14; ++i) { setPinModeCallback(i, OUTPUT); } // set all outputs to 0 to make sure internal pull-up resistors are off PORTB = 0; // pins 8-15 PORTC = 0; // analog port PORTD = 0; // pins 0-7 // TODO rethink the init, perhaps it should report analog on default for (i = 0; i < TOTAL_PORTS; ++i) { reportPINs[i] = false; } // TODO: load state from EEPROM here /* send digital inputs here, if enabled, to set the initial state on the * host computer, since once in the loop(), this firmware will only send * digital data on change. */ if (reportPINs[0]) outputPort(0, PIND & ~ B00000011); // ignore Rx/Tx 0/1 if (reportPINs[1]) outputPort(1, PINB); if (reportPINs[2]) outputPort(2, PINC); Firmata.begin(115200); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); currentMillis = millis(); if (currentMillis - previousMillis > 20) { previousMillis += 20; // run this every 20ms /* SERIALREAD - Serial.read() uses a 128 byte circular buffer, so handle * all serialReads at once, i.e. empty the buffer */ while (Firmata.available()) Firmata.processInput(); /* SEND FTDI WRITE BUFFER - make sure that the FTDI buffer doesn't go over * 60 bytes. use a timer to sending an event character every 4 ms to * trigger the buffer to dump. */ /* ANALOGREAD - right after the event character, do all of the * analogReads(). These only need to be done every 4ms. */ for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) { if ( analogInputsToReport & (1 << analogPin) ) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } } Video Demonstration","title":"OldStandardFirmata"},{"location":"05_examples_uno_r4_wifi/Firmata/OldStandardFirmata/#sketch-code","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. */ /* * This is an old version of StandardFirmata (v2.0). It is kept here because * its the last version that works on an ATMEGA8 chip. Also, it can be used * for host software that has not been updated to a newer version of the * protocol. It also uses the old baud rate of 115200 rather than 57600. */ #include <EEPROM.h> #include <Firmata.h> /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting int analogPin = 0; // counter for reading analog pins /* digital pins */ byte reportPINs[TOTAL_PORTS]; // PIN == input port byte previousPINs[TOTAL_PORTS]; // PIN == input port byte pinStatus[TOTAL_PINS]; // store pin status, default OUTPUT byte portStatus[TOTAL_PORTS]; /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis /*============================================================================== * FUNCTIONS *============================================================================*/ void outputPort(byte portNumber, byte portValue) { portValue = portValue & ~ portStatus[portNumber]; if (previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; Firmata.sendDigitalPort(portNumber, portValue); } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { byte i, tmp; for (i = 0; i < TOTAL_PORTS; i++) { if (reportPINs[i]) { switch (i) { case 0: outputPort(0, PIND & ~ B00000011); break; // ignore Rx/Tx 0/1 case 1: outputPort(1, PINB); break; case 2: outputPort(2, PINC); break; } } } } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { byte port = 0; byte offset = 0; if (pin < 8) { port = 0; offset = 0; } else if (pin < 14) { port = 1; offset = 8; } else if (pin < 22) { port = 2; offset = 14; } if (pin > 1) { // ignore RxTx (pins 0 and 1) pinStatus[pin] = mode; switch (mode) { case INPUT: pinMode(pin, INPUT); portStatus[port] = portStatus[port] & ~ (1 << (pin - offset)); break; case OUTPUT: digitalWrite(pin, LOW); // disable PWM case PWM: pinMode(pin, OUTPUT); portStatus[port] = portStatus[port] | (1 << (pin - offset)); break; //case ANALOG: // TODO figure this out default: Firmata.sendString(\"\"); } // TODO: save status to EEPROM here, if changed } } void analogWriteCallback(byte pin, int value) { setPinModeCallback(pin, PIN_MODE_PWM); analogWrite(pin, value); } void digitalWriteCallback(byte port, int value) { switch (port) { case 0: // pins 2-7 (don't change Rx/Tx, pins 0 and 1) // 0xFF03 == B1111111100000011 0x03 == B00000011 PORTD = (value & ~ 0xFF03) | (PORTD & 0x03); break; case 1: // pins 8-13 (14,15 are disabled for the crystal) PORTB = (byte)value; break; case 2: // analog pins used as digital PORTC = (byte)value; break; } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte pin, int value) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << pin); } else { // everything but 0 enables reporting of that pin analogInputsToReport = analogInputsToReport | (1 << pin); } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { reportPINs[port] = (byte)value; if (port == 2) // turn off analog reporting when used as digital analogInputsToReport = 0; } /*============================================================================== * SETUP() *============================================================================*/ void setup() { byte i; Firmata.setFirmwareVersion(2, 0); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); portStatus[0] = B00000011; // ignore Tx/RX pins portStatus[1] = B11000000; // ignore 14/15 pins portStatus[2] = B00000000; // for(i=0; i<TOTAL_PINS; ++i) { // TODO make this work with analogs for (i = 0; i < 14; ++i) { setPinModeCallback(i, OUTPUT); } // set all outputs to 0 to make sure internal pull-up resistors are off PORTB = 0; // pins 8-15 PORTC = 0; // analog port PORTD = 0; // pins 0-7 // TODO rethink the init, perhaps it should report analog on default for (i = 0; i < TOTAL_PORTS; ++i) { reportPINs[i] = false; } // TODO: load state from EEPROM here /* send digital inputs here, if enabled, to set the initial state on the * host computer, since once in the loop(), this firmware will only send * digital data on change. */ if (reportPINs[0]) outputPort(0, PIND & ~ B00000011); // ignore Rx/Tx 0/1 if (reportPINs[1]) outputPort(1, PINB); if (reportPINs[2]) outputPort(2, PINC); Firmata.begin(115200); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); currentMillis = millis(); if (currentMillis - previousMillis > 20) { previousMillis += 20; // run this every 20ms /* SERIALREAD - Serial.read() uses a 128 byte circular buffer, so handle * all serialReads at once, i.e. empty the buffer */ while (Firmata.available()) Firmata.processInput(); /* SEND FTDI WRITE BUFFER - make sure that the FTDI buffer doesn't go over * 60 bytes. use a timer to sending an event character every 4 ms to * trigger the buffer to dump. */ /* ANALOGREAD - right after the event character, do all of the * analogReads(). These only need to be done every 4ms. */ for (analogPin = 0; analogPin < TOTAL_ANALOG_PINS; analogPin++) { if ( analogInputsToReport & (1 << analogPin) ) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/OldStandardFirmata/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/ServoFirmata/","text":"Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This firmware supports as many servos as possible using the Servo library * included in Arduino 0017 * * This example code is in the public domain. */ #include <Servo.h> #include <Firmata.h> Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte servoCount = 0; void analogWriteCallback(byte pin, int value) { if (IS_PIN_DIGITAL(pin)) { servos[servoPinMap[pin]].write(value); } } void systemResetCallback() { servoCount = 0; } void setup() { byte pin; Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); Firmata.begin(57600); systemResetCallback(); // attach servos from first digital pin up to max number of // servos supported for the board for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { if (servoCount < MAX_SERVOS) { servoPinMap[pin] = servoCount; servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); servoCount++; } } } } void loop() { while (Firmata.available()) Firmata.processInput(); } Video Demonstration","title":"ServoFirmata"},{"location":"05_examples_uno_r4_wifi/Firmata/ServoFirmata/#sketch-code","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* This firmware supports as many servos as possible using the Servo library * included in Arduino 0017 * * This example code is in the public domain. */ #include <Servo.h> #include <Firmata.h> Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte servoCount = 0; void analogWriteCallback(byte pin, int value) { if (IS_PIN_DIGITAL(pin)) { servos[servoPinMap[pin]].write(value); } } void systemResetCallback() { servoCount = 0; } void setup() { byte pin; Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); Firmata.begin(57600); systemResetCallback(); // attach servos from first digital pin up to max number of // servos supported for the board for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { if (servoCount < MAX_SERVOS) { servoPinMap[pin] = servoCount; servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); servoCount++; } } } } void loop() { while (Firmata.available()) Firmata.processInput(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/ServoFirmata/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/SimpleAnalogFirmata/","text":"Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Supports as many analog inputs and analog PWM outputs as possible. * * This example code is in the public domain. */ #include <Firmata.h> byte analogPin = 0; void analogWriteCallback(byte pin, int value) { if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_DIGITAL(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), value); } } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.begin(57600); } void loop() { while (Firmata.available()) { Firmata.processInput(); } // do one analogRead per loop, so if PC is sending a lot of // analog write messages, we will only delay 1 analogRead Firmata.sendAnalog(analogPin, analogRead(analogPin)); analogPin = analogPin + 1; if (analogPin >= TOTAL_ANALOG_PINS) analogPin = 0; } Video Demonstration","title":"SimpleAnalogFirmata"},{"location":"05_examples_uno_r4_wifi/Firmata/SimpleAnalogFirmata/#sketch-code","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Supports as many analog inputs and analog PWM outputs as possible. * * This example code is in the public domain. */ #include <Firmata.h> byte analogPin = 0; void analogWriteCallback(byte pin, int value) { if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_DIGITAL(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), value); } } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.begin(57600); } void loop() { while (Firmata.available()) { Firmata.processInput(); } // do one analogRead per loop, so if PC is sending a lot of // analog write messages, we will only delay 1 analogRead Firmata.sendAnalog(analogPin, analogRead(analogPin)); analogPin = analogPin + 1; if (analogPin >= TOTAL_ANALOG_PINS) analogPin = 0; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/SimpleAnalogFirmata/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/SimpleDigitalFirmata/","text":"Sketch Code /* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Supports as many digital inputs and outputs as possible. * * This example code is in the public domain. */ #include <Firmata.h> byte previousPIN[TOTAL_PORTS]; // PIN means PORT for input byte previousPORT[TOTAL_PORTS]; void outputPort(byte portNumber, byte portValue) { // only send the data when it changes, otherwise you get too many messages! if (previousPIN[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPIN[portNumber] = portValue; } } void setPinModeCallback(byte pin, int mode) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), mode); } } void digitalWriteCallback(byte port, int value) { byte i; byte currentPinValue, previousPinValue; if (port < TOTAL_PORTS && value != previousPORT[port]) { for (i = 0; i < 8; i++) { currentPinValue = (byte) value & (1 << i); previousPinValue = previousPORT[port] & (1 << i); if (currentPinValue != previousPinValue) { digitalWrite(i + (port * 8), currentPinValue); } } previousPORT[port] = value; } } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.begin(57600); } void loop() { byte i; for (i = 0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, 0xff)); } while (Firmata.available()) { Firmata.processInput(); } } Video Demonstration","title":"SimpleDigitalFirmata"},{"location":"05_examples_uno_r4_wifi/Firmata/SimpleDigitalFirmata/#sketch-code","text":"/* * Firmata is a generic protocol for communicating with microcontrollers * from software on a host computer. It is intended to work with * any host computer software package. * * To download a host software package, please click on the following link * to open the list of Firmata client libraries in your default browser. * * https://github.com/firmata/arduino#firmata-client-libraries */ /* Supports as many digital inputs and outputs as possible. * * This example code is in the public domain. */ #include <Firmata.h> byte previousPIN[TOTAL_PORTS]; // PIN means PORT for input byte previousPORT[TOTAL_PORTS]; void outputPort(byte portNumber, byte portValue) { // only send the data when it changes, otherwise you get too many messages! if (previousPIN[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPIN[portNumber] = portValue; } } void setPinModeCallback(byte pin, int mode) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), mode); } } void digitalWriteCallback(byte port, int value) { byte i; byte currentPinValue, previousPinValue; if (port < TOTAL_PORTS && value != previousPORT[port]) { for (i = 0; i < 8; i++) { currentPinValue = (byte) value & (1 << i); previousPinValue = previousPORT[port] & (1 << i); if (currentPinValue != previousPinValue) { digitalWrite(i + (port * 8), currentPinValue); } } previousPORT[port] = value; } } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.begin(57600); } void loop() { byte i; for (i = 0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, 0xff)); } while (Firmata.available()) { Firmata.processInput(); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/SimpleDigitalFirmata/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataBLE/","text":"Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega, // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this: // Serial1.begin(57600); // Firmata.begin(Serial1); // However do not do this if you are using SERIAL_MESSAGE Firmata.begin(57600); while (!Serial) { ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101 } systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif } Video Demonstration","title":"StandardFirmataBLE"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataBLE/#sketch-code","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega, // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this: // Serial1.begin(57600); // Firmata.begin(Serial1); // However do not do this if you are using SERIAL_MESSAGE Firmata.begin(57600); while (!Serial) { ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101 } systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataBLE/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataChipKIT/","text":"Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. Copyright (C) 2015 Brian Schmalz. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ #include <SoftPWMServo.h> // Gives us PWM and Servo on every pin #include <Wire.h> #include <Firmata.h> #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; SoftServo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* Sets a pin that is in Servo mode to a particular output value * (i.e. pulse width). Different boards may have different ways of * setting servo values, so putting it in a function keeps things cleaner. */ void servoWrite(byte pin, int value) { SoftPWMServoPWMWrite(PIN_TO_PWM(pin), value); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); servoWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) servoWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); /* For chipKIT Pi board, we need to use Serial1. All others just use Serial. */ #if defined(_BOARD_CHIPKIT_PI_) Serial1.begin(57600); Firmata.begin(Serial1); #else Firmata.begin(57600); #endif systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } } Video Demonstration","title":"StandardFirmataChipKIT"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataChipKIT/#sketch-code","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. Copyright (C) 2015 Brian Schmalz. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ #include <SoftPWMServo.h> // Gives us PWM and Servo on every pin #include <Wire.h> #include <Firmata.h> #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; SoftServo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* Sets a pin that is in Servo mode to a particular output value * (i.e. pulse width). Different boards may have different ways of * setting servo values, so putting it in a function keeps things cleaner. */ void servoWrite(byte pin, int value) { SoftPWMServoPWMWrite(PIN_TO_PWM(pin), value); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); servoWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) servoWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); /* For chipKIT Pi board, we need to use Serial1. All others just use Serial. */ #if defined(_BOARD_CHIPKIT_PI_) Serial1.begin(57600); Firmata.begin(Serial1); #else Firmata.begin(57600); #endif systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataChipKIT/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataEthernet/","text":"Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2017 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated March 10th, 2020 */ /* README StandardFirmataEthernet is a TCP client/server implementation. You will need a Firmata client library with a network transport that can act as a TCP server or client in order to establish a connection between StandardFirmataEthernet and the Firmata client application. To use StandardFirmataEthernet you will need to have one of the following boards or shields: - Arduino Ethernet shield (or clone) - Arduino Ethernet board (or clone) - Arduino Yun Follow the instructions in the ethernetConfig.h file (ethernetConfig.h tab in Arduino IDE) to configure your particular hardware. NOTE: If you are using an Arduino Ethernet shield you cannot use the following pins on the following boards. Firmata will ignore any requests to use these pins: - Arduino Uno or other ATMega328 boards: (D4, D10, D11, D12, D13) - Arduino Mega: (D4, D10, D50, D51, D52, D53) - Arduino Leonardo: (D4, D10) - Arduino Due: (D4, D10) - Arduino Zero: (D4, D10) If you are using an ArduinoEthernet board, the following pins cannot be used (same as Uno): - D4, D10, D11, D12, D13 */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> /* * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your * connection that may help in the event of connection issues. If defined, some boards may not begin * executing this sketch until the Serial console is opened. */ //#define SERIAL_DEBUG #include \"utility/firmataDebug.h\" // follow the instructions in ethernetConfig.h to configure your particular hardware #include \"ethernetConfig.h\" #include \"utility/EthernetClientStream.h\" #include \"utility/EthernetServerStream.h\" /* * Uncomment the following include to enable interfacing with Serial devices via hardware or * software serial. * * DO NOT uncomment if you are running StandardFirmataEthernet on an Arduino Leonardo, * Arduino Micro or other ATMega32u4-based board or you will not have enough Flash and RAM * remaining to reliably run Firmata. Arduino Yun is okay because it doesn't import the Ethernet * libraries. */ // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. //#include \"utility/SerialFirmata.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #if defined remote_ip && !defined remote_host #ifdef local_ip EthernetClientStream stream(client, local_ip, remote_ip, NULL, network_port); #else EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), remote_ip, NULL, network_port); #endif #endif #if !defined remote_ip && defined remote_host #ifdef local_ip EthernetClientStream stream(client, local_ip, IPAddress(0, 0, 0, 0), remote_host, network_port ); #else EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), IPAddress(0, 0, 0, 0), remote_host, network_port); #endif #endif #if !defined remote_ip && !defined remote_host #ifdef local_ip EthernetServerStream stream(local_ip, network_port); #else EthernetServerStream stream(IPAddress(0, 0, 0, 0), network_port); #endif #endif #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous mode */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Stream output queue using Stream.write() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { // turn on/off reporting reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } #ifdef ETHERNETCLIENTSTREAM_H /* * Called when a TCP connection is either connected or disconnected. * TODO: * - report connected or reconnected state to host (to be added to protocol) * - report current state to host (to be added to protocol) */ void hostConnectionCallback(byte state) { switch (state) { case HOST_CONNECTION_CONNECTED: DEBUG_PRINTLN( \"TCP connection established\" ); break; case HOST_CONNECTION_DISCONNECTED: DEBUG_PRINTLN( \"TCP connection disconnected\" ); break; } } #endif void printEthernetStatus() { DEBUG_PRINT(\"Local IP Address: \"); IPAddress ip = Ethernet.localIP(); DEBUG_PRINTLN(ip); #ifdef remote_ip DEBUG_PRINT(\"Connecting to server at: \"); DEBUG_PRINTLN(remote_ip); #endif } /* * StandardFirmataEthernet communicates with Ethernet shields over SPI. Therefore all * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication. * Additional pins may also need to be ignored depending on the particular board or * shield in use. */ void ignorePins() { #ifdef IS_IGNORE_PIN for (byte i = 0; i < TOTAL_PINS; i++) { if (IS_IGNORE_PIN(i)) { Firmata.setPinMode(i, PIN_MODE_IGNORE); } } #endif #ifdef WIZ5100_ETHERNET // Arduino Ethernet and Arduino EthernetShield have SD SS wired to D4 pinMode(PIN_TO_DIGITAL(4), OUTPUT); // switch off SD card bypassing Firmata digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA #endif #endif // WIZ5100_ETHERNET } void initTransport() { #ifdef ETHERNETCLIENTSTREAM_H stream.attach(hostConnectionCallback); #endif #ifdef YUN_ETHERNET Bridge.begin(); #else #ifdef local_ip Ethernet.begin((uint8_t *)mac, local_ip); //start ethernet #else DEBUG_PRINTLN(\"Local IP will be requested from DHCP...\"); //start ethernet using dhcp if (Ethernet.begin((uint8_t *)mac) == 0) { DEBUG_PRINTLN(\"Failed to configure Ethernet using DHCP\"); } #endif #endif printEthernetStatus(); } void initFirmata() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); ignorePins(); // start up Network Firmata: Firmata.begin(stream); systemResetCallback(); // Initialize default configuration } void setup() { DEBUG_BEGIN(9600); initTransport(); initFirmata(); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * Stream buffer using Stream.write() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif #if !defined local_ip && !defined YUN_ETHERNET // only necessary when using DHCP, ensures local IP is updated appropriately if it changes if (Ethernet.maintain()) { stream.maintain(Ethernet.localIP()); } #endif } Video Demonstration","title":"StandardFirmataEthernet"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataEthernet/#sketch-code","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2017 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated March 10th, 2020 */ /* README StandardFirmataEthernet is a TCP client/server implementation. You will need a Firmata client library with a network transport that can act as a TCP server or client in order to establish a connection between StandardFirmataEthernet and the Firmata client application. To use StandardFirmataEthernet you will need to have one of the following boards or shields: - Arduino Ethernet shield (or clone) - Arduino Ethernet board (or clone) - Arduino Yun Follow the instructions in the ethernetConfig.h file (ethernetConfig.h tab in Arduino IDE) to configure your particular hardware. NOTE: If you are using an Arduino Ethernet shield you cannot use the following pins on the following boards. Firmata will ignore any requests to use these pins: - Arduino Uno or other ATMega328 boards: (D4, D10, D11, D12, D13) - Arduino Mega: (D4, D10, D50, D51, D52, D53) - Arduino Leonardo: (D4, D10) - Arduino Due: (D4, D10) - Arduino Zero: (D4, D10) If you are using an ArduinoEthernet board, the following pins cannot be used (same as Uno): - D4, D10, D11, D12, D13 */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> /* * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your * connection that may help in the event of connection issues. If defined, some boards may not begin * executing this sketch until the Serial console is opened. */ //#define SERIAL_DEBUG #include \"utility/firmataDebug.h\" // follow the instructions in ethernetConfig.h to configure your particular hardware #include \"ethernetConfig.h\" #include \"utility/EthernetClientStream.h\" #include \"utility/EthernetServerStream.h\" /* * Uncomment the following include to enable interfacing with Serial devices via hardware or * software serial. * * DO NOT uncomment if you are running StandardFirmataEthernet on an Arduino Leonardo, * Arduino Micro or other ATMega32u4-based board or you will not have enough Flash and RAM * remaining to reliably run Firmata. Arduino Yun is okay because it doesn't import the Ethernet * libraries. */ // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. //#include \"utility/SerialFirmata.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #if defined remote_ip && !defined remote_host #ifdef local_ip EthernetClientStream stream(client, local_ip, remote_ip, NULL, network_port); #else EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), remote_ip, NULL, network_port); #endif #endif #if !defined remote_ip && defined remote_host #ifdef local_ip EthernetClientStream stream(client, local_ip, IPAddress(0, 0, 0, 0), remote_host, network_port ); #else EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), IPAddress(0, 0, 0, 0), remote_host, network_port); #endif #endif #if !defined remote_ip && !defined remote_host #ifdef local_ip EthernetServerStream stream(local_ip, network_port); #else EthernetServerStream stream(IPAddress(0, 0, 0, 0), network_port); #endif #endif #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous mode */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Stream output queue using Stream.write() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { // turn on/off reporting reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } #ifdef ETHERNETCLIENTSTREAM_H /* * Called when a TCP connection is either connected or disconnected. * TODO: * - report connected or reconnected state to host (to be added to protocol) * - report current state to host (to be added to protocol) */ void hostConnectionCallback(byte state) { switch (state) { case HOST_CONNECTION_CONNECTED: DEBUG_PRINTLN( \"TCP connection established\" ); break; case HOST_CONNECTION_DISCONNECTED: DEBUG_PRINTLN( \"TCP connection disconnected\" ); break; } } #endif void printEthernetStatus() { DEBUG_PRINT(\"Local IP Address: \"); IPAddress ip = Ethernet.localIP(); DEBUG_PRINTLN(ip); #ifdef remote_ip DEBUG_PRINT(\"Connecting to server at: \"); DEBUG_PRINTLN(remote_ip); #endif } /* * StandardFirmataEthernet communicates with Ethernet shields over SPI. Therefore all * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication. * Additional pins may also need to be ignored depending on the particular board or * shield in use. */ void ignorePins() { #ifdef IS_IGNORE_PIN for (byte i = 0; i < TOTAL_PINS; i++) { if (IS_IGNORE_PIN(i)) { Firmata.setPinMode(i, PIN_MODE_IGNORE); } } #endif #ifdef WIZ5100_ETHERNET // Arduino Ethernet and Arduino EthernetShield have SD SS wired to D4 pinMode(PIN_TO_DIGITAL(4), OUTPUT); // switch off SD card bypassing Firmata digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA #endif #endif // WIZ5100_ETHERNET } void initTransport() { #ifdef ETHERNETCLIENTSTREAM_H stream.attach(hostConnectionCallback); #endif #ifdef YUN_ETHERNET Bridge.begin(); #else #ifdef local_ip Ethernet.begin((uint8_t *)mac, local_ip); //start ethernet #else DEBUG_PRINTLN(\"Local IP will be requested from DHCP...\"); //start ethernet using dhcp if (Ethernet.begin((uint8_t *)mac) == 0) { DEBUG_PRINTLN(\"Failed to configure Ethernet using DHCP\"); } #endif #endif printEthernetStatus(); } void initFirmata() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); ignorePins(); // start up Network Firmata: Firmata.begin(stream); systemResetCallback(); // Initialize default configuration } void setup() { DEBUG_BEGIN(9600); initTransport(); initFirmata(); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * Stream buffer using Stream.write() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif #if !defined local_ip && !defined YUN_ETHERNET // only necessary when using DHCP, ensures local IP is updated appropriately if it changes if (Ethernet.maintain()) { stream.maintain(Ethernet.localIP()); } #endif }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataEthernet/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataPlus/","text":"Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ /* README StandardFirmataPlus adds additional features that may exceed the Flash and RAM sizes of Arduino boards such as ATMega328p (Uno) and ATMega32u4 (Leonardo, Micro, Yun, etc). It is best to use StandardFirmataPlus with higher memory boards such as the Arduino Mega, Arduino Due, Teensy 3.0/3.1/3.2. All Firmata examples that are appended with \"Plus\" add the following features: - Ability to interface with serial devices using UART, USART, or SoftwareSerial depending on the capatilities of the board. NOTE: In order to use SoftwareSerial with the Firmata Serial feature, StandardFirmataPlus must be compiled with Arduino v1.6.6 or newer. At the time of this writing, StandardFirmataPlus will still compile and run on ATMega328p and ATMega32u4-based boards, but future versions of this sketch may not as new features are added. */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. #include \"utility/SerialFirmata.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); // Save a couple of seconds by disabling the startup blink sequence. Firmata.disableBlinkVersion(); // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega, // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this: // Serial1.begin(57600); // Firmata.begin(Serial1); // However do not do this if you are using SERIAL_MESSAGE Firmata.begin(57600); while (!Serial) { ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101 } systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif } Video Demonstration","title":"StandardFirmataPlus"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataPlus/#sketch-code","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ /* README StandardFirmataPlus adds additional features that may exceed the Flash and RAM sizes of Arduino boards such as ATMega328p (Uno) and ATMega32u4 (Leonardo, Micro, Yun, etc). It is best to use StandardFirmataPlus with higher memory boards such as the Arduino Mega, Arduino Due, Teensy 3.0/3.1/3.2. All Firmata examples that are appended with \"Plus\" add the following features: - Ability to interface with serial devices using UART, USART, or SoftwareSerial depending on the capatilities of the board. NOTE: In order to use SoftwareSerial with the Firmata Serial feature, StandardFirmataPlus must be compiled with Arduino v1.6.6 or newer. At the time of this writing, StandardFirmataPlus will still compile and run on ATMega328p and ATMega32u4-based boards, but future versions of this sketch may not as new features are added. */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. #include \"utility/SerialFirmata.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to run the main loop (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous more */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Serial output queue using Serial.print() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } void setup() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); // Save a couple of seconds by disabling the startup blink sequence. Firmata.disableBlinkVersion(); // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega, // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this: // Serial1.begin(57600); // Firmata.begin(Serial1); // However do not do this if you are using SERIAL_MESSAGE Firmata.begin(57600); while (!Serial) { ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101 } systemResetCallback(); // reset to default config } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * FTDI buffer using Serial.print() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) Firmata.processInput(); // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataPlus/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataWiFi/","text":"Sketch Code /* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. Copyright (C) 2015-2016 Jesse Frush. All rights reserved. Copyright (C) 2016 Jens B. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ /* README StandardFirmataWiFi enables the use of Firmata over a TCP connection. It can be configured as either a TCP server or TCP client. To use StandardFirmataWiFi you will need to have one of the following boards or shields: - Arduino WiFi Shield (or clone) - Arduino WiFi Shield 101 - Arduino MKR1000 board - Arduino MKRWIFI1010 board - ESP8266 WiFi board compatible with ESP8266 Arduino core Follow the instructions in the wifiConfig.h file (wifiConfig.h tab in Arduino IDE) to configure your particular hardware. Dependencies: - WiFi Shield 101 requires version 0.7.0 or higher of the WiFi101 library (available in Arduino 1.6.8 or higher, or update the library via the Arduino Library Manager or clone from source: https://github.com/arduino-libraries/WiFi101) - ESP8266 requires the Arduino ESP8266 core v2.1.0 or higher which can be obtained here: https://github.com/esp8266/Arduino In order to use the WiFi Shield 101 with Firmata you will need a board with at least 35k of Flash memory. This means you cannot use the WiFi Shield 101 with an Arduino Uno or any other ATmega328p-based microcontroller or with an Arduino Leonardo or other ATmega32u4-based microcontroller. Some boards that will work are: - Arduino Zero - Arduino Due - Arduino 101 - Arduino Mega NOTE: If you are using an Arduino WiFi (legacy) shield you cannot use the following pins on the following boards. Firmata will ignore any requests to use these pins: - Arduino Uno or other ATMega328 boards: (D4, D7, D10, D11, D12, D13) - Arduino Mega: (D4, D7, D10, D50, D51, D52, D53) - Arduino Due, Zero or Leonardo: (D4, D7, D10) If you are using an Arduino WiFi 101 shield you cannot use the following pins on the following boards: - Arduino Due or Zero: (D5, D7, D10) - Arduino Mega: (D5, D7, D10, D50, D52, D53) */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> /* * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your * connection that may help in the event of connection issues. If defined, some boards may not begin * executing this sketch until the Serial console is opened. */ //#define SERIAL_DEBUG #include \"utility/firmataDebug.h\" /* * Uncomment the following include to enable interfacing with Serial devices via hardware or * software serial. */ // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. //#include \"utility/SerialFirmata.h\" // follow the instructions in wifiConfig.h to configure your particular hardware #include \"wifiConfig.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 #define MAX_CONN_ATTEMPTS 20 // [500 ms] -> 10 s /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif #ifdef STATIC_IP_ADDRESS IPAddress local_ip(STATIC_IP_ADDRESS); #endif #ifdef SUBNET_MASK IPAddress subnet(SUBNET_MASK); #endif #ifdef GATEWAY_IP_ADDRESS IPAddress gateway(GATEWAY_IP_ADDRESS); #endif int connectionAttempts = 0; bool streamConnected = false; /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous mode */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Stream output queue using Stream.write() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- // function forward declarations for xtensa compiler (ESP8266) void enableI2CPins(); void disableI2CPins(); void reportAnalogCallback(byte analogPin, int value); // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } /* * Called when a TCP connection is either connected or disconnected. * TODO: * - report connected or reconnected state to host (to be added to protocol) * - report current state to host (to be added to protocol) */ void hostConnectionCallback(byte state) { switch (state) { case HOST_CONNECTION_CONNECTED: DEBUG_PRINTLN( \"TCP connection established\" ); break; case HOST_CONNECTION_DISCONNECTED: DEBUG_PRINTLN( \"TCP connection disconnected\" ); break; } } /* * Print the status of the WiFi connection. This is the connection to the access point rather * than the TCP connection. */ void printWifiStatus() { if ( WiFi.status() != WL_CONNECTED ) { DEBUG_PRINT( \"WiFi connection failed. Status value: \" ); DEBUG_PRINTLN( WiFi.status() ); } else { // print the SSID of the network you're attached to: DEBUG_PRINT( \"SSID: \" ); DEBUG_PRINTLN( WiFi.SSID() ); // print your WiFi shield's IP address: DEBUG_PRINT( \"IP Address: \" ); IPAddress ip = WiFi.localIP(); DEBUG_PRINTLN( ip ); // print the received signal strength: DEBUG_PRINT( \"signal strength (RSSI): \" ); long rssi = WiFi.RSSI(); DEBUG_PRINT( rssi ); DEBUG_PRINTLN( \" dBm\" ); } } /* * StandardFirmataWiFi communicates with WiFi shields over SPI. Therefore all * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication. * Additional pins may also need to be ignored depending on the particular board or * shield in use. */ void ignorePins() { #ifdef IS_IGNORE_PIN for (byte i = 0; i < TOTAL_PINS; i++) { if (IS_IGNORE_PIN(i)) { Firmata.setPinMode(i, PIN_MODE_IGNORE); } } #endif //Set up controls for the Arduino WiFi Shield SS for the SD Card #ifdef ARDUINO_WIFI_SHIELD // Arduino WiFi Shield has SD SS wired to D4 pinMode(PIN_TO_DIGITAL(4), OUTPUT); // switch off SD card bypassing Firmata digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA #endif //defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) #endif //ARDUINO_WIFI_SHIELD } void initTransport() { // This statement will clarify how a connection is being made DEBUG_PRINT( \"StandardFirmataWiFi will attempt a WiFi connection \" ); #if defined(WIFI_101) DEBUG_PRINTLN( \"using the WiFi 101 library.\" ); #elif defined(ARDUINO_WIFI_SHIELD) DEBUG_PRINTLN( \"using the legacy WiFi library.\" ); #elif defined(ESP8266_WIFI) DEBUG_PRINTLN( \"using the ESP8266 WiFi library.\" ); #elif defined(HUZZAH_WIFI) DEBUG_PRINTLN( \"using the HUZZAH WiFi library.\" ); #elif defined(WIFI_NINA) DEBUG_PRINTLN( \"using the WiFi NINA library.\" ); //else should never happen here as error-checking in wifiConfig.h will catch this #endif //defined(WIFI_101) // Configure WiFi IP Address #ifdef STATIC_IP_ADDRESS DEBUG_PRINT( \"Using static IP: \" ); DEBUG_PRINTLN( local_ip ); #if defined(ESP8266_WIFI) || (defined(SUBNET_MASK) && defined(GATEWAY_IP_ADDRESS)) stream.config( local_ip , gateway, subnet ); #else // you can also provide a static IP in the begin() functions, but this simplifies // ifdef logic in this sketch due to support for all different encryption types. stream.config( local_ip ); #endif #else DEBUG_PRINTLN( \"IP will be requested from DHCP ...\" ); #endif stream.attach(hostConnectionCallback); // Configure WiFi security and initiate WiFi connection #if defined(WIFI_WEP_SECURITY) DEBUG_PRINT( \"Attempting to connect to WEP SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid, wep_index, wep_key); #elif defined(WIFI_WPA_SECURITY) DEBUG_PRINT( \"Attempting to connect to WPA SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid, wpa_passphrase); #else //OPEN network DEBUG_PRINTLN( \"Attempting to connect to open SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid); #endif //defined(WIFI_WEP_SECURITY) DEBUG_PRINTLN( \"WiFi setup done\" ); // Wait for connection to access point to be established. while (WiFi.status() != WL_CONNECTED && ++connectionAttempts <= MAX_CONN_ATTEMPTS) { delay(500); DEBUG_PRINT(\".\"); } printWifiStatus(); } void initFirmata() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); ignorePins(); // Initialize Firmata to use the WiFi stream object as the transport. Firmata.begin(stream); systemResetCallback(); // reset to default config } void setup() { DEBUG_BEGIN(9600); initTransport(); initFirmata(); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * Stream buffer using Stream.write() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) { Firmata.processInput(); } // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif stream.maintain(); } Video Demonstration","title":"StandardFirmataWiFi"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataWiFi/#sketch-code","text":"/* Firmata is a generic protocol for communicating with microcontrollers from software on a host computer. It is intended to work with any host computer software package. To download a host software package, please click on the following link to open the list of Firmata client libraries in your default browser. https://github.com/firmata/arduino#firmata-client-libraries Copyright (C) 2006-2008 Hans-Christoph Steiner. All rights reserved. Copyright (C) 2010-2011 Paul Stoffregen. All rights reserved. Copyright (C) 2009 Shigeru Kobayashi. All rights reserved. Copyright (C) 2009-2016 Jeff Hoefs. All rights reserved. Copyright (C) 2015-2016 Jesse Frush. All rights reserved. Copyright (C) 2016 Jens B. All rights reserved. This library is free software; you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation; either version 2.1 of the License, or (at your option) any later version. See file LICENSE.txt for further informations on licensing terms. Last updated August 17th, 2017 */ /* README StandardFirmataWiFi enables the use of Firmata over a TCP connection. It can be configured as either a TCP server or TCP client. To use StandardFirmataWiFi you will need to have one of the following boards or shields: - Arduino WiFi Shield (or clone) - Arduino WiFi Shield 101 - Arduino MKR1000 board - Arduino MKRWIFI1010 board - ESP8266 WiFi board compatible with ESP8266 Arduino core Follow the instructions in the wifiConfig.h file (wifiConfig.h tab in Arduino IDE) to configure your particular hardware. Dependencies: - WiFi Shield 101 requires version 0.7.0 or higher of the WiFi101 library (available in Arduino 1.6.8 or higher, or update the library via the Arduino Library Manager or clone from source: https://github.com/arduino-libraries/WiFi101) - ESP8266 requires the Arduino ESP8266 core v2.1.0 or higher which can be obtained here: https://github.com/esp8266/Arduino In order to use the WiFi Shield 101 with Firmata you will need a board with at least 35k of Flash memory. This means you cannot use the WiFi Shield 101 with an Arduino Uno or any other ATmega328p-based microcontroller or with an Arduino Leonardo or other ATmega32u4-based microcontroller. Some boards that will work are: - Arduino Zero - Arduino Due - Arduino 101 - Arduino Mega NOTE: If you are using an Arduino WiFi (legacy) shield you cannot use the following pins on the following boards. Firmata will ignore any requests to use these pins: - Arduino Uno or other ATMega328 boards: (D4, D7, D10, D11, D12, D13) - Arduino Mega: (D4, D7, D10, D50, D51, D52, D53) - Arduino Due, Zero or Leonardo: (D4, D7, D10) If you are using an Arduino WiFi 101 shield you cannot use the following pins on the following boards: - Arduino Due or Zero: (D5, D7, D10) - Arduino Mega: (D5, D7, D10, D50, D52, D53) */ #include <Servo.h> #include <Wire.h> #include <Firmata.h> /* * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your * connection that may help in the event of connection issues. If defined, some boards may not begin * executing this sketch until the Serial console is opened. */ //#define SERIAL_DEBUG #include \"utility/firmataDebug.h\" /* * Uncomment the following include to enable interfacing with Serial devices via hardware or * software serial. */ // In order to use software serial, you will need to compile this sketch with // Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0. //#include \"utility/SerialFirmata.h\" // follow the instructions in wifiConfig.h to configure your particular hardware #include \"wifiConfig.h\" #define I2C_WRITE B00000000 #define I2C_READ B00001000 #define I2C_READ_CONTINUOUSLY B00010000 #define I2C_STOP_READING B00011000 #define I2C_READ_WRITE_MODE_MASK B00011000 #define I2C_10BIT_ADDRESS_MODE_MASK B00100000 #define I2C_END_TX_MASK B01000000 #define I2C_STOP_TX 1 #define I2C_RESTART_TX 0 #define I2C_MAX_QUERIES 8 #define I2C_REGISTER_NOT_SPECIFIED -1 // the minimum interval for sampling analog input #define MINIMUM_SAMPLING_INTERVAL 1 #define MAX_CONN_ATTEMPTS 20 // [500 ms] -> 10 s /*============================================================================== * GLOBAL VARIABLES *============================================================================*/ #ifdef FIRMATA_SERIAL_FEATURE SerialFirmata serialFeature; #endif #ifdef STATIC_IP_ADDRESS IPAddress local_ip(STATIC_IP_ADDRESS); #endif #ifdef SUBNET_MASK IPAddress subnet(SUBNET_MASK); #endif #ifdef GATEWAY_IP_ADDRESS IPAddress gateway(GATEWAY_IP_ADDRESS); #endif int connectionAttempts = 0; bool streamConnected = false; /* analog inputs */ int analogInputsToReport = 0; // bitwise array to store pin reporting /* digital input ports */ byte reportPINs[TOTAL_PORTS]; // 1 = report this port, 0 = silence byte previousPINs[TOTAL_PORTS]; // previous 8 bits sent /* pins configuration */ byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else /* timer variables */ unsigned long currentMillis; // store the current value from millis() unsigned long previousMillis; // for comparison with currentMillis unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms) /* i2c data */ struct i2c_device_info { byte addr; int reg; byte bytes; byte stopTX; }; /* for i2c read continuous mode */ i2c_device_info query[I2C_MAX_QUERIES]; byte i2cRxData[64]; boolean isI2CEnabled = false; signed char queryIndex = -1; // default delay time between i2c read request and Wire.requestFrom() unsigned int i2cReadDelayTime = 0; Servo servos[MAX_SERVOS]; byte servoPinMap[TOTAL_PINS]; byte detachedServos[MAX_SERVOS]; byte detachedServoCount = 0; byte servoCount = 0; boolean isResetting = false; // Forward declare a few functions to avoid compiler errors with older versions // of the Arduino IDE. void setPinModeCallback(byte, int); void reportAnalogCallback(byte analogPin, int value); void sysexCallback(byte, byte, byte*); /* utility functions */ void wireWrite(byte data) { #if ARDUINO >= 100 Wire.write((byte)data); #else Wire.send(data); #endif } byte wireRead(void) { #if ARDUINO >= 100 return Wire.read(); #else return Wire.receive(); #endif } /*============================================================================== * FUNCTIONS *============================================================================*/ void attachServo(byte pin, int minPulse, int maxPulse) { if (servoCount < MAX_SERVOS) { // reuse indexes of detached servos until all have been reallocated if (detachedServoCount > 0) { servoPinMap[pin] = detachedServos[detachedServoCount - 1]; if (detachedServoCount > 0) detachedServoCount--; } else { servoPinMap[pin] = servoCount; servoCount++; } if (minPulse > 0 && maxPulse > 0) { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse); } else { servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin)); } } else { Firmata.sendString(\"Max servos attached\"); } } void detachServo(byte pin) { servos[servoPinMap[pin]].detach(); // if we're detaching the last servo, decrement the count // otherwise store the index of the detached servo if (servoPinMap[pin] == servoCount && servoCount > 0) { servoCount--; } else if (servoCount > 0) { // keep track of detached servos because we want to reuse their indexes // before incrementing the count of attached servos detachedServoCount++; detachedServos[detachedServoCount - 1] = servoPinMap[pin]; } servoPinMap[pin] = 255; } void enableI2CPins() { byte i; // is there a faster way to do this? would probaby require importing // Arduino.h to get SCL and SDA pins for (i = 0; i < TOTAL_PINS; i++) { if (IS_PIN_I2C(i)) { // mark pins as i2c so they are ignore in non i2c data requests setPinModeCallback(i, PIN_MODE_I2C); } } isI2CEnabled = true; Wire.begin(); } /* disable the i2c pins so they can be used for other functions */ void disableI2CPins() { isI2CEnabled = false; // disable read continuous mode for all devices queryIndex = -1; } void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) { // allow I2C requests that don't require a register read // for example, some devices using an interrupt pin to signify new data available // do not always require the register read so upon interrupt you call Wire.requestFrom() if (theRegister != I2C_REGISTER_NOT_SPECIFIED) { Wire.beginTransmission(address); wireWrite((byte)theRegister); Wire.endTransmission(stopTX); // default = true // do not set a value of 0 if (i2cReadDelayTime > 0) { // delay is necessary for some devices such as WiiNunchuck delayMicroseconds(i2cReadDelayTime); } } else { theRegister = 0; // fill the register with a dummy value } Wire.requestFrom(address, numBytes); // all bytes are returned in requestFrom // check to be sure correct number of bytes were returned by slave if (numBytes < Wire.available()) { Firmata.sendString(\"I2C: Too many bytes received\"); } else if (numBytes > Wire.available()) { Firmata.sendString(\"I2C: Too few bytes received\"); numBytes = Wire.available(); } i2cRxData[0] = address; i2cRxData[1] = theRegister; for (int i = 0; i < numBytes && Wire.available(); i++) { i2cRxData[2 + i] = wireRead(); } // send slave address, register and received bytes Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData); } void outputPort(byte portNumber, byte portValue, byte forceSend) { // pins not configured as INPUT are cleared to zeros portValue = portValue & portConfigInputs[portNumber]; // only send if the value is different than previously sent if (forceSend || previousPINs[portNumber] != portValue) { Firmata.sendDigitalPort(portNumber, portValue); previousPINs[portNumber] = portValue; } } /* ----------------------------------------------------------------------------- * check all the active digital inputs for change of state, then add any events * to the Stream output queue using Stream.write() */ void checkDigitalInputs(void) { /* Using non-looping code allows constants to be given to readPort(). * The compiler will apply substantial optimizations if the inputs * to readPort() are compile-time constants. */ if (TOTAL_PORTS > 0 && reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false); if (TOTAL_PORTS > 1 && reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false); if (TOTAL_PORTS > 2 && reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false); if (TOTAL_PORTS > 3 && reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false); if (TOTAL_PORTS > 4 && reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false); if (TOTAL_PORTS > 5 && reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false); if (TOTAL_PORTS > 6 && reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false); if (TOTAL_PORTS > 7 && reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false); if (TOTAL_PORTS > 8 && reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false); if (TOTAL_PORTS > 9 && reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false); if (TOTAL_PORTS > 10 && reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false); if (TOTAL_PORTS > 11 && reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false); if (TOTAL_PORTS > 12 && reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false); if (TOTAL_PORTS > 13 && reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false); if (TOTAL_PORTS > 14 && reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false); if (TOTAL_PORTS > 15 && reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false); } // ----------------------------------------------------------------------------- // function forward declarations for xtensa compiler (ESP8266) void enableI2CPins(); void disableI2CPins(); void reportAnalogCallback(byte analogPin, int value); // ----------------------------------------------------------------------------- /* sets the pin mode to the correct state and sets the relevant bits in the * two bit-arrays that track Digital I/O and PWM status */ void setPinModeCallback(byte pin, int mode) { if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE) return; if (Firmata.getPinMode(pin) == PIN_MODE_I2C && isI2CEnabled && mode != PIN_MODE_I2C) { // disable i2c so pins can be used for other functions // the following if statements should reconfigure the pins properly disableI2CPins(); } if (IS_PIN_DIGITAL(pin) && mode != PIN_MODE_SERVO) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } } if (IS_PIN_ANALOG(pin)) { reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting } if (IS_PIN_DIGITAL(pin)) { if (mode == INPUT || mode == PIN_MODE_PULLUP) { portConfigInputs[pin / 8] |= (1 << (pin & 7)); } else { portConfigInputs[pin / 8] &= ~(1 << (pin & 7)); } } Firmata.setPinState(pin, 0); switch (mode) { case PIN_MODE_ANALOG: if (IS_PIN_ANALOG(pin)) { if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif } Firmata.setPinMode(pin, PIN_MODE_ANALOG); } break; case INPUT: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT); // disable output driver #if ARDUINO <= 100 // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6 digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups #endif Firmata.setPinMode(pin, INPUT); } break; case PIN_MODE_PULLUP: if (IS_PIN_DIGITAL(pin)) { pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP); Firmata.setPinMode(pin, PIN_MODE_PULLUP); Firmata.setPinState(pin, 1); } break; case OUTPUT: if (IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == PIN_MODE_PWM) { // Disable PWM if pin mode was previously set to PWM. digitalWrite(PIN_TO_DIGITAL(pin), LOW); } pinMode(PIN_TO_DIGITAL(pin), OUTPUT); Firmata.setPinMode(pin, OUTPUT); } break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) { pinMode(PIN_TO_PWM(pin), OUTPUT); analogWrite(PIN_TO_PWM(pin), 0); Firmata.setPinMode(pin, PIN_MODE_PWM); } break; case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) { Firmata.setPinMode(pin, PIN_MODE_SERVO); if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) { // pass -1 for min and max pulse values to use default values set // by Servo library attachServo(pin, -1, -1); } } break; case PIN_MODE_I2C: if (IS_PIN_I2C(pin)) { // mark the pin as i2c // the user must call I2C_CONFIG to enable I2C for a device Firmata.setPinMode(pin, PIN_MODE_I2C); } break; case PIN_MODE_SERIAL: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handlePinMode(pin, PIN_MODE_SERIAL); #endif break; default: Firmata.sendString(\"Unknown pin mode\"); // TODO: put error msgs in EEPROM } // TODO: save status to EEPROM here, if changed } /* * Sets the value of an individual pin. Useful if you want to set a pin value but * are not tracking the digital port state. * Can only be used on pins configured as OUTPUT. * Cannot be used to enable pull-ups on Digital INPUT pins. */ void setPinValueCallback(byte pin, int value) { if (pin < TOTAL_PINS && IS_PIN_DIGITAL(pin)) { if (Firmata.getPinMode(pin) == OUTPUT) { Firmata.setPinState(pin, value); digitalWrite(PIN_TO_DIGITAL(pin), value); } } } void analogWriteCallback(byte pin, int value) { if (pin < TOTAL_PINS) { switch (Firmata.getPinMode(pin)) { case PIN_MODE_SERVO: if (IS_PIN_DIGITAL(pin)) servos[servoPinMap[pin]].write(value); Firmata.setPinState(pin, value); break; case PIN_MODE_PWM: if (IS_PIN_PWM(pin)) analogWrite(PIN_TO_PWM(pin), value); Firmata.setPinState(pin, value); break; } } } void digitalWriteCallback(byte port, int value) { byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0; if (port < TOTAL_PORTS) { // create a mask of the pins on this port that are writable. lastPin = port * 8 + 8; if (lastPin > TOTAL_PINS) lastPin = TOTAL_PINS; for (pin = port * 8; pin < lastPin; pin++) { // do not disturb non-digital pins (eg, Rx & Tx) if (IS_PIN_DIGITAL(pin)) { // do not touch pins in PWM, ANALOG, SERVO or other modes if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) { pinValue = ((byte)value & mask) ? 1 : 0; if (Firmata.getPinMode(pin) == OUTPUT) { pinWriteMask |= mask; } else if (Firmata.getPinMode(pin) == INPUT && pinValue == 1 && Firmata.getPinState(pin) != 1) { // only handle INPUT here for backwards compatibility #if ARDUINO > 100 pinMode(pin, INPUT_PULLUP); #else // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier pinWriteMask |= mask; #endif } Firmata.setPinState(pin, pinValue); } } mask = mask << 1; } writePort(port, (byte)value, pinWriteMask); } } // ----------------------------------------------------------------------------- /* sets bits in a bit array (int) to toggle the reporting of the analogIns */ //void FirmataClass::setAnalogPinReporting(byte pin, byte state) { //} void reportAnalogCallback(byte analogPin, int value) { if (analogPin < TOTAL_ANALOG_PINS) { if (value == 0) { analogInputsToReport = analogInputsToReport & ~ (1 << analogPin); } else { analogInputsToReport = analogInputsToReport | (1 << analogPin); // prevent during system reset or all analog pin values will be reported // which may report noise for unconnected analog pins if (!isResetting) { // Send pin value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // TODO: save status to EEPROM here, if changed } void reportDigitalCallback(byte port, int value) { if (port < TOTAL_PORTS) { reportPINs[port] = (byte)value; // Send port value immediately. This is helpful when connected via // ethernet, wi-fi or bluetooth so pin states can be known upon // reconnecting. if (value) outputPort(port, readPort(port, portConfigInputs[port]), true); } // do not disable analog reporting on these 8 pins, to allow some // pins used for digital, others analog. Instead, allow both types // of reporting to be enabled, but check if the pin is configured // as analog when sampling the analog inputs. Likewise, while // scanning digital pins, portConfigInputs will mask off values from any // pins configured as analog } /*============================================================================== * SYSEX-BASED commands *============================================================================*/ void sysexCallback(byte command, byte argc, byte *argv) { byte mode; byte stopTX; byte slaveAddress; byte data; int slaveRegister; unsigned int delayTime; switch (command) { case I2C_REQUEST: mode = argv[1] & I2C_READ_WRITE_MODE_MASK; if (argv[1] & I2C_10BIT_ADDRESS_MODE_MASK) { Firmata.sendString(\"10-bit addressing not supported\"); return; } else { slaveAddress = argv[0]; } // need to invert the logic here since 0 will be default for client // libraries that have not updated to add support for restart tx if (argv[1] & I2C_END_TX_MASK) { stopTX = I2C_RESTART_TX; } else { stopTX = I2C_STOP_TX; // default } switch (mode) { case I2C_WRITE: Wire.beginTransmission(slaveAddress); for (byte i = 2; i < argc; i += 2) { data = argv[i] + (argv[i + 1] << 7); wireWrite(data); } Wire.endTransmission(); delayMicroseconds(70); break; case I2C_READ: if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX); break; case I2C_READ_CONTINUOUSLY: if ((queryIndex + 1) >= I2C_MAX_QUERIES) { // too many queries, just ignore Firmata.sendString(\"too many queries\"); break; } if (argc == 6) { // a slave register is specified slaveRegister = argv[2] + (argv[3] << 7); data = argv[4] + (argv[5] << 7); // bytes to read } else { // a slave register is NOT specified slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED; data = argv[2] + (argv[3] << 7); // bytes to read } queryIndex++; query[queryIndex].addr = slaveAddress; query[queryIndex].reg = slaveRegister; query[queryIndex].bytes = data; query[queryIndex].stopTX = stopTX; break; case I2C_STOP_READING: byte queryIndexToSkip; // if read continuous mode is enabled for only 1 i2c device, disable // read continuous reporting for that device if (queryIndex <= 0) { queryIndex = -1; } else { queryIndexToSkip = 0; // if read continuous mode is enabled for multiple devices, // determine which device to stop reading and remove it's data from // the array, shifiting other array data to fill the space for (byte i = 0; i < queryIndex + 1; i++) { if (query[i].addr == slaveAddress) { queryIndexToSkip = i; break; } } for (byte i = queryIndexToSkip; i < queryIndex + 1; i++) { if (i < I2C_MAX_QUERIES) { query[i].addr = query[i + 1].addr; query[i].reg = query[i + 1].reg; query[i].bytes = query[i + 1].bytes; query[i].stopTX = query[i + 1].stopTX; } } queryIndex--; } break; default: break; } break; case I2C_CONFIG: delayTime = (argv[0] + (argv[1] << 7)); if (argc > 1 && delayTime > 0) { i2cReadDelayTime = delayTime; } if (!isI2CEnabled) { enableI2CPins(); } break; case SERVO_CONFIG: if (argc > 4) { // these vars are here for clarity, they'll optimized away by the compiler byte pin = argv[0]; int minPulse = argv[1] + (argv[2] << 7); int maxPulse = argv[3] + (argv[4] << 7); if (IS_PIN_DIGITAL(pin)) { if (servoPinMap[pin] < MAX_SERVOS && servos[servoPinMap[pin]].attached()) { detachServo(pin); } attachServo(pin, minPulse, maxPulse); setPinModeCallback(pin, PIN_MODE_SERVO); } } break; case SAMPLING_INTERVAL: if (argc > 1) { samplingInterval = argv[0] + (argv[1] << 7); if (samplingInterval < MINIMUM_SAMPLING_INTERVAL) { samplingInterval = MINIMUM_SAMPLING_INTERVAL; } } else { //Firmata.sendString(\"Not enough data\"); } break; case EXTENDED_ANALOG: if (argc > 1) { int val = argv[1]; if (argc > 2) val |= (argv[2] << 7); if (argc > 3) val |= (argv[3] << 14); analogWriteCallback(argv[0], val); } break; case CAPABILITY_QUERY: Firmata.write(START_SYSEX); Firmata.write(CAPABILITY_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_DIGITAL(pin)) { Firmata.write((byte)INPUT); Firmata.write(1); Firmata.write((byte)PIN_MODE_PULLUP); Firmata.write(1); Firmata.write((byte)OUTPUT); Firmata.write(1); } if (IS_PIN_ANALOG(pin)) { Firmata.write(PIN_MODE_ANALOG); Firmata.write(10); // 10 = 10-bit resolution } if (IS_PIN_PWM(pin)) { Firmata.write(PIN_MODE_PWM); Firmata.write(DEFAULT_PWM_RESOLUTION); } if (IS_PIN_DIGITAL(pin)) { Firmata.write(PIN_MODE_SERVO); Firmata.write(14); } if (IS_PIN_I2C(pin)) { Firmata.write(PIN_MODE_I2C); Firmata.write(1); // TODO: could assign a number to map to SCL or SDA } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleCapability(pin); #endif Firmata.write(127); } Firmata.write(END_SYSEX); break; case PIN_STATE_QUERY: if (argc > 0) { byte pin = argv[0]; Firmata.write(START_SYSEX); Firmata.write(PIN_STATE_RESPONSE); Firmata.write(pin); if (pin < TOTAL_PINS) { Firmata.write(Firmata.getPinMode(pin)); Firmata.write((byte)Firmata.getPinState(pin) & 0x7F); if (Firmata.getPinState(pin) & 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) >> 7) & 0x7F); if (Firmata.getPinState(pin) & 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) >> 14) & 0x7F); } Firmata.write(END_SYSEX); } break; case ANALOG_MAPPING_QUERY: Firmata.write(START_SYSEX); Firmata.write(ANALOG_MAPPING_RESPONSE); for (byte pin = 0; pin < TOTAL_PINS; pin++) { Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127); } Firmata.write(END_SYSEX); break; case SERIAL_MESSAGE: #ifdef FIRMATA_SERIAL_FEATURE serialFeature.handleSysex(command, argc, argv); #endif break; } } /*============================================================================== * SETUP() *============================================================================*/ void systemResetCallback() { isResetting = true; // initialize a defalt state // TODO: option to load config from EEPROM instead of default #ifdef FIRMATA_SERIAL_FEATURE serialFeature.reset(); #endif if (isI2CEnabled) { disableI2CPins(); } for (byte i = 0; i < TOTAL_PORTS; i++) { reportPINs[i] = false; // by default, reporting off portConfigInputs[i] = 0; // until activated previousPINs[i] = 0; } for (byte i = 0; i < TOTAL_PINS; i++) { // pins with analog capability default to analog input // otherwise, pins default to digital output if (IS_PIN_ANALOG(i)) { // turns off pullup, configures everything setPinModeCallback(i, PIN_MODE_ANALOG); } else if (IS_PIN_DIGITAL(i)) { // sets the output to 0, configures portConfigInputs setPinModeCallback(i, OUTPUT); } servoPinMap[i] = 255; } // by default, do not report any analog inputs analogInputsToReport = 0; detachedServoCount = 0; servoCount = 0; /* send digital inputs to set the initial state on the host computer, * since once in the loop(), this firmware will only send on change */ /* TODO: this can never execute, since no pins default to digital input but it will be needed when/if we support EEPROM stored config for (byte i=0; i < TOTAL_PORTS; i++) { outputPort(i, readPort(i, portConfigInputs[i]), true); } */ isResetting = false; } /* * Called when a TCP connection is either connected or disconnected. * TODO: * - report connected or reconnected state to host (to be added to protocol) * - report current state to host (to be added to protocol) */ void hostConnectionCallback(byte state) { switch (state) { case HOST_CONNECTION_CONNECTED: DEBUG_PRINTLN( \"TCP connection established\" ); break; case HOST_CONNECTION_DISCONNECTED: DEBUG_PRINTLN( \"TCP connection disconnected\" ); break; } } /* * Print the status of the WiFi connection. This is the connection to the access point rather * than the TCP connection. */ void printWifiStatus() { if ( WiFi.status() != WL_CONNECTED ) { DEBUG_PRINT( \"WiFi connection failed. Status value: \" ); DEBUG_PRINTLN( WiFi.status() ); } else { // print the SSID of the network you're attached to: DEBUG_PRINT( \"SSID: \" ); DEBUG_PRINTLN( WiFi.SSID() ); // print your WiFi shield's IP address: DEBUG_PRINT( \"IP Address: \" ); IPAddress ip = WiFi.localIP(); DEBUG_PRINTLN( ip ); // print the received signal strength: DEBUG_PRINT( \"signal strength (RSSI): \" ); long rssi = WiFi.RSSI(); DEBUG_PRINT( rssi ); DEBUG_PRINTLN( \" dBm\" ); } } /* * StandardFirmataWiFi communicates with WiFi shields over SPI. Therefore all * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication. * Additional pins may also need to be ignored depending on the particular board or * shield in use. */ void ignorePins() { #ifdef IS_IGNORE_PIN for (byte i = 0; i < TOTAL_PINS; i++) { if (IS_IGNORE_PIN(i)) { Firmata.setPinMode(i, PIN_MODE_IGNORE); } } #endif //Set up controls for the Arduino WiFi Shield SS for the SD Card #ifdef ARDUINO_WIFI_SHIELD // Arduino WiFi Shield has SD SS wired to D4 pinMode(PIN_TO_DIGITAL(4), OUTPUT); // switch off SD card bypassing Firmata digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low; #if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA #endif //defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__) #endif //ARDUINO_WIFI_SHIELD } void initTransport() { // This statement will clarify how a connection is being made DEBUG_PRINT( \"StandardFirmataWiFi will attempt a WiFi connection \" ); #if defined(WIFI_101) DEBUG_PRINTLN( \"using the WiFi 101 library.\" ); #elif defined(ARDUINO_WIFI_SHIELD) DEBUG_PRINTLN( \"using the legacy WiFi library.\" ); #elif defined(ESP8266_WIFI) DEBUG_PRINTLN( \"using the ESP8266 WiFi library.\" ); #elif defined(HUZZAH_WIFI) DEBUG_PRINTLN( \"using the HUZZAH WiFi library.\" ); #elif defined(WIFI_NINA) DEBUG_PRINTLN( \"using the WiFi NINA library.\" ); //else should never happen here as error-checking in wifiConfig.h will catch this #endif //defined(WIFI_101) // Configure WiFi IP Address #ifdef STATIC_IP_ADDRESS DEBUG_PRINT( \"Using static IP: \" ); DEBUG_PRINTLN( local_ip ); #if defined(ESP8266_WIFI) || (defined(SUBNET_MASK) && defined(GATEWAY_IP_ADDRESS)) stream.config( local_ip , gateway, subnet ); #else // you can also provide a static IP in the begin() functions, but this simplifies // ifdef logic in this sketch due to support for all different encryption types. stream.config( local_ip ); #endif #else DEBUG_PRINTLN( \"IP will be requested from DHCP ...\" ); #endif stream.attach(hostConnectionCallback); // Configure WiFi security and initiate WiFi connection #if defined(WIFI_WEP_SECURITY) DEBUG_PRINT( \"Attempting to connect to WEP SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid, wep_index, wep_key); #elif defined(WIFI_WPA_SECURITY) DEBUG_PRINT( \"Attempting to connect to WPA SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid, wpa_passphrase); #else //OPEN network DEBUG_PRINTLN( \"Attempting to connect to open SSID: \" ); DEBUG_PRINTLN(ssid); stream.begin(ssid); #endif //defined(WIFI_WEP_SECURITY) DEBUG_PRINTLN( \"WiFi setup done\" ); // Wait for connection to access point to be established. while (WiFi.status() != WL_CONNECTED && ++connectionAttempts <= MAX_CONN_ATTEMPTS) { delay(500); DEBUG_PRINT(\".\"); } printWifiStatus(); } void initFirmata() { Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION); Firmata.attach(ANALOG_MESSAGE, analogWriteCallback); Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback); Firmata.attach(REPORT_ANALOG, reportAnalogCallback); Firmata.attach(REPORT_DIGITAL, reportDigitalCallback); Firmata.attach(SET_PIN_MODE, setPinModeCallback); Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback); Firmata.attach(START_SYSEX, sysexCallback); Firmata.attach(SYSTEM_RESET, systemResetCallback); ignorePins(); // Initialize Firmata to use the WiFi stream object as the transport. Firmata.begin(stream); systemResetCallback(); // reset to default config } void setup() { DEBUG_BEGIN(9600); initTransport(); initFirmata(); } /*============================================================================== * LOOP() *============================================================================*/ void loop() { byte pin, analogPin; /* DIGITALREAD - as fast as possible, check for changes and output them to the * Stream buffer using Stream.write() */ checkDigitalInputs(); /* STREAMREAD - processing incoming messagse as soon as possible, while still * checking digital inputs. */ while (Firmata.available()) { Firmata.processInput(); } // TODO - ensure that Stream buffer doesn't go over 60 bytes currentMillis = millis(); if (currentMillis - previousMillis > samplingInterval) { previousMillis += samplingInterval; /* ANALOGREAD - do all analogReads() at the configured sampling interval */ for (pin = 0; pin < TOTAL_PINS; pin++) { if (IS_PIN_ANALOG(pin) && Firmata.getPinMode(pin) == PIN_MODE_ANALOG) { analogPin = PIN_TO_ANALOG(pin); if (analogInputsToReport & (1 << analogPin)) { Firmata.sendAnalog(analogPin, analogRead(analogPin)); } } } // report i2c data for all device with read continuous mode enabled if (queryIndex > -1) { for (byte i = 0; i < queryIndex + 1; i++) { readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX); } } } #ifdef FIRMATA_SERIAL_FEATURE serialFeature.update(); #endif stream.maintain(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Firmata/StandardFirmataWiFi/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Keyboard/Serial/","text":"Sketch Code /* Keyboard test For the Arduino Leonardo, Micro or Due Reads a byte from the serial port, sends a keystroke back. The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send A you get B, and so forth. The circuit: - none created 21 Oct 2011 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardSerial */ #include \"Keyboard.h\" void setup() { // open the serial port: Serial.begin(9600); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // check for incoming serial data: if (Serial.available() > 0) { // read incoming serial data: char inChar = Serial.read(); // Type the next ASCII value from what you received: Keyboard.write(inChar + 1); } } Video Demonstration","title":"Serial"},{"location":"05_examples_uno_r4_wifi/Keyboard/Serial/#sketch-code","text":"/* Keyboard test For the Arduino Leonardo, Micro or Due Reads a byte from the serial port, sends a keystroke back. The sent keystroke is one higher than what's received, e.g. if you send a, you get b, send A you get B, and so forth. The circuit: - none created 21 Oct 2011 modified 27 Mar 2012 by Tom Igoe This example code is in the public domain. https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardSerial */ #include \"Keyboard.h\" void setup() { // open the serial port: Serial.begin(9600); // initialize control over the keyboard: Keyboard.begin(); } void loop() { // check for incoming serial data: if (Serial.available() > 0) { // read incoming serial data: char inChar = Serial.read(); // Type the next ASCII value from what you received: Keyboard.write(inChar + 1); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Keyboard/Serial/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/DisplaySingleFrame/","text":"Sketch Code /* Single Frame Displays single frames using matrix.loadFrame See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library #include \"frames.h\" // Include a header file containing frame data ArduinoLEDMatrix matrix; // Create an instance of the ArduinoLEDMatrix class void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 matrix.begin(); // Initialize the LED matrix } void loop() { // Load and display the \"chip\" frame on the LED matrix matrix.loadFrame(chip); delay(500); // Pause for 500 milliseconds (half a second) // Load and display the \"danger\" frame on the LED matrix matrix.loadFrame(danger); delay(500); // Load and display the \"happy\" frame on the LED matrix matrix.loadFrame(happy); delay(500); // Load and display the \"heart\" frame on the LED matrix matrix.loadFrame(heart); delay(500); // Print the current value of millis() to the serial monitor Serial.println(millis()); } Video Demonstration","title":"DisplaySingleFrame"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/DisplaySingleFrame/#sketch-code","text":"/* Single Frame Displays single frames using matrix.loadFrame See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library #include \"frames.h\" // Include a header file containing frame data ArduinoLEDMatrix matrix; // Create an instance of the ArduinoLEDMatrix class void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 matrix.begin(); // Initialize the LED matrix } void loop() { // Load and display the \"chip\" frame on the LED matrix matrix.loadFrame(chip); delay(500); // Pause for 500 milliseconds (half a second) // Load and display the \"danger\" frame on the LED matrix matrix.loadFrame(danger); delay(500); // Load and display the \"happy\" frame on the LED matrix matrix.loadFrame(happy); delay(500); // Load and display the \"heart\" frame on the LED matrix matrix.loadFrame(heart); delay(500); // Print the current value of millis() to the serial monitor Serial.println(millis()); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/DisplaySingleFrame/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/GameOfLife/","text":"Sketch Code /* Game Of Life The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. Example developed starting from Toby Oxborrow's sketch https://github.com/tobyoxborrow/gameoflife-arduino/blob/master/GameOfLife.ino See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library // grid dimensions. should not be larger than 8x8 #define MAX_Y 8 #define MAX_X 12 // time to wait between turns #define TURN_DELAY 200 // how many turns per game before starting a new game // you can also use the reset button on the board #define TURNS_MAX 60 // number of patterns in predefined list #define MAX_PATTERNS 4 // how many turns to wait if there are no changes before starting a new game #define NO_CHANGES_RESET 4 int turns = 0; // counter for turns int noChanges = 0; // counter for turns without changes // game state. 0 is dead cell, 1 is live cell uint8_t grid[MAX_Y][MAX_X] = { {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, }; int currentPattern = 0; String patternNames[] = { \"Glider\", \"Light-weight spaceship\", \"R-Pentomino\", \"Diehard\" }; // custom starting grid patterns boolean cGrids[][MAX_Y][MAX_X] = { { /* Glider */ {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* Light-weight spaceship */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* R-Pentomino */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* Die hard */ {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} } }; ArduinoLEDMatrix matrix; void setup() { Serial.begin(9600); delay(1000); Serial.println(\"Conway's game of life on Arduino LED Matrix\"); matrix.begin(); resetGrid(); displayGrid(); } void loop() { delay(TURN_DELAY); playGoL(); turns++; // reset the grid if no changes have occured recently // for when the game enters a static stable state if (noChanges > NO_CHANGES_RESET) { resetGrid(); } // reset the grid if the loop has been running a long time // for when the game cycles between a few stable states if (turns > TURNS_MAX) { resetGrid(); } displayGrid(); } // play game of life void playGoL() { /* 1. Any live cell with fewer than two neighbours dies, as if by loneliness. 2. Any live cell with more than three neighbours dies, as if by overcrowding. 3. Any live cell with two or three neighbours lives, unchanged, to the next generation. 4. Any dead cell with exactly three neighbours comes to life. */ boolean newGrid[MAX_Y][MAX_X] = { {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { int neighboughs = countNeighbours(y, x); if (grid[y][x] == 1) { if ((neighboughs == 2) || (neighboughs == 3)) { newGrid[y][x] = 1; } else { newGrid[y][x] = 0; } } else { if (neighboughs == 3) { newGrid[y][x] = 1; } else { newGrid[y][x] = 0; } } } } // update the current grid from the new grid and count how many changes // occured int changes = 0; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { if (newGrid[y][x] != grid[y][x]) { changes++; } grid[y][x] = newGrid[y][x]; } } // update global counter when no changes occured if (changes == 0) { noChanges++; } } // count the number of neighbour live cells for a given cell int countNeighbours(int y, int x) { int count = 0; // -- Row above us --- if (y > 0) { // above left if (x > 0) { count += grid[y - 1][x - 1]; } // above count += grid[y - 1][x]; // above right if ((x + 1) < 8) { count += grid[y - 1][x + 1]; } } // -- Same row ------- // left if (x > 0) { count += grid[y][x - 1]; } // right if ((x + 1) < 8) { count += grid[y][x + 1]; } // -- Row below us --- if ((y + 1) < 8) { // below left if (x > 0) { count += grid[y + 1][x - 1]; } // below count += grid[y + 1][x]; // below right if ((x + 1) < 8) { count += grid[y + 1][x + 1]; } } return count; } // reset the grid void resetGrid() { Serial.print(\"Current pattern: \"); Serial.println(patternNames[currentPattern]); noChanges = 0; turns = 0; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { grid[y][x] = cGrids[currentPattern][y][x]; } } currentPattern++; if(currentPattern >= MAX_PATTERNS){ currentPattern = 0; } } // display the current grid to the LED matrix void displayGrid() { matrix.renderBitmap(grid, 8, 12); } Video Demonstration","title":"GameOfLife"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/GameOfLife/#sketch-code","text":"/* Game Of Life The Game of Life, also known simply as Life, is a cellular automaton devised by the British mathematician John Horton Conway in 1970. It is a zero-player game, meaning that its evolution is determined by its initial state, requiring no further input. Example developed starting from Toby Oxborrow's sketch https://github.com/tobyoxborrow/gameoflife-arduino/blob/master/GameOfLife.ino See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library // grid dimensions. should not be larger than 8x8 #define MAX_Y 8 #define MAX_X 12 // time to wait between turns #define TURN_DELAY 200 // how many turns per game before starting a new game // you can also use the reset button on the board #define TURNS_MAX 60 // number of patterns in predefined list #define MAX_PATTERNS 4 // how many turns to wait if there are no changes before starting a new game #define NO_CHANGES_RESET 4 int turns = 0; // counter for turns int noChanges = 0; // counter for turns without changes // game state. 0 is dead cell, 1 is live cell uint8_t grid[MAX_Y][MAX_X] = { {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, }; int currentPattern = 0; String patternNames[] = { \"Glider\", \"Light-weight spaceship\", \"R-Pentomino\", \"Diehard\" }; // custom starting grid patterns boolean cGrids[][MAX_Y][MAX_X] = { { /* Glider */ {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* Light-weight spaceship */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0}, {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* R-Pentomino */ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }, { /* Die hard */ {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0}, {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} } }; ArduinoLEDMatrix matrix; void setup() { Serial.begin(9600); delay(1000); Serial.println(\"Conway's game of life on Arduino LED Matrix\"); matrix.begin(); resetGrid(); displayGrid(); } void loop() { delay(TURN_DELAY); playGoL(); turns++; // reset the grid if no changes have occured recently // for when the game enters a static stable state if (noChanges > NO_CHANGES_RESET) { resetGrid(); } // reset the grid if the loop has been running a long time // for when the game cycles between a few stable states if (turns > TURNS_MAX) { resetGrid(); } displayGrid(); } // play game of life void playGoL() { /* 1. Any live cell with fewer than two neighbours dies, as if by loneliness. 2. Any live cell with more than three neighbours dies, as if by overcrowding. 3. Any live cell with two or three neighbours lives, unchanged, to the next generation. 4. Any dead cell with exactly three neighbours comes to life. */ boolean newGrid[MAX_Y][MAX_X] = { {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0} }; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { int neighboughs = countNeighbours(y, x); if (grid[y][x] == 1) { if ((neighboughs == 2) || (neighboughs == 3)) { newGrid[y][x] = 1; } else { newGrid[y][x] = 0; } } else { if (neighboughs == 3) { newGrid[y][x] = 1; } else { newGrid[y][x] = 0; } } } } // update the current grid from the new grid and count how many changes // occured int changes = 0; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { if (newGrid[y][x] != grid[y][x]) { changes++; } grid[y][x] = newGrid[y][x]; } } // update global counter when no changes occured if (changes == 0) { noChanges++; } } // count the number of neighbour live cells for a given cell int countNeighbours(int y, int x) { int count = 0; // -- Row above us --- if (y > 0) { // above left if (x > 0) { count += grid[y - 1][x - 1]; } // above count += grid[y - 1][x]; // above right if ((x + 1) < 8) { count += grid[y - 1][x + 1]; } } // -- Same row ------- // left if (x > 0) { count += grid[y][x - 1]; } // right if ((x + 1) < 8) { count += grid[y][x + 1]; } // -- Row below us --- if ((y + 1) < 8) { // below left if (x > 0) { count += grid[y + 1][x - 1]; } // below count += grid[y + 1][x]; // below right if ((x + 1) < 8) { count += grid[y + 1][x + 1]; } } return count; } // reset the grid void resetGrid() { Serial.print(\"Current pattern: \"); Serial.println(patternNames[currentPattern]); noChanges = 0; turns = 0; for (int y = 0; y < MAX_Y; y++) { for (int x = 0; x < MAX_X; x++) { grid[y][x] = cGrids[currentPattern][y][x]; } } currentPattern++; if(currentPattern >= MAX_PATTERNS){ currentPattern = 0; } } // display the current grid to the LED matrix void displayGrid() { matrix.renderBitmap(grid, 8, 12); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/GameOfLife/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/LivePreview/","text":"Sketch Code /* This sketch allows live editing of the matrix pixels using WebSerial To test, head to https://ledmatrix-editor.arduino.cc The LED Matrix editor is part of Arduino Labs (https://labs.arduino.cc/), and is therefore considered experimental software. Don't forget to close any serial monitor already opened. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library ArduinoLEDMatrix matrix; // Create an instance of the ArduinoLEDMatrix class void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 matrix.begin(); // Initialize the LED matrix } // Define an array to hold pixel data for a single frame (4 pixels) uint32_t frame[] = { 0, 0, 0, 0xFFFF }; void loop() { // Check if there are at least 12 bytes available in the serial buffer if(Serial.available() >= 12){ // Read 4 bytes from the serial buffer and compose them into a 32-bit value for each element in the frame frame[0] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; frame[1] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; frame[2] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; // Load and display the received frame data on the LED matrix matrix.loadFrame(frame); } } Video Demonstration","title":"LivePreview"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/LivePreview/#sketch-code","text":"/* This sketch allows live editing of the matrix pixels using WebSerial To test, head to https://ledmatrix-editor.arduino.cc The LED Matrix editor is part of Arduino Labs (https://labs.arduino.cc/), and is therefore considered experimental software. Don't forget to close any serial monitor already opened. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" // Include the LED_Matrix library ArduinoLEDMatrix matrix; // Create an instance of the ArduinoLEDMatrix class void setup() { Serial.begin(115200); // Initialize serial communication at a baud rate of 115200 matrix.begin(); // Initialize the LED matrix } // Define an array to hold pixel data for a single frame (4 pixels) uint32_t frame[] = { 0, 0, 0, 0xFFFF }; void loop() { // Check if there are at least 12 bytes available in the serial buffer if(Serial.available() >= 12){ // Read 4 bytes from the serial buffer and compose them into a 32-bit value for each element in the frame frame[0] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; frame[1] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; frame[2] = Serial.read() | Serial.read() << 8 | Serial.read() << 16 | Serial.read() << 24; // Load and display the received frame data on the LED matrix matrix.loadFrame(frame); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/LivePreview/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/MatrixFrameBuffer/","text":"Sketch Code /* Matrix Frame Buffer This Arduino sketch demonstrates the creation and manipulation of a frame buffer for the LED matrix. The frame buffer is used to control the lighting of individual LEDs on the matrix, turning them randomly on and off. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ // Include the LED_Matrix library #include \"Arduino_LED_Matrix.h\" // Create an instance of the ArduinoLEDMatrix class ArduinoLEDMatrix matrix; // Define the frame array for the LED matrix with pixel values uint8_t frame[8][12] = { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 } }; // Set up time intervals and dimensions for the matrix unsigned long lastTickTime, lastGameTickTime; #define UPDATE_INTERVAL 100 #define GAME_UPDATE_INTERVAL 66 #define ROWS 8 #define COLUMNS 12 // Variables to track the current positions uint8_t pointX = 0, pointY = 0; void setup() { // Initialize serial communication and delaying for setup Serial.begin(115200); delay(1500); // Initialize the LED matrix matrix.begin(); // Initialize time tracking variables lastGameTickTime = lastTickTime = millis(); } void loop() { // Track the current time unsigned long msNow = millis(); // Update the game logic with a fixed interval if (msNow - lastGameTickTime > GAME_UPDATE_INTERVAL) { // Increment pointX and handling wraparound pointX++; if (pointX >= COLUMNS) { pointX = 0; pointY++; if (pointY >= ROWS) { pointY = 0; } } // Generate random positions and pixel value pointX = random(COLUMNS); pointY = random(ROWS); uint8_t pixelValue = random(2); // Update the frame with the new pixel value frame[pointY][pointX] = pixelValue; // Update the last game tick time lastGameTickTime = msNow; } // Render the LED matrix with the current frame at a fixed interval if (msNow - lastTickTime > UPDATE_INTERVAL) { matrix.renderBitmap(frame, 8, 12); // Update the last rendering tick time lastTickTime = msNow; } } Video Demonstration","title":"MatrixFrameBuffer"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/MatrixFrameBuffer/#sketch-code","text":"/* Matrix Frame Buffer This Arduino sketch demonstrates the creation and manipulation of a frame buffer for the LED matrix. The frame buffer is used to control the lighting of individual LEDs on the matrix, turning them randomly on and off. See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ // Include the LED_Matrix library #include \"Arduino_LED_Matrix.h\" // Create an instance of the ArduinoLEDMatrix class ArduinoLEDMatrix matrix; // Define the frame array for the LED matrix with pixel values uint8_t frame[8][12] = { { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 }, { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }, { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 }, { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 } }; // Set up time intervals and dimensions for the matrix unsigned long lastTickTime, lastGameTickTime; #define UPDATE_INTERVAL 100 #define GAME_UPDATE_INTERVAL 66 #define ROWS 8 #define COLUMNS 12 // Variables to track the current positions uint8_t pointX = 0, pointY = 0; void setup() { // Initialize serial communication and delaying for setup Serial.begin(115200); delay(1500); // Initialize the LED matrix matrix.begin(); // Initialize time tracking variables lastGameTickTime = lastTickTime = millis(); } void loop() { // Track the current time unsigned long msNow = millis(); // Update the game logic with a fixed interval if (msNow - lastGameTickTime > GAME_UPDATE_INTERVAL) { // Increment pointX and handling wraparound pointX++; if (pointX >= COLUMNS) { pointX = 0; pointY++; if (pointY >= ROWS) { pointY = 0; } } // Generate random positions and pixel value pointX = random(COLUMNS); pointY = random(ROWS); uint8_t pixelValue = random(2); // Update the frame with the new pixel value frame[pointY][pointX] = pixelValue; // Update the last game tick time lastGameTickTime = msNow; } // Render the LED matrix with the current frame at a fixed interval if (msNow - lastTickTime > UPDATE_INTERVAL) { matrix.renderBitmap(frame, 8, 12); // Update the last rendering tick time lastTickTime = msNow; } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/MatrixFrameBuffer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/MatrixIntro/","text":"Sketch Code /* Heart Animation Sketch This is the default sketch that comes shipped with every UNO R4 WiFi board. After the animation (a heart) is complete, the built-in LED blinks infinitely. No additional circuit required. created 26 Jun 2023 by Martino Facchin See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ // include the LED Matrix library from the Uno R4 core: #include \"Arduino_LED_Matrix.h\" // make an instance of the library: ArduinoLEDMatrix matrix; //include the \"animation.h\" header file that stores the frames for the animation #include \"animation.h\" void setup() { Serial.begin(115200); //load frames from the animation.h file matrix.loadSequence(frames); // start the matrix matrix.begin(); // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds // matrix.autoscroll(300); //play the animation on the matrix matrix.play(true); //define LED_BUILTIN as an output pinMode(LED_BUILTIN, OUTPUT); } void loop() { //blinks the built-in LED every second digitalWrite(LED_BUILTIN, HIGH); delay(1000); digitalWrite(LED_BUILTIN, LOW); delay(1000); } Video Demonstration","title":"MatrixIntro"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/MatrixIntro/#sketch-code","text":"/* Heart Animation Sketch This is the default sketch that comes shipped with every UNO R4 WiFi board. After the animation (a heart) is complete, the built-in LED blinks infinitely. No additional circuit required. created 26 Jun 2023 by Martino Facchin See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ // include the LED Matrix library from the Uno R4 core: #include \"Arduino_LED_Matrix.h\" // make an instance of the library: ArduinoLEDMatrix matrix; //include the \"animation.h\" header file that stores the frames for the animation #include \"animation.h\" void setup() { Serial.begin(115200); //load frames from the animation.h file matrix.loadSequence(frames); // start the matrix matrix.begin(); // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds // matrix.autoscroll(300); //play the animation on the matrix matrix.play(true); //define LED_BUILTIN as an output pinMode(LED_BUILTIN, OUTPUT); } void loop() { //blinks the built-in LED every second digitalWrite(LED_BUILTIN, HIGH); delay(1000); digitalWrite(LED_BUILTIN, LOW); delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/MatrixIntro/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/PlayAnimation/","text":"Sketch Code /* Play Animation Sketch shows animation defined in animation.h See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" //Include the LED_Matrix library #include \"animation.h\" //Include animation.h header file // Create an instance of the ArduinoLEDMatrix class ArduinoLEDMatrix matrix; void setup() { Serial.begin(115200); // you can also load frames at runtime, without stopping the refresh matrix.loadSequence(animation); matrix.begin(); // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds // matrix.autoscroll(300); matrix.play(true); } void loop() { delay(500); Serial.println(millis()); } Video Demonstration","title":"PlayAnimation"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/PlayAnimation/#sketch-code","text":"/* Play Animation Sketch shows animation defined in animation.h See the full documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix */ #include \"Arduino_LED_Matrix.h\" //Include the LED_Matrix library #include \"animation.h\" //Include animation.h header file // Create an instance of the ArduinoLEDMatrix class ArduinoLEDMatrix matrix; void setup() { Serial.begin(115200); // you can also load frames at runtime, without stopping the refresh matrix.loadSequence(animation); matrix.begin(); // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds // matrix.autoscroll(300); matrix.play(true); } void loop() { delay(500); Serial.println(millis()); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/PlayAnimation/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/TextWithArduinoGraphics/","text":"Sketch Code // To use ArduinoGraphics APIs, please include BEFORE Arduino_LED_Matrix #include \"ArduinoGraphics.h\" #include \"Arduino_LED_Matrix.h\" ArduinoLEDMatrix matrix; void setup() { Serial.begin(115200); matrix.begin(); matrix.beginDraw(); matrix.stroke(0xFFFFFFFF); // add some static text // will only show \"UNO\" (not enough space on the display) const char text[] = \"UNO r4\"; matrix.textFont(Font_4x6); matrix.beginText(0, 1, 0xFFFFFF); matrix.println(text); matrix.endText(); matrix.endDraw(); delay(2000); } void loop() { // Make it scroll! matrix.beginDraw(); matrix.stroke(0xFFFFFFFF); matrix.textScrollSpeed(50); // add the text const char text[] = \" Scrolling text! \"; matrix.textFont(Font_5x7); matrix.beginText(0, 1, 0xFFFFFF); matrix.println(text); matrix.endText(SCROLL_LEFT); matrix.endDraw(); } Video Demonstration","title":"TextWithArduinoGraphics"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/TextWithArduinoGraphics/#sketch-code","text":"// To use ArduinoGraphics APIs, please include BEFORE Arduino_LED_Matrix #include \"ArduinoGraphics.h\" #include \"Arduino_LED_Matrix.h\" ArduinoLEDMatrix matrix; void setup() { Serial.begin(115200); matrix.begin(); matrix.beginDraw(); matrix.stroke(0xFFFFFFFF); // add some static text // will only show \"UNO\" (not enough space on the display) const char text[] = \"UNO r4\"; matrix.textFont(Font_4x6); matrix.beginText(0, 1, 0xFFFFFF); matrix.println(text); matrix.endText(); matrix.endDraw(); delay(2000); } void loop() { // Make it scroll! matrix.beginDraw(); matrix.stroke(0xFFFFFFFF); matrix.textScrollSpeed(50); // add the text const char text[] = \" Scrolling text! \"; matrix.textFont(Font_5x7); matrix.beginText(0, 1, 0xFFFFFF); matrix.println(text); matrix.endText(SCROLL_LEFT); matrix.endDraw(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LED_Matrix/TextWithArduinoGraphics/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Autoscroll/","text":"Sketch Code /* LiquidCrystal Library - Autoscroll Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch demonstrates the use of the autoscroll() and noAutoscroll() functions to make new text scroll or not. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalAutoscroll */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); } void loop() { // set the cursor to (0,0): lcd.setCursor(0, 0); // print from 0 to 9: for (int thisChar = 0; thisChar < 10; thisChar++) { lcd.print(thisChar); delay(500); } // set the cursor to (16,1): lcd.setCursor(16, 1); // set the display to automatically scroll: lcd.autoscroll(); // print from 0 to 9: for (int thisChar = 0; thisChar < 10; thisChar++) { lcd.print(thisChar); delay(500); } // turn off automatic scrolling lcd.noAutoscroll(); // clear screen for the next loop: lcd.clear(); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Autoscroll"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Autoscroll/#sketch-code","text":"/* LiquidCrystal Library - Autoscroll Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch demonstrates the use of the autoscroll() and noAutoscroll() functions to make new text scroll or not. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalAutoscroll */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); } void loop() { // set the cursor to (0,0): lcd.setCursor(0, 0); // print from 0 to 9: for (int thisChar = 0; thisChar < 10; thisChar++) { lcd.print(thisChar); delay(500); } // set the cursor to (16,1): lcd.setCursor(16, 1); // set the display to automatically scroll: lcd.autoscroll(); // print from 0 to 9: for (int thisChar = 0; thisChar < 10; thisChar++) { lcd.print(thisChar); delay(500); } // turn off automatic scrolling lcd.noAutoscroll(); // clear screen for the next loop: lcd.clear(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Autoscroll/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Autoscroll/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Autoscroll/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Blink/","text":"Sketch Code /* LiquidCrystal Library - Blink Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and makes the cursor block blink. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalBlink */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the blinking cursor: lcd.noBlink(); delay(3000); // Turn on the blinking cursor: lcd.blink(); delay(3000); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Blink"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Blink/#sketch-code","text":"/* LiquidCrystal Library - Blink Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and makes the cursor block blink. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalBlink */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the blinking cursor: lcd.noBlink(); delay(3000); // Turn on the blinking cursor: lcd.blink(); delay(3000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Blink/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Blink/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Blink/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Cursor/","text":"Sketch Code ```C /* LiquidCrystal Library - Cursor Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the cursor() and noCursor() methods to turn on and off the cursor. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalCursor */ // include the library code: include // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the cursor: lcd.noCursor(); delay(500); // Turn on the cursor: lcd.cursor(); delay(500); } `` Fritzing Circuit KiCad Schematic Video Demonstration","title":"Cursor"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Cursor/#sketch-code","text":"```C /* LiquidCrystal Library - Cursor Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the cursor() and noCursor() methods to turn on and off the cursor. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalCursor */ // include the library code:","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Cursor/#include","text":"// initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the cursor: lcd.noCursor(); delay(500); // Turn on the cursor: lcd.cursor(); delay(500); } ``","title":"include"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Cursor/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Cursor/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Cursor/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/CustomCharacter/","text":"Sketch Code /* LiquidCrystal Library - Custom Characters Demonstrates how to add custom characters on an LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"I <heart> Arduino!\" and a little dancing man to the LCD. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K potentiometer: * ends to +5V and ground * wiper to LCD VO pin (pin 3) * 10K poterntiometer on pin A0 created 21 Mar 2011 by Tom Igoe modified 11 Nov 2013 by Scott Fitzgerald modified 7 Nov 2016 by Arturo Guadalupi Based on Adafruit's example at https://github.com/adafruit/SPI_VFD/blob/master/examples/createChar/createChar.pde This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalCustomCharacter Also useful: http://icontexto.com/charactercreator/ */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); // make some custom characters: byte heart[8] = { 0b00000, 0b01010, 0b11111, 0b11111, 0b11111, 0b01110, 0b00100, 0b00000 }; byte smiley[8] = { 0b00000, 0b00000, 0b01010, 0b00000, 0b00000, 0b10001, 0b01110, 0b00000 }; byte frownie[8] = { 0b00000, 0b00000, 0b01010, 0b00000, 0b00000, 0b00000, 0b01110, 0b10001 }; byte armsDown[8] = { 0b00100, 0b01010, 0b00100, 0b00100, 0b01110, 0b10101, 0b00100, 0b01010 }; byte armsUp[8] = { 0b00100, 0b01010, 0b00100, 0b10101, 0b01110, 0b00100, 0b00100, 0b01010 }; void setup() { // initialize LCD and set up the number of columns and rows: lcd.begin(16, 2); // create a new character lcd.createChar(0, heart); // create a new character lcd.createChar(1, smiley); // create a new character lcd.createChar(2, frownie); // create a new character lcd.createChar(3, armsDown); // create a new character lcd.createChar(4, armsUp); // set the cursor to the top left lcd.setCursor(0, 0); // Print a message to the lcd. lcd.print(\"I \"); lcd.write(byte(0)); // when calling lcd.write() '0' must be cast as a byte lcd.print(\" Arduino! \"); lcd.write((byte)1); } void loop() { // read the potentiometer on A0: int sensorReading = analogRead(A0); // map the result to 200 - 1000: int delayTime = map(sensorReading, 0, 1023, 200, 1000); // set the cursor to the bottom row, 5th position: lcd.setCursor(4, 1); // draw the little man, arms down: lcd.write(3); delay(delayTime); lcd.setCursor(4, 1); // draw him arms up: lcd.write(4); delay(delayTime); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"CustomCharacter"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/CustomCharacter/#sketch-code","text":"/* LiquidCrystal Library - Custom Characters Demonstrates how to add custom characters on an LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"I <heart> Arduino!\" and a little dancing man to the LCD. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K potentiometer: * ends to +5V and ground * wiper to LCD VO pin (pin 3) * 10K poterntiometer on pin A0 created 21 Mar 2011 by Tom Igoe modified 11 Nov 2013 by Scott Fitzgerald modified 7 Nov 2016 by Arturo Guadalupi Based on Adafruit's example at https://github.com/adafruit/SPI_VFD/blob/master/examples/createChar/createChar.pde This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalCustomCharacter Also useful: http://icontexto.com/charactercreator/ */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); // make some custom characters: byte heart[8] = { 0b00000, 0b01010, 0b11111, 0b11111, 0b11111, 0b01110, 0b00100, 0b00000 }; byte smiley[8] = { 0b00000, 0b00000, 0b01010, 0b00000, 0b00000, 0b10001, 0b01110, 0b00000 }; byte frownie[8] = { 0b00000, 0b00000, 0b01010, 0b00000, 0b00000, 0b00000, 0b01110, 0b10001 }; byte armsDown[8] = { 0b00100, 0b01010, 0b00100, 0b00100, 0b01110, 0b10101, 0b00100, 0b01010 }; byte armsUp[8] = { 0b00100, 0b01010, 0b00100, 0b10101, 0b01110, 0b00100, 0b00100, 0b01010 }; void setup() { // initialize LCD and set up the number of columns and rows: lcd.begin(16, 2); // create a new character lcd.createChar(0, heart); // create a new character lcd.createChar(1, smiley); // create a new character lcd.createChar(2, frownie); // create a new character lcd.createChar(3, armsDown); // create a new character lcd.createChar(4, armsUp); // set the cursor to the top left lcd.setCursor(0, 0); // Print a message to the lcd. lcd.print(\"I \"); lcd.write(byte(0)); // when calling lcd.write() '0' must be cast as a byte lcd.print(\" Arduino! \"); lcd.write((byte)1); } void loop() { // read the potentiometer on A0: int sensorReading = analogRead(A0); // map the result to 200 - 1000: int delayTime = map(sensorReading, 0, 1023, 200, 1000); // set the cursor to the bottom row, 5th position: lcd.setCursor(4, 1); // draw the little man, arms down: lcd.write(3); delay(delayTime); lcd.setCursor(4, 1); // draw him arms up: lcd.write(4); delay(delayTime); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/CustomCharacter/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/CustomCharacter/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/CustomCharacter/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Display/","text":"Sketch Code /* LiquidCrystal Library - display() and noDisplay() Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the display() and noDisplay() functions to turn on and off the display. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalDisplay */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the display: lcd.noDisplay(); delay(500); // Turn on the display: lcd.display(); delay(500); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Display"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Display/#sketch-code","text":"/* LiquidCrystal Library - display() and noDisplay() Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the display() and noDisplay() functions to turn on and off the display. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalDisplay */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // Turn off the display: lcd.noDisplay(); delay(500); // Turn on the display: lcd.display(); delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Display/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Display/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Display/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/HelloWorld/","text":"Sketch Code /* LiquidCrystal Library - Hello World Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and shows the time. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * LCD VSS pin to ground * LCD VCC pin to 5V * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalHelloWorld */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // set the cursor to column 0, line 1 // (note: line 1 is the second row, since counting begins with 0): lcd.setCursor(0, 1); // print the number of seconds since reset: lcd.print(millis() / 1000); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"HelloWorld"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/HelloWorld/#sketch-code","text":"/* LiquidCrystal Library - Hello World Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and shows the time. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * LCD VSS pin to ground * LCD VCC pin to 5V * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalHelloWorld */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); } void loop() { // set the cursor to column 0, line 1 // (note: line 1 is the second row, since counting begins with 0): lcd.setCursor(0, 1); // print the number of seconds since reset: lcd.print(millis() / 1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/HelloWorld/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/HelloWorld/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/HelloWorld/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Scroll/","text":"Sketch Code /* LiquidCrystal Library - scrollDisplayLeft() and scrollDisplayRight() Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the scrollDisplayLeft() and scrollDisplayRight() methods to scroll the text. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalScroll */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); delay(1000); } void loop() { // scroll 13 positions (string length) to the left // to move it offscreen left: for (int positionCounter = 0; positionCounter < 13; positionCounter++) { // scroll one position left: lcd.scrollDisplayLeft(); // wait a bit: delay(150); } // scroll 29 positions (string length + display length) to the right // to move it offscreen right: for (int positionCounter = 0; positionCounter < 29; positionCounter++) { // scroll one position right: lcd.scrollDisplayRight(); // wait a bit: delay(150); } // scroll 16 positions (display length + string length) to the left // to move it back to center: for (int positionCounter = 0; positionCounter < 16; positionCounter++) { // scroll one position left: lcd.scrollDisplayLeft(); // wait a bit: delay(150); } // delay at the end of the full loop: delay(1000); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Scroll"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Scroll/#sketch-code","text":"/* LiquidCrystal Library - scrollDisplayLeft() and scrollDisplayRight() Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints \"Hello World!\" to the LCD and uses the scrollDisplayLeft() and scrollDisplayRight() methods to scroll the text. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalScroll */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // Print a message to the LCD. lcd.print(\"hello, world!\"); delay(1000); } void loop() { // scroll 13 positions (string length) to the left // to move it offscreen left: for (int positionCounter = 0; positionCounter < 13; positionCounter++) { // scroll one position left: lcd.scrollDisplayLeft(); // wait a bit: delay(150); } // scroll 29 positions (string length + display length) to the right // to move it offscreen right: for (int positionCounter = 0; positionCounter < 29; positionCounter++) { // scroll one position right: lcd.scrollDisplayRight(); // wait a bit: delay(150); } // scroll 16 positions (display length + string length) to the left // to move it back to center: for (int positionCounter = 0; positionCounter < 16; positionCounter++) { // scroll one position left: lcd.scrollDisplayLeft(); // wait a bit: delay(150); } // delay at the end of the full loop: delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Scroll/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Scroll/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/Scroll/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/SerialDisplay/","text":"Sketch Code /* LiquidCrystal Library - Serial Input Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch displays text sent over the serial port (e.g. from the Serial Monitor) on an attached LCD. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalSerialDisplay */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // initialize the serial communications: Serial.begin(9600); } void loop() { // when characters arrive over the serial port... if (Serial.available()) { // wait a bit for the entire message to arrive delay(100); // clear the screen lcd.clear(); // read all the available characters while (Serial.available() > 0) { // display each character to the LCD lcd.write(Serial.read()); } } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"SerialDisplay"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/SerialDisplay/#sketch-code","text":"/* LiquidCrystal Library - Serial Input Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch displays text sent over the serial port (e.g. from the Serial Monitor) on an attached LCD. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalSerialDisplay */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // initialize the serial communications: Serial.begin(9600); } void loop() { // when characters arrive over the serial port... if (Serial.available()) { // wait a bit for the entire message to arrive delay(100); // clear the screen lcd.clear(); // read all the available characters while (Serial.available() > 0) { // display each character to the LCD lcd.write(Serial.read()); } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/SerialDisplay/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/SerialDisplay/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/SerialDisplay/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/TextDirection/","text":"Sketch Code /* LiquidCrystal Library - TextDirection Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch demonstrates how to use leftToRight() and rightToLeft() to move the cursor. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalTextDirection */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); int thisChar = 'a'; void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // turn on the cursor: lcd.cursor(); } void loop() { // reverse directions at 'm': if (thisChar == 'm') { // go right for the next letter lcd.rightToLeft(); } // reverse again at 's': if (thisChar == 's') { // go left for the next letter lcd.leftToRight(); } // reset at 'z': if (thisChar > 'z') { // go to (0,0): lcd.home(); // start again at 0 thisChar = 'a'; } // print the character lcd.write(thisChar); // wait a second: delay(1000); // increment the letter: thisChar++; } Fritzing Circuit KiCad Schematic Video Demonstration","title":"TextDirection"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/TextDirection/#sketch-code","text":"/* LiquidCrystal Library - TextDirection Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch demonstrates how to use leftToRight() and rightToLeft() to move the cursor. The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalTextDirection */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); int thisChar = 'a'; void setup() { // set up the LCD's number of columns and rows: lcd.begin(16, 2); // turn on the cursor: lcd.cursor(); } void loop() { // reverse directions at 'm': if (thisChar == 'm') { // go right for the next letter lcd.rightToLeft(); } // reverse again at 's': if (thisChar == 's') { // go left for the next letter lcd.leftToRight(); } // reset at 'z': if (thisChar > 'z') { // go to (0,0): lcd.home(); // start again at 0 thisChar = 'a'; } // print the character lcd.write(thisChar); // wait a second: delay(1000); // increment the letter: thisChar++; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/TextDirection/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/TextDirection/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/TextDirection/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/setCursor/","text":"Sketch Code /* LiquidCrystal Library - setCursor Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints to all the positions of the LCD using the setCursor() method: The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalSetCursor */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); // these constants won't change. But you can change the size of // your LCD using them: const int numRows = 2; const int numCols = 16; void setup() { // set up the LCD's number of columns and rows: lcd.begin(numCols, numRows); } void loop() { // loop from ASCII 'a' to ASCII 'z': for (int thisLetter = 'a'; thisLetter <= 'z'; thisLetter++) { // loop over the columns: for (int thisRow = 0; thisRow < numRows; thisRow++) { // loop over the rows: for (int thisCol = 0; thisCol < numCols; thisCol++) { // set the cursor position: lcd.setCursor(thisCol, thisRow); // print the letter: lcd.write(thisLetter); delay(200); } } } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"setCursor"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/setCursor/#sketch-code","text":"/* LiquidCrystal Library - setCursor Demonstrates the use a 16x2 LCD display. The LiquidCrystal library works with all LCD displays that are compatible with the Hitachi HD44780 driver. There are many of them out there, and you can usually tell them by the 16-pin interface. This sketch prints to all the positions of the LCD using the setCursor() method: The circuit: * LCD RS pin to digital pin 12 * LCD Enable pin to digital pin 11 * LCD D4 pin to digital pin 5 * LCD D5 pin to digital pin 4 * LCD D6 pin to digital pin 3 * LCD D7 pin to digital pin 2 * LCD R/W pin to ground * 10K resistor: * ends to +5V and ground * wiper to LCD VO pin (pin 3) Library originally added 18 Apr 2008 by David A. Mellis library modified 5 Jul 2009 by Limor Fried (http://www.ladyada.net) example added 9 Jul 2009 by Tom Igoe modified 22 Nov 2010 by Tom Igoe modified 7 Nov 2016 by Arturo Guadalupi This example code is in the public domain. http://www.arduino.cc/en/Tutorial/LiquidCrystalSetCursor */ // include the library code: #include <LiquidCrystal.h> // initialize the library by associating any needed LCD interface pin // with the arduino pin number it is connected to const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2; LiquidCrystal lcd(rs, en, d4, d5, d6, d7); // these constants won't change. But you can change the size of // your LCD using them: const int numRows = 2; const int numCols = 16; void setup() { // set up the LCD's number of columns and rows: lcd.begin(numCols, numRows); } void loop() { // loop from ASCII 'a' to ASCII 'z': for (int thisLetter = 'a'; thisLetter <= 'z'; thisLetter++) { // loop over the columns: for (int thisRow = 0; thisRow < numRows; thisRow++) { // loop over the rows: for (int thisCol = 0; thisCol < numCols; thisCol++) { // set the cursor position: lcd.setCursor(thisCol, thisRow); // print the letter: lcd.write(thisLetter); delay(200); } } } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/setCursor/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/setCursor/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/LiquidCrystal/setCursor/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/OPAMP/start_opamp/","text":"Sketch Code #include <OPAMP.h> void setup () { Serial.begin(9600); delay(2000); // serial monitor delay // activate OPAMP, default channel 0 // Plus: Analog A1 // Minus: Analog A2 // Output: Analog A3 if (!OPAMP.begin(OPAMP_SPEED_HIGHSPEED)) { Serial.println(\"Failed to start OPAMP!\"); } bool const isRunning = OPAMP.isRunning(0); if (isRunning) { Serial.println(\"OPAMP running on channel 0!\"); } else { Serial.println(\"OPAMP channel 0 is not running!\"); } } void loop() { delay(1000); // do nothing } Video Demonstration","title":"Start opamp"},{"location":"05_examples_uno_r4_wifi/OPAMP/start_opamp/#sketch-code","text":"#include <OPAMP.h> void setup () { Serial.begin(9600); delay(2000); // serial monitor delay // activate OPAMP, default channel 0 // Plus: Analog A1 // Minus: Analog A2 // Output: Analog A3 if (!OPAMP.begin(OPAMP_SPEED_HIGHSPEED)) { Serial.println(\"Failed to start OPAMP!\"); } bool const isRunning = OPAMP.isRunning(0); if (isRunning) { Serial.println(\"OPAMP running on channel 0!\"); } else { Serial.println(\"OPAMP channel 0 is not running!\"); } } void loop() { delay(1000); // do nothing }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/OPAMP/start_opamp/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/OTAUpdate/OTA/","text":"Sketch Code /* OTA This sketch demonstrates how to make an OTA Update on the UNO R4 WiFi. Upload the sketch and wait for the invasion! */ #include \"WiFiS3.h\" #include \"OTAUpdate.h\" #include \"root_ca.h\" #include \"arduino_secrets.h\" char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; OTAUpdate ota; static char const OTA_FILE_LOCATION[] = \"https://downloads.arduino.cc/ota/UNOR4WIFI_Animation.ota\"; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the Wi-Fi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with Wi-Fi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to Wi-Fi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 1 seconds for connection: delay(1000); } printWiFiStatus(); OTAUpdate::Error ret = OTAUpdate::Error::None; ret = ota.begin(\"/update.bin\"); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.begin() error: \"); Serial.println((int)ret); return; } ret = ota.setCACert(root_ca); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.setCACert() error: \"); Serial.println((int)ret); return; } int ota_size = ota.download(OTA_FILE_LOCATION, \"/update.bin\"); if(ota_size <= 0) { Serial.println(\"ota.download() error: \"); Serial.println(ota_size); return; } ret = ota.verify(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.verify() error: \"); Serial.println((int)ret); return; } ret = ota.update(\"/update.bin\"); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.update() error: \"); Serial.println((int)ret); return; } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ delay(1000); } /* -------------------------------------------------------------------------- */ void printWiFiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Video Demonstration","title":"OTA"},{"location":"05_examples_uno_r4_wifi/OTAUpdate/OTA/#sketch-code","text":"/* OTA This sketch demonstrates how to make an OTA Update on the UNO R4 WiFi. Upload the sketch and wait for the invasion! */ #include \"WiFiS3.h\" #include \"OTAUpdate.h\" #include \"root_ca.h\" #include \"arduino_secrets.h\" char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; OTAUpdate ota; static char const OTA_FILE_LOCATION[] = \"https://downloads.arduino.cc/ota/UNOR4WIFI_Animation.ota\"; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the Wi-Fi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with Wi-Fi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to Wi-Fi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 1 seconds for connection: delay(1000); } printWiFiStatus(); OTAUpdate::Error ret = OTAUpdate::Error::None; ret = ota.begin(\"/update.bin\"); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.begin() error: \"); Serial.println((int)ret); return; } ret = ota.setCACert(root_ca); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.setCACert() error: \"); Serial.println((int)ret); return; } int ota_size = ota.download(OTA_FILE_LOCATION, \"/update.bin\"); if(ota_size <= 0) { Serial.println(\"ota.download() error: \"); Serial.println(ota_size); return; } ret = ota.verify(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.verify() error: \"); Serial.println((int)ret); return; } ret = ota.update(\"/update.bin\"); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.update() error: \"); Serial.println((int)ret); return; } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ delay(1000); } /* -------------------------------------------------------------------------- */ void printWiFiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/OTAUpdate/OTA/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/OTAUpdate/WiFiFirmwareOTA/","text":"Sketch Code /* OTA This sketch demonstrates how to make the UNO R4 WiFi self-update its Wi-Fi module firmware via OTA. Upload the Sketch and wait for Serial detach. After the update the new Wi-Fi firmware version will be 98.98.98 WARNING: running this sketch will load a test Wi-Fi firmware version on the UNO R4 WiFi module. To restore a production firmware use the Arduino Firmware Uploader or the update packages available here: https://github.com/arduino/uno-r4-wifi-usb-bridge/releases */ #include \"WiFiS3.h\" #include \"OTAUpdate.h\" #include \"root_ca.h\" #include \"arduino_secrets.h\" char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; OTAUpdate ota; static char const OTA_FILE_LOCATION[] = \"https://downloads.arduino.cc/ota/UNOR4USBBridge.ino.ota\"; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the Wi-Fi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with Wi-Fi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } Serial.print(\"Current Wi-Fi firmware version: \"); Serial.println(fv); // attempt to connect to Wi-Fi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 1 seconds for connection: delay(1000); } printWiFiStatus(); OTAUpdate::Error ret = OTAUpdate::Error::None; ret = ota.begin(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.begin() error: \"); Serial.println((int)ret); return; } ret = ota.setCACert(root_ca); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.setCACert() error: \"); Serial.println((int)ret); return; } int ota_size = ota.download(OTA_FILE_LOCATION); if(ota_size <= 0) { Serial.println(\"ota.download() error: \"); Serial.println(ota_size); return; } ret = ota.verify(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.verify() error: \"); Serial.println((int)ret); return; } ret = ota.update(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.update() error: \"); Serial.println((int)ret); return; } ret = ota.reset(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.reset() error: \"); Serial.println((int)ret); return; } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ String fv = WiFi.firmwareVersion(); Serial.print(\"Updated Wi-Fi firmware version: \"); Serial.println(fv); delay(1000); } /* -------------------------------------------------------------------------- */ void printWiFiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Video Demonstration","title":"WiFiFirmwareOTA"},{"location":"05_examples_uno_r4_wifi/OTAUpdate/WiFiFirmwareOTA/#sketch-code","text":"/* OTA This sketch demonstrates how to make the UNO R4 WiFi self-update its Wi-Fi module firmware via OTA. Upload the Sketch and wait for Serial detach. After the update the new Wi-Fi firmware version will be 98.98.98 WARNING: running this sketch will load a test Wi-Fi firmware version on the UNO R4 WiFi module. To restore a production firmware use the Arduino Firmware Uploader or the update packages available here: https://github.com/arduino/uno-r4-wifi-usb-bridge/releases */ #include \"WiFiS3.h\" #include \"OTAUpdate.h\" #include \"root_ca.h\" #include \"arduino_secrets.h\" char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; OTAUpdate ota; static char const OTA_FILE_LOCATION[] = \"https://downloads.arduino.cc/ota/UNOR4USBBridge.ino.ota\"; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the Wi-Fi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with Wi-Fi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } Serial.print(\"Current Wi-Fi firmware version: \"); Serial.println(fv); // attempt to connect to Wi-Fi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 1 seconds for connection: delay(1000); } printWiFiStatus(); OTAUpdate::Error ret = OTAUpdate::Error::None; ret = ota.begin(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.begin() error: \"); Serial.println((int)ret); return; } ret = ota.setCACert(root_ca); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.setCACert() error: \"); Serial.println((int)ret); return; } int ota_size = ota.download(OTA_FILE_LOCATION); if(ota_size <= 0) { Serial.println(\"ota.download() error: \"); Serial.println(ota_size); return; } ret = ota.verify(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.verify() error: \"); Serial.println((int)ret); return; } ret = ota.update(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.update() error: \"); Serial.println((int)ret); return; } ret = ota.reset(); if(ret != OTAUpdate::Error::None) { Serial.println(\"ota.reset() error: \"); Serial.println((int)ret); return; } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ String fv = WiFi.firmwareVersion(); Serial.print(\"Updated Wi-Fi firmware version: \"); Serial.println(fv); delay(1000); } /* -------------------------------------------------------------------------- */ void printWiFiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/OTAUpdate/WiFiFirmwareOTA/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_Alarm/","text":"Sketch Code /* * RTC_Alarm * * This example demonstrates how to use the alarm functionality of the RTC * (Real Time Clock) on the Portenta C33 and UNO R4 Minima / WiFi. * * It turns on the built-in LED when the alarm * is triggered, which is once every minute in this example. * In addition, inside the loop, we print the state of the alarm * continuously, which is either 0 (LOW) or 1 (HIGH). * * Note that the Portenta C33's LED is inverted and will be lit when * the state is 0 (LOW). * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ unsigned long previousMillis = 0; const long interval = 1000; bool ledState = false; // Include the RTC library #include \"RTC.h\" void setup() { //initialize Serial Communication Serial.begin(9600); //define LED as output pinMode(LED_BUILTIN, OUTPUT); // Initialize the RTC RTC.begin(); // RTC.setTime() must be called for RTC.setAlarmCallback to work, but it doesn't matter // what date and time it's set to in this example RTCTime initialTime(7, Month::JUNE, 2023, 13, 03, 00, DayOfWeek::WEDNESDAY, SaveLight::SAVING_TIME_ACTIVE); RTC.setTime(initialTime); // Trigger the alarm every time the seconds are zero RTCTime alarmTime; alarmTime.setSecond(0); // Make sure to only match on the seconds in this example - not on any other parts of the date/time AlarmMatch matchTime; matchTime.addMatchSecond(); //sets the alarm callback RTC.setAlarmCallback(alarmCallback, alarmTime, matchTime); } void loop() { // in the loop, we continuously print the alarm's current state // this is for debugging only and has no effect on the alarm whatsoever unsigned long currentMillis = millis(); if (currentMillis - previousMillis >= interval) { // save the last time you blinked the LED previousMillis = currentMillis; Serial.print(\"Alarm state: \"); Serial.println(ledState); } } // this function activates every minute // and changes the ledState boolean void alarmCallback() { if (!ledState) { digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } ledState = !ledState; } Video Demonstration","title":"RTC Alarm"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_Alarm/#sketch-code","text":"/* * RTC_Alarm * * This example demonstrates how to use the alarm functionality of the RTC * (Real Time Clock) on the Portenta C33 and UNO R4 Minima / WiFi. * * It turns on the built-in LED when the alarm * is triggered, which is once every minute in this example. * In addition, inside the loop, we print the state of the alarm * continuously, which is either 0 (LOW) or 1 (HIGH). * * Note that the Portenta C33's LED is inverted and will be lit when * the state is 0 (LOW). * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ unsigned long previousMillis = 0; const long interval = 1000; bool ledState = false; // Include the RTC library #include \"RTC.h\" void setup() { //initialize Serial Communication Serial.begin(9600); //define LED as output pinMode(LED_BUILTIN, OUTPUT); // Initialize the RTC RTC.begin(); // RTC.setTime() must be called for RTC.setAlarmCallback to work, but it doesn't matter // what date and time it's set to in this example RTCTime initialTime(7, Month::JUNE, 2023, 13, 03, 00, DayOfWeek::WEDNESDAY, SaveLight::SAVING_TIME_ACTIVE); RTC.setTime(initialTime); // Trigger the alarm every time the seconds are zero RTCTime alarmTime; alarmTime.setSecond(0); // Make sure to only match on the seconds in this example - not on any other parts of the date/time AlarmMatch matchTime; matchTime.addMatchSecond(); //sets the alarm callback RTC.setAlarmCallback(alarmCallback, alarmTime, matchTime); } void loop() { // in the loop, we continuously print the alarm's current state // this is for debugging only and has no effect on the alarm whatsoever unsigned long currentMillis = millis(); if (currentMillis - previousMillis >= interval) { // save the last time you blinked the LED previousMillis = currentMillis; Serial.print(\"Alarm state: \"); Serial.println(ledState); } } // this function activates every minute // and changes the ledState boolean void alarmCallback() { if (!ledState) { digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } ledState = !ledState; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_Alarm/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_AutomaticExample/","text":"Sketch Code /* * RTC_AutomaticExample * * This example sets the RTC (Real Time Clock) on the Portenta C33 automatically by * retrieving the date and time from the computer you upload the sketch from, at the * point when you start the upload. * * Next, it gets the current time from the RTC and prints it to the Serial Monitor. * It then sets an RTC alarm to fire every time the seconds value of the time is zero. * The alarm, which now goes off once a minute, triggers a callback that prints the * current time to the Serial Monitor. * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" DayOfWeek convertDayOfWeek(String s) { if (s == String(\"Mon\")) { return DayOfWeek::MONDAY; } if (s == String(\"Tue\")) { return DayOfWeek::TUESDAY; } if (s == String(\"Wed\")) { return DayOfWeek::WEDNESDAY; } if (s == String(\"Thu\")) { return DayOfWeek::THURSDAY; } if (s == String(\"Fri\")) { return DayOfWeek::FRIDAY; } if (s == String(\"Sat\")) { return DayOfWeek::SATURDAY; } if (s == String(\"Sun\")) { return DayOfWeek::SUNDAY; } } Month convertMonth(String s) { if (s == String(\"Jan\")) { return Month::JANUARY; } if (s == String(\"Feb\")) { return Month::FEBRUARY; } if (s == String(\"Mar\")) { return Month::MARCH; } if (s == String(\"Apr\")) { return Month::APRIL; } if (s == String(\"May\")) { return Month::MAY; } if (s == String(\"Jun\")) { return Month::JUNE; } if (s == String(\"Jul\")) { return Month::JULY; } if (s == String(\"Aug\")) { return Month::AUGUST; } if (s == String(\"Sep\")) { return Month::SEPTEMBER; } if (s == String(\"Oct\")) { return Month::OCTOBER; } if (s == String(\"Nov\")) { return Month::NOVEMBER; } if (s == String(\"Dec\")) { return Month::DECEMBER; } } RTCTime currentRTCTime() { // Get a compilation timestamp of the format: Wed May 10 08:54:31 2023 // __TIMESTAMP__ is a GNU C extension macro // We can't use the standard macros __DATE__ and __TIME__ because they don't provide the day of the week String timeStamp = __TIMESTAMP__; // Extract the day of the week int pos1 = timeStamp.indexOf(\" \"); DayOfWeek dayOfWeek = convertDayOfWeek(timeStamp.substring(0, pos1)); // Extract the month ++pos1; int pos2 = timeStamp.indexOf(\" \", pos1); Month month = convertMonth(timeStamp.substring(pos1, pos2)); // Extract the day pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int day = timeStamp.substring(pos1, pos2).toInt(); // Extract the hour pos1 = ++pos2; pos2 = timeStamp.indexOf(\":\", pos1); int hour = timeStamp.substring(pos1, pos2).toInt(); // Extract the minute pos1 = ++pos2; pos2 = timeStamp.indexOf(\":\", pos1); int minute = timeStamp.substring(pos1, pos2).toInt(); // Extract the second pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int second = timeStamp.substring(pos1, pos2).toInt(); // Extract the year pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int year = timeStamp.substring(pos1, pos2).toInt(); return RTCTime(day, month, year, hour, minute, second, dayOfWeek, SaveLight::SAVING_TIME_INACTIVE); } void alarmCallback() { Serial.println(\"An alarm was triggered at:\"); RTCTime currentTime; RTC.getTime(currentTime); Serial.print(currentTime.getYear()); Serial.print(\"-\"); Serial.print(Month2int(currentTime.getMonth())); Serial.print(\"-\"); Serial.print(currentTime.getDayOfMonth()); Serial.print(\" \"); Serial.print(currentTime.getHour()); Serial.print(\":\"); Serial.print(currentTime.getMinutes()); Serial.print(\":\"); Serial.println(currentTime.getSeconds()); } void setup() { Serial.begin(9600); while (!Serial) ; // Initialize the RTC RTC.begin(); // Get the current date and time when the sketch is uploaded and set the RTC RTCTime timeToSet = currentRTCTime(); RTC.setTime(timeToSet); // Retrieve the date and time from the RTC and print them Serial.println(\"The RTC was just set to: \"); RTCTime currentTime; RTC.getTime(currentTime); Serial.print(currentTime.getYear()); Serial.print(\"-\"); Serial.print(Month2int(currentTime.getMonth())); Serial.print(\"-\"); Serial.print(currentTime.getDayOfMonth()); Serial.print(\" \"); Serial.print(currentTime.getHour()); Serial.print(\":\"); Serial.print(currentTime.getMinutes()); Serial.print(\":\"); Serial.println(currentTime.getSeconds()); // Create an alarm time with the seconds value set to zero RTCTime alarmTime; alarmTime.setSecond(0); // Tell the RTC to only match on the seconds value AlarmMatch alarmMatch; alarmMatch.addMatchSecond(); // Set the alarm callback function RTC.setAlarmCallback(alarmCallback, alarmTime, alarmMatch); } void loop() { } Video Demonstration","title":"RTC AutomaticExample"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_AutomaticExample/#sketch-code","text":"/* * RTC_AutomaticExample * * This example sets the RTC (Real Time Clock) on the Portenta C33 automatically by * retrieving the date and time from the computer you upload the sketch from, at the * point when you start the upload. * * Next, it gets the current time from the RTC and prints it to the Serial Monitor. * It then sets an RTC alarm to fire every time the seconds value of the time is zero. * The alarm, which now goes off once a minute, triggers a callback that prints the * current time to the Serial Monitor. * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" DayOfWeek convertDayOfWeek(String s) { if (s == String(\"Mon\")) { return DayOfWeek::MONDAY; } if (s == String(\"Tue\")) { return DayOfWeek::TUESDAY; } if (s == String(\"Wed\")) { return DayOfWeek::WEDNESDAY; } if (s == String(\"Thu\")) { return DayOfWeek::THURSDAY; } if (s == String(\"Fri\")) { return DayOfWeek::FRIDAY; } if (s == String(\"Sat\")) { return DayOfWeek::SATURDAY; } if (s == String(\"Sun\")) { return DayOfWeek::SUNDAY; } } Month convertMonth(String s) { if (s == String(\"Jan\")) { return Month::JANUARY; } if (s == String(\"Feb\")) { return Month::FEBRUARY; } if (s == String(\"Mar\")) { return Month::MARCH; } if (s == String(\"Apr\")) { return Month::APRIL; } if (s == String(\"May\")) { return Month::MAY; } if (s == String(\"Jun\")) { return Month::JUNE; } if (s == String(\"Jul\")) { return Month::JULY; } if (s == String(\"Aug\")) { return Month::AUGUST; } if (s == String(\"Sep\")) { return Month::SEPTEMBER; } if (s == String(\"Oct\")) { return Month::OCTOBER; } if (s == String(\"Nov\")) { return Month::NOVEMBER; } if (s == String(\"Dec\")) { return Month::DECEMBER; } } RTCTime currentRTCTime() { // Get a compilation timestamp of the format: Wed May 10 08:54:31 2023 // __TIMESTAMP__ is a GNU C extension macro // We can't use the standard macros __DATE__ and __TIME__ because they don't provide the day of the week String timeStamp = __TIMESTAMP__; // Extract the day of the week int pos1 = timeStamp.indexOf(\" \"); DayOfWeek dayOfWeek = convertDayOfWeek(timeStamp.substring(0, pos1)); // Extract the month ++pos1; int pos2 = timeStamp.indexOf(\" \", pos1); Month month = convertMonth(timeStamp.substring(pos1, pos2)); // Extract the day pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int day = timeStamp.substring(pos1, pos2).toInt(); // Extract the hour pos1 = ++pos2; pos2 = timeStamp.indexOf(\":\", pos1); int hour = timeStamp.substring(pos1, pos2).toInt(); // Extract the minute pos1 = ++pos2; pos2 = timeStamp.indexOf(\":\", pos1); int minute = timeStamp.substring(pos1, pos2).toInt(); // Extract the second pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int second = timeStamp.substring(pos1, pos2).toInt(); // Extract the year pos1 = ++pos2; pos2 = timeStamp.indexOf(\" \", pos1); int year = timeStamp.substring(pos1, pos2).toInt(); return RTCTime(day, month, year, hour, minute, second, dayOfWeek, SaveLight::SAVING_TIME_INACTIVE); } void alarmCallback() { Serial.println(\"An alarm was triggered at:\"); RTCTime currentTime; RTC.getTime(currentTime); Serial.print(currentTime.getYear()); Serial.print(\"-\"); Serial.print(Month2int(currentTime.getMonth())); Serial.print(\"-\"); Serial.print(currentTime.getDayOfMonth()); Serial.print(\" \"); Serial.print(currentTime.getHour()); Serial.print(\":\"); Serial.print(currentTime.getMinutes()); Serial.print(\":\"); Serial.println(currentTime.getSeconds()); } void setup() { Serial.begin(9600); while (!Serial) ; // Initialize the RTC RTC.begin(); // Get the current date and time when the sketch is uploaded and set the RTC RTCTime timeToSet = currentRTCTime(); RTC.setTime(timeToSet); // Retrieve the date and time from the RTC and print them Serial.println(\"The RTC was just set to: \"); RTCTime currentTime; RTC.getTime(currentTime); Serial.print(currentTime.getYear()); Serial.print(\"-\"); Serial.print(Month2int(currentTime.getMonth())); Serial.print(\"-\"); Serial.print(currentTime.getDayOfMonth()); Serial.print(\" \"); Serial.print(currentTime.getHour()); Serial.print(\":\"); Serial.print(currentTime.getMinutes()); Serial.print(\":\"); Serial.println(currentTime.getSeconds()); // Create an alarm time with the seconds value set to zero RTCTime alarmTime; alarmTime.setSecond(0); // Tell the RTC to only match on the seconds value AlarmMatch alarmMatch; alarmMatch.addMatchSecond(); // Set the alarm callback function RTC.setAlarmCallback(alarmCallback, alarmTime, alarmMatch); } void loop() { }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_AutomaticExample/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_NTPSync/","text":"Sketch Code /** * RTC_NTPSync * * This example shows how to set the RTC (Real Time Clock) on the Portenta C33 / UNO R4 WiFi * to the current date and time retrieved from an NTP server on the Internet (pool.ntp.org). * Then the current time from the RTC is printed to the Serial port. * * Instructions: * 1. Download the NTPClient library (https://github.com/arduino-libraries/NTPClient) through the Library Manager * 2. Change the WiFi credentials in the arduino_secrets.h file to match your WiFi network. * 3. Upload this sketch to Portenta C33 / UNO R4 WiFi. * 4. Open the Serial Monitor. * * Initial author: Sebastian Romero @sebromero * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" //Include the NTP library #include <NTPClient.h> #if defined(ARDUINO_PORTENTA_C33) #include <WiFiC3.h> #elif defined(ARDUINO_UNOWIFIR4) #include <WiFiS3.h> #endif #include <WiFiUdp.h> #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int wifiStatus = WL_IDLE_STATUS; WiFiUDP Udp; // A UDP instance to let us send and receive packets over UDP NTPClient timeClient(Udp); void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } void connectToWiFi(){ // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (wifiStatus != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: wifiStatus = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } Serial.println(\"Connected to WiFi\"); printWifiStatus(); } void setup(){ Serial.begin(9600); while (!Serial); connectToWiFi(); RTC.begin(); Serial.println(\"\\nStarting connection to server...\"); timeClient.begin(); timeClient.update(); // Get the current date and time from an NTP server and convert // it to UTC +2 by passing the time zone offset in hours. // You may change the time zone offset to your local one. auto timeZoneOffsetHours = 2; auto unixTime = timeClient.getEpochTime() + (timeZoneOffsetHours * 3600); Serial.print(\"Unix time = \"); Serial.println(unixTime); RTCTime timeToSet = RTCTime(unixTime); RTC.setTime(timeToSet); // Retrieve the date and time from the RTC and print them RTCTime currentTime; RTC.getTime(currentTime); Serial.println(\"The RTC was just set to: \" + String(currentTime)); } void loop(){} Video Demonstration","title":"RTC NTPSync"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_NTPSync/#sketch-code","text":"/** * RTC_NTPSync * * This example shows how to set the RTC (Real Time Clock) on the Portenta C33 / UNO R4 WiFi * to the current date and time retrieved from an NTP server on the Internet (pool.ntp.org). * Then the current time from the RTC is printed to the Serial port. * * Instructions: * 1. Download the NTPClient library (https://github.com/arduino-libraries/NTPClient) through the Library Manager * 2. Change the WiFi credentials in the arduino_secrets.h file to match your WiFi network. * 3. Upload this sketch to Portenta C33 / UNO R4 WiFi. * 4. Open the Serial Monitor. * * Initial author: Sebastian Romero @sebromero * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" //Include the NTP library #include <NTPClient.h> #if defined(ARDUINO_PORTENTA_C33) #include <WiFiC3.h> #elif defined(ARDUINO_UNOWIFIR4) #include <WiFiS3.h> #endif #include <WiFiUdp.h> #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int wifiStatus = WL_IDLE_STATUS; WiFiUDP Udp; // A UDP instance to let us send and receive packets over UDP NTPClient timeClient(Udp); void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } void connectToWiFi(){ // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (wifiStatus != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: wifiStatus = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } Serial.println(\"Connected to WiFi\"); printWifiStatus(); } void setup(){ Serial.begin(9600); while (!Serial); connectToWiFi(); RTC.begin(); Serial.println(\"\\nStarting connection to server...\"); timeClient.begin(); timeClient.update(); // Get the current date and time from an NTP server and convert // it to UTC +2 by passing the time zone offset in hours. // You may change the time zone offset to your local one. auto timeZoneOffsetHours = 2; auto unixTime = timeClient.getEpochTime() + (timeZoneOffsetHours * 3600); Serial.print(\"Unix time = \"); Serial.println(unixTime); RTCTime timeToSet = RTCTime(unixTime); RTC.setTime(timeToSet); // Retrieve the date and time from the RTC and print them RTCTime currentTime; RTC.getTime(currentTime); Serial.println(\"The RTC was just set to: \" + String(currentTime)); } void loop(){}","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_NTPSync/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_PeriodicExample/","text":"Sketch Code /* * RTC_PeriodicExample * * This example demonstrates how to use the periodic callback functionality of the RTC * (Real Time Clock) on the Portenta C33. * * It blinks the built-in LED at progressively faster and slower rates repeatedly. * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" #define BLINK_DELAY 2000 // This is the callback function to be passed to RTC.setPeriodicCallback() void periodicCallback() { static bool ledState = false; if (ledState == true) { digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } ledState = !ledState; } void setup() { pinMode(LED_BUILTIN, OUTPUT); // Initialize the RTC RTC.begin(); // RTC.setTime() must be called for RTC.setPeriodicCallback to work, but it doesn't matter // what date and time it's set to RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE); RTC.setTime(mytime); } void loop() { RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N32_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC); delay(BLINK_DELAY); } Video Demonstration","title":"RTC PeriodicExample"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_PeriodicExample/#sketch-code","text":"/* * RTC_PeriodicExample * * This example demonstrates how to use the periodic callback functionality of the RTC * (Real Time Clock) on the Portenta C33. * * It blinks the built-in LED at progressively faster and slower rates repeatedly. * * Find the full UNO R4 WiFi RTC documentation here: * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" #define BLINK_DELAY 2000 // This is the callback function to be passed to RTC.setPeriodicCallback() void periodicCallback() { static bool ledState = false; if (ledState == true) { digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } ledState = !ledState; } void setup() { pinMode(LED_BUILTIN, OUTPUT); // Initialize the RTC RTC.begin(); // RTC.setTime() must be called for RTC.setPeriodicCallback to work, but it doesn't matter // what date and time it's set to RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE); RTC.setTime(mytime); } void loop() { RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N32_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC); delay(BLINK_DELAY); RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC); delay(BLINK_DELAY); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/RTC/RTC_PeriodicExample/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/RTC/Test_RTC/","text":"Sketch Code /* Test RTC A test sketch showcasing all RTC showcasing various functionalities related to the RTC module, including setting the time, handling interrupts, and reading time values. Find the full UNO R4 WiFi RTC documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" // Define the interrupt pin for LED control during interrupts const int LED_ON_INTERRUPT = 22; // Callback function for periodic interrupt void periodic_cbk() { static bool clb_st = false; // Toggle the LED based on callback state if (clb_st) { digitalWrite(LED_ON_INTERRUPT, HIGH); } else { digitalWrite(LED_ON_INTERRUPT, LOW); } clb_st = !clb_st; // Toggle callback state // Print message indicating periodic interrupt Serial.println(\"PERIODIC INTERRUPT\"); } void alarm_cbk() { Serial.println(\"ALARM INTERRUPT\"); } // Callback function for alarm interrupt void setup() { // Initialize serial communication Serial.begin(9600); // Wait for serial connection while (!Serial) { } // Set LED pins as outputs pinMode(LED_BUILTIN, OUTPUT); pinMode(LED_ON_INTERRUPT, OUTPUT); // Initialize the RTC RTC.begin(); // Set a specific initial time (August 25, 2022, 14:37:00 Thursday) RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE); RTCTime savedTime; RTC.getTime(savedTime); // Set the initial time if RTC is not running if (!RTC.isRunning()) { if (savedTime.getYear() != 2000) { RTC.setTime(mytime); } else { RTC.setTime(savedTime); } } // Create an alarm time set to 35 seconds RTCTime alarmtime; alarmtime.setSecond(35); // Create an AlarmMatch object to match seconds AlarmMatch am; am.addMatchSecond(); // Set the periodic callback function to run once every 2 seconds if (!RTC.setPeriodicCallback(periodic_cbk, Period::ONCE_EVERY_2_SEC)) { Serial.println(\"ERROR: periodic callback not set\"); } // Set the alarm callback function with the alarm time and matching condition if (!RTC.setAlarmCallback(alarm_cbk, alarmtime, am)) { Serial.println(\"ERROR: alarm callback not set\"); } } void loop() { static bool status = false; RTCTime currenttime; // Check if RTC is running and print status if (status) { // Toggle LED and display RTC status if 'status' is true if (RTC.isRunning()) { Serial.println(\"RTC is running\"); } else { Serial.println(\"RTC is not running\"); } /* GET CURRENT TIME FROM RTC */ RTC.getTime(currenttime); /* PRINT CURRENT TIME on Serial */ Serial.print(\"Current time: \"); /* DATE */ Serial.print(currenttime.getDayOfMonth()); Serial.print(\"/\"); Serial.print(Month2int(currenttime.getMonth())); Serial.print(\"/\"); Serial.print(currenttime.getYear()); Serial.print(\" - \"); /* ORE:MINUTI:SECONDI */ Serial.print(currenttime.getHour()); Serial.print(\":\"); Serial.print(currenttime.getMinutes()); Serial.print(\":\"); Serial.println(currenttime.getSeconds()); digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } status = !status; delay(1000); } Video Demonstration","title":"Test RTC"},{"location":"05_examples_uno_r4_wifi/RTC/Test_RTC/#sketch-code","text":"/* Test RTC A test sketch showcasing all RTC showcasing various functionalities related to the RTC module, including setting the time, handling interrupts, and reading time values. Find the full UNO R4 WiFi RTC documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc */ // Include the RTC library #include \"RTC.h\" // Define the interrupt pin for LED control during interrupts const int LED_ON_INTERRUPT = 22; // Callback function for periodic interrupt void periodic_cbk() { static bool clb_st = false; // Toggle the LED based on callback state if (clb_st) { digitalWrite(LED_ON_INTERRUPT, HIGH); } else { digitalWrite(LED_ON_INTERRUPT, LOW); } clb_st = !clb_st; // Toggle callback state // Print message indicating periodic interrupt Serial.println(\"PERIODIC INTERRUPT\"); } void alarm_cbk() { Serial.println(\"ALARM INTERRUPT\"); } // Callback function for alarm interrupt void setup() { // Initialize serial communication Serial.begin(9600); // Wait for serial connection while (!Serial) { } // Set LED pins as outputs pinMode(LED_BUILTIN, OUTPUT); pinMode(LED_ON_INTERRUPT, OUTPUT); // Initialize the RTC RTC.begin(); // Set a specific initial time (August 25, 2022, 14:37:00 Thursday) RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE); RTCTime savedTime; RTC.getTime(savedTime); // Set the initial time if RTC is not running if (!RTC.isRunning()) { if (savedTime.getYear() != 2000) { RTC.setTime(mytime); } else { RTC.setTime(savedTime); } } // Create an alarm time set to 35 seconds RTCTime alarmtime; alarmtime.setSecond(35); // Create an AlarmMatch object to match seconds AlarmMatch am; am.addMatchSecond(); // Set the periodic callback function to run once every 2 seconds if (!RTC.setPeriodicCallback(periodic_cbk, Period::ONCE_EVERY_2_SEC)) { Serial.println(\"ERROR: periodic callback not set\"); } // Set the alarm callback function with the alarm time and matching condition if (!RTC.setAlarmCallback(alarm_cbk, alarmtime, am)) { Serial.println(\"ERROR: alarm callback not set\"); } } void loop() { static bool status = false; RTCTime currenttime; // Check if RTC is running and print status if (status) { // Toggle LED and display RTC status if 'status' is true if (RTC.isRunning()) { Serial.println(\"RTC is running\"); } else { Serial.println(\"RTC is not running\"); } /* GET CURRENT TIME FROM RTC */ RTC.getTime(currenttime); /* PRINT CURRENT TIME on Serial */ Serial.print(\"Current time: \"); /* DATE */ Serial.print(currenttime.getDayOfMonth()); Serial.print(\"/\"); Serial.print(Month2int(currenttime.getMonth())); Serial.print(\"/\"); Serial.print(currenttime.getYear()); Serial.print(\" - \"); /* ORE:MINUTI:SECONDI */ Serial.print(currenttime.getHour()); Serial.print(\":\"); Serial.print(currenttime.getMinutes()); Serial.print(\":\"); Serial.println(currenttime.getSeconds()); digitalWrite(LED_BUILTIN, HIGH); } else { digitalWrite(LED_BUILTIN, LOW); } status = !status; delay(1000); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/RTC/Test_RTC/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/SD/CardInfo/","text":"Sketch Code /* SD card test This example shows how use the utility libraries on which the' SD library is based in order to get info about your SD card. Very useful for testing a card when you're not sure whether its working or not. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila ** CS - depends on your SD card shield or module. Pin 4 used here for consistency with other Arduino examples created 28 Mar 2011 by Limor Fried modified 9 Apr 2012 by Tom Igoe */ // include the SD library: #include <SPI.h> #include <SD.h> // set up variables using the SD utility library functions: Sd2Card card; SdVolume volume; SdFile root; // change this to match your SD shield or module; // Arduino Ethernet shield: pin 4 // Adafruit SD shields and modules: pin 10 // Sparkfun SD shield: pin 8 // MKRZero SD: SDCARD_SS_PIN const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"\\nInitializing SD card...\"); // we'll use the initialization code from the utility libraries // since we're just testing if the card is working! if (!card.init(SPI_HALF_SPEED, chipSelect)) { Serial.println(\"initialization failed. Things to check:\"); Serial.println(\"* is a card inserted?\"); Serial.println(\"* is your wiring correct?\"); Serial.println(\"* did you change the chipSelect pin to match your shield or module?\"); while (1); } else { Serial.println(\"Wiring is correct and a card is present.\"); } // print the type of card Serial.println(); Serial.print(\"Card type: \"); switch (card.type()) { case SD_CARD_TYPE_SD1: Serial.println(\"SD1\"); break; case SD_CARD_TYPE_SD2: Serial.println(\"SD2\"); break; case SD_CARD_TYPE_SDHC: Serial.println(\"SDHC\"); break; default: Serial.println(\"Unknown\"); } // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32 if (!volume.init(card)) { Serial.println(\"Could not find FAT16/FAT32 partition.\\nMake sure you've formatted the card\"); while (1); } Serial.print(\"Clusters: \"); Serial.println(volume.clusterCount()); Serial.print(\"Blocks x Cluster: \"); Serial.println(volume.blocksPerCluster()); Serial.print(\"Total Blocks: \"); Serial.println(volume.blocksPerCluster() * volume.clusterCount()); Serial.println(); // print the type and size of the first FAT-type volume uint32_t volumesize; Serial.print(\"Volume type is: FAT\"); Serial.println(volume.fatType(), DEC); volumesize = volume.blocksPerCluster(); // clusters are collections of blocks volumesize *= volume.clusterCount(); // we'll have a lot of clusters volumesize /= 2; // SD card blocks are always 512 bytes (2 blocks are 1KB) Serial.print(\"Volume size (Kb): \"); Serial.println(volumesize); Serial.print(\"Volume size (Mb): \"); volumesize /= 1024; Serial.println(volumesize); Serial.print(\"Volume size (Gb): \"); Serial.println((float)volumesize / 1024.0); Serial.println(\"\\nFiles found on the card (name, date and size in bytes): \"); root.openRoot(volume); // list all files in the card with date and size root.ls(LS_R | LS_DATE | LS_SIZE); } void loop(void) { } Fritzing Circuit KiCad Schematic Video Demonstration","title":"CardInfo"},{"location":"05_examples_uno_r4_wifi/SD/CardInfo/#sketch-code","text":"/* SD card test This example shows how use the utility libraries on which the' SD library is based in order to get info about your SD card. Very useful for testing a card when you're not sure whether its working or not. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila ** CS - depends on your SD card shield or module. Pin 4 used here for consistency with other Arduino examples created 28 Mar 2011 by Limor Fried modified 9 Apr 2012 by Tom Igoe */ // include the SD library: #include <SPI.h> #include <SD.h> // set up variables using the SD utility library functions: Sd2Card card; SdVolume volume; SdFile root; // change this to match your SD shield or module; // Arduino Ethernet shield: pin 4 // Adafruit SD shields and modules: pin 10 // Sparkfun SD shield: pin 8 // MKRZero SD: SDCARD_SS_PIN const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"\\nInitializing SD card...\"); // we'll use the initialization code from the utility libraries // since we're just testing if the card is working! if (!card.init(SPI_HALF_SPEED, chipSelect)) { Serial.println(\"initialization failed. Things to check:\"); Serial.println(\"* is a card inserted?\"); Serial.println(\"* is your wiring correct?\"); Serial.println(\"* did you change the chipSelect pin to match your shield or module?\"); while (1); } else { Serial.println(\"Wiring is correct and a card is present.\"); } // print the type of card Serial.println(); Serial.print(\"Card type: \"); switch (card.type()) { case SD_CARD_TYPE_SD1: Serial.println(\"SD1\"); break; case SD_CARD_TYPE_SD2: Serial.println(\"SD2\"); break; case SD_CARD_TYPE_SDHC: Serial.println(\"SDHC\"); break; default: Serial.println(\"Unknown\"); } // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32 if (!volume.init(card)) { Serial.println(\"Could not find FAT16/FAT32 partition.\\nMake sure you've formatted the card\"); while (1); } Serial.print(\"Clusters: \"); Serial.println(volume.clusterCount()); Serial.print(\"Blocks x Cluster: \"); Serial.println(volume.blocksPerCluster()); Serial.print(\"Total Blocks: \"); Serial.println(volume.blocksPerCluster() * volume.clusterCount()); Serial.println(); // print the type and size of the first FAT-type volume uint32_t volumesize; Serial.print(\"Volume type is: FAT\"); Serial.println(volume.fatType(), DEC); volumesize = volume.blocksPerCluster(); // clusters are collections of blocks volumesize *= volume.clusterCount(); // we'll have a lot of clusters volumesize /= 2; // SD card blocks are always 512 bytes (2 blocks are 1KB) Serial.print(\"Volume size (Kb): \"); Serial.println(volumesize); Serial.print(\"Volume size (Mb): \"); volumesize /= 1024; Serial.println(volumesize); Serial.print(\"Volume size (Gb): \"); Serial.println((float)volumesize / 1024.0); Serial.println(\"\\nFiles found on the card (name, date and size in bytes): \"); root.openRoot(volume); // list all files in the card with date and size root.ls(LS_R | LS_DATE | LS_SIZE); } void loop(void) { }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/SD/CardInfo/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/SD/CardInfo/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/SD/CardInfo/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/SD/Datalogger/","text":"Sketch Code /* SD card datalogger This example shows how to log data from three analog sensors to an SD card using the SD library. The circuit: analog sensors on analog ins 0, 1, and 2 SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created 24 Nov 2010 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); // see if the card is present and can be initialized: if (!SD.begin(chipSelect)) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } Serial.println(\"card initialized.\"); } void loop() { // make a string for assembling the data to log: String dataString = \"\"; // read three sensors and append to the string: for (int analogPin = 0; analogPin < 3; analogPin++) { int sensor = analogRead(analogPin); dataString += String(sensor); if (analogPin < 2) { dataString += \",\"; } } // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. File dataFile = SD.open(\"datalog.txt\", FILE_WRITE); // if the file is available, write to it: if (dataFile) { dataFile.println(dataString); dataFile.close(); // print to the serial port too: Serial.println(dataString); } // if the file isn't open, pop up an error: else { Serial.println(\"error opening datalog.txt\"); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Datalogger"},{"location":"05_examples_uno_r4_wifi/SD/Datalogger/#sketch-code","text":"/* SD card datalogger This example shows how to log data from three analog sensors to an SD card using the SD library. The circuit: analog sensors on analog ins 0, 1, and 2 SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created 24 Nov 2010 modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); // see if the card is present and can be initialized: if (!SD.begin(chipSelect)) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } Serial.println(\"card initialized.\"); } void loop() { // make a string for assembling the data to log: String dataString = \"\"; // read three sensors and append to the string: for (int analogPin = 0; analogPin < 3; analogPin++) { int sensor = analogRead(analogPin); dataString += String(sensor); if (analogPin < 2) { dataString += \",\"; } } // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. File dataFile = SD.open(\"datalog.txt\", FILE_WRITE); // if the file is available, write to it: if (dataFile) { dataFile.println(dataString); dataFile.close(); // print to the serial port too: Serial.println(dataString); } // if the file isn't open, pop up an error: else { Serial.println(\"error opening datalog.txt\"); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/SD/Datalogger/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/SD/Datalogger/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/SD/Datalogger/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/SD/DumpFile/","text":"Sketch Code /* SD card file dump This example shows how to read a file from the SD card using the SD library and send it over the serial port. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created 22 December 2010 by Limor Fried modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); // see if the card is present and can be initialized: if (!SD.begin(chipSelect)) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } Serial.println(\"card initialized.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. File dataFile = SD.open(\"datalog.txt\"); // if the file is available, write to it: if (dataFile) { while (dataFile.available()) { Serial.write(dataFile.read()); } dataFile.close(); } // if the file isn't open, pop up an error: else { Serial.println(\"error opening datalog.txt\"); } } void loop() { } Fritzing Circuit KiCad Schematic Video Demonstration","title":"DumpFile"},{"location":"05_examples_uno_r4_wifi/SD/DumpFile/#sketch-code","text":"/* SD card file dump This example shows how to read a file from the SD card using the SD library and send it over the serial port. The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created 22 December 2010 by Limor Fried modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> const int chipSelect = 4; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); // see if the card is present and can be initialized: if (!SD.begin(chipSelect)) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } Serial.println(\"card initialized.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. File dataFile = SD.open(\"datalog.txt\"); // if the file is available, write to it: if (dataFile) { while (dataFile.available()) { Serial.write(dataFile.read()); } dataFile.close(); } // if the file isn't open, pop up an error: else { Serial.println(\"error opening datalog.txt\"); } } void loop() { }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/SD/DumpFile/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/SD/DumpFile/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/SD/DumpFile/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/SD/Files/","text":"Sketch Code /* SD card basic file example This example shows how to create and destroy an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } // open a new file and immediately close it: Serial.println(\"Creating example.txt...\"); myFile = SD.open(\"example.txt\", FILE_WRITE); myFile.close(); // Check to see if the file exists: if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } // delete the file: Serial.println(\"Removing example.txt...\"); SD.remove(\"example.txt\"); if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } } void loop() { // nothing happens after setup finishes. } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Files"},{"location":"05_examples_uno_r4_wifi/SD/Files/#sketch-code","text":"/* SD card basic file example This example shows how to create and destroy an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } // open a new file and immediately close it: Serial.println(\"Creating example.txt...\"); myFile = SD.open(\"example.txt\", FILE_WRITE); myFile.close(); // Check to see if the file exists: if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } // delete the file: Serial.println(\"Removing example.txt...\"); SD.remove(\"example.txt\"); if (SD.exists(\"example.txt\")) { Serial.println(\"example.txt exists.\"); } else { Serial.println(\"example.txt doesn't exist.\"); } } void loop() { // nothing happens after setup finishes. }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/SD/Files/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/SD/Files/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/SD/Files/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/SD/NonBlockingWrite/","text":"Sketch Code /* Non-blocking Write This example demonstrates how to perform non-blocking writes to a file on a SD card. The file will contain the current millis() value every 10ms. If the SD card is busy, the data will be buffered in order to not block the sketch. NOTE: myFile.availableForWrite() will automatically sync the file contents as needed. You may lose some unsynced data still if myFile.sync() or myFile.close() is not called. The circuit: - Arduino MKR Zero board - micro SD card attached This example code is in the public domain. */ #include <SD.h> // file name to use for writing const char filename[] = \"demo.txt\"; // File object to represent file File txtFile; // string to buffer output String buffer; unsigned long lastMillis = 0; void setup() { Serial.begin(9600); while (!Serial); // reserve 1kB for String used as a buffer buffer.reserve(1024); // set LED pin to output, used to blink when writing pinMode(LED_BUILTIN, OUTPUT); // init the SD card if (!SD.begin()) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } // If you want to start from an empty file, // uncomment the next line: // SD.remove(filename); // try to open the file for writing txtFile = SD.open(filename, FILE_WRITE); if (!txtFile) { Serial.print(\"error opening \"); Serial.println(filename); while (1); } // add some new lines to start txtFile.println(); txtFile.println(\"Hello World!\"); } void loop() { // check if it's been over 10 ms since the last line added unsigned long now = millis(); if ((now - lastMillis) >= 10) { // add a new line to the buffer buffer += \"Hello \"; buffer += now; buffer += \"\\r\\n\"; lastMillis = now; } // check if the SD card is available to write data without blocking // and if the buffered data is enough for the full chunk size unsigned int chunkSize = txtFile.availableForWrite(); if (chunkSize && buffer.length() >= chunkSize) { // write to file and blink LED digitalWrite(LED_BUILTIN, HIGH); txtFile.write(buffer.c_str(), chunkSize); digitalWrite(LED_BUILTIN, LOW); // remove written data from buffer buffer.remove(0, chunkSize); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"NonBlockingWrite"},{"location":"05_examples_uno_r4_wifi/SD/NonBlockingWrite/#sketch-code","text":"/* Non-blocking Write This example demonstrates how to perform non-blocking writes to a file on a SD card. The file will contain the current millis() value every 10ms. If the SD card is busy, the data will be buffered in order to not block the sketch. NOTE: myFile.availableForWrite() will automatically sync the file contents as needed. You may lose some unsynced data still if myFile.sync() or myFile.close() is not called. The circuit: - Arduino MKR Zero board - micro SD card attached This example code is in the public domain. */ #include <SD.h> // file name to use for writing const char filename[] = \"demo.txt\"; // File object to represent file File txtFile; // string to buffer output String buffer; unsigned long lastMillis = 0; void setup() { Serial.begin(9600); while (!Serial); // reserve 1kB for String used as a buffer buffer.reserve(1024); // set LED pin to output, used to blink when writing pinMode(LED_BUILTIN, OUTPUT); // init the SD card if (!SD.begin()) { Serial.println(\"Card failed, or not present\"); // don't do anything more: while (1); } // If you want to start from an empty file, // uncomment the next line: // SD.remove(filename); // try to open the file for writing txtFile = SD.open(filename, FILE_WRITE); if (!txtFile) { Serial.print(\"error opening \"); Serial.println(filename); while (1); } // add some new lines to start txtFile.println(); txtFile.println(\"Hello World!\"); } void loop() { // check if it's been over 10 ms since the last line added unsigned long now = millis(); if ((now - lastMillis) >= 10) { // add a new line to the buffer buffer += \"Hello \"; buffer += now; buffer += \"\\r\\n\"; lastMillis = now; } // check if the SD card is available to write data without blocking // and if the buffered data is enough for the full chunk size unsigned int chunkSize = txtFile.availableForWrite(); if (chunkSize && buffer.length() >= chunkSize) { // write to file and blink LED digitalWrite(LED_BUILTIN, HIGH); txtFile.write(buffer.c_str(), chunkSize); digitalWrite(LED_BUILTIN, LOW); // remove written data from buffer buffer.remove(0, chunkSize); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/SD/NonBlockingWrite/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/SD/NonBlockingWrite/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/SD/NonBlockingWrite/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/SD/ReadWrite/","text":"Sketch Code /* SD card read/write This example shows how to read and write data to and from an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. myFile = SD.open(\"test.txt\", FILE_WRITE); // if the file opened okay, write to it: if (myFile) { Serial.print(\"Writing to test.txt...\"); myFile.println(\"testing 1, 2, 3.\"); // close the file: myFile.close(); Serial.println(\"done.\"); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } // re-open the file for reading: myFile = SD.open(\"test.txt\"); if (myFile) { Serial.println(\"test.txt:\"); // read from the file until there's nothing else in it: while (myFile.available()) { Serial.write(myFile.read()); } // close the file: myFile.close(); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } } void loop() { // nothing happens after setup } /* SD card read/write This example shows how to read and write data to and from an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. myFile = SD.open(\"test.txt\", FILE_WRITE); // if the file opened okay, write to it: if (myFile) { Serial.print(\"Writing to test.txt...\"); myFile.println(\"testing 1, 2, 3.\"); // close the file: myFile.close(); Serial.println(\"done.\"); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } // re-open the file for reading: myFile = SD.open(\"test.txt\"); if (myFile) { Serial.println(\"test.txt:\"); // read from the file until there's nothing else in it: while (myFile.available()) { Serial.write(myFile.read()); } // close the file: myFile.close(); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } } void loop() { // nothing happens after setup } Fritzing Circuit KiCad Schematic Video Demonstration","title":"ReadWrite"},{"location":"05_examples_uno_r4_wifi/SD/ReadWrite/#sketch-code","text":"/* SD card read/write This example shows how to read and write data to and from an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. myFile = SD.open(\"test.txt\", FILE_WRITE); // if the file opened okay, write to it: if (myFile) { Serial.print(\"Writing to test.txt...\"); myFile.println(\"testing 1, 2, 3.\"); // close the file: myFile.close(); Serial.println(\"done.\"); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } // re-open the file for reading: myFile = SD.open(\"test.txt\"); if (myFile) { Serial.println(\"test.txt:\"); // read from the file until there's nothing else in it: while (myFile.available()) { Serial.write(myFile.read()); } // close the file: myFile.close(); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } } void loop() { // nothing happens after setup } /* SD card read/write This example shows how to read and write data to and from an SD card file The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File myFile; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); // open the file. note that only one file can be open at a time, // so you have to close this one before opening another. myFile = SD.open(\"test.txt\", FILE_WRITE); // if the file opened okay, write to it: if (myFile) { Serial.print(\"Writing to test.txt...\"); myFile.println(\"testing 1, 2, 3.\"); // close the file: myFile.close(); Serial.println(\"done.\"); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } // re-open the file for reading: myFile = SD.open(\"test.txt\"); if (myFile) { Serial.println(\"test.txt:\"); // read from the file until there's nothing else in it: while (myFile.available()) { Serial.write(myFile.read()); } // close the file: myFile.close(); } else { // if the file didn't open, print an error: Serial.println(\"error opening test.txt\"); } } void loop() { // nothing happens after setup }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/SD/ReadWrite/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/SD/ReadWrite/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/SD/ReadWrite/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/SD/listfiles/","text":"Sketch Code /* Listfiles This example shows how print out the files in a directory on a SD card The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe modified 2 Feb 2014 by Scott Fitzgerald This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File root; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); root = SD.open(\"/\"); printDirectory(root, 0); Serial.println(\"done!\"); } void loop() { // nothing happens after setup finishes. } void printDirectory(File dir, int numTabs) { while (true) { File entry = dir.openNextFile(); if (! entry) { // no more files break; } for (uint8_t i = 0; i < numTabs; i++) { Serial.print('\\t'); } Serial.print(entry.name()); if (entry.isDirectory()) { Serial.println(\"/\"); printDirectory(entry, numTabs + 1); } else { // files have sizes, directories do not Serial.print(\"\\t\\t\"); Serial.println(entry.size(), DEC); } entry.close(); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Listfiles"},{"location":"05_examples_uno_r4_wifi/SD/listfiles/#sketch-code","text":"/* Listfiles This example shows how print out the files in a directory on a SD card The circuit: SD card attached to SPI bus as follows: ** MOSI - pin 11 ** MISO - pin 12 ** CLK - pin 13 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN) created Nov 2010 by David A. Mellis modified 9 Apr 2012 by Tom Igoe modified 2 Feb 2014 by Scott Fitzgerald This example code is in the public domain. */ #include <SPI.h> #include <SD.h> File root; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.print(\"Initializing SD card...\"); if (!SD.begin(4)) { Serial.println(\"initialization failed!\"); while (1); } Serial.println(\"initialization done.\"); root = SD.open(\"/\"); printDirectory(root, 0); Serial.println(\"done!\"); } void loop() { // nothing happens after setup finishes. } void printDirectory(File dir, int numTabs) { while (true) { File entry = dir.openNextFile(); if (! entry) { // no more files break; } for (uint8_t i = 0; i < numTabs; i++) { Serial.print('\\t'); } Serial.print(entry.name()); if (entry.isDirectory()) { Serial.println(\"/\"); printDirectory(entry, numTabs + 1); } else { // files have sizes, directories do not Serial.print(\"\\t\\t\"); Serial.println(entry.size(), DEC); } entry.close(); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/SD/listfiles/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/SD/listfiles/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/SD/listfiles/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/SDU/Usage/","text":"Sketch Code /* Usage This example demonstrates how to use the UNO R4 SDU library to update a sketch on an Arduino UNO R4 (WiFi, Minima) board using an SD card. It prints out the date and time the sketch was compiled at to both Serial and Serial1. Circuit: * Arduino UNO R4 Minima or WiFi board * SD shield or breakout connected with CS pin of 4 * SD card Non-Arduino UNO R4 board are NOT supported. Steps to update sketch via SD card: 1) Upload this sketch or another sketch that includes the SDU library via #include <SDU.h> 2) Update the sketch as desired. For this example the sketch prints out the compiled date and time so no updates are needed. 3) In the IDE select: Sketch -> Export Compiled Binary 4) Copy the .bin file from the sketch's folder to the SD card and rename the file to UPDATE.bin. Eject the SD card from your PC. 5) Insert the SD card into the board, shield or breakout and press the reset button or power cycle the board. The SDU library will then update the sketch on the board with the contents of UPDATE.bin created 23 March 2017 by Sandeep Mistry */ /* Include the SDU library This will add some code to the sketch before setup() is called to check if an SD card is present and UPDATE.bin exists on the SD card. If UPDATE.bin is present, the file is used to update the sketch running on the board. After this UPDATE.bin is deleted from the SD card. */ #include <SDU.h> String message; void setup() { Serial.begin(115200); // Wait for Serial Monitor connection while (!Serial.available()) { Serial.println(\"Send any key.\"); delay(1000); } message += \"Sketch compile date and time: \"; message += __DATE__; message += \" \"; message += __TIME__; // print out the sketch compile date and time on the serial port Serial.println(message); } void loop() { // add you own code here } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Usage"},{"location":"05_examples_uno_r4_wifi/SDU/Usage/#sketch-code","text":"/* Usage This example demonstrates how to use the UNO R4 SDU library to update a sketch on an Arduino UNO R4 (WiFi, Minima) board using an SD card. It prints out the date and time the sketch was compiled at to both Serial and Serial1. Circuit: * Arduino UNO R4 Minima or WiFi board * SD shield or breakout connected with CS pin of 4 * SD card Non-Arduino UNO R4 board are NOT supported. Steps to update sketch via SD card: 1) Upload this sketch or another sketch that includes the SDU library via #include <SDU.h> 2) Update the sketch as desired. For this example the sketch prints out the compiled date and time so no updates are needed. 3) In the IDE select: Sketch -> Export Compiled Binary 4) Copy the .bin file from the sketch's folder to the SD card and rename the file to UPDATE.bin. Eject the SD card from your PC. 5) Insert the SD card into the board, shield or breakout and press the reset button or power cycle the board. The SDU library will then update the sketch on the board with the contents of UPDATE.bin created 23 March 2017 by Sandeep Mistry */ /* Include the SDU library This will add some code to the sketch before setup() is called to check if an SD card is present and UPDATE.bin exists on the SD card. If UPDATE.bin is present, the file is used to update the sketch running on the board. After this UPDATE.bin is deleted from the SD card. */ #include <SDU.h> String message; void setup() { Serial.begin(115200); // Wait for Serial Monitor connection while (!Serial.available()) { Serial.println(\"Send any key.\"); delay(1000); } message += \"Sketch compile date and time: \"; message += __DATE__; message += \" \"; message += __TIME__; // print out the sketch compile date and time on the serial port Serial.println(message); } void loop() { // add you own code here }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/SDU/Usage/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/SDU/Usage/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/SDU/Usage/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Servo/Knob/","text":"Sketch Code /* Controlling a servo position using a potentiometer (variable resistor) by Michal Rinott <http://people.interaction-ivrea.it/m.rinott> modified on 8 Nov 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/Knob */ #include <Servo.h> Servo myservo; // create servo object to control a servo int potpin = A0; // analog pin used to connect the potentiometer int val; // variable to read the value from the analog pin void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { val = analogRead(potpin); // reads the value of the potentiometer (value between 0 and 1023) val = map(val, 0, 1023, 0, 180); // scale it for use with the servo (value between 0 and 180) myservo.write(val); // sets the servo position according to the scaled value delay(15); // waits for the servo to get there } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Knob"},{"location":"05_examples_uno_r4_wifi/Servo/Knob/#sketch-code","text":"/* Controlling a servo position using a potentiometer (variable resistor) by Michal Rinott <http://people.interaction-ivrea.it/m.rinott> modified on 8 Nov 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/Knob */ #include <Servo.h> Servo myservo; // create servo object to control a servo int potpin = A0; // analog pin used to connect the potentiometer int val; // variable to read the value from the analog pin void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { val = analogRead(potpin); // reads the value of the potentiometer (value between 0 and 1023) val = map(val, 0, 1023, 0, 180); // scale it for use with the servo (value between 0 and 180) myservo.write(val); // sets the servo position according to the scaled value delay(15); // waits for the servo to get there }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Servo/Knob/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Servo/Knob/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Servo/Knob/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Servo/Sweep/","text":"Sketch Code /* Sweep by BARRAGAN <http://barraganstudio.com> This example code is in the public domain. modified 8 Nov 2013 by Scott Fitzgerald https://www.arduino.cc/en/Tutorial/LibraryExamples/Sweep */ #include <Servo.h> Servo myservo; // create servo object to control a servo // twelve servo objects can be created on most boards int pos = 0; // variable to store the servo position void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { for (pos = 0; pos <= 180; pos += 1) { // goes from 0 degrees to 180 degrees // in steps of 1 degree myservo.write(pos); // tell servo to go to position in variable 'pos' delay(15); // waits 15 ms for the servo to reach the position } for (pos = 180; pos >= 0; pos -= 1) { // goes from 180 degrees to 0 degrees myservo.write(pos); // tell servo to go to position in variable 'pos' delay(15); // waits 15 ms for the servo to reach the position } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"Sweep"},{"location":"05_examples_uno_r4_wifi/Servo/Sweep/#sketch-code","text":"/* Sweep by BARRAGAN <http://barraganstudio.com> This example code is in the public domain. modified 8 Nov 2013 by Scott Fitzgerald https://www.arduino.cc/en/Tutorial/LibraryExamples/Sweep */ #include <Servo.h> Servo myservo; // create servo object to control a servo // twelve servo objects can be created on most boards int pos = 0; // variable to store the servo position void setup() { myservo.attach(9); // attaches the servo on pin 9 to the servo object } void loop() { for (pos = 0; pos <= 180; pos += 1) { // goes from 0 degrees to 180 degrees // in steps of 1 degree myservo.write(pos); // tell servo to go to position in variable 'pos' delay(15); // waits 15 ms for the servo to reach the position } for (pos = 180; pos >= 0; pos -= 1) { // goes from 180 degrees to 0 degrees myservo.write(pos); // tell servo to go to position in variable 'pos' delay(15); // waits 15 ms for the servo to reach the position } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Servo/Sweep/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Servo/Sweep/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Servo/Sweep/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/SoftwareSerial/SerialEcho/","text":"Sketch Code #include <SoftwareSerial.h> // Note any pin can be used for TX, but only the following pins // can be used for RX: // D0, D1, D2, D3, D8, D14, D15, A1, A2, A3, A4, A5 SoftwareSerial SoftSerial(2, 7); // Rx, Tx void setup() { Serial.begin(9600); while (!Serial) { } if (!SoftSerial.begin(115200, SERIAL_8E2)) { Serial.println(\"Failed to init soft serial\"); while (1); } Serial.println(SoftSerial); } void loop() { // run over and over while (SoftSerial.available()) { SoftSerial.write(SoftSerial.read()); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"SerialEcho"},{"location":"05_examples_uno_r4_wifi/SoftwareSerial/SerialEcho/#sketch-code","text":"#include <SoftwareSerial.h> // Note any pin can be used for TX, but only the following pins // can be used for RX: // D0, D1, D2, D3, D8, D14, D15, A1, A2, A3, A4, A5 SoftwareSerial SoftSerial(2, 7); // Rx, Tx void setup() { Serial.begin(9600); while (!Serial) { } if (!SoftSerial.begin(115200, SERIAL_8E2)) { Serial.println(\"Failed to init soft serial\"); while (1); } Serial.println(SoftSerial); } void loop() { // run over and over while (SoftSerial.available()) { SoftSerial.write(SoftSerial.read()); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/SoftwareSerial/SerialEcho/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/SoftwareSerial/SerialEcho/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/SoftwareSerial/SerialEcho/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Stepper/MotorKnob/","text":"Sketch Code /* * MotorKnob * * A stepper motor follows the turns of a potentiometer * (or other sensor) on analog input 0. * * http://www.arduino.cc/en/Reference/Stepper * This example code is in the public domain. */ #include <Stepper.h> // change this to the number of steps on your motor #define STEPS 100 // create an instance of the stepper class, specifying // the number of steps of the motor and the pins it's // attached to Stepper stepper(STEPS, 8, 9, 10, 11); // the previous reading from the analog input int previous = 0; void setup() { // set the speed of the motor to 30 RPMs stepper.setSpeed(30); } void loop() { // get the sensor value int val = analogRead(0); // move a number of steps equal to the change in the // sensor reading stepper.step(val - previous); // remember the previous value of the sensor previous = val; } Fritzing Circuit KiCad Schematic Video Demonstration","title":"MotorKnob"},{"location":"05_examples_uno_r4_wifi/Stepper/MotorKnob/#sketch-code","text":"/* * MotorKnob * * A stepper motor follows the turns of a potentiometer * (or other sensor) on analog input 0. * * http://www.arduino.cc/en/Reference/Stepper * This example code is in the public domain. */ #include <Stepper.h> // change this to the number of steps on your motor #define STEPS 100 // create an instance of the stepper class, specifying // the number of steps of the motor and the pins it's // attached to Stepper stepper(STEPS, 8, 9, 10, 11); // the previous reading from the analog input int previous = 0; void setup() { // set the speed of the motor to 30 RPMs stepper.setSpeed(30); } void loop() { // get the sensor value int val = analogRead(0); // move a number of steps equal to the change in the // sensor reading stepper.step(val - previous); // remember the previous value of the sensor previous = val; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Stepper/MotorKnob/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Stepper/MotorKnob/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Stepper/MotorKnob/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneRevolution/","text":"Sketch Code /* Stepper Motor Control - one revolution This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. The motor should revolve one revolution in one direction, then one revolution in the other direction. Created 11 Mar. 2007 Modified 30 Nov. 2009 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper.setSpeed(60); // initialize the serial port: Serial.begin(9600); } void loop() { // step one revolution in one direction: Serial.println(\"clockwise\"); myStepper.step(stepsPerRevolution); delay(500); // step one revolution in the other direction: Serial.println(\"counterclockwise\"); myStepper.step(-stepsPerRevolution); delay(500); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"stepper oneRevolution"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneRevolution/#sketch-code","text":"/* Stepper Motor Control - one revolution This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. The motor should revolve one revolution in one direction, then one revolution in the other direction. Created 11 Mar. 2007 Modified 30 Nov. 2009 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); void setup() { // set the speed at 60 rpm: myStepper.setSpeed(60); // initialize the serial port: Serial.begin(9600); } void loop() { // step one revolution in one direction: Serial.println(\"clockwise\"); myStepper.step(stepsPerRevolution); delay(500); // step one revolution in the other direction: Serial.println(\"counterclockwise\"); myStepper.step(-stepsPerRevolution); delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneRevolution/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneRevolution/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneRevolution/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneStepAtATime/","text":"Sketch Code /* Stepper Motor Control - one step at a time This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. The motor will step one step at a time, very slowly. You can use this to test that you've got the four wires of your stepper wired to the correct pins. If wired correctly, all steps should be in the same direction. Use this also to count the number of steps per revolution of your motor, if you don't know it. Then plug that number into the oneRevolution example to see if you got it right. Created 30 Nov. 2009 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); int stepCount = 0; // number of steps the motor has taken void setup() { // initialize the serial port: Serial.begin(9600); } void loop() { // step one step: myStepper.step(1); Serial.print(\"steps:\"); Serial.println(stepCount); stepCount++; delay(500); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"stepper oneStepAtATime"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneStepAtATime/#sketch-code","text":"/* Stepper Motor Control - one step at a time This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. The motor will step one step at a time, very slowly. You can use this to test that you've got the four wires of your stepper wired to the correct pins. If wired correctly, all steps should be in the same direction. Use this also to count the number of steps per revolution of your motor, if you don't know it. Then plug that number into the oneRevolution example to see if you got it right. Created 30 Nov. 2009 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); int stepCount = 0; // number of steps the motor has taken void setup() { // initialize the serial port: Serial.begin(9600); } void loop() { // step one step: myStepper.step(1); Serial.print(\"steps:\"); Serial.println(stepCount); stepCount++; delay(500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneStepAtATime/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneStepAtATime/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_oneStepAtATime/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_speedControl/","text":"Sketch Code /* Stepper Motor Control - speed control This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. A potentiometer is connected to analog input 0. The motor will rotate in a clockwise direction. The higher the potentiometer value, the faster the motor speed. Because setSpeed() sets the delay between steps, you may notice the motor is less responsive to changes in the sensor value at low speeds. Created 30 Nov. 2009 Modified 28 Oct 2010 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); int stepCount = 0; // number of steps the motor has taken void setup() { // nothing to do inside the setup } void loop() { // read the sensor value: int sensorReading = analogRead(A0); // map it to a range from 0 to 100: int motorSpeed = map(sensorReading, 0, 1023, 0, 100); // set the motor speed: if (motorSpeed > 0) { myStepper.setSpeed(motorSpeed); // step 1/100 of a revolution: myStepper.step(stepsPerRevolution / 100); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"stepper speedControl"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_speedControl/#sketch-code","text":"/* Stepper Motor Control - speed control This program drives a unipolar or bipolar stepper motor. The motor is attached to digital pins 8 - 11 of the Arduino. A potentiometer is connected to analog input 0. The motor will rotate in a clockwise direction. The higher the potentiometer value, the faster the motor speed. Because setSpeed() sets the delay between steps, you may notice the motor is less responsive to changes in the sensor value at low speeds. Created 30 Nov. 2009 Modified 28 Oct 2010 by Tom Igoe */ #include <Stepper.h> const int stepsPerRevolution = 200; // change this to fit the number of steps per revolution // for your motor // initialize the stepper library on pins 8 through 11: Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11); int stepCount = 0; // number of steps the motor has taken void setup() { // nothing to do inside the setup } void loop() { // read the sensor value: int sensorReading = analogRead(A0); // map it to a range from 0 to 100: int motorSpeed = map(sensorReading, 0, 1023, 0, 100); // set the motor speed: if (motorSpeed > 0) { myStepper.setSpeed(motorSpeed); // step 1/100 of a revolution: myStepper.step(stepsPerRevolution / 100); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_speedControl/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_speedControl/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/Stepper/stepper_speedControl/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTBitmapLogo/","text":"Sketch Code /* Arduino TFT Bitmap Logo example This example reads an image file from a micro-SD card and draws it on the screen, at random locations. In this sketch, the Arduino logo is read from a micro-SD card. There is a .bmp file included with this sketch. - open the sketch folder (Ctrl-K or Cmd-K) - copy the \"arduino.bmp\" file to a micro-SD - put the SD into the SD slot of the Arduino TFT module. This example code is in the public domain. Created 19 April 2013 by Enrico Gueli http://www.arduino.cc/en/Tutorial/TFTBitmapLogo */ // include the necessary libraries #include <SPI.h> #include <SD.h> #include <TFT.h> // Arduino LCD library // pin definition for the Uno #define sd_cs 4 #define lcd_cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo //#define sd_cs 8 //#define lcd_cs 7 //#define dc 0 //#define rst 1 TFT TFTscreen = TFT(lcd_cs, dc, rst); // this variable represents the image to be drawn on screen PImage logo; void setup() { // initialize the GLCD and show a message // asking the user to open the serial line TFTscreen.begin(); TFTscreen.background(255, 255, 255); TFTscreen.stroke(0, 0, 255); TFTscreen.println(); TFTscreen.println(F(\"Arduino TFT Bitmap Example\")); TFTscreen.stroke(0, 0, 0); TFTscreen.println(F(\"Open serial monitor\")); TFTscreen.println(F(\"to run the sketch\")); // initialize the serial port: it will be used to // print some diagnostic info Serial.begin(9600); while (!Serial) { // wait for serial port to connect. Needed for native USB port only } // clear the GLCD screen before starting TFTscreen.background(255, 255, 255); // try to access the SD card. If that fails (e.g. // no card present), the setup process will stop. Serial.print(F(\"Initializing SD card...\")); if (!SD.begin(sd_cs)) { Serial.println(F(\"failed!\")); return; } Serial.println(F(\"OK!\")); // initialize and clear the GLCD screen TFTscreen.begin(); TFTscreen.background(255, 255, 255); // now that the SD card can be access, try to load the // image file. logo = TFTscreen.loadImage(\"arduino.bmp\"); if (!logo.isValid()) { Serial.println(F(\"error while loading arduino.bmp\")); } } void loop() { // don't do anything if the image wasn't loaded correctly. if (logo.isValid() == false) { return; } Serial.println(F(\"drawing image\")); // get a random location where to draw the image. // To avoid the image to be draw outside the screen, // take into account the image size. int x = random(TFTscreen.width() - logo.width()); int y = random(TFTscreen.height() - logo.height()); // draw the image to the screen TFTscreen.image(logo, x, y); // wait a little bit before drawing again delay(1500); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"TFTBitmapLogo"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTBitmapLogo/#sketch-code","text":"/* Arduino TFT Bitmap Logo example This example reads an image file from a micro-SD card and draws it on the screen, at random locations. In this sketch, the Arduino logo is read from a micro-SD card. There is a .bmp file included with this sketch. - open the sketch folder (Ctrl-K or Cmd-K) - copy the \"arduino.bmp\" file to a micro-SD - put the SD into the SD slot of the Arduino TFT module. This example code is in the public domain. Created 19 April 2013 by Enrico Gueli http://www.arduino.cc/en/Tutorial/TFTBitmapLogo */ // include the necessary libraries #include <SPI.h> #include <SD.h> #include <TFT.h> // Arduino LCD library // pin definition for the Uno #define sd_cs 4 #define lcd_cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo //#define sd_cs 8 //#define lcd_cs 7 //#define dc 0 //#define rst 1 TFT TFTscreen = TFT(lcd_cs, dc, rst); // this variable represents the image to be drawn on screen PImage logo; void setup() { // initialize the GLCD and show a message // asking the user to open the serial line TFTscreen.begin(); TFTscreen.background(255, 255, 255); TFTscreen.stroke(0, 0, 255); TFTscreen.println(); TFTscreen.println(F(\"Arduino TFT Bitmap Example\")); TFTscreen.stroke(0, 0, 0); TFTscreen.println(F(\"Open serial monitor\")); TFTscreen.println(F(\"to run the sketch\")); // initialize the serial port: it will be used to // print some diagnostic info Serial.begin(9600); while (!Serial) { // wait for serial port to connect. Needed for native USB port only } // clear the GLCD screen before starting TFTscreen.background(255, 255, 255); // try to access the SD card. If that fails (e.g. // no card present), the setup process will stop. Serial.print(F(\"Initializing SD card...\")); if (!SD.begin(sd_cs)) { Serial.println(F(\"failed!\")); return; } Serial.println(F(\"OK!\")); // initialize and clear the GLCD screen TFTscreen.begin(); TFTscreen.background(255, 255, 255); // now that the SD card can be access, try to load the // image file. logo = TFTscreen.loadImage(\"arduino.bmp\"); if (!logo.isValid()) { Serial.println(F(\"error while loading arduino.bmp\")); } } void loop() { // don't do anything if the image wasn't loaded correctly. if (logo.isValid() == false) { return; } Serial.println(F(\"drawing image\")); // get a random location where to draw the image. // To avoid the image to be draw outside the screen, // take into account the image size. int x = random(TFTscreen.width() - logo.width()); int y = random(TFTscreen.height() - logo.height()); // draw the image to the screen TFTscreen.image(logo, x, y); // wait a little bit before drawing again delay(1500); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTBitmapLogo/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTBitmapLogo/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTBitmapLogo/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTColorPicker/","text":"Sketch Code /* TFT Color Picker This example for the Arduino screen reads the input of potentiometers or analog sensors attached to A0, A1, and A2 and uses the values to change the screen's color. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTColorPicker */ // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 #include <TFT.h> // Arduino LCD library #include <SPI.h> TFT TFTscreen = TFT(cs, dc, rst); void setup() { // begin serial communication Serial.begin(9600); // initialize the display TFTscreen.begin(); // set the background to white TFTscreen.background(255, 255, 255); } void loop() { // read the values from your sensors and scale them to 0-255 int redVal = map(analogRead(A0), 0, 1023, 0, 255); int greenVal = map(analogRead(A1), 0, 1023, 0, 255); int blueVal = map(analogRead(A2), 0, 1023, 0, 255); // draw the background based on the mapped values TFTscreen.background(redVal, greenVal, blueVal); // send the values to the serial monitor Serial.print(\"background(\"); Serial.print(redVal); Serial.print(\" , \"); Serial.print(greenVal); Serial.print(\" , \"); Serial.print(blueVal); Serial.println(\")\"); // wait for a moment delay(33); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"TFTColorPicker"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTColorPicker/#sketch-code","text":"/* TFT Color Picker This example for the Arduino screen reads the input of potentiometers or analog sensors attached to A0, A1, and A2 and uses the values to change the screen's color. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTColorPicker */ // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 #include <TFT.h> // Arduino LCD library #include <SPI.h> TFT TFTscreen = TFT(cs, dc, rst); void setup() { // begin serial communication Serial.begin(9600); // initialize the display TFTscreen.begin(); // set the background to white TFTscreen.background(255, 255, 255); } void loop() { // read the values from your sensors and scale them to 0-255 int redVal = map(analogRead(A0), 0, 1023, 0, 255); int greenVal = map(analogRead(A1), 0, 1023, 0, 255); int blueVal = map(analogRead(A2), 0, 1023, 0, 255); // draw the background based on the mapped values TFTscreen.background(redVal, greenVal, blueVal); // send the values to the serial monitor Serial.print(\"background(\"); Serial.print(redVal); Serial.print(\" , \"); Serial.print(greenVal); Serial.print(\" , \"); Serial.print(blueVal); Serial.println(\")\"); // wait for a moment delay(33); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTColorPicker/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTColorPicker/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTColorPicker/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTDisplayText/","text":"Sketch Code /* Arduino TFT text example This example demonstrates how to draw text on the TFT with an Arduino. The Arduino reads the value of an analog sensor attached to pin A0, and writes the value to the LCD screen, updating every quarter second. This example code is in the public domain Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTDisplayText */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 // create an instance of the library TFT TFTscreen = TFT(cs, dc, rst); // char array to print to the screen char sensorPrintout[4]; void setup() { // Put this line at the beginning of every sketch that uses the GLCD: TFTscreen.begin(); // clear the screen with a black background TFTscreen.background(0, 0, 0); // write the static text to the screen // set the font color to white TFTscreen.stroke(255, 255, 255); // set the font size TFTscreen.setTextSize(2); // write the text to the top left corner of the screen TFTscreen.text(\"Sensor Value :\\n \", 0, 0); // ste the font size very large for the loop TFTscreen.setTextSize(5); } void loop() { // Read the value of the sensor on A0 String sensorVal = String(analogRead(A0)); // convert the reading to a char array sensorVal.toCharArray(sensorPrintout, 4); // set the font color TFTscreen.stroke(255, 255, 255); // print the sensor value TFTscreen.text(sensorPrintout, 0, 20); // wait for a moment delay(250); // erase the text you just wrote TFTscreen.stroke(0, 0, 0); TFTscreen.text(sensorPrintout, 0, 20); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"TFTDisplayText"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTDisplayText/#sketch-code","text":"/* Arduino TFT text example This example demonstrates how to draw text on the TFT with an Arduino. The Arduino reads the value of an analog sensor attached to pin A0, and writes the value to the LCD screen, updating every quarter second. This example code is in the public domain Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTDisplayText */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 // create an instance of the library TFT TFTscreen = TFT(cs, dc, rst); // char array to print to the screen char sensorPrintout[4]; void setup() { // Put this line at the beginning of every sketch that uses the GLCD: TFTscreen.begin(); // clear the screen with a black background TFTscreen.background(0, 0, 0); // write the static text to the screen // set the font color to white TFTscreen.stroke(255, 255, 255); // set the font size TFTscreen.setTextSize(2); // write the text to the top left corner of the screen TFTscreen.text(\"Sensor Value :\\n \", 0, 0); // ste the font size very large for the loop TFTscreen.setTextSize(5); } void loop() { // Read the value of the sensor on A0 String sensorVal = String(analogRead(A0)); // convert the reading to a char array sensorVal.toCharArray(sensorPrintout, 4); // set the font color TFTscreen.stroke(255, 255, 255); // print the sensor value TFTscreen.text(sensorPrintout, 0, 20); // wait for a moment delay(250); // erase the text you just wrote TFTscreen.stroke(0, 0, 0); TFTscreen.text(sensorPrintout, 0, 20); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTDisplayText/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTDisplayText/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTDisplayText/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTEtchAsketch/","text":"Sketch Code /* TFT EtchASketch This example for the Arduino screen draws a white point on the GLCD based on the values of 2 potentiometers. To clear the screen, press a button attached to pin 2. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTEtchASketch */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // initial position of the cursor int xPos = TFTscreen.width() / 2; int yPos = TFTscreen.height() / 2; // pin the erase switch is connected to int erasePin = 2; void setup() { // declare inputs pinMode(erasePin, INPUT); // initialize the screen TFTscreen.begin(); // make the background black TFTscreen.background(0, 0, 0); } void loop() { // read the potentiometers on A0 and A1 int xValue = analogRead(A0); int yValue = analogRead(A1); // map the values and update the position xPos = xPos + (map(xValue, 0, 1023, 2, -2)); yPos = yPos + (map(yValue, 0, 1023, -2, 2)); // don't let the point go past the screen edges if (xPos > 159) { (xPos = 159); } if (xPos < 0) { (xPos = 0); } if (yPos > 127) { (yPos = 127); } if (yPos < 0) { (yPos = 0); } // draw the point TFTscreen.stroke(255, 255, 255); TFTscreen.point(xPos, yPos); // read the value of the pin, and erase the screen if pressed if (digitalRead(erasePin) == HIGH) { TFTscreen.background(0, 0, 0); } delay(33); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"TFTEtchAsketch"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTEtchAsketch/#sketch-code","text":"/* TFT EtchASketch This example for the Arduino screen draws a white point on the GLCD based on the values of 2 potentiometers. To clear the screen, press a button attached to pin 2. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTEtchASketch */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // initial position of the cursor int xPos = TFTscreen.width() / 2; int yPos = TFTscreen.height() / 2; // pin the erase switch is connected to int erasePin = 2; void setup() { // declare inputs pinMode(erasePin, INPUT); // initialize the screen TFTscreen.begin(); // make the background black TFTscreen.background(0, 0, 0); } void loop() { // read the potentiometers on A0 and A1 int xValue = analogRead(A0); int yValue = analogRead(A1); // map the values and update the position xPos = xPos + (map(xValue, 0, 1023, 2, -2)); yPos = yPos + (map(yValue, 0, 1023, -2, 2)); // don't let the point go past the screen edges if (xPos > 159) { (xPos = 159); } if (xPos < 0) { (xPos = 0); } if (yPos > 127) { (yPos = 127); } if (yPos < 0) { (yPos = 0); } // draw the point TFTscreen.stroke(255, 255, 255); TFTscreen.point(xPos, yPos); // read the value of the pin, and erase the screen if pressed if (digitalRead(erasePin) == HIGH) { TFTscreen.background(0, 0, 0); } delay(33); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTEtchAsketch/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTEtchAsketch/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTEtchAsketch/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTGraph/","text":"Sketch Code /* TFT Graph This example for an Arduino screen reads the value of an analog sensor on A0, and graphs the values on the screen. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTGraph */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // position of the line on screen int xPos = 0; void setup() { // initialize the serial port Serial.begin(9600); // initialize the display TFTscreen.begin(); // clear the screen with a pretty color TFTscreen.background(250, 16, 200); } void loop() { // read the sensor and map it to the screen height int sensor = analogRead(A0); int drawHeight = map(sensor, 0, 1023, 0, TFTscreen.height()); // print out the height to the serial monitor Serial.println(drawHeight); // draw a line in a nice color TFTscreen.stroke(250, 180, 10); TFTscreen.line(xPos, TFTscreen.height() - drawHeight, xPos, TFTscreen.height()); // if the graph has reached the screen edge // erase the screen and start again if (xPos >= 160) { xPos = 0; TFTscreen.background(250, 16, 200); } else { // increment the horizontal position: xPos++; } delay(16); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"TFTGraph"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTGraph/#sketch-code","text":"/* TFT Graph This example for an Arduino screen reads the value of an analog sensor on A0, and graphs the values on the screen. This example code is in the public domain. Created 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTGraph */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // position of the line on screen int xPos = 0; void setup() { // initialize the serial port Serial.begin(9600); // initialize the display TFTscreen.begin(); // clear the screen with a pretty color TFTscreen.background(250, 16, 200); } void loop() { // read the sensor and map it to the screen height int sensor = analogRead(A0); int drawHeight = map(sensor, 0, 1023, 0, TFTscreen.height()); // print out the height to the serial monitor Serial.println(drawHeight); // draw a line in a nice color TFTscreen.stroke(250, 180, 10); TFTscreen.line(xPos, TFTscreen.height() - drawHeight, xPos, TFTscreen.height()); // if the graph has reached the screen edge // erase the screen and start again if (xPos >= 160) { xPos = 0; TFTscreen.background(250, 16, 200); } else { // increment the horizontal position: xPos++; } delay(16); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTGraph/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTGraph/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTGraph/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTPong/","text":"Sketch Code /* TFT Pong This example for the Arduino screen reads the values of 2 potentiometers to move a rectangular platform on the x and y axes. The platform can intersect with a ball causing it to bounce. This example code is in the public domain. Created by Tom Igoe December 2012 Modified 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTPong */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // variables for the position of the ball and paddle int paddleX = 0; int paddleY = 0; int oldPaddleX, oldPaddleY; int ballDirectionX = 1; int ballDirectionY = 1; int ballSpeed = 10; // lower numbers are faster int ballX, ballY, oldBallX, oldBallY; void setup() { // initialize the display TFTscreen.begin(); // black background TFTscreen.background(0, 0, 0); } void loop() { // save the width and height of the screen int myWidth = TFTscreen.width(); int myHeight = TFTscreen.height(); // map the paddle's location to the position of the potentiometers paddleX = map(analogRead(A0), 512, -512, 0, myWidth) - 20 / 2; paddleY = map(analogRead(A1), 512, -512, 0, myHeight) - 5 / 2; // set the fill color to black and erase the previous // position of the paddle if different from present TFTscreen.fill(0, 0, 0); if (oldPaddleX != paddleX || oldPaddleY != paddleY) { TFTscreen.rect(oldPaddleX, oldPaddleY, 20, 5); } // draw the paddle on screen, save the current position // as the previous. TFTscreen.fill(255, 255, 255); TFTscreen.rect(paddleX, paddleY, 20, 5); oldPaddleX = paddleX; oldPaddleY = paddleY; // update the ball's position and draw it on screen if (millis() % ballSpeed < 2) { moveBall(); } } // this function determines the ball's position on screen void moveBall() { // if the ball goes offscreen, reverse the direction: if (ballX > TFTscreen.width() || ballX < 0) { ballDirectionX = -ballDirectionX; } if (ballY > TFTscreen.height() || ballY < 0) { ballDirectionY = -ballDirectionY; } // check if the ball and the paddle occupy the same space on screen if (inPaddle(ballX, ballY, paddleX, paddleY, 20, 5)) { ballDirectionX = -ballDirectionX; ballDirectionY = -ballDirectionY; } // update the ball's position ballX += ballDirectionX; ballY += ballDirectionY; // erase the ball's previous position TFTscreen.fill(0, 0, 0); if (oldBallX != ballX || oldBallY != ballY) { TFTscreen.rect(oldBallX, oldBallY, 5, 5); } // draw the ball's current position TFTscreen.fill(255, 255, 255); TFTscreen.rect(ballX, ballY, 5, 5); oldBallX = ballX; oldBallY = ballY; } // this function checks the position of the ball // to see if it intersects with the paddle boolean inPaddle(int x, int y, int rectX, int rectY, int rectWidth, int rectHeight) { boolean result = false; if ((x >= rectX && x <= (rectX + rectWidth)) && (y >= rectY && y <= (rectY + rectHeight))) { result = true; } return result; } Fritzing Circuit KiCad Schematic Video Demonstration","title":"TFTPong"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTPong/#sketch-code","text":"/* TFT Pong This example for the Arduino screen reads the values of 2 potentiometers to move a rectangular platform on the x and y axes. The platform can intersect with a ball causing it to bounce. This example code is in the public domain. Created by Tom Igoe December 2012 Modified 15 April 2013 by Scott Fitzgerald http://www.arduino.cc/en/Tutorial/TFTPong */ #include <TFT.h> // Arduino LCD library #include <SPI.h> // pin definition for the Uno #define cs 10 #define dc 9 #define rst 8 // pin definition for the Leonardo // #define cs 7 // #define dc 0 // #define rst 1 TFT TFTscreen = TFT(cs, dc, rst); // variables for the position of the ball and paddle int paddleX = 0; int paddleY = 0; int oldPaddleX, oldPaddleY; int ballDirectionX = 1; int ballDirectionY = 1; int ballSpeed = 10; // lower numbers are faster int ballX, ballY, oldBallX, oldBallY; void setup() { // initialize the display TFTscreen.begin(); // black background TFTscreen.background(0, 0, 0); } void loop() { // save the width and height of the screen int myWidth = TFTscreen.width(); int myHeight = TFTscreen.height(); // map the paddle's location to the position of the potentiometers paddleX = map(analogRead(A0), 512, -512, 0, myWidth) - 20 / 2; paddleY = map(analogRead(A1), 512, -512, 0, myHeight) - 5 / 2; // set the fill color to black and erase the previous // position of the paddle if different from present TFTscreen.fill(0, 0, 0); if (oldPaddleX != paddleX || oldPaddleY != paddleY) { TFTscreen.rect(oldPaddleX, oldPaddleY, 20, 5); } // draw the paddle on screen, save the current position // as the previous. TFTscreen.fill(255, 255, 255); TFTscreen.rect(paddleX, paddleY, 20, 5); oldPaddleX = paddleX; oldPaddleY = paddleY; // update the ball's position and draw it on screen if (millis() % ballSpeed < 2) { moveBall(); } } // this function determines the ball's position on screen void moveBall() { // if the ball goes offscreen, reverse the direction: if (ballX > TFTscreen.width() || ballX < 0) { ballDirectionX = -ballDirectionX; } if (ballY > TFTscreen.height() || ballY < 0) { ballDirectionY = -ballDirectionY; } // check if the ball and the paddle occupy the same space on screen if (inPaddle(ballX, ballY, paddleX, paddleY, 20, 5)) { ballDirectionX = -ballDirectionX; ballDirectionY = -ballDirectionY; } // update the ball's position ballX += ballDirectionX; ballY += ballDirectionY; // erase the ball's previous position TFTscreen.fill(0, 0, 0); if (oldBallX != ballX || oldBallY != ballY) { TFTscreen.rect(oldBallX, oldBallY, 5, 5); } // draw the ball's current position TFTscreen.fill(255, 255, 255); TFTscreen.rect(ballX, ballY, 5, 5); oldBallX = ballX; oldBallY = ballY; } // this function checks the position of the ball // to see if it intersects with the paddle boolean inPaddle(int x, int y, int rectX, int rectY, int rectWidth, int rectHeight) { boolean result = false; if ((x >= rectX && x <= (rectX + rectWidth)) && (y >= rectY && y <= (rectY + rectHeight))) { result = true; } return result; }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTPong/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTPong/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Arduino/TFTPong/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/EsploraTFTBitmapLogo/","text":"Sketch Code Fritzing Circuit KiCad Schematic Video Demonstration","title":"EsploraTFTBitmapLogo"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/EsploraTFTBitmapLogo/#sketch-code","text":"","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/EsploraTFTBitmapLogo/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/EsploraTFTBitmapLogo/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/EsploraTFTBitmapLogo/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTColorPicker/","text":"Sketch Code Fritzing Circuit KiCad Schematic Video Demonstration","title":"ExploraTFTColorPicker"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTColorPicker/#sketch-code","text":"","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTColorPicker/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTColorPicker/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTColorPicker/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTEtchASketch/","text":"Sketch Code Fritzing Circuit KiCad Schematic Video Demonstration","title":"ExploraTFTEtchASketch"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTEtchASketch/#sketch-code","text":"","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTEtchASketch/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTEtchASketch/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTEtchASketch/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTGraph/","text":"Sketch Code Fritzing Circuit KiCad Schematic Video Demonstration","title":"ExploraTFTGraph"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTGraph/#sketch-code","text":"","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTGraph/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTGraph/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTGraph/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTHorizon/","text":"Sketch Code Fritzing Circuit KiCad Schematic Video Demonstration","title":"ExploraTFTHorizon"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTHorizon/#sketch-code","text":"","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTHorizon/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTHorizon/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTHorizon/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTPong/","text":"Sketch Code Fritzing Circuit KiCad Schematic Video Demonstration","title":"ExploraTFTPong"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTPong/#sketch-code","text":"","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTPong/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTPong/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTPong/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTTemp/","text":"Sketch Code Fritzing Circuit KiCad Schematic Video Demonstration","title":"ExploraTFTTemp"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTTemp/#sketch-code","text":"","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTTemp/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTTemp/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/TFT/Esplora/ExploraTFTTemp/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WDT/WatchdogRefresh/","text":"Sketch Code /* Watchdog Refresh This sketch shows how to enable the watchdog and refresh the timer to avoid resets Watchdog intervals are limited to 7 timeout periods the library will select the best clock divisor and timeout according to the selected wdtInterval. UNO R4 min wdtInterval 1ms / max wdtInterval 5592ms Comment out Serial.print() in the setup to make it work with small intervals Portenta C33 min wdtInterval 1ms / max wdtInterval 2684ms Circuit: - Portenta C33 - UNO R4 */ #include <WDT.h> const long ledInterval = 1000; unsigned long ledMillis = 0; bool ledState = true; const long wdtInterval = 2684; unsigned long wdtMillis = 0; void setup() { Serial.begin(9600); while (!Serial); pinMode(LED_BUILTIN, OUTPUT); if(wdtInterval < 1) { Serial.println(\"Invalid watchdog interval\"); while(1){} } if(WDT.begin(wdtInterval)) { Serial.print(\"WDT interval: \"); WDT.refresh(); Serial.print(WDT.getTimeout()); WDT.refresh(); Serial.println(\" ms\"); WDT.refresh(); } else { Serial.println(\"Error initializing watchdog\"); while(1){} } } void loop() { if(millis() - ledMillis >= ledInterval) { digitalWrite(LED_BUILTIN, ledState); ledState = !ledState; ledMillis = millis(); } if(millis() - wdtMillis >= wdtInterval - 1) { WDT.refresh(); // Comment this line to stop refreshing the watchdog wdtMillis = millis(); } } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WatchdogRefresh"},{"location":"05_examples_uno_r4_wifi/WDT/WatchdogRefresh/#sketch-code","text":"/* Watchdog Refresh This sketch shows how to enable the watchdog and refresh the timer to avoid resets Watchdog intervals are limited to 7 timeout periods the library will select the best clock divisor and timeout according to the selected wdtInterval. UNO R4 min wdtInterval 1ms / max wdtInterval 5592ms Comment out Serial.print() in the setup to make it work with small intervals Portenta C33 min wdtInterval 1ms / max wdtInterval 2684ms Circuit: - Portenta C33 - UNO R4 */ #include <WDT.h> const long ledInterval = 1000; unsigned long ledMillis = 0; bool ledState = true; const long wdtInterval = 2684; unsigned long wdtMillis = 0; void setup() { Serial.begin(9600); while (!Serial); pinMode(LED_BUILTIN, OUTPUT); if(wdtInterval < 1) { Serial.println(\"Invalid watchdog interval\"); while(1){} } if(WDT.begin(wdtInterval)) { Serial.print(\"WDT interval: \"); WDT.refresh(); Serial.print(WDT.getTimeout()); WDT.refresh(); Serial.println(\" ms\"); WDT.refresh(); } else { Serial.println(\"Error initializing watchdog\"); while(1){} } } void loop() { if(millis() - ledMillis >= ledInterval) { digitalWrite(LED_BUILTIN, ledState); ledState = !ledState; ledMillis = millis(); } if(millis() - wdtMillis >= wdtInterval - 1) { WDT.refresh(); // Comment this line to stop refreshing the watchdog wdtMillis = millis(); } }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WDT/WatchdogRefresh/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WDT/WatchdogRefresh/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WDT/WatchdogRefresh/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/AP_SimpleWebServer/","text":"Sketch Code /* WiFi Web Server LED Blink A simple web server that lets you blink an LED via the web. This sketch will create a new access point (with no password). It will then launch a new server and print out the IP address to the Serial Monitor. From there, you can open that address in a web browser to turn on and off the LED on pin 13. If the IP address of your board is yourAddress: http://yourAddress/H turns the LED on http://yourAddress/L turns it off created 25 Nov 2012 by Tom Igoe adapted to WiFi AP by Adafruit Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#access-point */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int led = LED_BUILTIN; int status = WL_IDLE_STATUS; WiFiServer server(80); void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"Access Point Web Server\"); pinMode(led, OUTPUT); // set the LED pin mode // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // by default the local IP address will be 192.168.4.1 // you can override it with the following: WiFi.config(IPAddress(192,48,56,2)); // print the network name (SSID); Serial.print(\"Creating access point named: \"); Serial.println(ssid); // Create open network. Change this line if you want to create an WEP network: status = WiFi.beginAP(ssid, pass); if (status != WL_AP_LISTENING) { Serial.println(\"Creating access point failed\"); // don't continue while (true); } // wait 10 seconds for connection: delay(10000); // start the web server on port 80 server.begin(); // you're connected now, so print out the status printWiFiStatus(); } void loop() { // compare the previous status to the current status if (status != WiFi.status()) { // it has changed update the variable status = WiFi.status(); if (status == WL_AP_CONNECTED) { // a device has connected to the AP Serial.println(\"Device connected to AP\"); } else { // a device has disconnected from the AP, and we are back in listening mode Serial.println(\"Device disconnected from AP\"); } } WiFiClient client = server.available(); // listen for incoming clients if (client) { // if you get a client, Serial.println(\"new client\"); // print a message out the serial port String currentLine = \"\"; // make a String to hold incoming data from the client while (client.connected()) { // loop while the client's connected delayMicroseconds(10); // This is required for the Arduino Nano RP2040 Connect - otherwise it will loop so fast that SPI will never be served. if (client.available()) { // if there's bytes to read from the client, char c = client.read(); // read a byte, then Serial.write(c); // print it out to the serial monitor if (c == '\\n') { // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that's the end of the client HTTP request, so send a response: if (currentLine.length() == 0) { // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what's coming, then a blank line: client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-type:text/html\"); client.println(); // the content of the HTTP response follows the header: client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/H\\\">here</a> turn the LED on<br></p>\"); client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/L\\\">here</a> turn the LED off<br></p>\"); // The HTTP response ends with another blank line: client.println(); // break out of the while loop: break; } else { // if you got a newline, then clear currentLine: currentLine = \"\"; } } else if (c != '\\r') { // if you got anything else but a carriage return character, currentLine += c; // add it to the end of the currentLine } // Check to see if the client request was \"GET /H\" or \"GET /L\": if (currentLine.endsWith(\"GET /H\")) { digitalWrite(led, HIGH); // GET /H turns the LED on } if (currentLine.endsWith(\"GET /L\")) { digitalWrite(led, LOW); // GET /L turns the LED off } } } // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } void printWiFiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your WiFi shield's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print where to go in a browser: Serial.print(\"To see this page in action, open a browser to http://\"); Serial.println(ip); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"AP SimpleWebServer"},{"location":"05_examples_uno_r4_wifi/WiFiS3/AP_SimpleWebServer/#sketch-code","text":"/* WiFi Web Server LED Blink A simple web server that lets you blink an LED via the web. This sketch will create a new access point (with no password). It will then launch a new server and print out the IP address to the Serial Monitor. From there, you can open that address in a web browser to turn on and off the LED on pin 13. If the IP address of your board is yourAddress: http://yourAddress/H turns the LED on http://yourAddress/L turns it off created 25 Nov 2012 by Tom Igoe adapted to WiFi AP by Adafruit Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#access-point */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int led = LED_BUILTIN; int status = WL_IDLE_STATUS; WiFiServer server(80); void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } Serial.println(\"Access Point Web Server\"); pinMode(led, OUTPUT); // set the LED pin mode // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // by default the local IP address will be 192.168.4.1 // you can override it with the following: WiFi.config(IPAddress(192,48,56,2)); // print the network name (SSID); Serial.print(\"Creating access point named: \"); Serial.println(ssid); // Create open network. Change this line if you want to create an WEP network: status = WiFi.beginAP(ssid, pass); if (status != WL_AP_LISTENING) { Serial.println(\"Creating access point failed\"); // don't continue while (true); } // wait 10 seconds for connection: delay(10000); // start the web server on port 80 server.begin(); // you're connected now, so print out the status printWiFiStatus(); } void loop() { // compare the previous status to the current status if (status != WiFi.status()) { // it has changed update the variable status = WiFi.status(); if (status == WL_AP_CONNECTED) { // a device has connected to the AP Serial.println(\"Device connected to AP\"); } else { // a device has disconnected from the AP, and we are back in listening mode Serial.println(\"Device disconnected from AP\"); } } WiFiClient client = server.available(); // listen for incoming clients if (client) { // if you get a client, Serial.println(\"new client\"); // print a message out the serial port String currentLine = \"\"; // make a String to hold incoming data from the client while (client.connected()) { // loop while the client's connected delayMicroseconds(10); // This is required for the Arduino Nano RP2040 Connect - otherwise it will loop so fast that SPI will never be served. if (client.available()) { // if there's bytes to read from the client, char c = client.read(); // read a byte, then Serial.write(c); // print it out to the serial monitor if (c == '\\n') { // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that's the end of the client HTTP request, so send a response: if (currentLine.length() == 0) { // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what's coming, then a blank line: client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-type:text/html\"); client.println(); // the content of the HTTP response follows the header: client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/H\\\">here</a> turn the LED on<br></p>\"); client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/L\\\">here</a> turn the LED off<br></p>\"); // The HTTP response ends with another blank line: client.println(); // break out of the while loop: break; } else { // if you got a newline, then clear currentLine: currentLine = \"\"; } } else if (c != '\\r') { // if you got anything else but a carriage return character, currentLine += c; // add it to the end of the currentLine } // Check to see if the client request was \"GET /H\" or \"GET /L\": if (currentLine.endsWith(\"GET /H\")) { digitalWrite(led, HIGH); // GET /H turns the LED on } if (currentLine.endsWith(\"GET /L\")) { digitalWrite(led, LOW); // GET /L turns the LED off } } } // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } void printWiFiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your WiFi shield's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print where to go in a browser: Serial.print(\"To see this page in action, open a browser to http://\"); Serial.println(ip); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/AP_SimpleWebServer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/AP_SimpleWebServer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/AP_SimpleWebServer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ConnectWithWPA/","text":"Sketch Code /* This example connects to an unencrypted WiFi network. Then it prints the MAC address of the WiFi module, the IP address obtained, and other network details. created 13 July 2010 by dlf (Metodo2 srl) modified 31 May 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#connect-with-wpa */ #include <WiFiS3.h> #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; // the WiFi radio's status void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to WPA SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } // you're connected now, so print out the data: Serial.print(\"You're connected to the network\"); printCurrentNet(); printWifiData(); } void loop() { // check the network connection once every 10 seconds: delay(10000); printCurrentNet(); } void printWifiData() { // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print your MAC address: byte mac[6]; WiFi.macAddress(mac); Serial.print(\"MAC address: \"); printMacAddress(mac); } void printCurrentNet() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print the MAC address of the router you're attached to: byte bssid[6]; WiFi.BSSID(bssid); Serial.print(\"BSSID: \"); printMacAddress(bssid); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.println(rssi); // print the encryption type: byte encryption = WiFi.encryptionType(); Serial.print(\"Encryption Type:\"); Serial.println(encryption, HEX); Serial.println(); } void printMacAddress(byte mac[]) { for (int i = 5; i >= 0; i--) { if (mac[i] < 16) { Serial.print(\"0\"); } Serial.print(mac[i], HEX); if (i > 0) { Serial.print(\":\"); } } Serial.println(); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"ConnectWithWPA"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ConnectWithWPA/#sketch-code","text":"/* This example connects to an unencrypted WiFi network. Then it prints the MAC address of the WiFi module, the IP address obtained, and other network details. created 13 July 2010 by dlf (Metodo2 srl) modified 31 May 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#connect-with-wpa */ #include <WiFiS3.h> #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; // the WiFi radio's status void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to WPA SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } // you're connected now, so print out the data: Serial.print(\"You're connected to the network\"); printCurrentNet(); printWifiData(); } void loop() { // check the network connection once every 10 seconds: delay(10000); printCurrentNet(); } void printWifiData() { // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print your MAC address: byte mac[6]; WiFi.macAddress(mac); Serial.print(\"MAC address: \"); printMacAddress(mac); } void printCurrentNet() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print the MAC address of the router you're attached to: byte bssid[6]; WiFi.BSSID(bssid); Serial.print(\"BSSID: \"); printMacAddress(bssid); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.println(rssi); // print the encryption type: byte encryption = WiFi.encryptionType(); Serial.print(\"Encryption Type:\"); Serial.println(encryption, HEX); Serial.println(); } void printMacAddress(byte mac[]) { for (int i = 5; i >= 0; i--) { if (mac[i] < 16) { Serial.print(\"0\"); } Serial.print(mac[i], HEX); if (i > 0) { Serial.print(\":\"); } } Serial.println(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ConnectWithWPA/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ConnectWithWPA/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ConnectWithWPA/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworks/","text":"Sketch Code /* This example prints the board's MAC address, and scans for available WiFi networks using the NINA module. Every ten seconds, it scans again. It doesn't actually connect to any network, so no encryption scheme is specified. Circuit: * Board with NINA module (Arduino MKR WiFi 1010, MKR VIDOR 4000 and Uno WiFi Rev.2) created 13 July 2010 by dlf (Metodo2 srl) modified 21 Junn 2012 by Tom Igoe and Jaymes Dec Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#scan-networks */ #include <WiFiS3.h> void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } } void loop() { byte mac[6]; // scan for existing networks: Serial.println(\"Scanning available networks...\"); listNetworks(); WiFi.macAddress(mac); Serial.println(); Serial.print(\"Your MAC Address is: \"); printMacAddress(mac); delay(10000); } void listNetworks() { // scan for nearby networks: Serial.println(\"** Scan Networks **\"); int numSsid = WiFi.scanNetworks(); if (numSsid == -1) { Serial.println(\"Couldn't get a WiFi connection\"); while (true); } // print the list of networks seen: Serial.print(\"number of available networks:\"); Serial.println(numSsid); // print the network number and name for each network found: for (int thisNet = 0; thisNet < numSsid; thisNet++) { Serial.print(thisNet); Serial.print(\") \"); Serial.print(WiFi.SSID(thisNet)); Serial.print(\" Signal: \"); Serial.print(WiFi.RSSI(thisNet)); Serial.print(\" dBm\"); Serial.print(\" Encryption: \"); printEncryptionType(WiFi.encryptionType(thisNet)); } } void printEncryptionType(int thisType) { // read the encryption type and print out the name: switch (thisType) { case ENC_TYPE_WEP: Serial.println(\"WEP\"); break; case ENC_TYPE_WPA: Serial.println(\"WPA\"); break; case ENC_TYPE_WPA2: Serial.println(\"WPA2\"); break; case ENC_TYPE_WPA3: Serial.print(\"WPA3\"); break; case ENC_TYPE_NONE: Serial.println(\"None\"); break; case ENC_TYPE_AUTO: Serial.println(\"Auto\"); break; case ENC_TYPE_UNKNOWN: default: Serial.println(\"Unknown\"); break; } } void printMacAddress(byte mac[]) { for (int i = 5; i >= 0; i--) { if (mac[i] < 16) { Serial.print(\"0\"); } Serial.print(mac[i], HEX); if (i > 0) { Serial.print(\":\"); } } Serial.println(); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"ScanNetworks"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworks/#sketch-code","text":"/* This example prints the board's MAC address, and scans for available WiFi networks using the NINA module. Every ten seconds, it scans again. It doesn't actually connect to any network, so no encryption scheme is specified. Circuit: * Board with NINA module (Arduino MKR WiFi 1010, MKR VIDOR 4000 and Uno WiFi Rev.2) created 13 July 2010 by dlf (Metodo2 srl) modified 21 Junn 2012 by Tom Igoe and Jaymes Dec Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#scan-networks */ #include <WiFiS3.h> void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } } void loop() { byte mac[6]; // scan for existing networks: Serial.println(\"Scanning available networks...\"); listNetworks(); WiFi.macAddress(mac); Serial.println(); Serial.print(\"Your MAC Address is: \"); printMacAddress(mac); delay(10000); } void listNetworks() { // scan for nearby networks: Serial.println(\"** Scan Networks **\"); int numSsid = WiFi.scanNetworks(); if (numSsid == -1) { Serial.println(\"Couldn't get a WiFi connection\"); while (true); } // print the list of networks seen: Serial.print(\"number of available networks:\"); Serial.println(numSsid); // print the network number and name for each network found: for (int thisNet = 0; thisNet < numSsid; thisNet++) { Serial.print(thisNet); Serial.print(\") \"); Serial.print(WiFi.SSID(thisNet)); Serial.print(\" Signal: \"); Serial.print(WiFi.RSSI(thisNet)); Serial.print(\" dBm\"); Serial.print(\" Encryption: \"); printEncryptionType(WiFi.encryptionType(thisNet)); } } void printEncryptionType(int thisType) { // read the encryption type and print out the name: switch (thisType) { case ENC_TYPE_WEP: Serial.println(\"WEP\"); break; case ENC_TYPE_WPA: Serial.println(\"WPA\"); break; case ENC_TYPE_WPA2: Serial.println(\"WPA2\"); break; case ENC_TYPE_WPA3: Serial.print(\"WPA3\"); break; case ENC_TYPE_NONE: Serial.println(\"None\"); break; case ENC_TYPE_AUTO: Serial.println(\"Auto\"); break; case ENC_TYPE_UNKNOWN: default: Serial.println(\"Unknown\"); break; } } void printMacAddress(byte mac[]) { for (int i = 5; i >= 0; i--) { if (mac[i] < 16) { Serial.print(\"0\"); } Serial.print(mac[i], HEX); if (i > 0) { Serial.print(\":\"); } } Serial.println(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworks/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworks/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworks/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworksAdvanced/","text":"Sketch Code /* This example prints the board's MAC address, and scans for available WiFi networks using the NINA module. Every ten seconds, it scans again. It doesn't actually connect to any network, so no encryption scheme is specified. BSSID and WiFi channel are printed Circuit: * Board with NINA module (Arduino MKR WiFi 1010, MKR VIDOR 4000 and Uno WiFi Rev.2) This example is based on ScanNetworks created 1 Mar 2017 by Arturo Guadalupi Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#scan-networks-advanced */ #include <WiFiS3.h> void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // scan for existing networks: Serial.println(); Serial.println(\"Scanning available networks...\"); listNetworks(); // print your MAC address: byte mac[6]; WiFi.macAddress(mac); Serial.print(\"MAC: \"); printMacAddress(mac); } void loop() { delay(10000); // scan for existing networks: Serial.println(\"Scanning available networks...\"); listNetworks(); } void listNetworks() { // scan for nearby networks: Serial.println(\"** Scan Networks **\"); int numSsid = WiFi.scanNetworks(); if (numSsid == -1) { Serial.println(\"Couldn't get a WiFi connection\"); while (true); } // print the list of networks seen: Serial.print(\"number of available networks: \"); Serial.println(numSsid); // print the network number and name for each network found: for (int thisNet = 0; thisNet < numSsid; thisNet++) { Serial.print(thisNet + 1); Serial.print(\") \"); Serial.print(\"Signal: \"); Serial.print(WiFi.RSSI(thisNet)); Serial.print(\" dBm\"); Serial.print(\"\\tChannel: \"); Serial.print(WiFi.channel(thisNet)); byte bssid[6]; Serial.print(\"\\t\\tBSSID: \"); printMacAddress(WiFi.BSSID(thisNet, bssid)); Serial.print(\"\\tEncryption: \"); printEncryptionType(WiFi.encryptionType(thisNet)); Serial.print(\"\\t\\tSSID: \"); Serial.println(WiFi.SSID(thisNet)); Serial.flush(); } Serial.println(); } void printEncryptionType(int thisType) { // read the encryption type and print out the name: switch (thisType) { case ENC_TYPE_WEP: Serial.print(\"WEP\"); break; case ENC_TYPE_WPA: Serial.print(\"WPA\"); break; case ENC_TYPE_WPA2: Serial.print(\"WPA2\"); break; case ENC_TYPE_WPA3: Serial.print(\"WPA3\"); break; case ENC_TYPE_NONE: Serial.print(\"None\"); break; case ENC_TYPE_AUTO: Serial.print(\"Auto\"); break; case ENC_TYPE_UNKNOWN: default: Serial.print(\"Unknown\"); break; } } void print2Digits(byte thisByte) { if (thisByte < 0xF) { Serial.print(\"0\"); } Serial.print(thisByte, HEX); } void printMacAddress(byte mac[]) { for (int i = 5; i >= 0; i--) { if (mac[i] < 16) { Serial.print(\"0\"); } Serial.print(mac[i], HEX); if (i > 0) { Serial.print(\":\"); } } Serial.println(); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"ScanNetworksAdvanced"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworksAdvanced/#sketch-code","text":"/* This example prints the board's MAC address, and scans for available WiFi networks using the NINA module. Every ten seconds, it scans again. It doesn't actually connect to any network, so no encryption scheme is specified. BSSID and WiFi channel are printed Circuit: * Board with NINA module (Arduino MKR WiFi 1010, MKR VIDOR 4000 and Uno WiFi Rev.2) This example is based on ScanNetworks created 1 Mar 2017 by Arturo Guadalupi Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#scan-networks-advanced */ #include <WiFiS3.h> void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // scan for existing networks: Serial.println(); Serial.println(\"Scanning available networks...\"); listNetworks(); // print your MAC address: byte mac[6]; WiFi.macAddress(mac); Serial.print(\"MAC: \"); printMacAddress(mac); } void loop() { delay(10000); // scan for existing networks: Serial.println(\"Scanning available networks...\"); listNetworks(); } void listNetworks() { // scan for nearby networks: Serial.println(\"** Scan Networks **\"); int numSsid = WiFi.scanNetworks(); if (numSsid == -1) { Serial.println(\"Couldn't get a WiFi connection\"); while (true); } // print the list of networks seen: Serial.print(\"number of available networks: \"); Serial.println(numSsid); // print the network number and name for each network found: for (int thisNet = 0; thisNet < numSsid; thisNet++) { Serial.print(thisNet + 1); Serial.print(\") \"); Serial.print(\"Signal: \"); Serial.print(WiFi.RSSI(thisNet)); Serial.print(\" dBm\"); Serial.print(\"\\tChannel: \"); Serial.print(WiFi.channel(thisNet)); byte bssid[6]; Serial.print(\"\\t\\tBSSID: \"); printMacAddress(WiFi.BSSID(thisNet, bssid)); Serial.print(\"\\tEncryption: \"); printEncryptionType(WiFi.encryptionType(thisNet)); Serial.print(\"\\t\\tSSID: \"); Serial.println(WiFi.SSID(thisNet)); Serial.flush(); } Serial.println(); } void printEncryptionType(int thisType) { // read the encryption type and print out the name: switch (thisType) { case ENC_TYPE_WEP: Serial.print(\"WEP\"); break; case ENC_TYPE_WPA: Serial.print(\"WPA\"); break; case ENC_TYPE_WPA2: Serial.print(\"WPA2\"); break; case ENC_TYPE_WPA3: Serial.print(\"WPA3\"); break; case ENC_TYPE_NONE: Serial.print(\"None\"); break; case ENC_TYPE_AUTO: Serial.print(\"Auto\"); break; case ENC_TYPE_UNKNOWN: default: Serial.print(\"Unknown\"); break; } } void print2Digits(byte thisByte) { if (thisByte < 0xF) { Serial.print(\"0\"); } Serial.print(thisByte, HEX); } void printMacAddress(byte mac[]) { for (int i = 5; i >= 0; i--) { if (mac[i] < 16) { Serial.print(\"0\"); } Serial.print(mac[i], HEX); if (i > 0) { Serial.print(\":\"); } } Serial.println(); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworksAdvanced/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworksAdvanced/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/ScanNetworksAdvanced/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/SimpleWebServerWiFi/","text":"Sketch Code /* WiFi Web Server LED Blink A simple web server that lets you blink an LED via the web. This sketch will print the IP address of your WiFi module (once connected) to the Serial Monitor. From there, you can open that address in a web browser to turn on and off the LED_BUILTIN. If the IP address of your board is yourAddress: http://yourAddress/H turns the LED on http://yourAddress/L turns it off This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. Circuit: * Board with NINA module (Arduino MKR WiFi 1010, MKR VIDOR 4000 and Uno WiFi Rev.2) * LED attached to pin 9 created 25 Nov 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#simple-webserver */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int led = LED_BUILTIN; int status = WL_IDLE_STATUS; WiFiServer server(80); void setup() { Serial.begin(9600); // initialize serial communication pinMode(led, OUTPUT); // set the LED pin mode // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to Network named: \"); Serial.println(ssid); // print the network name (SSID); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } server.begin(); // start the web server on port 80 printWifiStatus(); // you're connected now, so print out the status } void loop() { WiFiClient client = server.available(); // listen for incoming clients if (client) { // if you get a client, Serial.println(\"new client\"); // print a message out the serial port String currentLine = \"\"; // make a String to hold incoming data from the client while (client.connected()) { // loop while the client's connected if (client.available()) { // if there's bytes to read from the client, char c = client.read(); // read a byte, then Serial.write(c); // print it out to the serial monitor if (c == '\\n') { // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that's the end of the client HTTP request, so send a response: if (currentLine.length() == 0) { // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what's coming, then a blank line: client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-type:text/html\"); client.println(); // the content of the HTTP response follows the header: client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/H\\\">here</a> turn the LED on<br></p>\"); client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/L\\\">here</a> turn the LED off<br></p>\"); // The HTTP response ends with another blank line: client.println(); // break out of the while loop: break; } else { // if you got a newline, then clear currentLine: currentLine = \"\"; } } else if (c != '\\r') { // if you got anything else but a carriage return character, currentLine += c; // add it to the end of the currentLine } // Check to see if the client request was \"GET /H\" or \"GET /L\": if (currentLine.endsWith(\"GET /H\")) { digitalWrite(LED_BUILTIN, HIGH); // GET /H turns the LED on } if (currentLine.endsWith(\"GET /L\")) { digitalWrite(LED_BUILTIN, LOW); // GET /L turns the LED off } } } // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); // print where to go in a browser: Serial.print(\"To see this page in action, open a browser to http://\"); Serial.println(ip); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"SimpleWebServerWiFi"},{"location":"05_examples_uno_r4_wifi/WiFiS3/SimpleWebServerWiFi/#sketch-code","text":"/* WiFi Web Server LED Blink A simple web server that lets you blink an LED via the web. This sketch will print the IP address of your WiFi module (once connected) to the Serial Monitor. From there, you can open that address in a web browser to turn on and off the LED_BUILTIN. If the IP address of your board is yourAddress: http://yourAddress/H turns the LED on http://yourAddress/L turns it off This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. Circuit: * Board with NINA module (Arduino MKR WiFi 1010, MKR VIDOR 4000 and Uno WiFi Rev.2) * LED attached to pin 9 created 25 Nov 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#simple-webserver */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int led = LED_BUILTIN; int status = WL_IDLE_STATUS; WiFiServer server(80); void setup() { Serial.begin(9600); // initialize serial communication pinMode(led, OUTPUT); // set the LED pin mode // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to Network named: \"); Serial.println(ssid); // print the network name (SSID); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } server.begin(); // start the web server on port 80 printWifiStatus(); // you're connected now, so print out the status } void loop() { WiFiClient client = server.available(); // listen for incoming clients if (client) { // if you get a client, Serial.println(\"new client\"); // print a message out the serial port String currentLine = \"\"; // make a String to hold incoming data from the client while (client.connected()) { // loop while the client's connected if (client.available()) { // if there's bytes to read from the client, char c = client.read(); // read a byte, then Serial.write(c); // print it out to the serial monitor if (c == '\\n') { // if the byte is a newline character // if the current line is blank, you got two newline characters in a row. // that's the end of the client HTTP request, so send a response: if (currentLine.length() == 0) { // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK) // and a content-type so the client knows what's coming, then a blank line: client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-type:text/html\"); client.println(); // the content of the HTTP response follows the header: client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/H\\\">here</a> turn the LED on<br></p>\"); client.print(\"<p style=\\\"font-size:7vw;\\\">Click <a href=\\\"/L\\\">here</a> turn the LED off<br></p>\"); // The HTTP response ends with another blank line: client.println(); // break out of the while loop: break; } else { // if you got a newline, then clear currentLine: currentLine = \"\"; } } else if (c != '\\r') { // if you got anything else but a carriage return character, currentLine += c; // add it to the end of the currentLine } // Check to see if the client request was \"GET /H\" or \"GET /L\": if (currentLine.endsWith(\"GET /H\")) { digitalWrite(LED_BUILTIN, HIGH); // GET /H turns the LED on } if (currentLine.endsWith(\"GET /L\")) { digitalWrite(LED_BUILTIN, LOW); // GET /L turns the LED off } } } // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); // print where to go in a browser: Serial.print(\"To see this page in action, open a browser to http://\"); Serial.println(ip); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/SimpleWebServerWiFi/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/SimpleWebServerWiFi/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/SimpleWebServerWiFi/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiChatServer/","text":"Sketch Code /* Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. Circuit: * Board with NINA module (Arduino MKR WiFi 1010, MKR VIDOR 4000 and Uno WiFi Rev.2) created 18 Dec 2009 by David A. Mellis modified 31 May 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-chat-server */ #include <WiFiS3.h> #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int status = WL_IDLE_STATUS; WiFiServer server(23); boolean alreadyConnected = false; // whether or not the client was connected previously void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } // start the server: server.begin(); // you're connected now, so print out the status: printWifiStatus(); } void loop() { // wait for a new client: WiFiClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!alreadyConnected) { // clear out the input buffer: client.flush(); Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); alreadyConnected = true; } if (client.available() > 0) { // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.write(thisChar); } } } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WiFiChatServer"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiChatServer/#sketch-code","text":"/* Chat Server A simple server that distributes any incoming messages to all connected clients. To use, telnet to your device's IP address and type. You can see the client's input in the serial monitor as well. This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. Circuit: * Board with NINA module (Arduino MKR WiFi 1010, MKR VIDOR 4000 and Uno WiFi Rev.2) created 18 Dec 2009 by David A. Mellis modified 31 May 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-chat-server */ #include <WiFiS3.h> #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int status = WL_IDLE_STATUS; WiFiServer server(23); boolean alreadyConnected = false; // whether or not the client was connected previously void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } // start the server: server.begin(); // you're connected now, so print out the status: printWifiStatus(); } void loop() { // wait for a new client: WiFiClient client = server.available(); // when the client sends the first byte, say hello: if (client) { if (!alreadyConnected) { // clear out the input buffer: client.flush(); Serial.println(\"We have a new client\"); client.println(\"Hello, client!\"); alreadyConnected = true; } if (client.available() > 0) { // read the bytes incoming from the client: char thisChar = client.read(); // echo the bytes back to the client: server.write(thisChar); // echo the bytes to the server as well: Serial.write(thisChar); } } } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiChatServer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiChatServer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiChatServer/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpNtpClient/","text":"Sketch Code /* Udp NTP Client Get the time from a Network Time Protocol (NTP) time server Demonstrates use of UDP sendPacket and ReceivePacket For more on NTP time servers and the messages needed to communicate with them, see http://en.wikipedia.org/wiki/Network_Time_Protocol created 4 Sep 2010 by Michael Margolis modified 9 Apr 2012 by Tom Igoe modified May, 4th 2023 by Daniele Aimo This code is in the public domain. Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-udp-ntp-client */ #include <WiFiS3.h> int status = WL_IDLE_STATUS; #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) unsigned int localPort = 2390; // local port to listen for UDP packets IPAddress timeServer(162, 159, 200, 123); // pool.ntp.org NTP server const int NTP_PACKET_SIZE = 48; // NTP timestamp is in the first 48 bytes of the message byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming and outgoing packets // A UDP instance to let us send and receive packets over UDP WiFiUDP Udp; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } Serial.println(\"Connected to WiFi\"); printWifiStatus(); Serial.println(\"\\nStarting connection to server...\"); Udp.begin(localPort); } void loop() { sendNTPpacket(timeServer); // send an NTP packet to a time server // wait to see if a reply is available delay(1000); if (Udp.parsePacket()) { Serial.println(\"packet received\"); // We've received a packet, read the data from it Udp.read(packetBuffer, NTP_PACKET_SIZE); // read the packet into the buffer //the timestamp starts at byte 40 of the received packet and is four bytes, // or two words, long. First, extract the two words: unsigned long highWord = word(packetBuffer[40], packetBuffer[41]); unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]); // combine the four bytes (two words) into a long integer // this is NTP time (seconds since Jan 1 1900): unsigned long secsSince1900 = highWord << 16 | lowWord; Serial.print(\"Seconds since Jan 1 1900 = \"); Serial.println(secsSince1900); // now convert NTP time into everyday time: Serial.print(\"Unix time = \"); // Unix time starts on Jan 1 1970. In seconds, that's 2208988800: const unsigned long seventyYears = 2208988800UL; // subtract seventy years: unsigned long epoch = secsSince1900 - seventyYears; // print Unix time: Serial.println(epoch); // print the hour, minute and second: Serial.print(\"The UTC time is \"); // UTC is the time at Greenwich Meridian (GMT) Serial.print((epoch % 86400L) / 3600); // print the hour (86400 equals secs per day) Serial.print(':'); if (((epoch % 3600) / 60) < 10) { // In the first 10 minutes of each hour, we'll want a leading '0' Serial.print('0'); } Serial.print((epoch % 3600) / 60); // print the minute (3600 equals secs per minute) Serial.print(':'); if ((epoch % 60) < 10) { // In the first 10 seconds of each minute, we'll want a leading '0' Serial.print('0'); } Serial.println(epoch % 60); // print the second } // wait ten seconds before asking for the time again delay(10000); } // send an NTP request to the time server at the given address unsigned long sendNTPpacket(IPAddress& address) { //Serial.println(\"1\"); // set all bytes in the buffer to 0 memset(packetBuffer, 0, NTP_PACKET_SIZE); // Initialize values needed to form NTP request // (see URL above for details on the packets) //Serial.println(\"2\"); packetBuffer[0] = 0b11100011; // LI, Version, Mode packetBuffer[1] = 0; // Stratum, or type of clock packetBuffer[2] = 6; // Polling Interval packetBuffer[3] = 0xEC; // Peer Clock Precision // 8 bytes of zero for Root Delay & Root Dispersion packetBuffer[12] = 49; packetBuffer[13] = 0x4E; packetBuffer[14] = 49; packetBuffer[15] = 52; //Serial.println(\"3\"); // all NTP fields have been given values, now // you can send a packet requesting a timestamp: Udp.beginPacket(address, 123); //NTP requests are to port 123 //Serial.println(\"4\"); Udp.write(packetBuffer, NTP_PACKET_SIZE); //Serial.println(\"5\"); Udp.endPacket(); //Serial.println(\"6\"); } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WiFiUdpNtpClient"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpNtpClient/#sketch-code","text":"/* Udp NTP Client Get the time from a Network Time Protocol (NTP) time server Demonstrates use of UDP sendPacket and ReceivePacket For more on NTP time servers and the messages needed to communicate with them, see http://en.wikipedia.org/wiki/Network_Time_Protocol created 4 Sep 2010 by Michael Margolis modified 9 Apr 2012 by Tom Igoe modified May, 4th 2023 by Daniele Aimo This code is in the public domain. Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-udp-ntp-client */ #include <WiFiS3.h> int status = WL_IDLE_STATUS; #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) unsigned int localPort = 2390; // local port to listen for UDP packets IPAddress timeServer(162, 159, 200, 123); // pool.ntp.org NTP server const int NTP_PACKET_SIZE = 48; // NTP timestamp is in the first 48 bytes of the message byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming and outgoing packets // A UDP instance to let us send and receive packets over UDP WiFiUDP Udp; void setup() { // Open serial communications and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } Serial.println(\"Connected to WiFi\"); printWifiStatus(); Serial.println(\"\\nStarting connection to server...\"); Udp.begin(localPort); } void loop() { sendNTPpacket(timeServer); // send an NTP packet to a time server // wait to see if a reply is available delay(1000); if (Udp.parsePacket()) { Serial.println(\"packet received\"); // We've received a packet, read the data from it Udp.read(packetBuffer, NTP_PACKET_SIZE); // read the packet into the buffer //the timestamp starts at byte 40 of the received packet and is four bytes, // or two words, long. First, extract the two words: unsigned long highWord = word(packetBuffer[40], packetBuffer[41]); unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]); // combine the four bytes (two words) into a long integer // this is NTP time (seconds since Jan 1 1900): unsigned long secsSince1900 = highWord << 16 | lowWord; Serial.print(\"Seconds since Jan 1 1900 = \"); Serial.println(secsSince1900); // now convert NTP time into everyday time: Serial.print(\"Unix time = \"); // Unix time starts on Jan 1 1970. In seconds, that's 2208988800: const unsigned long seventyYears = 2208988800UL; // subtract seventy years: unsigned long epoch = secsSince1900 - seventyYears; // print Unix time: Serial.println(epoch); // print the hour, minute and second: Serial.print(\"The UTC time is \"); // UTC is the time at Greenwich Meridian (GMT) Serial.print((epoch % 86400L) / 3600); // print the hour (86400 equals secs per day) Serial.print(':'); if (((epoch % 3600) / 60) < 10) { // In the first 10 minutes of each hour, we'll want a leading '0' Serial.print('0'); } Serial.print((epoch % 3600) / 60); // print the minute (3600 equals secs per minute) Serial.print(':'); if ((epoch % 60) < 10) { // In the first 10 seconds of each minute, we'll want a leading '0' Serial.print('0'); } Serial.println(epoch % 60); // print the second } // wait ten seconds before asking for the time again delay(10000); } // send an NTP request to the time server at the given address unsigned long sendNTPpacket(IPAddress& address) { //Serial.println(\"1\"); // set all bytes in the buffer to 0 memset(packetBuffer, 0, NTP_PACKET_SIZE); // Initialize values needed to form NTP request // (see URL above for details on the packets) //Serial.println(\"2\"); packetBuffer[0] = 0b11100011; // LI, Version, Mode packetBuffer[1] = 0; // Stratum, or type of clock packetBuffer[2] = 6; // Polling Interval packetBuffer[3] = 0xEC; // Peer Clock Precision // 8 bytes of zero for Root Delay & Root Dispersion packetBuffer[12] = 49; packetBuffer[13] = 0x4E; packetBuffer[14] = 49; packetBuffer[15] = 52; //Serial.println(\"3\"); // all NTP fields have been given values, now // you can send a packet requesting a timestamp: Udp.beginPacket(address, 123); //NTP requests are to port 123 //Serial.println(\"4\"); Udp.write(packetBuffer, NTP_PACKET_SIZE); //Serial.println(\"5\"); Udp.endPacket(); //Serial.println(\"6\"); } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpNtpClient/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpNtpClient/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpNtpClient/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpSendReceiveString/","text":"Sketch Code /* WiFi UDP Send and Receive String This sketch waits for a UDP packet on localPort using the WiFi module. When a packet is received an Acknowledge packet is sent to the client on port remotePort created 30 December 2012 by dlf (Metodo2 srl) Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-udp-send-receive-string */ #include <WiFiS3.h> int status = WL_IDLE_STATUS; #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) unsigned int localPort = 2390; // local port to listen on char packetBuffer[256]; //buffer to hold incoming packet char ReplyBuffer[] = \"acknowledged\\n\"; // a string to send back WiFiUDP Udp; void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } Serial.println(\"Connected to WiFi\"); printWifiStatus(); Serial.println(\"\\nStarting connection to server...\"); // if you get a connection, report back via serial: Udp.begin(localPort); } void loop() { // if there's data available, read a packet int packetSize = Udp.parsePacket(); if (packetSize) { Serial.print(\"Received packet of size \"); Serial.println(packetSize); Serial.print(\"From \"); IPAddress remoteIp = Udp.remoteIP(); Serial.print(remoteIp); Serial.print(\", port \"); Serial.println(Udp.remotePort()); // read the packet into packetBuffer int len = Udp.read(packetBuffer, 255); if (len > 0) { packetBuffer[len] = 0; } Serial.println(\"Contents:\"); Serial.println(packetBuffer); // send a reply, to the IP address and port that sent us the packet we received Udp.beginPacket(Udp.remoteIP(), Udp.remotePort()); Udp.write(ReplyBuffer); Udp.endPacket(); } } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WiFiUdpSendReceiveString"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpSendReceiveString/#sketch-code","text":"/* WiFi UDP Send and Receive String This sketch waits for a UDP packet on localPort using the WiFi module. When a packet is received an Acknowledge packet is sent to the client on port remotePort created 30 December 2012 by dlf (Metodo2 srl) Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-udp-send-receive-string */ #include <WiFiS3.h> int status = WL_IDLE_STATUS; #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) unsigned int localPort = 2390; // local port to listen on char packetBuffer[256]; //buffer to hold incoming packet char ReplyBuffer[] = \"acknowledged\\n\"; // a string to send back WiFiUDP Udp; void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } Serial.println(\"Connected to WiFi\"); printWifiStatus(); Serial.println(\"\\nStarting connection to server...\"); // if you get a connection, report back via serial: Udp.begin(localPort); } void loop() { // if there's data available, read a packet int packetSize = Udp.parsePacket(); if (packetSize) { Serial.print(\"Received packet of size \"); Serial.println(packetSize); Serial.print(\"From \"); IPAddress remoteIp = Udp.remoteIP(); Serial.print(remoteIp); Serial.print(\", port \"); Serial.println(Udp.remotePort()); // read the packet into packetBuffer int len = Udp.read(packetBuffer, 255); if (len > 0) { packetBuffer[len] = 0; } Serial.println(\"Contents:\"); Serial.println(packetBuffer); // send a reply, to the IP address and port that sent us the packet we received Udp.beginPacket(Udp.remoteIP(), Udp.remotePort()); Udp.write(ReplyBuffer); Udp.endPacket(); } } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpSendReceiveString/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpSendReceiveString/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiUdpSendReceiveString/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClient/","text":"Sketch Code /* Web client This sketch connects to a website (http://www.google.com) using the WiFi module. This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. created 13 July 2010 by dlf (Metodo2 srl) modified 31 May 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-web-client */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int status = WL_IDLE_STATUS; // if you don't want to use DNS (and reduce your sketch size) // use the numeric IP instead of the name for the server: //IPAddress server(74,125,232,128); // numeric IP for Google (no DNS) char server[] = \"www.google.com\"; // name address for Google (using DNS) // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 80 is default for HTTP): WiFiClient client; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } printWifiStatus(); Serial.println(\"\\nStarting connection to server...\"); // if you get a connection, report back via serial: if (client.connect(server, 80)) { Serial.println(\"connected to server\"); // Make a HTTP request: client.println(\"GET /search?q=arduino HTTP/1.1\"); client.println(\"Host: www.google.com\"); client.println(\"Connection: close\"); client.println(); } } /* just wrap the received data up to 80 columns in the serial print*/ /* -------------------------------------------------------------------------- */ void read_response() { /* -------------------------------------------------------------------------- */ uint32_t received_data_num = 0; while (client.available()) { /* actual data reception */ char c = client.read(); /* print data to serial port */ Serial.print(c); /* wrap data to 80 columns*/ received_data_num++; if(received_data_num % 80 == 0) { Serial.println(); } } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ read_response(); // if the server's disconnected, stop the client: if (!client.connected()) { Serial.println(); Serial.println(\"disconnecting from server.\"); client.stop(); // do nothing forevermore: while (true); } } /* -------------------------------------------------------------------------- */ void printWifiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WiFiWebClient"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClient/#sketch-code","text":"/* Web client This sketch connects to a website (http://www.google.com) using the WiFi module. This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. created 13 July 2010 by dlf (Metodo2 srl) modified 31 May 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-web-client */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int status = WL_IDLE_STATUS; // if you don't want to use DNS (and reduce your sketch size) // use the numeric IP instead of the name for the server: //IPAddress server(74,125,232,128); // numeric IP for Google (no DNS) char server[] = \"www.google.com\"; // name address for Google (using DNS) // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 80 is default for HTTP): WiFiClient client; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } printWifiStatus(); Serial.println(\"\\nStarting connection to server...\"); // if you get a connection, report back via serial: if (client.connect(server, 80)) { Serial.println(\"connected to server\"); // Make a HTTP request: client.println(\"GET /search?q=arduino HTTP/1.1\"); client.println(\"Host: www.google.com\"); client.println(\"Connection: close\"); client.println(); } } /* just wrap the received data up to 80 columns in the serial print*/ /* -------------------------------------------------------------------------- */ void read_response() { /* -------------------------------------------------------------------------- */ uint32_t received_data_num = 0; while (client.available()) { /* actual data reception */ char c = client.read(); /* print data to serial port */ Serial.print(c); /* wrap data to 80 columns*/ received_data_num++; if(received_data_num % 80 == 0) { Serial.println(); } } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ read_response(); // if the server's disconnected, stop the client: if (!client.connected()) { Serial.println(); Serial.println(\"disconnecting from server.\"); client.stop(); // do nothing forevermore: while (true); } } /* -------------------------------------------------------------------------- */ void printWifiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClient/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClient/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClient/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientRepeating/","text":"Sketch Code /* Repeating WiFi Web Client This sketch connects to a a web server and makes a request using a WiFi equipped Arduino board. created 23 April 2012 modified 31 May 2012 by Tom Igoe modified 13 Jan 2014 by Federico Vanzati This code is in the public domain. Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-web-client-repeating */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int status = WL_IDLE_STATUS; // Initialize the WiFi client library WiFiClient client; // server address: char server[] = \"example.org\"; //IPAddress server(64,131,82,241); unsigned long lastConnectionTime = 0; // last time you connected to the server, in milliseconds const unsigned long postingInterval = 10L * 1000L; // delay between updates, in milliseconds /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: //delay(10000); } // you're connected now, so print out the status: printWifiStatus(); } /* just wrap the received data up to 80 columns in the serial print*/ /* -------------------------------------------------------------------------- */ void read_request() { /* -------------------------------------------------------------------------- */ uint32_t received_data_num = 0; while (client.available()) { /* actual data reception */ char c = client.read(); /* print data to serial port */ Serial.print(c); /* wrap data to 80 columns*/ received_data_num++; if(received_data_num % 80 == 0) { } } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ // if there's incoming data from the net connection. // send it out the serial port. This is for debugging // purposes only: read_request(); // if ten seconds have passed since your last connection, // then connect again and send data: if (millis() - lastConnectionTime > postingInterval) { httpRequest(); } } // this method makes a HTTP connection to the server: /* -------------------------------------------------------------------------- */ void httpRequest() { /* -------------------------------------------------------------------------- */ // close any connection before send a new request. // This will free the socket on the NINA module client.stop(); // if there's a successful connection: if (client.connect(server, 80)) { Serial.println(\"connecting...\"); // send the HTTP GET request: client.println(\"GET / HTTP/1.1\"); client.println(\"Host: example.org\"); client.println(\"User-Agent: ArduinoWiFi/1.1\"); client.println(\"Connection: close\"); client.println(); // note the time that the connection was made: lastConnectionTime = millis(); } else { // if you couldn't make a connection: Serial.println(\"connection failed\"); } } /* -------------------------------------------------------------------------- */ void printWifiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WiFiWebClientRepeating"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientRepeating/#sketch-code","text":"/* Repeating WiFi Web Client This sketch connects to a a web server and makes a request using a WiFi equipped Arduino board. created 23 April 2012 modified 31 May 2012 by Tom Igoe modified 13 Jan 2014 by Federico Vanzati This code is in the public domain. Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-web-client-repeating */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int status = WL_IDLE_STATUS; // Initialize the WiFi client library WiFiClient client; // server address: char server[] = \"example.org\"; //IPAddress server(64,131,82,241); unsigned long lastConnectionTime = 0; // last time you connected to the server, in milliseconds const unsigned long postingInterval = 10L * 1000L; // delay between updates, in milliseconds /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: //delay(10000); } // you're connected now, so print out the status: printWifiStatus(); } /* just wrap the received data up to 80 columns in the serial print*/ /* -------------------------------------------------------------------------- */ void read_request() { /* -------------------------------------------------------------------------- */ uint32_t received_data_num = 0; while (client.available()) { /* actual data reception */ char c = client.read(); /* print data to serial port */ Serial.print(c); /* wrap data to 80 columns*/ received_data_num++; if(received_data_num % 80 == 0) { } } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ // if there's incoming data from the net connection. // send it out the serial port. This is for debugging // purposes only: read_request(); // if ten seconds have passed since your last connection, // then connect again and send data: if (millis() - lastConnectionTime > postingInterval) { httpRequest(); } } // this method makes a HTTP connection to the server: /* -------------------------------------------------------------------------- */ void httpRequest() { /* -------------------------------------------------------------------------- */ // close any connection before send a new request. // This will free the socket on the NINA module client.stop(); // if there's a successful connection: if (client.connect(server, 80)) { Serial.println(\"connecting...\"); // send the HTTP GET request: client.println(\"GET / HTTP/1.1\"); client.println(\"Host: example.org\"); client.println(\"User-Agent: ArduinoWiFi/1.1\"); client.println(\"Connection: close\"); client.println(); // note the time that the connection was made: lastConnectionTime = millis(); } else { // if you couldn't make a connection: Serial.println(\"connection failed\"); } } /* -------------------------------------------------------------------------- */ void printWifiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientRepeating/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientRepeating/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientRepeating/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientSSL/","text":"Sketch Code /* TLS WiFi Web client Remeber to update the CA certificates using CertificateUploader sketch before using this sketch. Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-web-client-ssl */ #include \"WiFiS3.h\" #include \"WiFiSSLClient.h\" #include \"IPAddress.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; // if you don't want to use DNS (and reduce your sketch size) // use the numeric IP instead of the name for the server: //IPAddress server(74,125,232,128); // numeric IP for Google (no DNS) char server[] = \"www.google.com\"; // name address for Google (using DNS) // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 80 is default for HTTP): WiFiSSLClient client; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } printWifiStatus(); Serial.println(\"\\nStarting connection to server...\"); // if you get a connection, report back via serial: if (client.connect(server, 443)) { Serial.println(\"connected to server\"); // Make a HTTP request: client.println(\"GET / HTTP/1.1\"); client.println(\"Host: www.google.com\"); client.println(\"Connection: close\"); client.println(); } } /* just wrap the received data up to 80 columns in the serial print*/ /* -------------------------------------------------------------------------- */ void read_response() { /* -------------------------------------------------------------------------- */ uint32_t received_data_num = 0; while (client.available()) { /* actual data reception */ char c = client.read(); /* print data to serial port */ Serial.print(c); /* wrap data to 80 columns*/ received_data_num++; if(received_data_num % 80 == 0) { Serial.println(); } } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ read_response(); // if the server's disconnected, stop the client: if (!client.connected()) { Serial.println(); Serial.println(\"disconnecting from server.\"); client.stop(); // do nothing forevermore: while (true); } } /* -------------------------------------------------------------------------- */ void printWifiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WiFiWebClientSSL"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientSSL/#sketch-code","text":"/* TLS WiFi Web client Remeber to update the CA certificates using CertificateUploader sketch before using this sketch. Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-web-client-ssl */ #include \"WiFiS3.h\" #include \"WiFiSSLClient.h\" #include \"IPAddress.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int status = WL_IDLE_STATUS; // if you don't want to use DNS (and reduce your sketch size) // use the numeric IP instead of the name for the server: //IPAddress server(74,125,232,128); // numeric IP for Google (no DNS) char server[] = \"www.google.com\"; // name address for Google (using DNS) // Initialize the Ethernet client library // with the IP address and port of the server // that you want to connect to (port 80 is default for HTTP): WiFiSSLClient client; /* -------------------------------------------------------------------------- */ void setup() { /* -------------------------------------------------------------------------- */ //Initialize serial and wait for port to open: Serial.begin(115200); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } printWifiStatus(); Serial.println(\"\\nStarting connection to server...\"); // if you get a connection, report back via serial: if (client.connect(server, 443)) { Serial.println(\"connected to server\"); // Make a HTTP request: client.println(\"GET / HTTP/1.1\"); client.println(\"Host: www.google.com\"); client.println(\"Connection: close\"); client.println(); } } /* just wrap the received data up to 80 columns in the serial print*/ /* -------------------------------------------------------------------------- */ void read_response() { /* -------------------------------------------------------------------------- */ uint32_t received_data_num = 0; while (client.available()) { /* actual data reception */ char c = client.read(); /* print data to serial port */ Serial.print(c); /* wrap data to 80 columns*/ received_data_num++; if(received_data_num % 80 == 0) { Serial.println(); } } } /* -------------------------------------------------------------------------- */ void loop() { /* -------------------------------------------------------------------------- */ read_response(); // if the server's disconnected, stop the client: if (!client.connected()) { Serial.println(); Serial.println(\"disconnecting from server.\"); client.stop(); // do nothing forevermore: while (true); } } /* -------------------------------------------------------------------------- */ void printWifiStatus() { /* -------------------------------------------------------------------------- */ // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientSSL/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientSSL/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebClientSSL/#video-demonstration","text":"","title":"Video Demonstration"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebServer/","text":"Sketch Code /* WiFi Web Server A simple web server that shows the value of the analog input pins. This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. Circuit: * Analog inputs attached to pins A0 through A5 (optional) created 13 July 2010 by dlf (Metodo2 srl) modified 31 May 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-web-server */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int status = WL_IDLE_STATUS; WiFiServer server(80); void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } server.begin(); // you're connected now, so print out the status: printWifiStatus(); } void loop() { // listen for incoming clients WiFiClient client = server.available(); if (client) { Serial.println(\"new client\"); // an HTTP request ends with a blank line boolean currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); Serial.write(c); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(\"Connection: close\"); // the connection will be closed after completion of the response client.println(\"Refresh: 5\"); // refresh the page automatically every 5 sec client.println(); client.println(\"<!DOCTYPE HTML>\"); client.println(\"<html>\"); // output the value of each analog input pin for (int analogChannel = 0; analogChannel < 6; analogChannel++) { int sensorReading = analogRead(analogChannel); client.print(\"analog input \"); client.print(analogChannel); client.print(\" is \"); client.print(sensorReading); client.println(\"<br />\"); } client.println(\"</html>\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); } Fritzing Circuit KiCad Schematic Video Demonstration","title":"WiFiWebServer"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebServer/#sketch-code","text":"/* WiFi Web Server A simple web server that shows the value of the analog input pins. This example is written for a network using WPA encryption. For WEP or WPA, change the WiFi.begin() call accordingly. Circuit: * Analog inputs attached to pins A0 through A5 (optional) created 13 July 2010 by dlf (Metodo2 srl) modified 31 May 2012 by Tom Igoe Find the full UNO R4 WiFi Network documentation here: https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#wi-fi-web-server */ #include \"WiFiS3.h\" #include \"arduino_secrets.h\" ///////please enter your sensitive data in the Secret tab/arduino_secrets.h char ssid[] = SECRET_SSID; // your network SSID (name) char pass[] = SECRET_PASS; // your network password (use for WPA, or use as key for WEP) int keyIndex = 0; // your network key index number (needed only for WEP) int status = WL_IDLE_STATUS; WiFiServer server(80); void setup() { //Initialize serial and wait for port to open: Serial.begin(9600); while (!Serial) { ; // wait for serial port to connect. Needed for native USB port only } // check for the WiFi module: if (WiFi.status() == WL_NO_MODULE) { Serial.println(\"Communication with WiFi module failed!\"); // don't continue while (true); } String fv = WiFi.firmwareVersion(); if (fv < WIFI_FIRMWARE_LATEST_VERSION) { Serial.println(\"Please upgrade the firmware\"); } // attempt to connect to WiFi network: while (status != WL_CONNECTED) { Serial.print(\"Attempting to connect to SSID: \"); Serial.println(ssid); // Connect to WPA/WPA2 network. Change this line if using open or WEP network: status = WiFi.begin(ssid, pass); // wait 10 seconds for connection: delay(10000); } server.begin(); // you're connected now, so print out the status: printWifiStatus(); } void loop() { // listen for incoming clients WiFiClient client = server.available(); if (client) { Serial.println(\"new client\"); // an HTTP request ends with a blank line boolean currentLineIsBlank = true; while (client.connected()) { if (client.available()) { char c = client.read(); Serial.write(c); // if you've gotten to the end of the line (received a newline // character) and the line is blank, the HTTP request has ended, // so you can send a reply if (c == '\\n' && currentLineIsBlank) { // send a standard HTTP response header client.println(\"HTTP/1.1 200 OK\"); client.println(\"Content-Type: text/html\"); client.println(\"Connection: close\"); // the connection will be closed after completion of the response client.println(\"Refresh: 5\"); // refresh the page automatically every 5 sec client.println(); client.println(\"<!DOCTYPE HTML>\"); client.println(\"<html>\"); // output the value of each analog input pin for (int analogChannel = 0; analogChannel < 6; analogChannel++) { int sensorReading = analogRead(analogChannel); client.print(\"analog input \"); client.print(analogChannel); client.print(\" is \"); client.print(sensorReading); client.println(\"<br />\"); } client.println(\"</html>\"); break; } if (c == '\\n') { // you're starting a new line currentLineIsBlank = true; } else if (c != '\\r') { // you've gotten a character on the current line currentLineIsBlank = false; } } } // give the web browser time to receive the data delay(1); // close the connection: client.stop(); Serial.println(\"client disconnected\"); } } void printWifiStatus() { // print the SSID of the network you're attached to: Serial.print(\"SSID: \"); Serial.println(WiFi.SSID()); // print your board's IP address: IPAddress ip = WiFi.localIP(); Serial.print(\"IP Address: \"); Serial.println(ip); // print the received signal strength: long rssi = WiFi.RSSI(); Serial.print(\"signal strength (RSSI):\"); Serial.print(rssi); Serial.println(\" dBm\"); }","title":"Sketch Code"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebServer/#fritzing-circuit","text":"","title":"Fritzing Circuit"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebServer/#kicad-schematic","text":"","title":"KiCad Schematic"},{"location":"05_examples_uno_r4_wifi/WiFiS3/WiFiWebServer/#video-demonstration","text":"","title":"Video Demonstration"}]}
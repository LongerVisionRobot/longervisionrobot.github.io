<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
      <link rel="shortcut icon" href="../img/favicon.ico" />
    <title>Chapter 5: Arduino Build-in Examples - Arduino UNO R4 Wifi</title>
    <link rel="stylesheet" href="../css/theme.css" />
    <link rel="stylesheet" href="../css/theme_extra.css" />
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css" />
        <link href="../assets/_mkdocstrings.css" rel="stylesheet" />
    
      <script>
        // Current page data
        var mkdocs_page_name = "Chapter 5: Arduino Build-in Examples";
        var mkdocs_page_input_path = "05_examples_uno_r4_wifi.md";
        var mkdocs_page_url = null;
      </script>
    
    <!--[if lt IE 9]>
      <script src="../js/html5shiv.min.js"></script>
    <![endif]-->
      <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
      <script>hljs.highlightAll();</script> 
</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side stickynav">
    <div class="wy-side-scroll">
      <div class="wy-side-nav-search">
          <a href=".." class="icon icon-home"> Arduino UNO R4 Wifi
        </a><div role="search">
  <form id ="rtd-search-form" class="wy-form" action="../search.html" method="get">
      <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" title="Type search term here" />
  </form>
</div>
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="..">Home</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../01_introduction/">Chapter 1 - Intruduction</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../02_components/">Chapter 2 - Components</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../03_arduinoide_fritzing_kicad/">Chapter 3 - Arduino IDE, Fritzing and KiCad</a>
                </li>
              </ul>
              <ul>
                <li class="toctree-l1"><a class="reference internal" href="../04_builtin_examples/">Chapter 4 - Built-in Examples</a>
                </li>
              </ul>
      </div>
    </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">
      <nav class="wy-nav-top" role="navigation" aria-label="Mobile navigation menu">
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="..">Arduino UNO R4 Wifi</a>
        
      </nav>
      <div class="wy-nav-content">
        <div class="rst-content"><div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href=".." class="icon icon-home" aria-label="Docs"></a></li>
      <li class="breadcrumb-item active">Chapter 5: Arduino Build-in Examples</li>
    <li class="wy-breadcrumbs-aside">
    </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
            <div class="section" itemprop="articleBody">
              
                <h1 id="chapter-5-arduino-build-in-examples">Chapter 5: Arduino Build-in Examples</h1>
<h2 id="section-51-analogwave">Section 5.1: AnalogWave</h2>
<h3 id="511-dacequaltemperedscale">5.1.1 DACEqualTemperedScale</h3>
<h4 id="sketch-code">Sketch Code</h4>
<pre><code class="language-C">/*
  Plays a tone in response to a potentiometer
  formula from https://newt.phys.unsw.edu.au/jw/notes.html
  and https://en.wikipedia.org/wiki/MIDI_tuning_standard:

  the MIDI protocol divides the notes of an equal-tempered scale into 
  128 possible note values. Middle A is MIDI note value 69. There is
  a formula for converting MIDI note numbers (0-127) to pitches. This sketch
  reduces that to the notes 21 - 108, which are the 88 keys found on a piano:

     frequency =  440 * ((noteNumber - 69) / 12.0)^2

  You can see this applied in the code below. 

  circuit:
     * audio amp (LM386 used for testing) input+ attached to A0
     * audio amp input- attached to ground
     * 4-8-ohm speaker attached to amp output+
     * Potentiometer connected to pin A5

   created 18 Dec 2018
   modified 3 Jul 2023
   by Tom Igoe

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/dac
*/

// include the AnalogWave library:
#include &quot;analogWave.h&quot;
analogWave wave(DAC);

// middle A is the reference frequency for an
// equal-tempered scale. Set its frequency and note value:
#define NOTE_A4 69         // MIDI note value for middle A
#define FREQ_A4 440        // frequency for middle A

const int speakerPin = A0;  // the pin number for the speaker
void setup() {
  Serial.begin(9600);
  wave.sine(10);
}
void loop() {
  // convert sensor reading to 21 - 108 range
  // which is the range of MIDI notes on an 88-key keyboard
  // (from A0 to C8):
  int sensorReading = analogRead(A5);
  int noteValue = map(sensorReading, 0, 1023, 21, 108);
  // then convert to frequency:
  float frequency =  FREQ_A4 * pow(2, ((noteValue - NOTE_A4) / 12.0));
  int freq = int(frequency);
  // turn the speaker on:
  wave.freq(freq);
  Serial.print(&quot;note value: &quot;+ String(noteValue) + &quot; freq: &quot;);
  Serial.println(freq);
  delay(500);
}
</code></pre>
<h4 id="fritzing-circuit"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration">Video Demonstration</h4>
<h3 id="512-dacjacques">5.1.2 DACJacques</h3>
<h4 id="sketch-code_1">Sketch Code</h4>
<pre><code class="language-C">/*
  DAC Melody player

  Generates a series of tones from MIDI note values
  using the Uno R4 DAC and the AnalogWave Library.
   The melody is &quot;Frere Jacques&quot;

circuit:
     * audio amp (LM386 used for testing) input+ attached to A0
     * audio amp input- attached to ground
     * 4-8-ohm speaker attached to amp output+
     * Potentiometer connected to pin A5

  created 13 Feb 2017
  modified 3 Jul 2023
  by Tom Igoe

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/dac
*/
#include &quot;analogWave.h&quot;
analogWave wave(DAC);

#define NOTE_A4 69         // MIDI note value for middle A
#define FREQ_A4 440        // frequency for middle A

// the tonic, or first note of the key signature for the song:
int tonic = 65;
// the melody sequence. Note values are relative to the tonic:
int melody[] = {1, 3, 5, 1,
                1, 3, 5, 1,
                5, 6, 8, 5, 6, 8,
                8, 10, 8, 6, 5, 1,
                8, 10, 8, 6, 5, 1,
                1, -4, 1,
                1, -4, 1
               };
// the rhythm sequence. Values are 1/note, e.g. 4 = 1/4 note:
int rhythm[] = {4, 4, 4, 4,
                4, 4, 4, 4,
                4, 4, 2,
                4, 4, 2,
                8, 8, 8, 8, 4, 4,
                8, 8, 8, 8, 4, 4,
                4, 4, 2,
                4, 4, 2
               };
// which note of the melody to play:
int noteCounter = 0;

int bpm = 120;  // beats per minute
// duration of a beat in ms
float beatDuration = 60.0 / bpm * 1000;

void setup() {
// start the sine wave generator:
  wave.sine(10);
}

void loop() {
  // current note is an element of the array:
  int currentNote = melody[noteCounter] + tonic;
  // play a note from the melody:
  // convert MIDI note number to frequency:
  float frequency =  FREQ_A4 * pow(2, ((currentNote - NOTE_A4) / 12.0));

  // all the notes in this are sixteenth notes,
  // which is 1/4 of a beat, so:
  float noteDuration = beatDuration * (4.0 / rhythm[noteCounter]);
  // turn the note on:
  wave.freq(frequency);
 // tone(speakerPin, frequency, noteDuration * 0.85);
  // keep it on for the appropriate duration:
  delay(noteDuration * 0.85);
  wave.stop();
  delay(noteDuration * 0.15);
  // turn the note off:
 // noTone(speakerPin);
  // increment the note number for next time through the loop:
  noteCounter++;
  // keep the note in the range from 0 - 32 using modulo:
  noteCounter = noteCounter % 32;

}
</code></pre>
<h4 id="fritzing-circuit_1"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_1"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_1">Video Demonstration</h4>
<h3 id="513-sinewave">5.1.3 SineWave</h3>
<h4 id="sketch-code_2">Sketch Code</h4>
<pre><code class="language-C">/*
  SineWave

  Generates a pre-generated sawtooth-waveform.

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/dac
*/

#include &quot;analogWave.h&quot; // Include the library for analog waveform generation

analogWave wave(DAC);   // Create an instance of the analogWave class, using the DAC pin

int freq = 10;  // in hertz, change accordingly

void setup() {
  Serial.begin(115200);  // Initialize serial communication at a baud rate of 115200
  wave.sine(freq);       // Generate a sine wave with the initial frequency
}

void loop() {
  // Read an analog value from pin A5 and map it to a frequency range
  freq = map(analogRead(A5), 0, 1024, 0, 10000);

  // Print the updated frequency to the serial monitor
  Serial.println(&quot;Frequency is now &quot; + String(freq) + &quot; hz&quot;);

  wave.freq(freq);  // Set the frequency of the waveform generator to the updated value
  delay(1000);      // Delay for one second before repeating
}
</code></pre>
<h4 id="fritzing-circuit_2"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_2"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_2">Video Demonstration</h4>
<h2 id="section-52-arduino_can">Section 5.2: Arduino_CAN</h2>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>CAN1 is only available on <a href="https://store.arduino.cc/products/portenta-c33">Portenta C33</a>.</p>
</div>
<h3 id="521-canread">5.2.1 CANRead</h3>
<h4 id="sketch-code_3">Sketch Code</h4>
<pre><code class="language-C">/*
  CANRead

  Receive and read CAN Bus messages

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/can
*/

/**************************************************************************************
 * INCLUDE
 **************************************************************************************/

#include &lt;Arduino_CAN.h&gt;

/**************************************************************************************
 * SETUP/LOOP
 **************************************************************************************/

void setup()
{
  Serial.begin(115200);
  while (!Serial) { }

  if (!CAN.begin(CanBitRate::BR_250k))
  {
    Serial.println(&quot;CAN.begin(...) failed.&quot;);
    for (;;) {}
  }
}

void loop()
{
  if (CAN.available())
  {
    CanMsg const msg = CAN.read();
    Serial.println(msg);
  }
}
</code></pre>
<h4 id="fritzing-circuit_3"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_3"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_3">Video Demonstration</h4>
<h3 id="522-canwrite">5.2.2 CANWrite</h3>
<h4 id="sketch-code_4">Sketch Code</h4>
<pre><code class="language-C">/*
  CANWrite

  Write and send CAN Bus messages

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/can
*/

/**************************************************************************************
 * INCLUDE
 **************************************************************************************/

#include &lt;Arduino_CAN.h&gt;

/**************************************************************************************
 * CONSTANTS
 **************************************************************************************/

static uint32_t const CAN_ID = 0x20;

/**************************************************************************************
 * SETUP/LOOP
 **************************************************************************************/

void setup()
{
  Serial.begin(115200);
  while (!Serial) { }

  if (!CAN.begin(CanBitRate::BR_250k))
  {
    Serial.println(&quot;CAN.begin(...) failed.&quot;);
    for (;;) {}
  }
}

static uint32_t msg_cnt = 0;

void loop()
{
  /* Assemble a CAN message with the format of
   * 0xCA 0xFE 0x00 0x00 [4 byte message counter]
   */
  uint8_t const msg_data[] = {0xCA,0xFE,0,0,0,0,0,0};
  memcpy((void *)(msg_data + 4), &amp;msg_cnt, sizeof(msg_cnt));
  CanMsg const msg(CanStandardId(CAN_ID), sizeof(msg_data), msg_data);

  /* Transmit the CAN message, capture and display an
   * error core in case of failure.
   */
  if (int const rc = CAN.write(msg); rc &lt; 0)
  {
    Serial.print  (&quot;CAN.write(...) failed with error code &quot;);
    Serial.println(rc);
    for (;;) { }
  }

  /* Increase the message counter. */
  msg_cnt++;

  /* Only send one message per second. */
  delay(1000);
}
</code></pre>
<h4 id="fritzing-circuit_4"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_4"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_4">Video Demonstration</h4>
<h2 id="section-53-arduino_freertos">Section 5.3: Arduino_FreeRTOS</h2>
<h3 id="531-freertos-blink">5.3.1 FreeRTOS-Blink</h3>
<h4 id="sketch-code_5">Sketch Code</h4>
<pre><code class="language-C">/*
  The code demonstrates the usage of FreeRTOS (Real-Time Operating System) to run concurrent tasks.

  One task is responsible for running the loop() logic (in a thread-safe manner), 
  while the other task blinks an LED using the built-in LED on non-Portenta boards or 
  the RGB LED on the Portenta C33 board.
*/

/**************************************************************************************
 * INCLUDE
 **************************************************************************************/

#include &lt;Arduino_FreeRTOS.h&gt;

/**************************************************************************************
 * GLOBAL VARIABLES
 **************************************************************************************/

TaskHandle_t loop_task, blinky_task;

/**************************************************************************************
 * SETUP/LOOP
 **************************************************************************************/

void setup()
{
  Serial.begin(115200);
  while (!Serial) { }

#if defined(ARDUINO_PORTENTA_C33)
  /* Only the Portenta C33 has an RGB LED. */
  pinMode(LEDR, OUTPUT);
  digitalWrite(LEDR, LOW);
#endif

  /* Init a task that calls 'loop'
   * since after the call to
   * 'vTaskStartScheduler' we'll never
   * get out of setup() and therefore
   * would never get to loop(), as we
   * are leaving the default execution
   * flow.
   */
  auto const rc_loop = xTaskCreate
    (
      loop_thread_func,
      static_cast&lt;const char*&gt;(&quot;Loop Thread&quot;),
      512 / 4,   /* usStackDepth in words */
      nullptr,   /* pvParameters */
      1,         /* uxPriority */
      &amp;loop_task /* pxCreatedTask */
    );

  if (rc_loop != pdPASS) {
    Serial.println(&quot;Failed to create 'loop' thread&quot;);
    return;
  }

  auto const rc_blinky = xTaskCreate
    (
      blinky_thread_func,
      static_cast&lt;const char*&gt;(&quot;Blinky Thread&quot;),
      512 / 4,     /* usStackDepth in words */
      nullptr,     /* pvParameters */
      1,           /* uxPriority */
      &amp;blinky_task /* pxCreatedTask */
    );

  if (rc_blinky != pdPASS) {
    Serial.println(&quot;Failed to create 'loop' thread&quot;);
    return;
  }

  Serial.println(&quot;Starting scheduler ...&quot;);
  /* Start the scheduler. */
  vTaskStartScheduler();
  /* We'll never get here. */
  for( ;; );
}

void loop()
{
#if defined(ARDUINO_PORTENTA_C33)
  /* Only the Portenta C33 has an RGB LED. */
  digitalWrite(LEDR, !digitalRead(LEDR));
#else
  Serial.println(millis());
#endif
  vTaskDelay(configTICK_RATE_HZ/4);
}

void loop_thread_func(void *pvParameters)
{
  for(;;)
  {
    loop();
    taskYIELD();
  }
}

void blinky_thread_func(void *pvParameters)
{
  /* setup() */
  pinMode(LED_BUILTIN, OUTPUT);
  digitalWrite(LED_BUILTIN, LOW);

  /* loop() */
  for(;;)
  {
    digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
    vTaskDelay(configTICK_RATE_HZ);
  }
}
</code></pre>
<h4 id="fritzing-circuit_5"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_5"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_5">Video Demonstration</h4>
<h2 id="section-54-eeprom">Section 5.4: EEPROM</h2>
<h3 id="541-eeprom_clear">5.4.1 eeprom_clear</h3>
<h4 id="sketch-code_6">Sketch Code</h4>
<pre><code class="language-C">/*
 * EEPROM Clear
 *
 * Sets all of the bytes of the EEPROM to 0.
 * Please see eeprom_iteration for a more in depth
 * look at how to traverse the EEPROM.
 *
 * This example code is in the public domain.
 */

#include &lt;EEPROM.h&gt;

void setup() {
  // initialize the LED pin as an output.
  pinMode(13, OUTPUT);

  /***
    Iterate through each byte of the EEPROM storage.

    Larger AVR processors have larger EEPROM sizes, E.g:
    - Arduino Duemilanove: 512 B EEPROM storage.
    - Arduino Uno:         1 kB EEPROM storage.
    - Arduino Mega:        4 kB EEPROM storage.

    Rather than hard-coding the length, you should use the pre-provided length function.
    This will make your code portable to all AVR processors.
  ***/

  for (int i = 0 ; i &lt; EEPROM.length() ; i++) {
    EEPROM.write(i, 0);
  }

  // turn the LED on when we're done
  digitalWrite(13, HIGH);
}

void loop() {
  /** Empty loop. **/
}
</code></pre>
<h4 id="fritzing-circuit_6"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_6"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_6">Video Demonstration</h4>
<h3 id="542-eeprom_crc">5.4.2 eeprom_crc</h3>
<h4 id="sketch-code_7">Sketch Code</h4>
<pre><code class="language-C">/***
    Written by Christopher Andrews.
    CRC algorithm generated by pycrc, MIT licence ( https://github.com/tpircher/pycrc ).

    A CRC is a simple way of checking whether data has changed or become corrupted.
    This example calculates a CRC value directly on the EEPROM values.
    The purpose of this example is to highlight how the EEPROM object can be used just like an array.
***/

#include &lt;Arduino.h&gt;
#include &lt;EEPROM.h&gt;

void setup() {

  //Start serial
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  //Print length of data to run CRC on.
  Serial.print(&quot;EEPROM length: &quot;);
  Serial.println(EEPROM.length());

  //Print the result of calling eeprom_crc()
  Serial.print(&quot;CRC32 of EEPROM data: 0x&quot;);
  Serial.println(eeprom_crc(), HEX);
  Serial.print(&quot;\n\nDone!&quot;);
}

void loop() {
  /* Empty loop */
}

unsigned long eeprom_crc(void) {

  const unsigned long crc_table[16] = {
    0x00000000, 0x1db71064, 0x3b6e20c8, 0x26d930ac,
    0x76dc4190, 0x6b6b51f4, 0x4db26158, 0x5005713c,
    0xedb88320, 0xf00f9344, 0xd6d6a3e8, 0xcb61b38c,
    0x9b64c2b0, 0x86d3d2d4, 0xa00ae278, 0xbdbdf21c
  };

  unsigned long crc = ~0L;

  for (int index = 0 ; index &lt; EEPROM.length()  ; ++index) {
    crc = crc_table[(crc ^ EEPROM[index]) &amp; 0x0f] ^ (crc &gt;&gt; 4);
    crc = crc_table[(crc ^ (EEPROM[index] &gt;&gt; 4)) &amp; 0x0f] ^ (crc &gt;&gt; 4);
    crc = ~crc;
  }
  return crc;
}
</code></pre>
<h4 id="fritzing-circuit_7"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_7"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_7">Video Demonstration</h4>
<h3 id="543-eeprom_get">5.4.3 eeprom_get</h3>
<h4 id="sketch-code_8">Sketch Code</h4>
<pre><code class="language-C">/***
    eeprom_get example.

    This shows how to use the EEPROM.get() method.

    To pre-set the EEPROM data, run the example sketch eeprom_put.
    This sketch will run without it, however, the values shown
    will be shown from what ever is already on the EEPROM.

    This may cause the serial object to print out a large string
    of garbage if there is no null character inside one of the strings
    loaded.

    Written by Christopher Andrews 2015
    Released under MIT licence.
***/

#include &lt;EEPROM.h&gt;

void setup() {

  float f = 0.00f;   //Variable to store data read from EEPROM.
  int eeAddress = 0; //EEPROM address to start reading from

  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
  Serial.print(&quot;Read float from EEPROM: &quot;);

  //Get the float data from the EEPROM at position 'eeAddress'
  EEPROM.get(eeAddress, f);
  Serial.println(f, 3);    //This may print 'ovf, nan' if the data inside the EEPROM is not a valid float.

  /***
    As get also returns a reference to 'f', you can use it inline.
    E.g: Serial.print( EEPROM.get( eeAddress, f ) );
  ***/

  /***
    Get can be used with custom structures too.
    I have separated this into an extra function.
  ***/

  secondTest(); //Run the next test.
}

struct MyObject {
  float field1;
  byte field2;
  char name[10];
};

void secondTest() {
  int eeAddress = sizeof(float); //Move address to the next byte after float 'f'.

  MyObject customVar; //Variable to store custom object read from EEPROM.
  EEPROM.get(eeAddress, customVar);

  Serial.println(&quot;Read custom object from EEPROM: &quot;);
  Serial.println(customVar.field1);
  Serial.println(customVar.field2);
  Serial.println(customVar.name);
}

void loop() {
  /* Empty loop */
}
</code></pre>
<h4 id="fritzing-circuit_8"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_8"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_8">Video Demonstration</h4>
<h3 id="544-eeprom_iteration">5.4.4 eeprom_iteration</h3>
<h4 id="sketch-code_9">Sketch Code</h4>
<pre><code class="language-C">/***
    eeprom_iteration example.

    A set of example snippets highlighting the
    simplest methods for traversing the EEPROM.

    Running this sketch is not necessary, this is
    simply highlighting certain programming methods.

    Written by Christopher Andrews 2015
    Released under MIT licence.
***/

#include &lt;EEPROM.h&gt;

void setup() {

  /***
    Iterate the EEPROM using a for loop.
  ***/

  for (int index = 0 ; index &lt; EEPROM.length() ; index++) {

    //Add one to each cell in the EEPROM
    EEPROM[ index ] += 1;
  }

  /***
    Iterate the EEPROM using a while loop.
  ***/

  int index = 0;

  while (index &lt; EEPROM.length()) {

    //Add one to each cell in the EEPROM
    EEPROM[ index ] += 1;
    index++;
  }

  /***
    Iterate the EEPROM using a do-while loop.
  ***/

  int idx = 0;  //Used 'idx' to avoid name conflict with 'index' above.

  do {

    //Add one to each cell in the EEPROM
    EEPROM[ idx ] += 1;
    idx++;
  } while (idx &lt; EEPROM.length());


} //End of setup function.

void loop() {}
</code></pre>
<h4 id="fritzing-circuit_9"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_9"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_9">Video Demonstration</h4>
<h3 id="545-eeprom_put">5.4.5 eeprom_put</h3>
<h4 id="sketch-code_10">Sketch Code</h4>
<pre><code class="language-C">/***
    eeprom_put example.

    This shows how to use the EEPROM.put() method.
    Also, this sketch will pre-set the EEPROM data for the
    example sketch eeprom_get.

    Note, unlike the single byte version EEPROM.write(),
    the put method will use update semantics. As in a byte
    will only be written to the EEPROM if the data is actually
    different.

    Written by Christopher Andrews 2015
    Released under MIT licence.
***/

#include &lt;EEPROM.h&gt;

struct MyObject {
  float field1;
  byte field2;
  char name[10];
};

void setup() {

  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  float f = 123.456f;  //Variable to store in EEPROM.
  int eeAddress = 0;   //Location we want the data to be put.


  //One simple call, with the address first and the object second.
  EEPROM.put(eeAddress, f);

  Serial.println(&quot;Written float data type!&quot;);

  /** Put is designed for use with custom structures also. **/

  //Data to store.
  MyObject customVar = {
    3.14f,
    65,
    &quot;Working!&quot;
  };

  eeAddress += sizeof(float); //Move address to the next byte after float 'f'.

  EEPROM.put(eeAddress, customVar);
  Serial.print(&quot;Written custom data type! \n\nView the example sketch eeprom_get to see how you can retrieve the values!&quot;);
}

void loop() {
  /* Empty loop */
}
</code></pre>
<h4 id="fritzing-circuit_10"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_10"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_10">Video Demonstration</h4>
<h3 id="546-eeprom_read">5.4.6 eeprom_read</h3>
<h4 id="sketch-code_11">Sketch Code</h4>
<pre><code class="language-C">/*
  EEPROM Read

  Reads the value of each byte of the EEPROM and prints it
  to the computer.
  This example code is in the public domain.

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom
 */

// Include the EEPROM library
#include &lt;EEPROM.h&gt;

// start reading from the first byte (address 0) of the EEPROM
int address = 0;
byte value;

void setup() {
  // initialize serial and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
}

void loop() {
  // read a byte from the current address of the EEPROM
  value = EEPROM.read(address);

  Serial.print(address);
  Serial.print(&quot;\t&quot;);
  Serial.print(value, DEC);
  Serial.println();

  /***
    Advance to the next address, when at the end restart at the beginning.

    Larger AVR processors have larger EEPROM sizes, E.g:
    - Arduino Duemilanove: 512 B EEPROM storage.
    - Arduino Uno:         1 kB EEPROM storage.
    - Arduino Mega:        4 kB EEPROM storage.

    Rather than hard-coding the length, you should use the pre-provided length function.
    This will make your code portable to all AVR processors.
  ***/
  address = address + 1;
  if (address == EEPROM.length()) {
    address = 0;
  }

  /***
    As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an
    EEPROM address is also doable by a bitwise and of the length - 1.

    ++address &amp;= EEPROM.length() - 1;
  ***/

  delay(500);
}
</code></pre>
<h4 id="fritzing-circuit_11"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_11"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_11">Video Demonstration</h4>
<h3 id="547-eeprom_update">5.4.7 eeprom_update</h3>
<h4 id="sketch-code_12">Sketch Code</h4>
<pre><code class="language-C">/***
   EEPROM Update method

   Stores values read from analog input 0 into the EEPROM.
   These values will stay in the EEPROM when the board is
   turned off and may be retrieved later by another sketch.

   If a value has not changed in the EEPROM, it is not overwritten
   which would reduce the life span of the EEPROM unnecessarily.

   Released using MIT licence.
 ***/

#include &lt;EEPROM.h&gt;

/** the current address in the EEPROM (i.e. which byte we're going to write to next) **/
int address = 0;

void setup() {
  /** Empty setup **/
}

void loop() {
  /***
    need to divide by 4 because analog inputs range from
    0 to 1023 and each byte of the EEPROM can only hold a
    value from 0 to 255.
  ***/
  int val = analogRead(0) / 4;

  /***
    Update the particular EEPROM cell.
    these values will remain there when the board is
    turned off.
  ***/
  EEPROM.update(address, val);

  /***
    The function EEPROM.update(address, val) is equivalent to the following:

    if( EEPROM.read(address) != val ){
      EEPROM.write(address, val);
    }
  ***/


  /***
    Advance to the next address, when at the end restart at the beginning.

    Larger AVR processors have larger EEPROM sizes, E.g:
    - Arduino Duemilanove: 512 B EEPROM storage.
    - Arduino Uno:         1 kB EEPROM storage.
    - Arduino Mega:        4 kB EEPROM storage.

    Rather than hard-coding the length, you should use the pre-provided length function.
    This will make your code portable to all AVR processors.
  ***/
  address = address + 1;
  if (address == EEPROM.length()) {
    address = 0;
  }

  /***
    As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an
    EEPROM address is also doable by a bitwise and of the length - 1.

    ++address &amp;= EEPROM.length() - 1;
  ***/

  delay(100);
}
</code></pre>
<h4 id="fritzing-circuit_12"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_12"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_12">Video Demonstration</h4>
<h3 id="548-eeprom_write">5.4.8 eeprom_write</h3>
<h4 id="sketch-code_13">Sketch Code</h4>
<pre><code class="language-C">/*
  EEPROM Write

  Stores values read from analog input 0 into the EEPROM.
  These values will stay in the EEPROM when the board is
  turned off and may be retrieved later by another sketch.

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/eeprom
 */

// Include the EEPROM library
#include &lt;EEPROM.h&gt;

/** the current address in the EEPROM (i.e. which byte we're going to write to next) **/
int addr = 0;

void setup() {
  /** Empty setup. **/
}

void loop() {
  /***
    Need to divide by 4 because analog inputs range from
    0 to 1023 and each byte of the EEPROM can only hold a
    value from 0 to 255.
  ***/

  int val = analogRead(0) / 4;

  /***
    Write the value to the appropriate byte of the EEPROM.
    these values will remain there when the board is
    turned off.
  ***/

  EEPROM.write(addr, val);

  /***
    Advance to the next address, when at the end restart at the beginning.

    Larger AVR processors have larger EEPROM sizes, E.g:
    - Arduino Duemilanove: 512 B EEPROM storage.
    - Arduino Uno:         1 kB EEPROM storage.
    - Arduino Mega:        4 kB EEPROM storage.

    Rather than hard-coding the length, you should use the pre-provided length function.
    This will make your code portable to all AVR processors.
  ***/
  addr = addr + 1;
  if (addr == EEPROM.length()) {
    addr = 0;
  }

  /***
    As the EEPROM sizes are powers of two, wrapping (preventing overflow) of an
    EEPROM address is also doable by a bitwise and of the length - 1.

    ++addr &amp;= EEPROM.length() - 1;
  ***/


  delay(100);
}
</code></pre>
<h4 id="fritzing-circuit_13"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_13"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_13">Video Demonstration</h4>
<h2 id="section-55-ethernet">Section 5.5: Ethernet</h2>
<h3 id="551-advancedchatserver">5.5.1 AdvancedChatServer</h3>
<h4 id="sketch-code_14">Sketch Code</h4>
<pre><code class="language-C">/*
 Advanced Chat Server

 A more advanced server that distributes any incoming messages
 to all connected clients but the client the message comes from.
 To use, telnet to your device's IP address and type.
 You can see the client's input in the serial monitor as well.
 Using an Arduino WIZnet Ethernet shield.

 Circuit:
 * Ethernet shield attached to pins 10, 11, 12, 13

 created 18 Dec 2009
 by David A. Mellis
 modified 9 Apr 2012
 by Tom Igoe
 redesigned to make use of operator== 25 Nov 2013
 by Norbert Truchsess

 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network.
// gateway and subnet are optional:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};
IPAddress ip(192, 168, 1, 177);
IPAddress myDns(192, 168, 1, 1);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(255, 255, 0, 0);


// telnet defaults to port 23
EthernetServer server(23);

EthernetClient clients[8];

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // initialize the Ethernet device
  Ethernet.begin(mac, ip, myDns, gateway, subnet);

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // Check for Ethernet hardware present
  if (Ethernet.hardwareStatus() == EthernetNoHardware) {
    Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
    while (true) {
      delay(1); // do nothing, no point running without Ethernet hardware
    }
  }
  if (Ethernet.linkStatus() == LinkOFF) {
    Serial.println(&quot;Ethernet cable is not connected.&quot;);
  }

  // start listening for clients
  server.begin();

  Serial.print(&quot;Chat server address:&quot;);
  Serial.println(Ethernet.localIP());
}

void loop() {
  // check for any new client connecting, and say hello (before any incoming data)
  EthernetClient newClient = server.accept();
  if (newClient) {
    for (byte i=0; i &lt; 8; i++) {
      if (!clients[i]) {
        Serial.print(&quot;We have a new client #&quot;);
        Serial.println(i);
        newClient.print(&quot;Hello, client number: &quot;);
        newClient.println(i);
        // Once we &quot;accept&quot;, the client is no longer tracked by EthernetServer
        // so we must store it into our list of clients
        clients[i] = newClient;
        break;
      }
    }
  }

  // check for incoming data from all clients
  for (byte i=0; i &lt; 8; i++) {
    if (clients[i] &amp;&amp; clients[i].available() &gt; 0) {
      // read bytes from a client
      byte buffer[80];
      int count = clients[i].read(buffer, 80);
      // write the bytes to all other connected clients
      for (byte j=0; j &lt; 8; j++) {
        if (j != i &amp;&amp; clients[j].connected()) {
          clients[j].write(buffer, count);
        }
      }
    }
  }

  // stop any clients which disconnect
  for (byte i=0; i &lt; 8; i++) {
    if (clients[i] &amp;&amp; !clients[i].connected()) {
      Serial.print(&quot;disconnect client #&quot;);
      Serial.println(i);
      clients[i].stop();
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_14"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_14"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_14">Video Demonstration</h4>
<h3 id="552-barometricpressurewebserver">5.5.2 BarometricPressureWebServer</h3>
<h4 id="sketch-code_15">Sketch Code</h4>
<pre><code class="language-C">/*
 SCP1000 Barometric Pressure Sensor Display

 Serves the output of a Barometric Pressure Sensor as a web page.
 Uses the SPI library. For details on the sensor, see:
 http://www.sparkfun.com/commerce/product_info.php?products_id=8161

 This sketch adapted from Nathan Seidle's SCP1000 example for PIC:
 http://www.sparkfun.com/datasheets/Sensors/SCP1000-Testing.zip

 TODO: this hardware is long obsolete.  This example program should
 be rewritten to use https://www.sparkfun.com/products/9721

 Circuit:
 SCP1000 sensor attached to pins 6,7, and 11 - 13:
 DRDY: pin 6
 CSB: pin 7
 MOSI: pin 11
 MISO: pin 12
 SCK: pin 13

 created 31 July 2010
 by Tom Igoe
 */

#include &lt;Ethernet.h&gt;
// the sensor communicates using SPI, so include the library:
#include &lt;SPI.h&gt;


// assign a MAC address for the Ethernet controller.
// fill in your address here:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};
// assign an IP address for the controller:
IPAddress ip(192, 168, 1, 20);


// Initialize the Ethernet server library
// with the IP address and port you want to use
// (port 80 is default for HTTP):
EthernetServer server(80);


//Sensor's memory register addresses:
const int PRESSURE = 0x1F;      //3 most significant bits of pressure
const int PRESSURE_LSB = 0x20;  //16 least significant bits of pressure
const int TEMPERATURE = 0x21;   //16 bit temperature reading

// pins used for the connection with the sensor
// the others you need are controlled by the SPI library):
const int dataReadyPin = 6;
const int chipSelectPin = 7;

float temperature = 0.0;
long pressure = 0;
long lastReadingTime = 0;

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // start the SPI library:
  SPI.begin();

  // start the Ethernet connection
  Ethernet.begin(mac, ip);

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // Check for Ethernet hardware present
  if (Ethernet.hardwareStatus() == EthernetNoHardware) {
    Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
    while (true) {
      delay(1); // do nothing, no point running without Ethernet hardware
    }
  }
  if (Ethernet.linkStatus() == LinkOFF) {
    Serial.println(&quot;Ethernet cable is not connected.&quot;);
  }

  // start listening for clients
  server.begin();

  // initialize the data ready and chip select pins:
  pinMode(dataReadyPin, INPUT);
  pinMode(chipSelectPin, OUTPUT);

  //Configure SCP1000 for low noise configuration:
  writeRegister(0x02, 0x2D);
  writeRegister(0x01, 0x03);
  writeRegister(0x03, 0x02);

  // give the sensor and Ethernet shield time to set up:
  delay(1000);

  //Set the sensor to high resolution mode to start readings:
  writeRegister(0x03, 0x0A);

}

void loop() {
  // check for a reading no more than once a second.
  if (millis() - lastReadingTime &gt; 1000) {
    // if there's a reading ready, read it:
    // don't do anything until the data ready pin is high:
    if (digitalRead(dataReadyPin) == HIGH) {
      getData();
      // timestamp the last time you got a reading:
      lastReadingTime = millis();
    }
  }

  // listen for incoming Ethernet connections:
  listenForEthernetClients();
}


void getData() {
  Serial.println(&quot;Getting reading&quot;);
  //Read the temperature data
  int tempData = readRegister(0x21, 2);

  // convert the temperature to Celsius and display it:
  temperature = (float)tempData / 20.0;

  //Read the pressure data highest 3 bits:
  byte  pressureDataHigh = readRegister(0x1F, 1);
  pressureDataHigh &amp;= 0b00000111; //you only needs bits 2 to 0

  //Read the pressure data lower 16 bits:
  unsigned int pressureDataLow = readRegister(0x20, 2);
  //combine the two parts into one 19-bit number:
  pressure = ((pressureDataHigh &lt;&lt; 16) | pressureDataLow) / 4;

  Serial.print(&quot;Temperature: &quot;);
  Serial.print(temperature);
  Serial.println(&quot; degrees C&quot;);
  Serial.print(&quot;Pressure: &quot; + String(pressure));
  Serial.println(&quot; Pa&quot;);
}

void listenForEthernetClients() {
  // listen for incoming clients
  EthernetClient client = server.available();
  if (client) {
    Serial.println(&quot;Got a client&quot;);
    // an HTTP request ends with a blank line
    bool currentLineIsBlank = true;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        // if you've gotten to the end of the line (received a newline
        // character) and the line is blank, the HTTP request has ended,
        // so you can send a reply
        if (c == '\n' &amp;&amp; currentLineIsBlank) {
          // send a standard HTTP response header
          client.println(&quot;HTTP/1.1 200 OK&quot;);
          client.println(&quot;Content-Type: text/html&quot;);
          client.println();
          // print the current readings, in HTML format:
          client.print(&quot;Temperature: &quot;);
          client.print(temperature);
          client.print(&quot; degrees C&quot;);
          client.println(&quot;&lt;br /&gt;&quot;);
          client.print(&quot;Pressure: &quot; + String(pressure));
          client.print(&quot; Pa&quot;);
          client.println(&quot;&lt;br /&gt;&quot;);
          break;
        }
        if (c == '\n') {
          // you're starting a new line
          currentLineIsBlank = true;
        } else if (c != '\r') {
          // you've gotten a character on the current line
          currentLineIsBlank = false;
        }
      }
    }
    // give the web browser time to receive the data
    delay(1);
    // close the connection:
    client.stop();
  }
}


//Send a write command to SCP1000
void writeRegister(byte registerName, byte registerValue) {
  // SCP1000 expects the register name in the upper 6 bits
  // of the byte:
  registerName &lt;&lt;= 2;
  // command (read or write) goes in the lower two bits:
  registerName |= 0b00000010; //Write command

  // take the chip select low to select the device:
  digitalWrite(chipSelectPin, LOW);

  SPI.transfer(registerName); //Send register location
  SPI.transfer(registerValue); //Send value to record into register

  // take the chip select high to de-select:
  digitalWrite(chipSelectPin, HIGH);
}


//Read register from the SCP1000:
unsigned int readRegister(byte registerName, int numBytes) {
  byte inByte = 0;           // incoming from the SPI read
  unsigned int result = 0;   // result to return

  // SCP1000 expects the register name in the upper 6 bits
  // of the byte:
  registerName &lt;&lt;=  2;
  // command (read or write) goes in the lower two bits:
  registerName &amp;= 0b11111100; //Read command

  // take the chip select low to select the device:
  digitalWrite(chipSelectPin, LOW);
  // send the device the register you want to read:
  SPI.transfer(registerName);
  // send a value of 0 to read the first byte returned:
  inByte = SPI.transfer(0x00);

  result = inByte;
  // if there's more than one byte returned,
  // shift the first byte then get the second byte:
  if (numBytes &gt; 1) {
    result = inByte &lt;&lt; 8;
    inByte = SPI.transfer(0x00);
    result = result | inByte;
  }
  // take the chip select high to de-select:
  digitalWrite(chipSelectPin, HIGH);
  // return the result:
  return (result);
}
</code></pre>
<h4 id="fritzing-circuit_15"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_15"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_15">Video Demonstration</h4>
<h3 id="553-chatserver">5.5.3 ChatServer</h3>
<h4 id="sketch-code_16">Sketch Code</h4>
<pre><code class="language-C">/*
 Chat Server

 A simple server that distributes any incoming messages to all
 connected clients.  To use, telnet to your device's IP address and type.
 You can see the client's input in the serial monitor as well.
 Using an Arduino WIZnet Ethernet shield.

 Circuit:
 * Ethernet shield attached to pins 10, 11, 12, 13

 created 18 Dec 2009
 by David A. Mellis
 modified 9 Apr 2012
 by Tom Igoe

 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network.
// gateway and subnet are optional:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };
IPAddress ip(192, 168, 1, 177);
IPAddress myDns(192, 168, 1, 1);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(255, 255, 0, 0);


// telnet defaults to port 23
EthernetServer server(23);
bool alreadyConnected = false; // whether or not the client was connected previously

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // initialize the Ethernet device
  Ethernet.begin(mac, ip, myDns, gateway, subnet);

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
   while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // Check for Ethernet hardware present
  if (Ethernet.hardwareStatus() == EthernetNoHardware) {
    Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
    while (true) {
      delay(1); // do nothing, no point running without Ethernet hardware
    }
  }
  if (Ethernet.linkStatus() == LinkOFF) {
    Serial.println(&quot;Ethernet cable is not connected.&quot;);
  }

  // start listening for clients
  server.begin();

  Serial.print(&quot;Chat server address:&quot;);
  Serial.println(Ethernet.localIP());
}

void loop() {
  // wait for a new client:
  EthernetClient client = server.available();

  // when the client sends the first byte, say hello:
  if (client) {
    if (!alreadyConnected) {
      // clear out the input buffer:
      client.flush();
      Serial.println(&quot;We have a new client&quot;);
      client.println(&quot;Hello, client!&quot;);
      alreadyConnected = true;
    }

    if (client.available() &gt; 0) {
      // read the bytes incoming from the client:
      char thisChar = client.read();
      // echo the bytes back to the client:
      server.write(thisChar);
      // echo the bytes to the server as well:
      Serial.write(thisChar);
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_16"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_16"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_16">Video Demonstration</h4>
<h3 id="554-dhcpaddressprinter">5.5.4 DhcpAddressPrinter</h3>
<h4 id="sketch-code_17">Sketch Code</h4>
<pre><code class="language-C">/*
  DHCP-based IP printer

  This sketch uses the DHCP extensions to the Ethernet library
  to get an IP address via DHCP and print the address obtained.
  using an Arduino WIZnet Ethernet shield.

  Circuit:
   Ethernet shield attached to pins 10, 11, 12, 13

  created 12 April 2011
  modified 9 Apr 2012
  by Tom Igoe
  modified 02 Sept 2015
  by Arturo Guadalupi

 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// Enter a MAC address for your controller below.
// Newer Ethernet shields have a MAC address printed on a sticker on the shield
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // start the Ethernet connection:
  Serial.println(&quot;Initialize Ethernet with DHCP:&quot;);
  if (Ethernet.begin(mac) == 0) {
    Serial.println(&quot;Failed to configure Ethernet using DHCP&quot;);
    if (Ethernet.hardwareStatus() == EthernetNoHardware) {
      Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
    } else if (Ethernet.linkStatus() == LinkOFF) {
      Serial.println(&quot;Ethernet cable is not connected.&quot;);
    }
    // no point in carrying on, so do nothing forevermore:
    while (true) {
      delay(1);
    }
  }
  // print your local IP address:
  Serial.print(&quot;My IP address: &quot;);
  Serial.println(Ethernet.localIP());
}

void loop() {
  switch (Ethernet.maintain()) {
    case 1:
      //renewed fail
      Serial.println(&quot;Error: renewed fail&quot;);
      break;

    case 2:
      //renewed success
      Serial.println(&quot;Renewed success&quot;);
      //print your local IP address:
      Serial.print(&quot;My IP address: &quot;);
      Serial.println(Ethernet.localIP());
      break;

    case 3:
      //rebind fail
      Serial.println(&quot;Error: rebind fail&quot;);
      break;

    case 4:
      //rebind success
      Serial.println(&quot;Rebind success&quot;);
      //print your local IP address:
      Serial.print(&quot;My IP address: &quot;);
      Serial.println(Ethernet.localIP());
      break;

    default:
      //nothing happened
      break;
  }
}
</code></pre>
<h4 id="fritzing-circuit_17"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_17"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_17">Video Demonstration</h4>
<h3 id="555-dhcpchatserver">5.5.5 DhcpChatServer</h3>
<h4 id="sketch-code_18">Sketch Code</h4>
<pre><code class="language-C">/*
 DHCP Chat Server

 A simple server that distributes any incoming messages to all
 connected clients.  To use, telnet to your device's IP address and type.
 You can see the client's input in the serial monitor as well.
 Using an Arduino WIZnet Ethernet shield.

 THis version attempts to get an IP address using DHCP

 Circuit:
 * Ethernet shield attached to pins 10, 11, 12, 13

 created 21 May 2011
 modified 9 Apr 2012
 by Tom Igoe
 modified 02 Sept 2015
 by Arturo Guadalupi
 Based on ChatServer example by David A. Mellis

 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network.
// gateway and subnet are optional:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};
IPAddress ip(192, 168, 1, 177);
IPAddress myDns(192, 168, 1, 1);
IPAddress gateway(192, 168, 1, 1);
IPAddress subnet(255, 255, 0, 0);

// telnet defaults to port 23
EthernetServer server(23);
bool gotAMessage = false; // whether or not you got a message from the client yet

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // start the Ethernet connection:
  Serial.println(&quot;Trying to get an IP address using DHCP&quot;);
  if (Ethernet.begin(mac) == 0) {
    Serial.println(&quot;Failed to configure Ethernet using DHCP&quot;);
    // Check for Ethernet hardware present
    if (Ethernet.hardwareStatus() == EthernetNoHardware) {
      Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
      while (true) {
        delay(1); // do nothing, no point running without Ethernet hardware
      }
    }
    if (Ethernet.linkStatus() == LinkOFF) {
      Serial.println(&quot;Ethernet cable is not connected.&quot;);
    }
    // initialize the Ethernet device not using DHCP:
    Ethernet.begin(mac, ip, myDns, gateway, subnet);
  }
  // print your local IP address:
  Serial.print(&quot;My IP address: &quot;);
  Serial.println(Ethernet.localIP());

  // start listening for clients
  server.begin();
}

void loop() {
  // wait for a new client:
  EthernetClient client = server.available();

  // when the client sends the first byte, say hello:
  if (client) {
    if (!gotAMessage) {
      Serial.println(&quot;We have a new client&quot;);
      client.println(&quot;Hello, client!&quot;);
      gotAMessage = true;
    }

    // read the bytes incoming from the client:
    char thisChar = client.read();
    // echo the bytes back to the client:
    server.write(thisChar);
    // echo the bytes to the server as well:
    Serial.print(thisChar);
    Ethernet.maintain();
  }
}
</code></pre>
<h4 id="fritzing-circuit_18"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_18"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_18">Video Demonstration</h4>
<h3 id="556-linkstatus">5.5.6 LinkStatus</h3>
<h4 id="sketch-code_19">Sketch Code</h4>
<pre><code class="language-C">/*
  Link Status

  This sketch prints the Ethernet link status. When the
  Ethernet cable is connected the link status should go to &quot;ON&quot;.
  NOTE: Only WIZnet W5200 and W5500 are capable of reporting
  the link status. W5100 will report &quot;Unknown&quot;.
  Hardware:
   - Ethernet shield or equivalent board/shield with WIZnet W5200/W5500
  Written by Cristian Maglie
  This example is public domain.
*/

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  Serial.begin(9600);
}

void loop() {
  auto link = Ethernet.linkStatus();
  Serial.print(&quot;Link status: &quot;);
  switch (link) {
    case Unknown:
      Serial.println(&quot;Unknown&quot;);
      break;
    case LinkON:
      Serial.println(&quot;ON&quot;);
      break;
    case LinkOFF:
      Serial.println(&quot;OFF&quot;);
      break;
  }
  delay(1000);
}
</code></pre>
<h4 id="fritzing-circuit_19"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_19"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_19">Video Demonstration</h4>
<h3 id="557-pagerserver">5.5.7 PagerServer</h3>
<h4 id="sketch-code_20">Sketch Code</h4>
<pre><code class="language-C">/*
 Pager Server

 A simple server that echoes any incoming messages to all
 connected clients. Connect two or more telnet sessions
 to see how server.available() and server.print() works.

 created in September 2020 for the Ethernet library
 by Juraj Andrassy https://github.com/jandrassy

*/
#include &lt;Ethernet.h&gt;

// Enter a MAC address for your controller below.
// Newer Ethernet shields have a MAC address printed on a sticker on the shield
byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };

// Set the static IP address to use if the DHCP fails to assign
IPAddress ip(192, 168, 0, 177);

EthernetServer server(2323);

void setup() {

  Serial.begin(9600);
  while (!Serial);

  // start the Ethernet connection:
  Serial.println(&quot;Initialize Ethernet with DHCP:&quot;);
  if (Ethernet.begin(mac) == 0) {
    Serial.println(&quot;Failed to configure Ethernet using DHCP&quot;);
    // Check for Ethernet hardware present
    if (Ethernet.hardwareStatus() == EthernetNoHardware) {
      Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
      while (true) {
        delay(1); // do nothing, no point running without Ethernet hardware
      }
    }
    if (Ethernet.linkStatus() == LinkOFF) {
      Serial.println(&quot;Ethernet cable is not connected.&quot;);
    }
    // try to configure using IP address instead of DHCP:
    Ethernet.begin(mac, ip);
  } else {
    Serial.print(&quot;  DHCP assigned IP &quot;);
    Serial.println(Ethernet.localIP());
  }

  server.begin();

  IPAddress ip = Ethernet.localIP();
  Serial.println();
  Serial.print(&quot;To access the server, connect with Telnet client to &quot;);
  Serial.print(ip);
  Serial.println(&quot; 2323&quot;);
}

void loop() {

  EthernetClient client = server.available(); // returns first client which has data to read or a 'false' client
  if (client) { // client is true only if it is connected and has data to read
    String s = client.readStringUntil('\n'); // read the message incoming from one of the clients
    s.trim(); // trim eventual \r
    Serial.println(s); // print the message to Serial Monitor
    client.print(&quot;echo: &quot;); // this is only for the sending client
    server.println(s); // send the message to all connected clients
#ifndef ARDUINO_ARCH_SAM
    server.flush(); // flush the buffers
#endif /* !defined(ARDUINO_ARCH_SAM) */
  }
}
</code></pre>
<h4 id="fritzing-circuit_20"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_20"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_20">Video Demonstration</h4>
<h3 id="558-telnetclient">5.5.8 TelnetClient</h3>
<h4 id="sketch-code_21">Sketch Code</h4>
<pre><code class="language-C">/*
 Telnet client

 This sketch connects to a telnet server (http://www.google.com)
 using an Arduino WIZnet Ethernet shield.  You'll need a telnet server
 to test this with.
 Processing's ChatServer example (part of the Network library) works well,
 running on port 10002. It can be found as part of the examples
 in the Processing application, available at
 https://processing.org/

 Circuit:
 * Ethernet shield attached to pins 10, 11, 12, 13

 created 14 Sep 2010
 modified 9 Apr 2012
 by Tom Igoe
 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};
IPAddress ip(192, 168, 1, 177);

// Enter the IP address of the server you're connecting to:
IPAddress server(1, 1, 1, 1);

// Initialize the Ethernet client library
// with the IP address and port of the server
// that you want to connect to (port 23 is default for telnet;
// if you're using Processing's ChatServer, use port 10002):
EthernetClient client;

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // start the Ethernet connection:
  Ethernet.begin(mac, ip);

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // Check for Ethernet hardware present
  if (Ethernet.hardwareStatus() == EthernetNoHardware) {
    Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
    while (true) {
      delay(1); // do nothing, no point running without Ethernet hardware
    }
  }
  while (Ethernet.linkStatus() == LinkOFF) {
    Serial.println(&quot;Ethernet cable is not connected.&quot;);
    delay(500);
  }

  // give the Ethernet shield a second to initialize:
  delay(1000);
  Serial.println(&quot;connecting...&quot;);

  // if you get a connection, report back via serial:
  if (client.connect(server, 10002)) {
    Serial.println(&quot;connected&quot;);
  } else {
    // if you didn't get a connection to the server:
    Serial.println(&quot;connection failed&quot;);
  }
}

void loop() {
  // if there are incoming bytes available
  // from the server, read them and print them:
  if (client.available()) {
    char c = client.read();
    Serial.print(c);
  }

  // as long as there are bytes in the serial queue,
  // read them and send them out the socket if it's open:
  while (Serial.available() &gt; 0) {
    char inChar = Serial.read();
    if (client.connected()) {
      client.print(inChar);
    }
  }

  // if the server's disconnected, stop the client:
  if (!client.connected()) {
    Serial.println();
    Serial.println(&quot;disconnecting.&quot;);
    client.stop();
    // do nothing:
    while (true) {
      delay(1);
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_21"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_21"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_21">Video Demonstration</h4>
<h3 id="559-udpntpclient">5.5.9 UdpNtpClient</h3>
<h4 id="sketch-code_22">Sketch Code</h4>
<pre><code class="language-C">/*
 Udp NTP Client

 Get the time from a Network Time Protocol (NTP) time server
 Demonstrates use of UDP sendPacket and ReceivePacket
 For more on NTP time servers and the messages needed to communicate with them,
 see https://en.wikipedia.org/wiki/Network_Time_Protocol

 created 4 Sep 2010
 by Michael Margolis
 modified 9 Apr 2012
 by Tom Igoe
 modified 02 Sept 2015
 by Arturo Guadalupi

 This code is in the public domain.

 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;
#include &lt;EthernetUdp.h&gt;

// Enter a MAC address for your controller below.
// Newer Ethernet shields have a MAC address printed on a sticker on the shield
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};

unsigned int localPort = 8888;       // local port to listen for UDP packets

const char timeServer[] = &quot;time.nist.gov&quot;; // time.nist.gov NTP server

const int NTP_PACKET_SIZE = 48; // NTP time stamp is in the first 48 bytes of the message

byte packetBuffer[NTP_PACKET_SIZE]; //buffer to hold incoming and outgoing packets

// A UDP instance to let us send and receive packets over UDP
EthernetUDP Udp;

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // start Ethernet and UDP
  if (Ethernet.begin(mac) == 0) {
    Serial.println(&quot;Failed to configure Ethernet using DHCP&quot;);
    // Check for Ethernet hardware present
    if (Ethernet.hardwareStatus() == EthernetNoHardware) {
      Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
    } else if (Ethernet.linkStatus() == LinkOFF) {
      Serial.println(&quot;Ethernet cable is not connected.&quot;);
    }
    // no point in carrying on, so do nothing forevermore:
    while (true) {
      delay(1);
    }
  }
  Udp.begin(localPort);
}

void loop() {
  sendNTPpacket(timeServer); // send an NTP packet to a time server

  // wait to see if a reply is available
  delay(1000);
  if (Udp.parsePacket()) {
    // We've received a packet, read the data from it
    Udp.read(packetBuffer, NTP_PACKET_SIZE); // read the packet into the buffer

    // the timestamp starts at byte 40 of the received packet and is four bytes,
    // or two words, long. First, extract the two words:

    unsigned long highWord = word(packetBuffer[40], packetBuffer[41]);
    unsigned long lowWord = word(packetBuffer[42], packetBuffer[43]);
    // combine the four bytes (two words) into a long integer
    // this is NTP time (seconds since Jan 1 1900):
    unsigned long secsSince1900 = highWord &lt;&lt; 16 | lowWord;
    Serial.print(&quot;Seconds since Jan 1 1900 = &quot;);
    Serial.println(secsSince1900);

    // now convert NTP time into everyday time:
    Serial.print(&quot;Unix time = &quot;);
    // Unix time starts on Jan 1 1970. In seconds, that's 2208988800:
    const unsigned long seventyYears = 2208988800UL;
    // subtract seventy years:
    unsigned long epoch = secsSince1900 - seventyYears;
    // print Unix time:
    Serial.println(epoch);


    // print the hour, minute and second:
    Serial.print(&quot;The UTC time is &quot;);       // UTC is the time at Greenwich Meridian (GMT)
    Serial.print((epoch  % 86400L) / 3600); // print the hour (86400 equals secs per day)
    Serial.print(':');
    if (((epoch % 3600) / 60) &lt; 10) {
      // In the first 10 minutes of each hour, we'll want a leading '0'
      Serial.print('0');
    }
    Serial.print((epoch  % 3600) / 60); // print the minute (3600 equals secs per minute)
    Serial.print(':');
    if ((epoch % 60) &lt; 10) {
      // In the first 10 seconds of each minute, we'll want a leading '0'
      Serial.print('0');
    }
    Serial.println(epoch % 60); // print the second
  }
  // wait ten seconds before asking for the time again
  delay(10000);
  Ethernet.maintain();
}

// send an NTP request to the time server at the given address
void sendNTPpacket(const char * address) {
  // set all bytes in the buffer to 0
  memset(packetBuffer, 0, NTP_PACKET_SIZE);
  // Initialize values needed to form NTP request
  // (see URL above for details on the packets)
  packetBuffer[0] = 0b11100011;   // LI, Version, Mode
  packetBuffer[1] = 0;     // Stratum, or type of clock
  packetBuffer[2] = 6;     // Polling Interval
  packetBuffer[3] = 0xEC;  // Peer Clock Precision
  // 8 bytes of zero for Root Delay &amp; Root Dispersion
  packetBuffer[12]  = 49;
  packetBuffer[13]  = 0x4E;
  packetBuffer[14]  = 49;
  packetBuffer[15]  = 52;

  // all NTP fields have been given values, now
  // you can send a packet requesting a timestamp:
  Udp.beginPacket(address, 123); // NTP requests are to port 123
  Udp.write(packetBuffer, NTP_PACKET_SIZE);
  Udp.endPacket();
}
</code></pre>
<h4 id="fritzing-circuit_22"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_22"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_22">Video Demonstration</h4>
<h3 id="5510-udpsendreceivestring">5.5.10 UDPSendReceiveString</h3>
<h4 id="sketch-code_23">Sketch Code</h4>
<pre><code class="language-C">/*
 UDPSendReceiveString

 This sketch receives UDP message strings, prints them to the serial port
 and sends an &quot;acknowledge&quot; string back to the sender

 A Processing sketch is included at the end of file that can be used to send
 and receive messages for testing with a computer.

 created 21 Aug 2010
 by Michael Margolis

 This code is in the public domain.
 */


#include &lt;Ethernet.h&gt;
#include &lt;EthernetUdp.h&gt;

// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};
IPAddress ip(192, 168, 1, 177);

unsigned int localPort = 8888;      // local port to listen on

// buffers for receiving and sending data
char packetBuffer[UDP_TX_PACKET_MAX_SIZE];  // buffer to hold incoming packet,
char ReplyBuffer[] = &quot;acknowledged&quot;;        // a string to send back

// An EthernetUDP instance to let us send and receive packets over UDP
EthernetUDP Udp;

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // start the Ethernet
  Ethernet.begin(mac, ip);

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // Check for Ethernet hardware present
  if (Ethernet.hardwareStatus() == EthernetNoHardware) {
    Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
    while (true) {
      delay(1); // do nothing, no point running without Ethernet hardware
    }
  }
  if (Ethernet.linkStatus() == LinkOFF) {
    Serial.println(&quot;Ethernet cable is not connected.&quot;);
  }

  // start UDP
  Udp.begin(localPort);
}

void loop() {
  // if there's data available, read a packet
  int packetSize = Udp.parsePacket();
  if (packetSize) {
    Serial.print(&quot;Received packet of size &quot;);
    Serial.println(packetSize);
    Serial.print(&quot;From &quot;);
    IPAddress remote = Udp.remoteIP();
    for (int i=0; i &lt; 4; i++) {
      Serial.print(remote[i], DEC);
      if (i &lt; 3) {
        Serial.print(&quot;.&quot;);
      }
    }
    Serial.print(&quot;, port &quot;);
    Serial.println(Udp.remotePort());

    // read the packet into packetBuffer
    Udp.read(packetBuffer, UDP_TX_PACKET_MAX_SIZE);
    Serial.println(&quot;Contents:&quot;);
    Serial.println(packetBuffer);

    // send a reply to the IP address and port that sent us the packet we received
    Udp.beginPacket(Udp.remoteIP(), Udp.remotePort());
    Udp.write(ReplyBuffer);
    Udp.endPacket();
  }
  delay(10);
}


/*
  Processing sketch to run with this example
 =====================================================

 // Processing UDP example to send and receive string data from Arduino
 // press any key to send the &quot;Hello Arduino&quot; message


 import hypermedia.net.*;

 UDP udp;  // define the UDP object


 void setup() {
 udp = new UDP( this, 6000 );  // create a new datagram connection on port 6000
 //udp.log( true );         // &lt;-- printout the connection activity
 udp.listen( true );           // and wait for incoming message
 }

 void draw()
 {
 }

 void keyPressed() {
 String ip       = &quot;192.168.1.177&quot;; // the remote IP address
 int port        = 8888;        // the destination port

 udp.send(&quot;Hello World&quot;, ip, port );   // the message to send

 }

 void receive( byte[] data ) {          // &lt;-- default handler
 //void receive( byte[] data, String ip, int port ) {   // &lt;-- extended handler

 for(int i=0; i &lt; data.length; i++)
 print(char(data[i]));
 println();
 }
 */
</code></pre>
<h4 id="fritzing-circuit_23"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_23"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_23">Video Demonstration</h4>
<h3 id="5511-webclient">5.5.11 WebClient</h3>
<h4 id="sketch-code_24">Sketch Code</h4>
<pre><code class="language-C">/*
 Web client

 This sketch connects to a website (http://www.google.com)
 using an Arduino WIZnet Ethernet shield.

 Circuit:
 * Ethernet shield attached to pins 10, 11, 12, 13

 created 18 Dec 2009
 by David A. Mellis
 modified 9 Apr 2012
 by Tom Igoe, based on work by Adrian McEwen

 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// Enter a MAC address for your controller below.
// Newer Ethernet shields have a MAC address printed on a sticker on the shield
byte mac[] = { 0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED };

// if you don't want to use DNS (and reduce your sketch size)
// use the numeric IP instead of the name for the server:
//IPAddress server(74,125,232,128);  // numeric IP for Google (no DNS)
char server[] = &quot;www.google.com&quot;;    // name address for Google (using DNS)

// Set the static IP address to use if the DHCP fails to assign
IPAddress ip(192, 168, 0, 177);
IPAddress myDns(192, 168, 0, 1);

// Initialize the Ethernet client library
// with the IP address and port of the server
// that you want to connect to (port 80 is default for HTTP):
EthernetClient client;

// Variables to measure the speed
unsigned long beginMicros, endMicros;
unsigned long byteCount = 0;
bool printWebData = true;  // set to false for better speed measurement

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // start the Ethernet connection:
  Serial.println(&quot;Initialize Ethernet with DHCP:&quot;);
  if (Ethernet.begin(mac) == 0) {
    Serial.println(&quot;Failed to configure Ethernet using DHCP&quot;);
    // Check for Ethernet hardware present
    if (Ethernet.hardwareStatus() == EthernetNoHardware) {
      Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
      while (true) {
        delay(1); // do nothing, no point running without Ethernet hardware
      }
    }
    if (Ethernet.linkStatus() == LinkOFF) {
      Serial.println(&quot;Ethernet cable is not connected.&quot;);
    }
    // try to configure using IP address instead of DHCP:
    Ethernet.begin(mac, ip, myDns);
  } else {
    Serial.print(&quot;  DHCP assigned IP &quot;);
    Serial.println(Ethernet.localIP());
  }
  // give the Ethernet shield a second to initialize:
  delay(1000);
  Serial.print(&quot;connecting to &quot;);
  Serial.print(server);
  Serial.println(&quot;...&quot;);

  // if you get a connection, report back via serial:
  if (client.connect(server, 80)) {
    Serial.print(&quot;connected to &quot;);
    Serial.println(client.remoteIP());
    // Make a HTTP request:
    client.println(&quot;GET /search?q=arduino HTTP/1.1&quot;);
    client.println(&quot;Host: www.google.com&quot;);
    client.println(&quot;Connection: close&quot;);
    client.println();
  } else {
    // if you didn't get a connection to the server:
    Serial.println(&quot;connection failed&quot;);
  }
  beginMicros = micros();
}

void loop() {
  // if there are incoming bytes available
  // from the server, read them and print them:
  int len = client.available();
  if (len &gt; 0) {
    byte buffer[80];
    if (len &gt; 80) len = 80;
    client.read(buffer, len);
    if (printWebData) {
      Serial.write(buffer, len); // show in the serial monitor (slows some boards)
    }
    byteCount = byteCount + len;
  }

  // if the server's disconnected, stop the client:
  if (!client.connected()) {
    endMicros = micros();
    Serial.println();
    Serial.println(&quot;disconnecting.&quot;);
    client.stop();
    Serial.print(&quot;Received &quot;);
    Serial.print(byteCount);
    Serial.print(&quot; bytes in &quot;);
    float seconds = (float)(endMicros - beginMicros) / 1000000.0;
    Serial.print(seconds, 4);
    float rate = (float)byteCount / seconds / 1000.0;
    Serial.print(&quot;, rate = &quot;);
    Serial.print(rate);
    Serial.print(&quot; kbytes/second&quot;);
    Serial.println();

    // do nothing forevermore:
    while (true) {
      delay(1);
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_24"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_24"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_24">Video Demonstration</h4>
<h3 id="5512-webclientrepeating">5.5.12 WebClientRepeating</h3>
<h4 id="sketch-code_25">Sketch Code</h4>
<pre><code class="language-C">/*
 Repeating Web client

 This sketch connects to a web server and makes a request
 using a WIZnet Ethernet shield. You can use the Arduino Ethernet Shield, or
 the Adafruit Ethernet shield, either one will work, as long as it's got
 a WIZnet Ethernet module on board.

 This example uses DNS, by assigning the Ethernet client with a MAC address,
 IP address, and DNS address.

 Circuit:
 * Ethernet shield attached to pins 10, 11, 12, 13

 created 19 Apr 2012
 by Tom Igoe
 modified 21 Jan 2014
 by Federico Vanzati

 https://www.arduino.cc/en/Tutorial/WebClientRepeating
 This code is in the public domain.

 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// assign a MAC address for the Ethernet controller.
// fill in your address here:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};
// Set the static IP address to use if the DHCP fails to assign
IPAddress ip(192, 168, 0, 177);
IPAddress myDns(192, 168, 0, 1);

// initialize the library instance:
EthernetClient client;

char server[] = &quot;www.arduino.cc&quot;;  // also change the Host line in httpRequest()
//IPAddress server(64,131,82,241);

unsigned long lastConnectionTime = 0;           // last time you connected to the server, in milliseconds
const unsigned long postingInterval = 10*1000;  // delay between updates, in milliseconds

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // start serial port:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // start the Ethernet connection:
  Serial.println(&quot;Initialize Ethernet with DHCP:&quot;);
  if (Ethernet.begin(mac) == 0) {
    Serial.println(&quot;Failed to configure Ethernet using DHCP&quot;);
    // Check for Ethernet hardware present
    if (Ethernet.hardwareStatus() == EthernetNoHardware) {
      Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
      while (true) {
        delay(1); // do nothing, no point running without Ethernet hardware
      }
    }
    if (Ethernet.linkStatus() == LinkOFF) {
      Serial.println(&quot;Ethernet cable is not connected.&quot;);
    }
    // try to configure using IP address instead of DHCP:
    Ethernet.begin(mac, ip, myDns);
    Serial.print(&quot;My IP address: &quot;);
    Serial.println(Ethernet.localIP());
  } else {
    Serial.print(&quot;  DHCP assigned IP &quot;);
    Serial.println(Ethernet.localIP());
  }
  // give the Ethernet shield a second to initialize:
  delay(1000);
}

void loop() {
  // if there's incoming data from the net connection.
  // send it out the serial port.  This is for debugging
  // purposes only:
  if (client.available()) {
    char c = client.read();
    Serial.write(c);
  }

  // if ten seconds have passed since your last connection,
  // then connect again and send data:
  if (millis() - lastConnectionTime &gt; postingInterval) {
    httpRequest();
  }

}

// this method makes a HTTP connection to the server:
void httpRequest() {
  // close any connection before send a new request.
  // This will free the socket on the Ethernet shield
  client.stop();

  // if there's a successful connection:
  if (client.connect(server, 80)) {
    Serial.println(&quot;connecting...&quot;);
    // send the HTTP GET request:
    client.println(&quot;GET /latest.txt HTTP/1.1&quot;);
    client.println(&quot;Host: www.arduino.cc&quot;);
    client.println(&quot;User-Agent: arduino-ethernet&quot;);
    client.println(&quot;Connection: close&quot;);
    client.println();

    // note the time that the connection was made:
    lastConnectionTime = millis();
  } else {
    // if you couldn't make a connection:
    Serial.println(&quot;connection failed&quot;);
  }
}
</code></pre>
<h4 id="fritzing-circuit_25"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_25"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_25">Video Demonstration</h4>
<h3 id="5513-webserver">5.5.13 WebServer</h3>
<h4 id="sketch-code_26">Sketch Code</h4>
<pre><code class="language-C">/*
 Web Server

 A simple web server that shows the value of the analog input pins.
 using an Arduino WIZnet Ethernet shield.

 Circuit:
 * Ethernet shield attached to pins 10, 11, 12, 13
 * Analog inputs attached to pins A0 through A5 (optional)

 created 18 Dec 2009
 by David A. Mellis
 modified 9 Apr 2012
 by Tom Igoe
 modified 02 Sept 2015
 by Arturo Guadalupi

 */

#include &lt;SPI.h&gt;
#include &lt;Ethernet.h&gt;

// Enter a MAC address and IP address for your controller below.
// The IP address will be dependent on your local network:
byte mac[] = {
  0xDE, 0xAD, 0xBE, 0xEF, 0xFE, 0xED
};
IPAddress ip(192, 168, 1, 177);

// Initialize the Ethernet server library
// with the IP address and port you want to use
// (port 80 is default for HTTP):
EthernetServer server(80);

void setup() {
  // You can use Ethernet.init(pin) to configure the CS pin
  //Ethernet.init(10);  // Most Arduino shields
  //Ethernet.init(5);   // MKR ETH Shield
  //Ethernet.init(0);   // Teensy 2.0
  //Ethernet.init(20);  // Teensy++ 2.0
  //Ethernet.init(15);  // ESP8266 with Adafruit FeatherWing Ethernet
  //Ethernet.init(33);  // ESP32 with Adafruit FeatherWing Ethernet

  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
  Serial.println(&quot;Ethernet WebServer Example&quot;);

  // start the Ethernet connection and the server:
  Ethernet.begin(mac, ip);

  // Check for Ethernet hardware present
  if (Ethernet.hardwareStatus() == EthernetNoHardware) {
    Serial.println(&quot;Ethernet shield was not found.  Sorry, can't run without hardware. :(&quot;);
    while (true) {
      delay(1); // do nothing, no point running without Ethernet hardware
    }
  }
  if (Ethernet.linkStatus() == LinkOFF) {
    Serial.println(&quot;Ethernet cable is not connected.&quot;);
  }

  // start the server
  server.begin();
  Serial.print(&quot;server is at &quot;);
  Serial.println(Ethernet.localIP());
}


void loop() {
  // listen for incoming clients
  EthernetClient client = server.available();
  if (client) {
    Serial.println(&quot;new client&quot;);
    // an HTTP request ends with a blank line
    bool currentLineIsBlank = true;
    while (client.connected()) {
      if (client.available()) {
        char c = client.read();
        Serial.write(c);
        // if you've gotten to the end of the line (received a newline
        // character) and the line is blank, the HTTP request has ended,
        // so you can send a reply
        if (c == '\n' &amp;&amp; currentLineIsBlank) {
          // send a standard HTTP response header
          client.println(&quot;HTTP/1.1 200 OK&quot;);
          client.println(&quot;Content-Type: text/html&quot;);
          client.println(&quot;Connection: close&quot;);  // the connection will be closed after completion of the response
          client.println(&quot;Refresh: 5&quot;);  // refresh the page automatically every 5 sec
          client.println();
          client.println(&quot;&lt;!DOCTYPE HTML&gt;&quot;);
          client.println(&quot;&lt;html&gt;&quot;);
          // output the value of each analog input pin
          for (int analogChannel = 0; analogChannel &lt; 6; analogChannel++) {
            int sensorReading = analogRead(analogChannel);
            client.print(&quot;analog input &quot;);
            client.print(analogChannel);
            client.print(&quot; is &quot;);
            client.print(sensorReading);
            client.println(&quot;&lt;br /&gt;&quot;);
          }
          client.println(&quot;&lt;/html&gt;&quot;);
          break;
        }
        if (c == '\n') {
          // you're starting a new line
          currentLineIsBlank = true;
        } else if (c != '\r') {
          // you've gotten a character on the current line
          currentLineIsBlank = false;
        }
      }
    }
    // give the web browser time to receive the data
    delay(1);
    // close the connection:
    client.stop();
    Serial.println(&quot;client disconnected&quot;);
  }
}
</code></pre>
<h4 id="fritzing-circuit_26"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_26"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_26">Video Demonstration</h4>
<h2 id="section-56-firmata">Section 5.6: Firmata</h2>
<h3 id="561-allinputsfirmata">5.6.1 AllInputsFirmata</h3>
<h4 id="sketch-code_27">Sketch Code</h4>
<pre><code class="language-C">/*
 * Firmata is a generic protocol for communicating with microcontrollers
 * from software on a host computer. It is intended to work with
 * any host computer software package.
 *
 * To download a host software package, please click on the following link
 * to open the list of Firmata client libraries in your default browser.
 *
 * https://github.com/firmata/arduino#firmata-client-libraries
 */

/*
 * This firmware reads all inputs and sends them as fast as it can.  It was
 * inspired by the ease-of-use of the Arduino2Max program.
 *
 * This example code is in the public domain.
 */
#include &lt;Firmata.h&gt;

byte pin;

int analogValue;
int previousAnalogValues[TOTAL_ANALOG_PINS];

byte portStatus[TOTAL_PORTS]; // each bit: 1=pin is digital input, 0=other/ignore
byte previousPINs[TOTAL_PORTS];

/* timer variables */
unsigned long currentMillis;     // store the current value from millis()
unsigned long previousMillis;    // for comparison with currentMillis
/* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you
   get long, random delays.  So only read analogs every 20ms or so */
int samplingInterval = 19;      // how often to run the main loop (in ms)

void sendPort(byte portNumber, byte portValue)
{
  portValue = portValue &amp; portStatus[portNumber];
  if (previousPINs[portNumber] != portValue) {
    Firmata.sendDigitalPort(portNumber, portValue);
    previousPINs[portNumber] = portValue;
  }
}

void setup()
{
  byte i, port, status;

  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);

  for (pin = 0; pin &lt; TOTAL_PINS; pin++) {
    if IS_PIN_DIGITAL(pin) pinMode(PIN_TO_DIGITAL(pin), INPUT);
  }

  for (port = 0; port &lt; TOTAL_PORTS; port++) {
    status = 0;
    for (i = 0; i &lt; 8; i++) {
      if (IS_PIN_DIGITAL(port * 8 + i)) status |= (1 &lt;&lt; i);
    }
    portStatus[port] = status;
  }

  Firmata.begin(57600);
}

void loop()
{
  byte i;

  for (i = 0; i &lt; TOTAL_PORTS; i++) {
    sendPort(i, readPort(i, 0xff));
  }
  /* make sure that the FTDI buffer doesn't go over 60 bytes, otherwise you
     get long, random delays.  So only read analogs every 20ms or so */
  currentMillis = millis();
  if (currentMillis - previousMillis &gt; samplingInterval) {
    previousMillis += samplingInterval;
    while (Firmata.available()) {
      Firmata.processInput();
    }
    for (pin = 0; pin &lt; TOTAL_ANALOG_PINS; pin++) {
      analogValue = analogRead(pin);
      if (analogValue != previousAnalogValues[pin]) {
        Firmata.sendAnalog(pin, analogValue);
        previousAnalogValues[pin] = analogValue;
      }
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_27"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_27"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_27">Video Demonstration</h4>
<h3 id="562-analogfirmata">5.6.2 AnalogFirmata</h3>
<h4 id="sketch-code_28">Sketch Code</h4>
<pre><code class="language-C">/*
 * Firmata is a generic protocol for communicating with microcontrollers
 * from software on a host computer. It is intended to work with
 * any host computer software package.
 *
 * To download a host software package, please click on the following link
 * to open the list of Firmata client libraries in your default browser.
 *
 * https://github.com/firmata/arduino#firmata-client-libraries
 */

/* This firmware supports as many analog ports as possible, all analog inputs,
 * four PWM outputs, and two with servo support.
 *
 * This example code is in the public domain.
 */
#include &lt;Servo.h&gt;
#include &lt;Firmata.h&gt;

/*==============================================================================
 * GLOBAL VARIABLES
 *============================================================================*/

/* servos */
Servo servo9, servo10; // one instance per pin
/* analog inputs */
int analogInputsToReport = 0; // bitwise array to store pin reporting
int analogPin = 0; // counter for reading analog pins
/* timer variables */
unsigned long currentMillis;     // store the current value from millis()
unsigned long previousMillis;    // for comparison with currentMillis


/*==============================================================================
 * FUNCTIONS
 *============================================================================*/

void analogWriteCallback(byte pin, int value)
{
  switch (pin) {
    case 9: servo9.write(value); break;
    case 10: servo10.write(value); break;
    case 3:
    case 5:
    case 6:
    case 11: // PWM pins
      analogWrite(pin, value);
      break;
  }
}
// -----------------------------------------------------------------------------
// sets bits in a bit array (int) to toggle the reporting of the analogIns
void reportAnalogCallback(byte pin, int value)
{
  if (value == 0) {
    analogInputsToReport = analogInputsToReport &amp; ~ (1 &lt;&lt; pin);
  }
  else { // everything but 0 enables reporting of that pin
    analogInputsToReport = analogInputsToReport | (1 &lt;&lt; pin);
  }
  // TODO: save status to EEPROM here, if changed
}

/*==============================================================================
 * SETUP()
 *============================================================================*/
void setup()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);
  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);

  servo9.attach(9);
  servo10.attach(10);
  Firmata.begin(57600);
}

/*==============================================================================
 * LOOP()
 *============================================================================*/
void loop()
{
  while (Firmata.available())
    Firmata.processInput();
  currentMillis = millis();
  if (currentMillis - previousMillis &gt; 20) {
    previousMillis += 20;                   // run this every 20ms
    for (analogPin = 0; analogPin &lt; TOTAL_ANALOG_PINS; analogPin++) {
      if ( analogInputsToReport &amp; (1 &lt;&lt; analogPin) )
        Firmata.sendAnalog(analogPin, analogRead(analogPin));
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_28"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_28"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_28">Video Demonstration</h4>
<h3 id="563-echostring">5.6.3 EchoString</h3>
<h4 id="sketch-code_29">Sketch Code</h4>
<pre><code class="language-C">/*
 * Firmata is a generic protocol for communicating with microcontrollers
 * from software on a host computer. It is intended to work with
 * any host computer software package.
 *
 * To download a host software package, please click on the following link
 * to open the list of Firmata client libraries in your default browser.
 *
 * https://github.com/firmata/arduino#firmata-client-libraries
 */

/* This sketch accepts strings and raw sysex messages and echos them back.
 *
 * This example code is in the public domain.
 */
#include &lt;Firmata.h&gt;

void stringCallback(char *myString)
{
  Firmata.sendString(myString);
}


void sysexCallback(byte command, byte argc, byte *argv)
{
  Firmata.sendSysex(command, argc, argv);
}

void setup()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);
  Firmata.attach(STRING_DATA, stringCallback);
  Firmata.attach(START_SYSEX, sysexCallback);
  Firmata.begin(57600);
}

void loop()
{
  while (Firmata.available()) {
    Firmata.processInput();
  }
}
</code></pre>
<h4 id="fritzing-circuit_29"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_29"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_29">Video Demonstration</h4>
<h3 id="564-oldstandardfirmata">5.6.4 OldStandardFirmata</h3>
<h4 id="sketch-code_30">Sketch Code</h4>
<pre><code class="language-C">/*
 * Firmata is a generic protocol for communicating with microcontrollers
 * from software on a host computer. It is intended to work with
 * any host computer software package.
 *
 * To download a host software package, please click on the following link
 * to open the list of Firmata client libraries in your default browser.
 *
 * https://github.com/firmata/arduino#firmata-client-libraries
 */

/*
  Copyright (C) 2006-2008 Hans-Christoph Steiner.  All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  See file LICENSE.txt for further informations on licensing terms.
 */

/*
 * This is an old version of StandardFirmata (v2.0).  It is kept here because
 * its the last version that works on an ATMEGA8 chip.  Also, it can be used
 * for host software that has not been updated to a newer version of the
 * protocol.  It also uses the old baud rate of 115200 rather than 57600.
 */

#include &lt;EEPROM.h&gt;
#include &lt;Firmata.h&gt;

/*==============================================================================
 * GLOBAL VARIABLES
 *============================================================================*/

/* analog inputs */
int analogInputsToReport = 0; // bitwise array to store pin reporting
int analogPin = 0; // counter for reading analog pins

/* digital pins */
byte reportPINs[TOTAL_PORTS];   // PIN == input port
byte previousPINs[TOTAL_PORTS]; // PIN == input port
byte pinStatus[TOTAL_PINS]; // store pin status, default OUTPUT
byte portStatus[TOTAL_PORTS];

/* timer variables */
unsigned long currentMillis;     // store the current value from millis()
unsigned long previousMillis;    // for comparison with currentMillis


/*==============================================================================
 * FUNCTIONS
 *============================================================================*/

void outputPort(byte portNumber, byte portValue)
{
  portValue = portValue &amp; ~ portStatus[portNumber];
  if (previousPINs[portNumber] != portValue) {
    Firmata.sendDigitalPort(portNumber, portValue);
    previousPINs[portNumber] = portValue;
    Firmata.sendDigitalPort(portNumber, portValue);
  }
}

/* -----------------------------------------------------------------------------
 * check all the active digital inputs for change of state, then add any events
 * to the Serial output queue using Serial.print() */
void checkDigitalInputs(void)
{
  byte i, tmp;
  for (i = 0; i &lt; TOTAL_PORTS; i++) {
    if (reportPINs[i]) {
      switch (i) {
        case 0: outputPort(0, PIND &amp; ~ B00000011); break; // ignore Rx/Tx 0/1
        case 1: outputPort(1, PINB); break;
        case 2: outputPort(2, PINC); break;
      }
    }
  }
}

// -----------------------------------------------------------------------------
/* sets the pin mode to the correct state and sets the relevant bits in the
 * two bit-arrays that track Digital I/O and PWM status
 */
void setPinModeCallback(byte pin, int mode) {
  byte port = 0;
  byte offset = 0;

  if (pin &lt; 8) {
    port = 0;
    offset = 0;
  } else if (pin &lt; 14) {
    port = 1;
    offset = 8;
  } else if (pin &lt; 22) {
    port = 2;
    offset = 14;
  }

  if (pin &gt; 1) { // ignore RxTx (pins 0 and 1)
    pinStatus[pin] = mode;
    switch (mode) {
      case INPUT:
        pinMode(pin, INPUT);
        portStatus[port] = portStatus[port] &amp; ~ (1 &lt;&lt; (pin - offset));
        break;
      case OUTPUT:
        digitalWrite(pin, LOW); // disable PWM
      case PWM:
        pinMode(pin, OUTPUT);
        portStatus[port] = portStatus[port] | (1 &lt;&lt; (pin - offset));
        break;
      //case ANALOG: // TODO figure this out
      default:
        Firmata.sendString(&quot;&quot;);
    }
    // TODO: save status to EEPROM here, if changed
  }
}

void analogWriteCallback(byte pin, int value)
{
  setPinModeCallback(pin, PIN_MODE_PWM);
  analogWrite(pin, value);
}

void digitalWriteCallback(byte port, int value)
{
  switch (port) {
    case 0: // pins 2-7 (don't change Rx/Tx, pins 0 and 1)
      // 0xFF03 == B1111111100000011    0x03 == B00000011
      PORTD = (value &amp; ~ 0xFF03) | (PORTD &amp; 0x03);
      break;
    case 1: // pins 8-13 (14,15 are disabled for the crystal)
      PORTB = (byte)value;
      break;
    case 2: // analog pins used as digital
      PORTC = (byte)value;
      break;
  }
}

// -----------------------------------------------------------------------------
/* sets bits in a bit array (int) to toggle the reporting of the analogIns
 */
//void FirmataClass::setAnalogPinReporting(byte pin, byte state) {
//}
void reportAnalogCallback(byte pin, int value)
{
  if (value == 0) {
    analogInputsToReport = analogInputsToReport &amp; ~ (1 &lt;&lt; pin);
  }
  else { // everything but 0 enables reporting of that pin
    analogInputsToReport = analogInputsToReport | (1 &lt;&lt; pin);
  }
  // TODO: save status to EEPROM here, if changed
}

void reportDigitalCallback(byte port, int value)
{
  reportPINs[port] = (byte)value;
  if (port == 2) // turn off analog reporting when used as digital
    analogInputsToReport = 0;
}

/*==============================================================================
 * SETUP()
 *============================================================================*/
void setup()
{
  byte i;

  Firmata.setFirmwareVersion(2, 0);

  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);
  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);
  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);
  Firmata.attach(SET_PIN_MODE, setPinModeCallback);

  portStatus[0] = B00000011;  // ignore Tx/RX pins
  portStatus[1] = B11000000;  // ignore 14/15 pins
  portStatus[2] = B00000000;

  //    for(i=0; i&lt;TOTAL_PINS; ++i) { // TODO make this work with analogs
  for (i = 0; i &lt; 14; ++i) {
    setPinModeCallback(i, OUTPUT);
  }
  // set all outputs to 0 to make sure internal pull-up resistors are off
  PORTB = 0; // pins 8-15
  PORTC = 0; // analog port
  PORTD = 0; // pins 0-7

  // TODO rethink the init, perhaps it should report analog on default
  for (i = 0; i &lt; TOTAL_PORTS; ++i) {
    reportPINs[i] = false;
  }
  // TODO: load state from EEPROM here

  /* send digital inputs here, if enabled, to set the initial state on the
   * host computer, since once in the loop(), this firmware will only send
   * digital data on change. */
  if (reportPINs[0]) outputPort(0, PIND &amp; ~ B00000011); // ignore Rx/Tx 0/1
  if (reportPINs[1]) outputPort(1, PINB);
  if (reportPINs[2]) outputPort(2, PINC);

  Firmata.begin(115200);
}

/*==============================================================================
 * LOOP()
 *============================================================================*/
void loop()
{
  /* DIGITALREAD - as fast as possible, check for changes and output them to the
   * FTDI buffer using Serial.print()  */
  checkDigitalInputs();
  currentMillis = millis();
  if (currentMillis - previousMillis &gt; 20) {
    previousMillis += 20;     // run this every 20ms
    /* SERIALREAD - Serial.read() uses a 128 byte circular buffer, so handle
     * all serialReads at once, i.e. empty the buffer */
    while (Firmata.available())
      Firmata.processInput();
    /* SEND FTDI WRITE BUFFER - make sure that the FTDI buffer doesn't go over
     * 60 bytes. use a timer to sending an event character every 4 ms to
     * trigger the buffer to dump. */

    /* ANALOGREAD - right after the event character, do all of the
     * analogReads().  These only need to be done every 4ms. */
    for (analogPin = 0; analogPin &lt; TOTAL_ANALOG_PINS; analogPin++) {
      if ( analogInputsToReport &amp; (1 &lt;&lt; analogPin) ) {
        Firmata.sendAnalog(analogPin, analogRead(analogPin));
      }
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_30"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_30"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_30">Video Demonstration</h4>
<h3 id="565-servofirmata">5.6.5 ServoFirmata</h3>
<h4 id="sketch-code_31">Sketch Code</h4>
<pre><code class="language-C">/*
 * Firmata is a generic protocol for communicating with microcontrollers
 * from software on a host computer. It is intended to work with
 * any host computer software package.
 *
 * To download a host software package, please click on the following link
 * to open the list of Firmata client libraries in your default browser.
 *
 * https://github.com/firmata/arduino#firmata-client-libraries
 */

/* This firmware supports as many servos as possible using the Servo library
 * included in Arduino 0017
 *
 * This example code is in the public domain.
 */

#include &lt;Servo.h&gt;
#include &lt;Firmata.h&gt;

Servo servos[MAX_SERVOS];
byte servoPinMap[TOTAL_PINS];
byte servoCount = 0;

void analogWriteCallback(byte pin, int value)
{
  if (IS_PIN_DIGITAL(pin)) {
    servos[servoPinMap[pin]].write(value);
  }
}

void systemResetCallback()
{
  servoCount = 0;
}

void setup()
{
  byte pin;

  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);
  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.attach(SYSTEM_RESET, systemResetCallback);

  Firmata.begin(57600);
  systemResetCallback();

  // attach servos from first digital pin up to max number of
  // servos supported for the board
  for (pin = 0; pin &lt; TOTAL_PINS; pin++) {
    if (IS_PIN_DIGITAL(pin)) {
      if (servoCount &lt; MAX_SERVOS) {
        servoPinMap[pin] = servoCount;
        servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin));
        servoCount++;
      }
    }
  }
}

void loop()
{
  while (Firmata.available())
    Firmata.processInput();
}
</code></pre>
<h4 id="fritzing-circuit_31"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_31"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_31">Video Demonstration</h4>
<h3 id="566-simpleanalogfirmata">5.6.6 SimpleAnalogFirmata</h3>
<h4 id="sketch-code_32">Sketch Code</h4>
<pre><code class="language-C">/*
 * Firmata is a generic protocol for communicating with microcontrollers
 * from software on a host computer. It is intended to work with
 * any host computer software package.
 *
 * To download a host software package, please click on the following link
 * to open the list of Firmata client libraries in your default browser.
 *
 * https://github.com/firmata/arduino#firmata-client-libraries
 */

/* Supports as many analog inputs and analog PWM outputs as possible.
 *
 * This example code is in the public domain.
 */
#include &lt;Firmata.h&gt;

byte analogPin = 0;

void analogWriteCallback(byte pin, int value)
{
  if (IS_PIN_PWM(pin)) {
    pinMode(PIN_TO_DIGITAL(pin), OUTPUT);
    analogWrite(PIN_TO_PWM(pin), value);
  }
}

void setup()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);
  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.begin(57600);
}

void loop()
{
  while (Firmata.available()) {
    Firmata.processInput();
  }
  // do one analogRead per loop, so if PC is sending a lot of
  // analog write messages, we will only delay 1 analogRead
  Firmata.sendAnalog(analogPin, analogRead(analogPin));
  analogPin = analogPin + 1;
  if (analogPin &gt;= TOTAL_ANALOG_PINS) analogPin = 0;
}
</code></pre>
<h4 id="fritzing-circuit_32"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_32"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_32">Video Demonstration</h4>
<h3 id="567-simpledigitalfirmata">5.6.7 SimpleDigitalFirmata</h3>
<h4 id="sketch-code_33">Sketch Code</h4>
<pre><code class="language-C">/*
 * Firmata is a generic protocol for communicating with microcontrollers
 * from software on a host computer. It is intended to work with
 * any host computer software package.
 *
 * To download a host software package, please click on the following link
 * to open the list of Firmata client libraries in your default browser.
 *
 * https://github.com/firmata/arduino#firmata-client-libraries
 */

/* Supports as many digital inputs and outputs as possible.
 *
 * This example code is in the public domain.
 */
#include &lt;Firmata.h&gt;

byte previousPIN[TOTAL_PORTS];  // PIN means PORT for input
byte previousPORT[TOTAL_PORTS];

void outputPort(byte portNumber, byte portValue)
{
  // only send the data when it changes, otherwise you get too many messages!
  if (previousPIN[portNumber] != portValue) {
    Firmata.sendDigitalPort(portNumber, portValue);
    previousPIN[portNumber] = portValue;
  }
}

void setPinModeCallback(byte pin, int mode) {
  if (IS_PIN_DIGITAL(pin)) {
    pinMode(PIN_TO_DIGITAL(pin), mode);
  }
}

void digitalWriteCallback(byte port, int value)
{
  byte i;
  byte currentPinValue, previousPinValue;

  if (port &lt; TOTAL_PORTS &amp;&amp; value != previousPORT[port]) {
    for (i = 0; i &lt; 8; i++) {
      currentPinValue = (byte) value &amp; (1 &lt;&lt; i);
      previousPinValue = previousPORT[port] &amp; (1 &lt;&lt; i);
      if (currentPinValue != previousPinValue) {
        digitalWrite(i + (port * 8), currentPinValue);
      }
    }
    previousPORT[port] = value;
  }
}

void setup()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);
  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);
  Firmata.attach(SET_PIN_MODE, setPinModeCallback);
  Firmata.begin(57600);
}

void loop()
{
  byte i;

  for (i = 0; i &lt; TOTAL_PORTS; i++) {
    outputPort(i, readPort(i, 0xff));
  }

  while (Firmata.available()) {
    Firmata.processInput();
  }
}
</code></pre>
<h4 id="fritzing-circuit_33"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_33"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_33">Video Demonstration</h4>
<h3 id="568-standardfirmatable">5.6.8 StandardFirmataBLE</h3>
<h4 id="sketch-code_34">Sketch Code</h4>
<pre><code class="language-C">/*
  Firmata is a generic protocol for communicating with microcontrollers
  from software on a host computer. It is intended to work with
  any host computer software package.

  To download a host software package, please click on the following link
  to open the list of Firmata client libraries in your default browser.

  https://github.com/firmata/arduino#firmata-client-libraries

  Copyright (C) 2006-2008 Hans-Christoph Steiner.  All rights reserved.
  Copyright (C) 2010-2011 Paul Stoffregen.  All rights reserved.
  Copyright (C) 2009 Shigeru Kobayashi.  All rights reserved.
  Copyright (C) 2009-2016 Jeff Hoefs.  All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  See file LICENSE.txt for further informations on licensing terms.

  Last updated August 17th, 2017
*/

#include &lt;Servo.h&gt;
#include &lt;Wire.h&gt;
#include &lt;Firmata.h&gt;

#define I2C_WRITE                   B00000000
#define I2C_READ                    B00001000
#define I2C_READ_CONTINUOUSLY       B00010000
#define I2C_STOP_READING            B00011000
#define I2C_READ_WRITE_MODE_MASK    B00011000
#define I2C_10BIT_ADDRESS_MODE_MASK B00100000
#define I2C_END_TX_MASK             B01000000
#define I2C_STOP_TX                 1
#define I2C_RESTART_TX              0
#define I2C_MAX_QUERIES             8
#define I2C_REGISTER_NOT_SPECIFIED  -1

// the minimum interval for sampling analog input
#define MINIMUM_SAMPLING_INTERVAL   1


/*==============================================================================
 * GLOBAL VARIABLES
 *============================================================================*/

#ifdef FIRMATA_SERIAL_FEATURE
SerialFirmata serialFeature;
#endif

/* analog inputs */
int analogInputsToReport = 0; // bitwise array to store pin reporting

/* digital input ports */
byte reportPINs[TOTAL_PORTS];       // 1 = report this port, 0 = silence
byte previousPINs[TOTAL_PORTS];     // previous 8 bits sent

/* pins configuration */
byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else

/* timer variables */
unsigned long currentMillis;        // store the current value from millis()
unsigned long previousMillis;       // for comparison with currentMillis
unsigned int samplingInterval = 19; // how often to run the main loop (in ms)

/* i2c data */
struct i2c_device_info {
  byte addr;
  int reg;
  byte bytes;
  byte stopTX;
};

/* for i2c read continuous more */
i2c_device_info query[I2C_MAX_QUERIES];

byte i2cRxData[64];
boolean isI2CEnabled = false;
signed char queryIndex = -1;
// default delay time between i2c read request and Wire.requestFrom()
unsigned int i2cReadDelayTime = 0;

Servo servos[MAX_SERVOS];
byte servoPinMap[TOTAL_PINS];
byte detachedServos[MAX_SERVOS];
byte detachedServoCount = 0;
byte servoCount = 0;

boolean isResetting = false;

// Forward declare a few functions to avoid compiler errors with older versions
// of the Arduino IDE.
void setPinModeCallback(byte, int);
void reportAnalogCallback(byte analogPin, int value);
void sysexCallback(byte, byte, byte*);

/* utility functions */
void wireWrite(byte data)
{
#if ARDUINO &gt;= 100
  Wire.write((byte)data);
#else
  Wire.send(data);
#endif
}

byte wireRead(void)
{
#if ARDUINO &gt;= 100
  return Wire.read();
#else
  return Wire.receive();
#endif
}

/*==============================================================================
 * FUNCTIONS
 *============================================================================*/

void attachServo(byte pin, int minPulse, int maxPulse)
{
  if (servoCount &lt; MAX_SERVOS) {
    // reuse indexes of detached servos until all have been reallocated
    if (detachedServoCount &gt; 0) {
      servoPinMap[pin] = detachedServos[detachedServoCount - 1];
      if (detachedServoCount &gt; 0) detachedServoCount--;
    } else {
      servoPinMap[pin] = servoCount;
      servoCount++;
    }
    if (minPulse &gt; 0 &amp;&amp; maxPulse &gt; 0) {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse);
    } else {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin));
    }
  } else {
    Firmata.sendString(&quot;Max servos attached&quot;);
  }
}

void detachServo(byte pin)
{
  servos[servoPinMap[pin]].detach();
  // if we're detaching the last servo, decrement the count
  // otherwise store the index of the detached servo
  if (servoPinMap[pin] == servoCount &amp;&amp; servoCount &gt; 0) {
    servoCount--;
  } else if (servoCount &gt; 0) {
    // keep track of detached servos because we want to reuse their indexes
    // before incrementing the count of attached servos
    detachedServoCount++;
    detachedServos[detachedServoCount - 1] = servoPinMap[pin];
  }

  servoPinMap[pin] = 255;
}

void enableI2CPins()
{
  byte i;
  // is there a faster way to do this? would probaby require importing
  // Arduino.h to get SCL and SDA pins
  for (i = 0; i &lt; TOTAL_PINS; i++) {
    if (IS_PIN_I2C(i)) {
      // mark pins as i2c so they are ignore in non i2c data requests
      setPinModeCallback(i, PIN_MODE_I2C);
    }
  }

  isI2CEnabled = true;

  Wire.begin();
}

/* disable the i2c pins so they can be used for other functions */
void disableI2CPins() {
  isI2CEnabled = false;
  // disable read continuous mode for all devices
  queryIndex = -1;
}

void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) {
  // allow I2C requests that don't require a register read
  // for example, some devices using an interrupt pin to signify new data available
  // do not always require the register read so upon interrupt you call Wire.requestFrom()
  if (theRegister != I2C_REGISTER_NOT_SPECIFIED) {
    Wire.beginTransmission(address);
    wireWrite((byte)theRegister);
    Wire.endTransmission(stopTX); // default = true
    // do not set a value of 0
    if (i2cReadDelayTime &gt; 0) {
      // delay is necessary for some devices such as WiiNunchuck
      delayMicroseconds(i2cReadDelayTime);
    }
  } else {
    theRegister = 0;  // fill the register with a dummy value
  }

  Wire.requestFrom(address, numBytes);  // all bytes are returned in requestFrom

  // check to be sure correct number of bytes were returned by slave
  if (numBytes &lt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too many bytes received&quot;);
  } else if (numBytes &gt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too few bytes received&quot;);
    numBytes = Wire.available();
  }

  i2cRxData[0] = address;
  i2cRxData[1] = theRegister;

  for (int i = 0; i &lt; numBytes &amp;&amp; Wire.available(); i++) {
    i2cRxData[2 + i] = wireRead();
  }

  // send slave address, register and received bytes
  Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData);
}

void outputPort(byte portNumber, byte portValue, byte forceSend)
{
  // pins not configured as INPUT are cleared to zeros
  portValue = portValue &amp; portConfigInputs[portNumber];
  // only send if the value is different than previously sent
  if (forceSend || previousPINs[portNumber] != portValue) {
    Firmata.sendDigitalPort(portNumber, portValue);
    previousPINs[portNumber] = portValue;
  }
}

/* -----------------------------------------------------------------------------
 * check all the active digital inputs for change of state, then add any events
 * to the Serial output queue using Serial.print() */
void checkDigitalInputs(void)
{
  /* Using non-looping code allows constants to be given to readPort().
   * The compiler will apply substantial optimizations if the inputs
   * to readPort() are compile-time constants. */
  if (TOTAL_PORTS &gt; 0 &amp;&amp; reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false);
  if (TOTAL_PORTS &gt; 1 &amp;&amp; reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false);
  if (TOTAL_PORTS &gt; 2 &amp;&amp; reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false);
  if (TOTAL_PORTS &gt; 3 &amp;&amp; reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false);
  if (TOTAL_PORTS &gt; 4 &amp;&amp; reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false);
  if (TOTAL_PORTS &gt; 5 &amp;&amp; reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false);
  if (TOTAL_PORTS &gt; 6 &amp;&amp; reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false);
  if (TOTAL_PORTS &gt; 7 &amp;&amp; reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false);
  if (TOTAL_PORTS &gt; 8 &amp;&amp; reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false);
  if (TOTAL_PORTS &gt; 9 &amp;&amp; reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false);
  if (TOTAL_PORTS &gt; 10 &amp;&amp; reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false);
  if (TOTAL_PORTS &gt; 11 &amp;&amp; reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false);
  if (TOTAL_PORTS &gt; 12 &amp;&amp; reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false);
  if (TOTAL_PORTS &gt; 13 &amp;&amp; reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false);
  if (TOTAL_PORTS &gt; 14 &amp;&amp; reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false);
  if (TOTAL_PORTS &gt; 15 &amp;&amp; reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false);
}

// -----------------------------------------------------------------------------
/* sets the pin mode to the correct state and sets the relevant bits in the
 * two bit-arrays that track Digital I/O and PWM status
 */
void setPinModeCallback(byte pin, int mode)
{
  if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE)
    return;

  if (Firmata.getPinMode(pin) == PIN_MODE_I2C &amp;&amp; isI2CEnabled &amp;&amp; mode != PIN_MODE_I2C) {
    // disable i2c so pins can be used for other functions
    // the following if statements should reconfigure the pins properly
    disableI2CPins();
  }
  if (IS_PIN_DIGITAL(pin) &amp;&amp; mode != PIN_MODE_SERVO) {
    if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
      detachServo(pin);
    }
  }
  if (IS_PIN_ANALOG(pin)) {
    reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting
  }
  if (IS_PIN_DIGITAL(pin)) {
    if (mode == INPUT || mode == PIN_MODE_PULLUP) {
      portConfigInputs[pin / 8] |= (1 &lt;&lt; (pin &amp; 7));
    } else {
      portConfigInputs[pin / 8] &amp;= ~(1 &lt;&lt; (pin &amp; 7));
    }
  }
  Firmata.setPinState(pin, 0);
  switch (mode) {
    case PIN_MODE_ANALOG:
      if (IS_PIN_ANALOG(pin)) {
        if (IS_PIN_DIGITAL(pin)) {
          pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
          // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
          digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        }
        Firmata.setPinMode(pin, PIN_MODE_ANALOG);
      }
      break;
    case INPUT:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
        // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
        digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        Firmata.setPinMode(pin, INPUT);
      }
      break;
    case PIN_MODE_PULLUP:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP);
        Firmata.setPinMode(pin, PIN_MODE_PULLUP);
        Firmata.setPinState(pin, 1);
      }
      break;
    case OUTPUT:
      if (IS_PIN_DIGITAL(pin)) {
        if (Firmata.getPinMode(pin) == PIN_MODE_PWM) {
          // Disable PWM if pin mode was previously set to PWM.
          digitalWrite(PIN_TO_DIGITAL(pin), LOW);
        }
        pinMode(PIN_TO_DIGITAL(pin), OUTPUT);
        Firmata.setPinMode(pin, OUTPUT);
      }
      break;
    case PIN_MODE_PWM:
      if (IS_PIN_PWM(pin)) {
        pinMode(PIN_TO_PWM(pin), OUTPUT);
        analogWrite(PIN_TO_PWM(pin), 0);
        Firmata.setPinMode(pin, PIN_MODE_PWM);
      }
      break;
    case PIN_MODE_SERVO:
      if (IS_PIN_DIGITAL(pin)) {
        Firmata.setPinMode(pin, PIN_MODE_SERVO);
        if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) {
          // pass -1 for min and max pulse values to use default values set
          // by Servo library
          attachServo(pin, -1, -1);
        }
      }
      break;
    case PIN_MODE_I2C:
      if (IS_PIN_I2C(pin)) {
        // mark the pin as i2c
        // the user must call I2C_CONFIG to enable I2C for a device
        Firmata.setPinMode(pin, PIN_MODE_I2C);
      }
      break;
    case PIN_MODE_SERIAL:
#ifdef FIRMATA_SERIAL_FEATURE
      serialFeature.handlePinMode(pin, PIN_MODE_SERIAL);
#endif
      break;
    default:
      Firmata.sendString(&quot;Unknown pin mode&quot;); // TODO: put error msgs in EEPROM
  }
  // TODO: save status to EEPROM here, if changed
}

/*
 * Sets the value of an individual pin. Useful if you want to set a pin value but
 * are not tracking the digital port state.
 * Can only be used on pins configured as OUTPUT.
 * Cannot be used to enable pull-ups on Digital INPUT pins.
 */
void setPinValueCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS &amp;&amp; IS_PIN_DIGITAL(pin)) {
    if (Firmata.getPinMode(pin) == OUTPUT) {
      Firmata.setPinState(pin, value);
      digitalWrite(PIN_TO_DIGITAL(pin), value);
    }
  }
}

void analogWriteCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS) {
    switch (Firmata.getPinMode(pin)) {
      case PIN_MODE_SERVO:
        if (IS_PIN_DIGITAL(pin))
          servos[servoPinMap[pin]].write(value);
        Firmata.setPinState(pin, value);
        break;
      case PIN_MODE_PWM:
        if (IS_PIN_PWM(pin))
          analogWrite(PIN_TO_PWM(pin), value);
        Firmata.setPinState(pin, value);
        break;
    }
  }
}

void digitalWriteCallback(byte port, int value)
{
  byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0;

  if (port &lt; TOTAL_PORTS) {
    // create a mask of the pins on this port that are writable.
    lastPin = port * 8 + 8;
    if (lastPin &gt; TOTAL_PINS) lastPin = TOTAL_PINS;
    for (pin = port * 8; pin &lt; lastPin; pin++) {
      // do not disturb non-digital pins (eg, Rx &amp; Tx)
      if (IS_PIN_DIGITAL(pin)) {
        // do not touch pins in PWM, ANALOG, SERVO or other modes
        if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) {
          pinValue = ((byte)value &amp; mask) ? 1 : 0;
          if (Firmata.getPinMode(pin) == OUTPUT) {
            pinWriteMask |= mask;
          } else if (Firmata.getPinMode(pin) == INPUT &amp;&amp; pinValue == 1 &amp;&amp; Firmata.getPinState(pin) != 1) {
            // only handle INPUT here for backwards compatibility
#if ARDUINO &gt; 100
            pinMode(pin, INPUT_PULLUP);
#else
            // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier
            pinWriteMask |= mask;
#endif
          }
          Firmata.setPinState(pin, pinValue);
        }
      }
      mask = mask &lt;&lt; 1;
    }
    writePort(port, (byte)value, pinWriteMask);
  }
}


// -----------------------------------------------------------------------------
/* sets bits in a bit array (int) to toggle the reporting of the analogIns
 */
//void FirmataClass::setAnalogPinReporting(byte pin, byte state) {
//}
void reportAnalogCallback(byte analogPin, int value)
{
  if (analogPin &lt; TOTAL_ANALOG_PINS) {
    if (value == 0) {
      analogInputsToReport = analogInputsToReport &amp; ~ (1 &lt;&lt; analogPin);
    } else {
      analogInputsToReport = analogInputsToReport | (1 &lt;&lt; analogPin);
      // prevent during system reset or all analog pin values will be reported
      // which may report noise for unconnected analog pins
      if (!isResetting) {
        // Send pin value immediately. This is helpful when connected via
        // ethernet, wi-fi or bluetooth so pin states can be known upon
        // reconnecting.
        Firmata.sendAnalog(analogPin, analogRead(analogPin));
      }
    }
  }
  // TODO: save status to EEPROM here, if changed
}

void reportDigitalCallback(byte port, int value)
{
  if (port &lt; TOTAL_PORTS) {
    reportPINs[port] = (byte)value;
    // Send port value immediately. This is helpful when connected via
    // ethernet, wi-fi or bluetooth so pin states can be known upon
    // reconnecting.
    if (value) outputPort(port, readPort(port, portConfigInputs[port]), true);
  }
  // do not disable analog reporting on these 8 pins, to allow some
  // pins used for digital, others analog.  Instead, allow both types
  // of reporting to be enabled, but check if the pin is configured
  // as analog when sampling the analog inputs.  Likewise, while
  // scanning digital pins, portConfigInputs will mask off values from any
  // pins configured as analog
}

/*==============================================================================
 * SYSEX-BASED commands
 *============================================================================*/

void sysexCallback(byte command, byte argc, byte *argv)
{
  byte mode;
  byte stopTX;
  byte slaveAddress;
  byte data;
  int slaveRegister;
  unsigned int delayTime;

  switch (command) {
    case I2C_REQUEST:
      mode = argv[1] &amp; I2C_READ_WRITE_MODE_MASK;
      if (argv[1] &amp; I2C_10BIT_ADDRESS_MODE_MASK) {
        Firmata.sendString(&quot;10-bit addressing not supported&quot;);
        return;
      }
      else {
        slaveAddress = argv[0];
      }

      // need to invert the logic here since 0 will be default for client
      // libraries that have not updated to add support for restart tx
      if (argv[1] &amp; I2C_END_TX_MASK) {
        stopTX = I2C_RESTART_TX;
      }
      else {
        stopTX = I2C_STOP_TX; // default
      }

      switch (mode) {
        case I2C_WRITE:
          Wire.beginTransmission(slaveAddress);
          for (byte i = 2; i &lt; argc; i += 2) {
            data = argv[i] + (argv[i + 1] &lt;&lt; 7);
            wireWrite(data);
          }
          Wire.endTransmission();
          delayMicroseconds(70);
          break;
        case I2C_READ:
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX);
          break;
        case I2C_READ_CONTINUOUSLY:
          if ((queryIndex + 1) &gt;= I2C_MAX_QUERIES) {
            // too many queries, just ignore
            Firmata.sendString(&quot;too many queries&quot;);
            break;
          }
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          queryIndex++;
          query[queryIndex].addr = slaveAddress;
          query[queryIndex].reg = slaveRegister;
          query[queryIndex].bytes = data;
          query[queryIndex].stopTX = stopTX;
          break;
        case I2C_STOP_READING:
          byte queryIndexToSkip;
          // if read continuous mode is enabled for only 1 i2c device, disable
          // read continuous reporting for that device
          if (queryIndex &lt;= 0) {
            queryIndex = -1;
          } else {
            queryIndexToSkip = 0;
            // if read continuous mode is enabled for multiple devices,
            // determine which device to stop reading and remove it's data from
            // the array, shifiting other array data to fill the space
            for (byte i = 0; i &lt; queryIndex + 1; i++) {
              if (query[i].addr == slaveAddress) {
                queryIndexToSkip = i;
                break;
              }
            }

            for (byte i = queryIndexToSkip; i &lt; queryIndex + 1; i++) {
              if (i &lt; I2C_MAX_QUERIES) {
                query[i].addr = query[i + 1].addr;
                query[i].reg = query[i + 1].reg;
                query[i].bytes = query[i + 1].bytes;
                query[i].stopTX = query[i + 1].stopTX;
              }
            }
            queryIndex--;
          }
          break;
        default:
          break;
      }
      break;
    case I2C_CONFIG:
      delayTime = (argv[0] + (argv[1] &lt;&lt; 7));

      if (argc &gt; 1 &amp;&amp; delayTime &gt; 0) {
        i2cReadDelayTime = delayTime;
      }

      if (!isI2CEnabled) {
        enableI2CPins();
      }

      break;
    case SERVO_CONFIG:
      if (argc &gt; 4) {
        // these vars are here for clarity, they'll optimized away by the compiler
        byte pin = argv[0];
        int minPulse = argv[1] + (argv[2] &lt;&lt; 7);
        int maxPulse = argv[3] + (argv[4] &lt;&lt; 7);

        if (IS_PIN_DIGITAL(pin)) {
          if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
            detachServo(pin);
          }
          attachServo(pin, minPulse, maxPulse);
          setPinModeCallback(pin, PIN_MODE_SERVO);
        }
      }
      break;
    case SAMPLING_INTERVAL:
      if (argc &gt; 1) {
        samplingInterval = argv[0] + (argv[1] &lt;&lt; 7);
        if (samplingInterval &lt; MINIMUM_SAMPLING_INTERVAL) {
          samplingInterval = MINIMUM_SAMPLING_INTERVAL;
        }
      } else {
        //Firmata.sendString(&quot;Not enough data&quot;);
      }
      break;
    case EXTENDED_ANALOG:
      if (argc &gt; 1) {
        int val = argv[1];
        if (argc &gt; 2) val |= (argv[2] &lt;&lt; 7);
        if (argc &gt; 3) val |= (argv[3] &lt;&lt; 14);
        analogWriteCallback(argv[0], val);
      }
      break;
    case CAPABILITY_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(CAPABILITY_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write((byte)INPUT);
          Firmata.write(1);
          Firmata.write((byte)PIN_MODE_PULLUP);
          Firmata.write(1);
          Firmata.write((byte)OUTPUT);
          Firmata.write(1);
        }
        if (IS_PIN_ANALOG(pin)) {
          Firmata.write(PIN_MODE_ANALOG);
          Firmata.write(10); // 10 = 10-bit resolution
        }
        if (IS_PIN_PWM(pin)) {
          Firmata.write(PIN_MODE_PWM);
          Firmata.write(DEFAULT_PWM_RESOLUTION);
        }
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write(PIN_MODE_SERVO);
          Firmata.write(14);
        }
        if (IS_PIN_I2C(pin)) {
          Firmata.write(PIN_MODE_I2C);
          Firmata.write(1);  // TODO: could assign a number to map to SCL or SDA
        }
#ifdef FIRMATA_SERIAL_FEATURE
        serialFeature.handleCapability(pin);
#endif
        Firmata.write(127);
      }
      Firmata.write(END_SYSEX);
      break;
    case PIN_STATE_QUERY:
      if (argc &gt; 0) {
        byte pin = argv[0];
        Firmata.write(START_SYSEX);
        Firmata.write(PIN_STATE_RESPONSE);
        Firmata.write(pin);
        if (pin &lt; TOTAL_PINS) {
          Firmata.write(Firmata.getPinMode(pin));
          Firmata.write((byte)Firmata.getPinState(pin) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 7) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 14) &amp; 0x7F);
        }
        Firmata.write(END_SYSEX);
      }
      break;
    case ANALOG_MAPPING_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(ANALOG_MAPPING_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127);
      }
      Firmata.write(END_SYSEX);
      break;

    case SERIAL_MESSAGE:
#ifdef FIRMATA_SERIAL_FEATURE
      serialFeature.handleSysex(command, argc, argv);
#endif
      break;
  }
}

/*==============================================================================
 * SETUP()
 *============================================================================*/

void systemResetCallback()
{
  isResetting = true;

  // initialize a defalt state
  // TODO: option to load config from EEPROM instead of default

#ifdef FIRMATA_SERIAL_FEATURE
  serialFeature.reset();
#endif

  if (isI2CEnabled) {
    disableI2CPins();
  }

  for (byte i = 0; i &lt; TOTAL_PORTS; i++) {
    reportPINs[i] = false;    // by default, reporting off
    portConfigInputs[i] = 0;  // until activated
    previousPINs[i] = 0;
  }

  for (byte i = 0; i &lt; TOTAL_PINS; i++) {
    // pins with analog capability default to analog input
    // otherwise, pins default to digital output
    if (IS_PIN_ANALOG(i)) {
      // turns off pullup, configures everything
      setPinModeCallback(i, PIN_MODE_ANALOG);
    } else if (IS_PIN_DIGITAL(i)) {
      // sets the output to 0, configures portConfigInputs
      setPinModeCallback(i, OUTPUT);
    }

    servoPinMap[i] = 255;
  }
  // by default, do not report any analog inputs
  analogInputsToReport = 0;

  detachedServoCount = 0;
  servoCount = 0;

  /* send digital inputs to set the initial state on the host computer,
   * since once in the loop(), this firmware will only send on change */
  /*
  TODO: this can never execute, since no pins default to digital input
        but it will be needed when/if we support EEPROM stored config
  for (byte i=0; i &lt; TOTAL_PORTS; i++) {
    outputPort(i, readPort(i, portConfigInputs[i]), true);
  }
  */
  isResetting = false;
}

void setup()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);

  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);
  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);
  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);
  Firmata.attach(SET_PIN_MODE, setPinModeCallback);
  Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback);
  Firmata.attach(START_SYSEX, sysexCallback);
  Firmata.attach(SYSTEM_RESET, systemResetCallback);

  // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega,
  // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this:
  // Serial1.begin(57600);
  // Firmata.begin(Serial1);
  // However do not do this if you are using SERIAL_MESSAGE

  Firmata.begin(57600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101
  }

  systemResetCallback();  // reset to default config
}

/*==============================================================================
 * LOOP()
 *============================================================================*/
void loop()
{
  byte pin, analogPin;

  /* DIGITALREAD - as fast as possible, check for changes and output them to the
   * FTDI buffer using Serial.print()  */
  checkDigitalInputs();

  /* STREAMREAD - processing incoming messagse as soon as possible, while still
   * checking digital inputs.  */
  while (Firmata.available())
    Firmata.processInput();

  // TODO - ensure that Stream buffer doesn't go over 60 bytes

  currentMillis = millis();
  if (currentMillis - previousMillis &gt; samplingInterval) {
    previousMillis += samplingInterval;
    /* ANALOGREAD - do all analogReads() at the configured sampling interval */
    for (pin = 0; pin &lt; TOTAL_PINS; pin++) {
      if (IS_PIN_ANALOG(pin) &amp;&amp; Firmata.getPinMode(pin) == PIN_MODE_ANALOG) {
        analogPin = PIN_TO_ANALOG(pin);
        if (analogInputsToReport &amp; (1 &lt;&lt; analogPin)) {
          Firmata.sendAnalog(analogPin, analogRead(analogPin));
        }
      }
    }
    // report i2c data for all device with read continuous mode enabled
    if (queryIndex &gt; -1) {
      for (byte i = 0; i &lt; queryIndex + 1; i++) {
        readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX);
      }
    }
  }

#ifdef FIRMATA_SERIAL_FEATURE
  serialFeature.update();
#endif
}
</code></pre>
<h4 id="fritzing-circuit_34"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_34"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_34">Video Demonstration</h4>
<h3 id="569-standardfirmatachipkit">5.6.9 StandardFirmataChipKIT</h3>
<h4 id="sketch-code_35">Sketch Code</h4>
<pre><code class="language-C">/*
  Firmata is a generic protocol for communicating with microcontrollers
  from software on a host computer. It is intended to work with
  any host computer software package.

  To download a host software package, please click on the following link
  to open the list of Firmata client libraries in your default browser.

  https://github.com/firmata/arduino#firmata-client-libraries

  Copyright (C) 2006-2008 Hans-Christoph Steiner.  All rights reserved.
  Copyright (C) 2010-2011 Paul Stoffregen.  All rights reserved.
  Copyright (C) 2009 Shigeru Kobayashi.  All rights reserved.
  Copyright (C) 2009-2016 Jeff Hoefs.  All rights reserved.
  Copyright (C) 2015 Brian Schmalz. All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  See file LICENSE.txt for further informations on licensing terms.

  Last updated August 17th, 2017
*/

#include &lt;SoftPWMServo.h&gt;  // Gives us PWM and Servo on every pin
#include &lt;Wire.h&gt;
#include &lt;Firmata.h&gt;

#define I2C_WRITE                   B00000000
#define I2C_READ                    B00001000
#define I2C_READ_CONTINUOUSLY       B00010000
#define I2C_STOP_READING            B00011000
#define I2C_READ_WRITE_MODE_MASK    B00011000
#define I2C_10BIT_ADDRESS_MODE_MASK B00100000
#define I2C_END_TX_MASK             B01000000
#define I2C_STOP_TX                 1
#define I2C_RESTART_TX              0
#define I2C_MAX_QUERIES             8
#define I2C_REGISTER_NOT_SPECIFIED  -1

// the minimum interval for sampling analog input
#define MINIMUM_SAMPLING_INTERVAL   1


/*==============================================================================
 * GLOBAL VARIABLES
 *============================================================================*/

/* analog inputs */
int analogInputsToReport = 0; // bitwise array to store pin reporting

/* digital input ports */
byte reportPINs[TOTAL_PORTS];       // 1 = report this port, 0 = silence
byte previousPINs[TOTAL_PORTS];     // previous 8 bits sent

/* pins configuration */
byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else

/* timer variables */
unsigned long currentMillis;        // store the current value from millis()
unsigned long previousMillis;       // for comparison with currentMillis
unsigned int samplingInterval = 19; // how often to run the main loop (in ms)

/* i2c data */
struct i2c_device_info {
  byte addr;
  int reg;
  byte bytes;
  byte stopTX;
};

/* for i2c read continuous more */
i2c_device_info query[I2C_MAX_QUERIES];

byte i2cRxData[64];
boolean isI2CEnabled = false;
signed char queryIndex = -1;
// default delay time between i2c read request and Wire.requestFrom()
unsigned int i2cReadDelayTime = 0;

SoftServo servos[MAX_SERVOS];
byte servoPinMap[TOTAL_PINS];
byte detachedServos[MAX_SERVOS];
byte detachedServoCount = 0;
byte servoCount = 0;

boolean isResetting = false;

// Forward declare a few functions to avoid compiler errors with older versions
// of the Arduino IDE.
void setPinModeCallback(byte, int);
void reportAnalogCallback(byte analogPin, int value);
void sysexCallback(byte, byte, byte*);

/* utility functions */
void wireWrite(byte data)
{
#if ARDUINO &gt;= 100
  Wire.write((byte)data);
#else
  Wire.send(data);
#endif
}

byte wireRead(void)
{
#if ARDUINO &gt;= 100
  return Wire.read();
#else
  return Wire.receive();
#endif
}

/*==============================================================================
 * FUNCTIONS
 *============================================================================*/

void attachServo(byte pin, int minPulse, int maxPulse)
{
  if (servoCount &lt; MAX_SERVOS) {
    // reuse indexes of detached servos until all have been reallocated
    if (detachedServoCount &gt; 0) {
      servoPinMap[pin] = detachedServos[detachedServoCount - 1];
      if (detachedServoCount &gt; 0) detachedServoCount--;
    } else {
      servoPinMap[pin] = servoCount;
      servoCount++;
    }
    if (minPulse &gt; 0 &amp;&amp; maxPulse &gt; 0) {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse);
    } else {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin));
    }
  } else {
    Firmata.sendString(&quot;Max servos attached&quot;);
  }
}

void detachServo(byte pin)
{
  servos[servoPinMap[pin]].detach();
  // if we're detaching the last servo, decrement the count
  // otherwise store the index of the detached servo
  if (servoPinMap[pin] == servoCount &amp;&amp; servoCount &gt; 0) {
    servoCount--;
  } else if (servoCount &gt; 0) {
    // keep track of detached servos because we want to reuse their indexes
    // before incrementing the count of attached servos
    detachedServoCount++;
    detachedServos[detachedServoCount - 1] = servoPinMap[pin];
  }

  servoPinMap[pin] = 255;
}

void enableI2CPins()
{
  byte i;
  // is there a faster way to do this? would probaby require importing
  // Arduino.h to get SCL and SDA pins
  for (i = 0; i &lt; TOTAL_PINS; i++) {
    if (IS_PIN_I2C(i)) {
      // mark pins as i2c so they are ignore in non i2c data requests
      setPinModeCallback(i, PIN_MODE_I2C);
    }
  }

  isI2CEnabled = true;

  Wire.begin();
}

/* disable the i2c pins so they can be used for other functions */
void disableI2CPins() {
  isI2CEnabled = false;
  // disable read continuous mode for all devices
  queryIndex = -1;
}

void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) {
  // allow I2C requests that don't require a register read
  // for example, some devices using an interrupt pin to signify new data available
  // do not always require the register read so upon interrupt you call Wire.requestFrom()
  if (theRegister != I2C_REGISTER_NOT_SPECIFIED) {
    Wire.beginTransmission(address);
    wireWrite((byte)theRegister);
    Wire.endTransmission(stopTX); // default = true
    // do not set a value of 0
    if (i2cReadDelayTime &gt; 0) {
      // delay is necessary for some devices such as WiiNunchuck
      delayMicroseconds(i2cReadDelayTime);
    }
  } else {
    theRegister = 0;  // fill the register with a dummy value
  }

  Wire.requestFrom(address, numBytes);  // all bytes are returned in requestFrom

  // check to be sure correct number of bytes were returned by slave
  if (numBytes &lt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too many bytes received&quot;);
  } else if (numBytes &gt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too few bytes received&quot;);
    numBytes = Wire.available();
  }

  i2cRxData[0] = address;
  i2cRxData[1] = theRegister;

  for (int i = 0; i &lt; numBytes &amp;&amp; Wire.available(); i++) {
    i2cRxData[2 + i] = wireRead();
  }

  // send slave address, register and received bytes
  Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData);
}

void outputPort(byte portNumber, byte portValue, byte forceSend)
{
  // pins not configured as INPUT are cleared to zeros
  portValue = portValue &amp; portConfigInputs[portNumber];
  // only send if the value is different than previously sent
  if (forceSend || previousPINs[portNumber] != portValue) {
    Firmata.sendDigitalPort(portNumber, portValue);
    previousPINs[portNumber] = portValue;
  }
}

/* -----------------------------------------------------------------------------
 * check all the active digital inputs for change of state, then add any events
 * to the Serial output queue using Serial.print() */
void checkDigitalInputs(void)
{
  /* Using non-looping code allows constants to be given to readPort().
   * The compiler will apply substantial optimizations if the inputs
   * to readPort() are compile-time constants. */
  if (TOTAL_PORTS &gt; 0 &amp;&amp; reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false);
  if (TOTAL_PORTS &gt; 1 &amp;&amp; reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false);
  if (TOTAL_PORTS &gt; 2 &amp;&amp; reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false);
  if (TOTAL_PORTS &gt; 3 &amp;&amp; reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false);
  if (TOTAL_PORTS &gt; 4 &amp;&amp; reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false);
  if (TOTAL_PORTS &gt; 5 &amp;&amp; reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false);
  if (TOTAL_PORTS &gt; 6 &amp;&amp; reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false);
  if (TOTAL_PORTS &gt; 7 &amp;&amp; reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false);
  if (TOTAL_PORTS &gt; 8 &amp;&amp; reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false);
  if (TOTAL_PORTS &gt; 9 &amp;&amp; reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false);
  if (TOTAL_PORTS &gt; 10 &amp;&amp; reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false);
  if (TOTAL_PORTS &gt; 11 &amp;&amp; reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false);
  if (TOTAL_PORTS &gt; 12 &amp;&amp; reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false);
  if (TOTAL_PORTS &gt; 13 &amp;&amp; reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false);
  if (TOTAL_PORTS &gt; 14 &amp;&amp; reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false);
  if (TOTAL_PORTS &gt; 15 &amp;&amp; reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false);
}

// -----------------------------------------------------------------------------
/* Sets a pin that is in Servo mode to a particular output value
 * (i.e. pulse width). Different boards may have different ways of
 * setting servo values, so putting it in a function keeps things cleaner.
 */
void servoWrite(byte pin, int value)
{
  SoftPWMServoPWMWrite(PIN_TO_PWM(pin), value);
}

// -----------------------------------------------------------------------------
/* sets the pin mode to the correct state and sets the relevant bits in the
 * two bit-arrays that track Digital I/O and PWM status
 */
void setPinModeCallback(byte pin, int mode)
{
  if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE)
    return;

  if (Firmata.getPinMode(pin) == PIN_MODE_I2C &amp;&amp; isI2CEnabled &amp;&amp; mode != PIN_MODE_I2C) {
    // disable i2c so pins can be used for other functions
    // the following if statements should reconfigure the pins properly
    disableI2CPins();
  }
  if (IS_PIN_DIGITAL(pin) &amp;&amp; mode != PIN_MODE_SERVO) {
    if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
      detachServo(pin);
    }
  }
  if (IS_PIN_ANALOG(pin)) {
    reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting
  }
  if (IS_PIN_DIGITAL(pin)) {
    if (mode == INPUT || mode == PIN_MODE_PULLUP) {
      portConfigInputs[pin / 8] |= (1 &lt;&lt; (pin &amp; 7));
    } else {
      portConfigInputs[pin / 8] &amp;= ~(1 &lt;&lt; (pin &amp; 7));
    }
  }
  Firmata.setPinState(pin, 0);
  switch (mode) {
    case PIN_MODE_ANALOG:
      if (IS_PIN_ANALOG(pin)) {
        if (IS_PIN_DIGITAL(pin)) {
          pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
          // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
          digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        }
        Firmata.setPinMode(pin, PIN_MODE_ANALOG);
      }
      break;
    case INPUT:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
        // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
        digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        Firmata.setPinMode(pin, INPUT);
      }
      break;
    case PIN_MODE_PULLUP:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP);
        Firmata.setPinMode(pin, PIN_MODE_PULLUP);
        Firmata.setPinState(pin, 1);
      }
      break;
    case OUTPUT:
      if (IS_PIN_DIGITAL(pin)) {
        if (Firmata.getPinMode(pin) == PIN_MODE_PWM) {
          // Disable PWM if pin mode was previously set to PWM.
          digitalWrite(PIN_TO_DIGITAL(pin), LOW);
        }
        pinMode(PIN_TO_DIGITAL(pin), OUTPUT);
        Firmata.setPinMode(pin, OUTPUT);
      }
      break;
    case PIN_MODE_PWM:
      if (IS_PIN_PWM(pin)) {
        pinMode(PIN_TO_PWM(pin), OUTPUT);
        servoWrite(PIN_TO_PWM(pin), 0);
        Firmata.setPinMode(pin, PIN_MODE_PWM);
      }
      break;
    case PIN_MODE_SERVO:
      if (IS_PIN_DIGITAL(pin)) {
        Firmata.setPinMode(pin, PIN_MODE_SERVO);
        if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) {
          // pass -1 for min and max pulse values to use default values set
          // by Servo library
          attachServo(pin, -1, -1);
        }
      }
      break;
    case PIN_MODE_I2C:
      if (IS_PIN_I2C(pin)) {
        // mark the pin as i2c
        // the user must call I2C_CONFIG to enable I2C for a device
        Firmata.setPinMode(pin, PIN_MODE_I2C);
      }
      break;
    default:
      Firmata.sendString(&quot;Unknown pin mode&quot;); // TODO: put error msgs in EEPROM
  }
  // TODO: save status to EEPROM here, if changed
}

/*
 * Sets the value of an individual pin. Useful if you want to set a pin value but
 * are not tracking the digital port state.
 * Can only be used on pins configured as OUTPUT.
 * Cannot be used to enable pull-ups on Digital INPUT pins.
 */
void setPinValueCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS &amp;&amp; IS_PIN_DIGITAL(pin)) {
    if (Firmata.getPinMode(pin) == OUTPUT) {
      Firmata.setPinState(pin, value);
      digitalWrite(PIN_TO_DIGITAL(pin), value);
    }
  }
}

void analogWriteCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS) {
    switch (Firmata.getPinMode(pin)) {
      case PIN_MODE_SERVO:
        if (IS_PIN_DIGITAL(pin))
          servos[servoPinMap[pin]].write(value);
        Firmata.setPinState(pin, value);
        break;
      case PIN_MODE_PWM:
        if (IS_PIN_PWM(pin))
          servoWrite(PIN_TO_PWM(pin), value);
        Firmata.setPinState(pin, value);
        break;
    }
  }
}

void digitalWriteCallback(byte port, int value)
{
  byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0;

  if (port &lt; TOTAL_PORTS) {
    // create a mask of the pins on this port that are writable.
    lastPin = port * 8 + 8;
    if (lastPin &gt; TOTAL_PINS) lastPin = TOTAL_PINS;
    for (pin = port * 8; pin &lt; lastPin; pin++) {
      // do not disturb non-digital pins (eg, Rx &amp; Tx)
      if (IS_PIN_DIGITAL(pin)) {
        // do not touch pins in PWM, ANALOG, SERVO or other modes
        if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) {
          pinValue = ((byte)value &amp; mask) ? 1 : 0;
          if (Firmata.getPinMode(pin) == OUTPUT) {
            pinWriteMask |= mask;
          } else if (Firmata.getPinMode(pin) == INPUT &amp;&amp; pinValue == 1 &amp;&amp; Firmata.getPinState(pin) != 1) {
            // only handle INPUT here for backwards compatibility
#if ARDUINO &gt; 100
            pinMode(pin, INPUT_PULLUP);
#else
            // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier
            pinWriteMask |= mask;
#endif
          }
          Firmata.setPinState(pin, pinValue);
        }
      }
      mask = mask &lt;&lt; 1;
    }
    writePort(port, (byte)value, pinWriteMask);
  }
}


// -----------------------------------------------------------------------------
/* sets bits in a bit array (int) to toggle the reporting of the analogIns
 */
//void FirmataClass::setAnalogPinReporting(byte pin, byte state) {
//}
void reportAnalogCallback(byte analogPin, int value)
{
  if (analogPin &lt; TOTAL_ANALOG_PINS) {
    if (value == 0) {
      analogInputsToReport = analogInputsToReport &amp; ~ (1 &lt;&lt; analogPin);
    } else {
      analogInputsToReport = analogInputsToReport | (1 &lt;&lt; analogPin);
      // prevent during system reset or all analog pin values will be reported
      // which may report noise for unconnected analog pins
      if (!isResetting) {
        // Send pin value immediately. This is helpful when connected via
        // ethernet, wi-fi or bluetooth so pin states can be known upon
        // reconnecting.
        Firmata.sendAnalog(analogPin, analogRead(analogPin));
      }
    }
  }
  // TODO: save status to EEPROM here, if changed
}

void reportDigitalCallback(byte port, int value)
{
  if (port &lt; TOTAL_PORTS) {
    reportPINs[port] = (byte)value;
    // Send port value immediately. This is helpful when connected via
    // ethernet, wi-fi or bluetooth so pin states can be known upon
    // reconnecting.
    if (value) outputPort(port, readPort(port, portConfigInputs[port]), true);
  }
  // do not disable analog reporting on these 8 pins, to allow some
  // pins used for digital, others analog.  Instead, allow both types
  // of reporting to be enabled, but check if the pin is configured
  // as analog when sampling the analog inputs.  Likewise, while
  // scanning digital pins, portConfigInputs will mask off values from any
  // pins configured as analog
}

/*==============================================================================
 * SYSEX-BASED commands
 *============================================================================*/

void sysexCallback(byte command, byte argc, byte *argv)
{
  byte mode;
  byte stopTX;
  byte slaveAddress;
  byte data;
  int slaveRegister;
  unsigned int delayTime;

  switch (command) {
    case I2C_REQUEST:
      mode = argv[1] &amp; I2C_READ_WRITE_MODE_MASK;
      if (argv[1] &amp; I2C_10BIT_ADDRESS_MODE_MASK) {
        Firmata.sendString(&quot;10-bit addressing not supported&quot;);
        return;
      }
      else {
        slaveAddress = argv[0];
      }

      // need to invert the logic here since 0 will be default for client
      // libraries that have not updated to add support for restart tx
      if (argv[1] &amp; I2C_END_TX_MASK) {
        stopTX = I2C_RESTART_TX;
      }
      else {
        stopTX = I2C_STOP_TX; // default
      }

      switch (mode) {
        case I2C_WRITE:
          Wire.beginTransmission(slaveAddress);
          for (byte i = 2; i &lt; argc; i += 2) {
            data = argv[i] + (argv[i + 1] &lt;&lt; 7);
            wireWrite(data);
          }
          Wire.endTransmission();
          delayMicroseconds(70);
          break;
        case I2C_READ:
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX);
          break;
        case I2C_READ_CONTINUOUSLY:
          if ((queryIndex + 1) &gt;= I2C_MAX_QUERIES) {
            // too many queries, just ignore
            Firmata.sendString(&quot;too many queries&quot;);
            break;
          }
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          queryIndex++;
          query[queryIndex].addr = slaveAddress;
          query[queryIndex].reg = slaveRegister;
          query[queryIndex].bytes = data;
          query[queryIndex].stopTX = stopTX;
          break;
        case I2C_STOP_READING:
          byte queryIndexToSkip;
          // if read continuous mode is enabled for only 1 i2c device, disable
          // read continuous reporting for that device
          if (queryIndex &lt;= 0) {
            queryIndex = -1;
          } else {
            queryIndexToSkip = 0;
            // if read continuous mode is enabled for multiple devices,
            // determine which device to stop reading and remove it's data from
            // the array, shifiting other array data to fill the space
            for (byte i = 0; i &lt; queryIndex + 1; i++) {
              if (query[i].addr == slaveAddress) {
                queryIndexToSkip = i;
                break;
              }
            }

            for (byte i = queryIndexToSkip; i &lt; queryIndex + 1; i++) {
              if (i &lt; I2C_MAX_QUERIES) {
                query[i].addr = query[i + 1].addr;
                query[i].reg = query[i + 1].reg;
                query[i].bytes = query[i + 1].bytes;
                query[i].stopTX = query[i + 1].stopTX;
              }
            }
            queryIndex--;
          }
          break;
        default:
          break;
      }
      break;
    case I2C_CONFIG:
      delayTime = (argv[0] + (argv[1] &lt;&lt; 7));

      if (argc &gt; 1 &amp;&amp; delayTime &gt; 0) {
        i2cReadDelayTime = delayTime;
      }

      if (!isI2CEnabled) {
        enableI2CPins();
      }

      break;
    case SERVO_CONFIG:
      if (argc &gt; 4) {
        // these vars are here for clarity, they'll optimized away by the compiler
        byte pin = argv[0];
        int minPulse = argv[1] + (argv[2] &lt;&lt; 7);
        int maxPulse = argv[3] + (argv[4] &lt;&lt; 7);

        if (IS_PIN_DIGITAL(pin)) {
          if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
            detachServo(pin);
          }
          attachServo(pin, minPulse, maxPulse);
          setPinModeCallback(pin, PIN_MODE_SERVO);
        }
      }
      break;
    case SAMPLING_INTERVAL:
      if (argc &gt; 1) {
        samplingInterval = argv[0] + (argv[1] &lt;&lt; 7);
        if (samplingInterval &lt; MINIMUM_SAMPLING_INTERVAL) {
          samplingInterval = MINIMUM_SAMPLING_INTERVAL;
        }
      } else {
        //Firmata.sendString(&quot;Not enough data&quot;);
      }
      break;
    case EXTENDED_ANALOG:
      if (argc &gt; 1) {
        int val = argv[1];
        if (argc &gt; 2) val |= (argv[2] &lt;&lt; 7);
        if (argc &gt; 3) val |= (argv[3] &lt;&lt; 14);
        analogWriteCallback(argv[0], val);
      }
      break;
    case CAPABILITY_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(CAPABILITY_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write((byte)INPUT);
          Firmata.write(1);
          Firmata.write((byte)PIN_MODE_PULLUP);
          Firmata.write(1);
          Firmata.write((byte)OUTPUT);
          Firmata.write(1);
        }
        if (IS_PIN_ANALOG(pin)) {
          Firmata.write(PIN_MODE_ANALOG);
          Firmata.write(10); // 10 = 10-bit resolution
        }
        if (IS_PIN_PWM(pin)) {
          Firmata.write(PIN_MODE_PWM);
          Firmata.write(DEFAULT_PWM_RESOLUTION);
        }
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write(PIN_MODE_SERVO);
          Firmata.write(14);
        }
        if (IS_PIN_I2C(pin)) {
          Firmata.write(PIN_MODE_I2C);
          Firmata.write(1);  // TODO: could assign a number to map to SCL or SDA
        }
        Firmata.write(127);
      }
      Firmata.write(END_SYSEX);
      break;
    case PIN_STATE_QUERY:
      if (argc &gt; 0) {
        byte pin = argv[0];
        Firmata.write(START_SYSEX);
        Firmata.write(PIN_STATE_RESPONSE);
        Firmata.write(pin);
        if (pin &lt; TOTAL_PINS) {
          Firmata.write(Firmata.getPinMode(pin));
          Firmata.write((byte)Firmata.getPinState(pin) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 7) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 14) &amp; 0x7F);
        }
        Firmata.write(END_SYSEX);
      }
      break;
    case ANALOG_MAPPING_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(ANALOG_MAPPING_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127);
      }
      Firmata.write(END_SYSEX);
      break;
  }
}

/*==============================================================================
 * SETUP()
 *============================================================================*/

void systemResetCallback()
{
  isResetting = true;
  // initialize a defalt state
  // TODO: option to load config from EEPROM instead of default
  if (isI2CEnabled) {
    disableI2CPins();
  }

  for (byte i = 0; i &lt; TOTAL_PORTS; i++) {
    reportPINs[i] = false;    // by default, reporting off
    portConfigInputs[i] = 0;  // until activated
    previousPINs[i] = 0;
  }

  for (byte i = 0; i &lt; TOTAL_PINS; i++) {
    // pins with analog capability default to analog input
    // otherwise, pins default to digital output
    if (IS_PIN_ANALOG(i)) {
      // turns off pullup, configures everything
      setPinModeCallback(i, PIN_MODE_ANALOG);
    } else if (IS_PIN_DIGITAL(i)) {
      // sets the output to 0, configures portConfigInputs
      setPinModeCallback(i, OUTPUT);
    }

    servoPinMap[i] = 255;
  }
  // by default, do not report any analog inputs
  analogInputsToReport = 0;

  detachedServoCount = 0;
  servoCount = 0;

  /* send digital inputs to set the initial state on the host computer,
   * since once in the loop(), this firmware will only send on change */
  /*
  TODO: this can never execute, since no pins default to digital input
        but it will be needed when/if we support EEPROM stored config
  for (byte i=0; i &lt; TOTAL_PORTS; i++) {
    outputPort(i, readPort(i, portConfigInputs[i]), true);
  }
  */
  isResetting = false;
}

void setup()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);

  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);
  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);
  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);
  Firmata.attach(SET_PIN_MODE, setPinModeCallback);
  Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback);
  Firmata.attach(START_SYSEX, sysexCallback);
  Firmata.attach(SYSTEM_RESET, systemResetCallback);

  /* For chipKIT Pi board, we need to use Serial1. All others just use Serial. */
#if defined(_BOARD_CHIPKIT_PI_)
  Serial1.begin(57600);
  Firmata.begin(Serial1);
#else
  Firmata.begin(57600);
#endif
  systemResetCallback();  // reset to default config
}

/*==============================================================================
 * LOOP()
 *============================================================================*/
void loop()
{
  byte pin, analogPin;

  /* DIGITALREAD - as fast as possible, check for changes and output them to the
   * FTDI buffer using Serial.print()  */
  checkDigitalInputs();

  /* STREAMREAD - processing incoming messagse as soon as possible, while still
   * checking digital inputs.  */
  while (Firmata.available())
    Firmata.processInput();

  // TODO - ensure that Stream buffer doesn't go over 60 bytes

  currentMillis = millis();
  if (currentMillis - previousMillis &gt; samplingInterval) {
    previousMillis += samplingInterval;
    /* ANALOGREAD - do all analogReads() at the configured sampling interval */
    for (pin = 0; pin &lt; TOTAL_PINS; pin++) {
      if (IS_PIN_ANALOG(pin) &amp;&amp; Firmata.getPinMode(pin) == PIN_MODE_ANALOG) {
        analogPin = PIN_TO_ANALOG(pin);
        if (analogInputsToReport &amp; (1 &lt;&lt; analogPin)) {
          Firmata.sendAnalog(analogPin, analogRead(analogPin));
        }
      }
    }
    // report i2c data for all device with read continuous mode enabled
    if (queryIndex &gt; -1) {
      for (byte i = 0; i &lt; queryIndex + 1; i++) {
        readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX);
      }
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_35"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_35"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_35">Video Demonstration</h4>
<h3 id="5610-standardfirmataethernet">5.6.10 StandardFirmataEthernet</h3>
<h4 id="sketch-code_36">Sketch Code</h4>
<pre><code class="language-C">/*
  Firmata is a generic protocol for communicating with microcontrollers
  from software on a host computer. It is intended to work with
  any host computer software package.

  To download a host software package, please click on the following link
  to open the list of Firmata client libraries in your default browser.

  https://github.com/firmata/arduino#firmata-client-libraries

  Copyright (C) 2006-2008 Hans-Christoph Steiner.  All rights reserved.
  Copyright (C) 2010-2011 Paul Stoffregen.  All rights reserved.
  Copyright (C) 2009 Shigeru Kobayashi.  All rights reserved.
  Copyright (C) 2009-2017 Jeff Hoefs.  All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  See file LICENSE.txt for further informations on licensing terms.

  Last updated March 10th, 2020
*/

/*
  README

  StandardFirmataEthernet is a TCP client/server implementation. You will need a Firmata client library
  with a network transport that can act as a TCP server or client in order to establish a connection between
  StandardFirmataEthernet and the Firmata client application.

  To use StandardFirmataEthernet you will need to have one of the following
  boards or shields:

  - Arduino Ethernet shield (or clone)
  - Arduino Ethernet board (or clone)
  - Arduino Yun

  Follow the instructions in the ethernetConfig.h file (ethernetConfig.h tab in Arduino IDE) to
  configure your particular hardware.

  NOTE: If you are using an Arduino Ethernet shield you cannot use the following pins on
  the following boards. Firmata will ignore any requests to use these pins:

  - Arduino Uno or other ATMega328 boards: (D4, D10, D11, D12, D13)
  - Arduino Mega: (D4, D10, D50, D51, D52, D53)
  - Arduino Leonardo: (D4, D10)
  - Arduino Due: (D4, D10)
  - Arduino Zero: (D4, D10)

  If you are using an ArduinoEthernet board, the following pins cannot be used (same as Uno):
  - D4, D10, D11, D12, D13
*/

#include &lt;Servo.h&gt;
#include &lt;Wire.h&gt;
#include &lt;Firmata.h&gt;

/*
 * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your
 * connection that may help in the event of connection issues. If defined, some boards may not begin
 * executing this sketch until the Serial console is opened.
 */
//#define SERIAL_DEBUG
#include &quot;utility/firmataDebug.h&quot;

// follow the instructions in ethernetConfig.h to configure your particular hardware
#include &quot;ethernetConfig.h&quot;
#include &quot;utility/EthernetClientStream.h&quot;
#include &quot;utility/EthernetServerStream.h&quot;

/*
 * Uncomment the following include to enable interfacing with Serial devices via hardware or
 * software serial.
 *
 * DO NOT uncomment if you are running StandardFirmataEthernet on an Arduino Leonardo,
 * Arduino Micro or other ATMega32u4-based board or you will not have enough Flash and RAM
 * remaining to reliably run Firmata. Arduino Yun is okay because it doesn't import the Ethernet
 * libraries.
 */
// In order to use software serial, you will need to compile this sketch with
// Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0.
//#include &quot;utility/SerialFirmata.h&quot;

#define I2C_WRITE                   B00000000
#define I2C_READ                    B00001000
#define I2C_READ_CONTINUOUSLY       B00010000
#define I2C_STOP_READING            B00011000
#define I2C_READ_WRITE_MODE_MASK    B00011000
#define I2C_10BIT_ADDRESS_MODE_MASK B00100000
#define I2C_END_TX_MASK             B01000000
#define I2C_STOP_TX                 1
#define I2C_RESTART_TX              0
#define I2C_MAX_QUERIES             8
#define I2C_REGISTER_NOT_SPECIFIED  -1

// the minimum interval for sampling analog input
#define MINIMUM_SAMPLING_INTERVAL   1

/*==============================================================================
 * GLOBAL VARIABLES
 *============================================================================*/

#if defined remote_ip &amp;&amp; !defined remote_host
#ifdef local_ip
EthernetClientStream stream(client, local_ip, remote_ip, NULL, network_port);
#else
EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), remote_ip, NULL, network_port);
#endif
#endif

#if !defined remote_ip &amp;&amp; defined remote_host
#ifdef local_ip
EthernetClientStream stream(client, local_ip, IPAddress(0, 0, 0, 0), remote_host, network_port );
#else
EthernetClientStream stream(client, IPAddress(0, 0, 0, 0), IPAddress(0, 0, 0, 0), remote_host, network_port);
#endif
#endif

#if !defined remote_ip &amp;&amp; !defined remote_host
#ifdef local_ip
EthernetServerStream stream(local_ip, network_port);
#else
EthernetServerStream stream(IPAddress(0, 0, 0, 0), network_port);
#endif
#endif

#ifdef FIRMATA_SERIAL_FEATURE
SerialFirmata serialFeature;
#endif

/* analog inputs */
int analogInputsToReport = 0;      // bitwise array to store pin reporting

/* digital input ports */
byte reportPINs[TOTAL_PORTS];       // 1 = report this port, 0 = silence
byte previousPINs[TOTAL_PORTS];     // previous 8 bits sent

/* pins configuration */
byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else

/* timer variables */
unsigned long currentMillis;        // store the current value from millis()
unsigned long previousMillis;       // for comparison with currentMillis
unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms)

/* i2c data */
struct i2c_device_info {
  byte addr;
  int reg;
  byte bytes;
  byte stopTX;
};

/* for i2c read continuous mode */
i2c_device_info query[I2C_MAX_QUERIES];

byte i2cRxData[64];
boolean isI2CEnabled = false;
signed char queryIndex = -1;
// default delay time between i2c read request and Wire.requestFrom()
unsigned int i2cReadDelayTime = 0;

Servo servos[MAX_SERVOS];
byte servoPinMap[TOTAL_PINS];
byte detachedServos[MAX_SERVOS];
byte detachedServoCount = 0;
byte servoCount = 0;

boolean isResetting = false;

// Forward declare a few functions to avoid compiler errors with older versions
// of the Arduino IDE.
void setPinModeCallback(byte, int);
void reportAnalogCallback(byte analogPin, int value);
void sysexCallback(byte, byte, byte*);

/* utility functions */
void wireWrite(byte data)
{
#if ARDUINO &gt;= 100
  Wire.write((byte)data);
#else
  Wire.send(data);
#endif
}

byte wireRead(void)
{
#if ARDUINO &gt;= 100
  return Wire.read();
#else
  return Wire.receive();
#endif
}

/*==============================================================================
 * FUNCTIONS
 *============================================================================*/

void attachServo(byte pin, int minPulse, int maxPulse)
{
  if (servoCount &lt; MAX_SERVOS) {
    // reuse indexes of detached servos until all have been reallocated
    if (detachedServoCount &gt; 0) {
      servoPinMap[pin] = detachedServos[detachedServoCount - 1];
      if (detachedServoCount &gt; 0) detachedServoCount--;
    } else {
      servoPinMap[pin] = servoCount;
      servoCount++;
    }
    if (minPulse &gt; 0 &amp;&amp; maxPulse &gt; 0) {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse);
    } else {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin));
    }
  } else {
    Firmata.sendString(&quot;Max servos attached&quot;);
  }
}

void detachServo(byte pin)
{
  servos[servoPinMap[pin]].detach();
  // if we're detaching the last servo, decrement the count
  // otherwise store the index of the detached servo
  if (servoPinMap[pin] == servoCount &amp;&amp; servoCount &gt; 0) {
    servoCount--;
  } else if (servoCount &gt; 0) {
    // keep track of detached servos because we want to reuse their indexes
    // before incrementing the count of attached servos
    detachedServoCount++;
    detachedServos[detachedServoCount - 1] = servoPinMap[pin];
  }

  servoPinMap[pin] = 255;
}

void enableI2CPins()
{
  byte i;
  // is there a faster way to do this? would probaby require importing
  // Arduino.h to get SCL and SDA pins
  for (i = 0; i &lt; TOTAL_PINS; i++) {
    if (IS_PIN_I2C(i)) {
      // mark pins as i2c so they are ignore in non i2c data requests
      setPinModeCallback(i, PIN_MODE_I2C);
    }
  }

  isI2CEnabled = true;

  Wire.begin();
}

/* disable the i2c pins so they can be used for other functions */
void disableI2CPins() {
  isI2CEnabled = false;
  // disable read continuous mode for all devices
  queryIndex = -1;
}

void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) {
  // allow I2C requests that don't require a register read
  // for example, some devices using an interrupt pin to signify new data available
  // do not always require the register read so upon interrupt you call Wire.requestFrom()
  if (theRegister != I2C_REGISTER_NOT_SPECIFIED) {
    Wire.beginTransmission(address);
    wireWrite((byte)theRegister);
    Wire.endTransmission(stopTX); // default = true
    // do not set a value of 0
    if (i2cReadDelayTime &gt; 0) {
      // delay is necessary for some devices such as WiiNunchuck
      delayMicroseconds(i2cReadDelayTime);
    }
  } else {
    theRegister = 0;  // fill the register with a dummy value
  }

  Wire.requestFrom(address, numBytes);  // all bytes are returned in requestFrom

  // check to be sure correct number of bytes were returned by slave
  if (numBytes &lt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too many bytes received&quot;);
  } else if (numBytes &gt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too few bytes received&quot;);
    numBytes = Wire.available();
  }

  i2cRxData[0] = address;
  i2cRxData[1] = theRegister;

  for (int i = 0; i &lt; numBytes &amp;&amp; Wire.available(); i++) {
    i2cRxData[2 + i] = wireRead();
  }

  // send slave address, register and received bytes
  Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData);
}

void outputPort(byte portNumber, byte portValue, byte forceSend)
{
  // pins not configured as INPUT are cleared to zeros
  portValue = portValue &amp; portConfigInputs[portNumber];
  // only send if the value is different than previously sent
  if (forceSend || previousPINs[portNumber] != portValue) {
    Firmata.sendDigitalPort(portNumber, portValue);
    previousPINs[portNumber] = portValue;
  }
}

/* -----------------------------------------------------------------------------
 * check all the active digital inputs for change of state, then add any events
 * to the Stream output queue using Stream.write() */
void checkDigitalInputs(void)
{
  /* Using non-looping code allows constants to be given to readPort().
   * The compiler will apply substantial optimizations if the inputs
   * to readPort() are compile-time constants. */
  if (TOTAL_PORTS &gt; 0 &amp;&amp; reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false);
  if (TOTAL_PORTS &gt; 1 &amp;&amp; reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false);
  if (TOTAL_PORTS &gt; 2 &amp;&amp; reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false);
  if (TOTAL_PORTS &gt; 3 &amp;&amp; reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false);
  if (TOTAL_PORTS &gt; 4 &amp;&amp; reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false);
  if (TOTAL_PORTS &gt; 5 &amp;&amp; reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false);
  if (TOTAL_PORTS &gt; 6 &amp;&amp; reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false);
  if (TOTAL_PORTS &gt; 7 &amp;&amp; reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false);
  if (TOTAL_PORTS &gt; 8 &amp;&amp; reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false);
  if (TOTAL_PORTS &gt; 9 &amp;&amp; reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false);
  if (TOTAL_PORTS &gt; 10 &amp;&amp; reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false);
  if (TOTAL_PORTS &gt; 11 &amp;&amp; reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false);
  if (TOTAL_PORTS &gt; 12 &amp;&amp; reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false);
  if (TOTAL_PORTS &gt; 13 &amp;&amp; reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false);
  if (TOTAL_PORTS &gt; 14 &amp;&amp; reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false);
  if (TOTAL_PORTS &gt; 15 &amp;&amp; reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false);
}

// -----------------------------------------------------------------------------
/* sets the pin mode to the correct state and sets the relevant bits in the
 * two bit-arrays that track Digital I/O and PWM status
 */
void setPinModeCallback(byte pin, int mode)
{
  if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE)
    return;

  if (Firmata.getPinMode(pin) == PIN_MODE_I2C &amp;&amp; isI2CEnabled &amp;&amp; mode != PIN_MODE_I2C) {
    // disable i2c so pins can be used for other functions
    // the following if statements should reconfigure the pins properly
    disableI2CPins();
  }
  if (IS_PIN_DIGITAL(pin) &amp;&amp; mode != PIN_MODE_SERVO) {
    if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
      detachServo(pin);
    }
  }
  if (IS_PIN_ANALOG(pin)) {
    // turn on/off reporting
    reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0);
  }
  if (IS_PIN_DIGITAL(pin)) {
    if (mode == INPUT || mode == PIN_MODE_PULLUP) {
      portConfigInputs[pin / 8] |= (1 &lt;&lt; (pin &amp; 7));
    } else {
      portConfigInputs[pin / 8] &amp;= ~(1 &lt;&lt; (pin &amp; 7));
    }
  }
  Firmata.setPinState(pin, 0);
  switch (mode) {
    case PIN_MODE_ANALOG:
      if (IS_PIN_ANALOG(pin)) {
        if (IS_PIN_DIGITAL(pin)) {
          pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
          // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
          digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        }
        Firmata.setPinMode(pin, PIN_MODE_ANALOG);
      }
      break;
    case INPUT:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
        // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
        digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        Firmata.setPinMode(pin, INPUT);
      }
      break;
    case PIN_MODE_PULLUP:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP);
        Firmata.setPinMode(pin, PIN_MODE_PULLUP);
        Firmata.setPinState(pin, 1);
      }
      break;
    case OUTPUT:
      if (IS_PIN_DIGITAL(pin)) {
        if (Firmata.getPinMode(pin) == PIN_MODE_PWM) {
          // Disable PWM if pin mode was previously set to PWM.
          digitalWrite(PIN_TO_DIGITAL(pin), LOW);
        }
        pinMode(PIN_TO_DIGITAL(pin), OUTPUT);
        Firmata.setPinMode(pin, OUTPUT);
      }
      break;
    case PIN_MODE_PWM:
      if (IS_PIN_PWM(pin)) {
        pinMode(PIN_TO_PWM(pin), OUTPUT);
        analogWrite(PIN_TO_PWM(pin), 0);
        Firmata.setPinMode(pin, PIN_MODE_PWM);
      }
      break;
    case PIN_MODE_SERVO:
      if (IS_PIN_DIGITAL(pin)) {
        Firmata.setPinMode(pin, PIN_MODE_SERVO);
        if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) {
          // pass -1 for min and max pulse values to use default values set
          // by Servo library
          attachServo(pin, -1, -1);
        }
      }
      break;
    case PIN_MODE_I2C:
      if (IS_PIN_I2C(pin)) {
        // mark the pin as i2c
        // the user must call I2C_CONFIG to enable I2C for a device
        Firmata.setPinMode(pin, PIN_MODE_I2C);
      }
      break;
    case PIN_MODE_SERIAL:
#ifdef FIRMATA_SERIAL_FEATURE
      serialFeature.handlePinMode(pin, PIN_MODE_SERIAL);
#endif
      break;
    default:
      Firmata.sendString(&quot;Unknown pin mode&quot;); // TODO: put error msgs in EEPROM
  }
  // TODO: save status to EEPROM here, if changed
}

/*
 * Sets the value of an individual pin. Useful if you want to set a pin value but
 * are not tracking the digital port state.
 * Can only be used on pins configured as OUTPUT.
 * Cannot be used to enable pull-ups on Digital INPUT pins.
 */
void setPinValueCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS &amp;&amp; IS_PIN_DIGITAL(pin)) {
    if (Firmata.getPinMode(pin) == OUTPUT) {
      Firmata.setPinState(pin, value);
      digitalWrite(PIN_TO_DIGITAL(pin), value);
    }
  }
}

void analogWriteCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS) {
    switch (Firmata.getPinMode(pin)) {
      case PIN_MODE_SERVO:
        if (IS_PIN_DIGITAL(pin))
          servos[servoPinMap[pin]].write(value);
        Firmata.setPinState(pin, value);
        break;
      case PIN_MODE_PWM:
        if (IS_PIN_PWM(pin))
          analogWrite(PIN_TO_PWM(pin), value);
        Firmata.setPinState(pin, value);
        break;
    }
  }
}

void digitalWriteCallback(byte port, int value)
{
  byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0;

  if (port &lt; TOTAL_PORTS) {
    // create a mask of the pins on this port that are writable.
    lastPin = port * 8 + 8;
    if (lastPin &gt; TOTAL_PINS) lastPin = TOTAL_PINS;
    for (pin = port * 8; pin &lt; lastPin; pin++) {
      // do not disturb non-digital pins (eg, Rx &amp; Tx)
      if (IS_PIN_DIGITAL(pin)) {
        // do not touch pins in PWM, ANALOG, SERVO or other modes
        if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) {
          pinValue = ((byte)value &amp; mask) ? 1 : 0;
          if (Firmata.getPinMode(pin) == OUTPUT) {
            pinWriteMask |= mask;
          } else if (Firmata.getPinMode(pin) == INPUT &amp;&amp; pinValue == 1 &amp;&amp; Firmata.getPinState(pin) != 1) {
            // only handle INPUT here for backwards compatibility
#if ARDUINO &gt; 100
            pinMode(pin, INPUT_PULLUP);
#else
            // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier
            pinWriteMask |= mask;
#endif
          }
          Firmata.setPinState(pin, pinValue);
        }
      }
      mask = mask &lt;&lt; 1;
    }
    writePort(port, (byte)value, pinWriteMask);
  }
}


// -----------------------------------------------------------------------------
/* sets bits in a bit array (int) to toggle the reporting of the analogIns
 */
//void FirmataClass::setAnalogPinReporting(byte pin, byte state) {
//}
void reportAnalogCallback(byte analogPin, int value)
{
  if (analogPin &lt; TOTAL_ANALOG_PINS) {
    if (value == 0) {
      analogInputsToReport = analogInputsToReport &amp; ~ (1 &lt;&lt; analogPin);
    } else {
      analogInputsToReport = analogInputsToReport | (1 &lt;&lt; analogPin);
      // prevent during system reset or all analog pin values will be reported
      // which may report noise for unconnected analog pins
      if (!isResetting) {
        // Send pin value immediately. This is helpful when connected via
        // ethernet, wi-fi or bluetooth so pin states can be known upon
        // reconnecting.
        Firmata.sendAnalog(analogPin, analogRead(analogPin));
      }
    }
  }
  // TODO: save status to EEPROM here, if changed
}

void reportDigitalCallback(byte port, int value)
{
  if (port &lt; TOTAL_PORTS) {
    reportPINs[port] = (byte)value;
    // Send port value immediately. This is helpful when connected via
    // ethernet, wi-fi or bluetooth so pin states can be known upon
    // reconnecting.
    if (value) outputPort(port, readPort(port, portConfigInputs[port]), true);
  }
  // do not disable analog reporting on these 8 pins, to allow some
  // pins used for digital, others analog.  Instead, allow both types
  // of reporting to be enabled, but check if the pin is configured
  // as analog when sampling the analog inputs.  Likewise, while
  // scanning digital pins, portConfigInputs will mask off values from any
  // pins configured as analog
}

/*==============================================================================
 * SYSEX-BASED commands
 *============================================================================*/

void sysexCallback(byte command, byte argc, byte *argv)
{
  byte mode;
  byte stopTX;
  byte slaveAddress;
  byte data;
  int slaveRegister;
  unsigned int delayTime;

  switch (command) {
    case I2C_REQUEST:
      mode = argv[1] &amp; I2C_READ_WRITE_MODE_MASK;
      if (argv[1] &amp; I2C_10BIT_ADDRESS_MODE_MASK) {
        Firmata.sendString(&quot;10-bit addressing not supported&quot;);
        return;
      }
      else {
        slaveAddress = argv[0];
      }

      // need to invert the logic here since 0 will be default for client
      // libraries that have not updated to add support for restart tx
      if (argv[1] &amp; I2C_END_TX_MASK) {
        stopTX = I2C_RESTART_TX;
      }
      else {
        stopTX = I2C_STOP_TX; // default
      }

      switch (mode) {
        case I2C_WRITE:
          Wire.beginTransmission(slaveAddress);
          for (byte i = 2; i &lt; argc; i += 2) {
            data = argv[i] + (argv[i + 1] &lt;&lt; 7);
            wireWrite(data);
          }
          Wire.endTransmission();
          delayMicroseconds(70);
          break;
        case I2C_READ:
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX);
          break;
        case I2C_READ_CONTINUOUSLY:
          if ((queryIndex + 1) &gt;= I2C_MAX_QUERIES) {
            // too many queries, just ignore
            Firmata.sendString(&quot;too many queries&quot;);
            break;
          }
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          queryIndex++;
          query[queryIndex].addr = slaveAddress;
          query[queryIndex].reg = slaveRegister;
          query[queryIndex].bytes = data;
          query[queryIndex].stopTX = stopTX;
          break;
        case I2C_STOP_READING:
          byte queryIndexToSkip;
          // if read continuous mode is enabled for only 1 i2c device, disable
          // read continuous reporting for that device
          if (queryIndex &lt;= 0) {
            queryIndex = -1;
          } else {
            queryIndexToSkip = 0;
            // if read continuous mode is enabled for multiple devices,
            // determine which device to stop reading and remove it's data from
            // the array, shifiting other array data to fill the space
            for (byte i = 0; i &lt; queryIndex + 1; i++) {
              if (query[i].addr == slaveAddress) {
                queryIndexToSkip = i;
                break;
              }
            }

            for (byte i = queryIndexToSkip; i &lt; queryIndex + 1; i++) {
              if (i &lt; I2C_MAX_QUERIES) {
                query[i].addr = query[i + 1].addr;
                query[i].reg = query[i + 1].reg;
                query[i].bytes = query[i + 1].bytes;
                query[i].stopTX = query[i + 1].stopTX;
              }
            }
            queryIndex--;
          }
          break;
        default:
          break;
      }
      break;
    case I2C_CONFIG:
      delayTime = (argv[0] + (argv[1] &lt;&lt; 7));

      if (argc &gt; 1 &amp;&amp; delayTime &gt; 0) {
        i2cReadDelayTime = delayTime;
      }

      if (!isI2CEnabled) {
        enableI2CPins();
      }

      break;
    case SERVO_CONFIG:
      if (argc &gt; 4) {
        // these vars are here for clarity, they'll optimized away by the compiler
        byte pin = argv[0];
        int minPulse = argv[1] + (argv[2] &lt;&lt; 7);
        int maxPulse = argv[3] + (argv[4] &lt;&lt; 7);

        if (IS_PIN_DIGITAL(pin)) {
          if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
            detachServo(pin);
          }
          attachServo(pin, minPulse, maxPulse);
          setPinModeCallback(pin, PIN_MODE_SERVO);
        }
      }
      break;
    case SAMPLING_INTERVAL:
      if (argc &gt; 1) {
        samplingInterval = argv[0] + (argv[1] &lt;&lt; 7);
        if (samplingInterval &lt; MINIMUM_SAMPLING_INTERVAL) {
          samplingInterval = MINIMUM_SAMPLING_INTERVAL;
        }
      } else {
        //Firmata.sendString(&quot;Not enough data&quot;);
      }
      break;
    case EXTENDED_ANALOG:
      if (argc &gt; 1) {
        int val = argv[1];
        if (argc &gt; 2) val |= (argv[2] &lt;&lt; 7);
        if (argc &gt; 3) val |= (argv[3] &lt;&lt; 14);
        analogWriteCallback(argv[0], val);
      }
      break;
    case CAPABILITY_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(CAPABILITY_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write((byte)INPUT);
          Firmata.write(1);
          Firmata.write((byte)PIN_MODE_PULLUP);
          Firmata.write(1);
          Firmata.write((byte)OUTPUT);
          Firmata.write(1);
        }
        if (IS_PIN_ANALOG(pin)) {
          Firmata.write(PIN_MODE_ANALOG);
          Firmata.write(10); // 10 = 10-bit resolution
        }
        if (IS_PIN_PWM(pin)) {
          Firmata.write(PIN_MODE_PWM);
          Firmata.write(DEFAULT_PWM_RESOLUTION);
        }
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write(PIN_MODE_SERVO);
          Firmata.write(14);
        }
        if (IS_PIN_I2C(pin)) {
          Firmata.write(PIN_MODE_I2C);
          Firmata.write(1);  // TODO: could assign a number to map to SCL or SDA
        }
#ifdef FIRMATA_SERIAL_FEATURE
        serialFeature.handleCapability(pin);
#endif
        Firmata.write(127);
      }
      Firmata.write(END_SYSEX);
      break;
    case PIN_STATE_QUERY:
      if (argc &gt; 0) {
        byte pin = argv[0];
        Firmata.write(START_SYSEX);
        Firmata.write(PIN_STATE_RESPONSE);
        Firmata.write(pin);
        if (pin &lt; TOTAL_PINS) {
          Firmata.write(Firmata.getPinMode(pin));
          Firmata.write((byte)Firmata.getPinState(pin) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 7) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 14) &amp; 0x7F);
        }
        Firmata.write(END_SYSEX);
      }
      break;
    case ANALOG_MAPPING_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(ANALOG_MAPPING_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127);
      }
      Firmata.write(END_SYSEX);
      break;

    case SERIAL_MESSAGE:
#ifdef FIRMATA_SERIAL_FEATURE
      serialFeature.handleSysex(command, argc, argv);
#endif
      break;
  }
}

/*==============================================================================
 * SETUP()
 *============================================================================*/

void systemResetCallback()
{
  isResetting = true;

  // initialize a defalt state
  // TODO: option to load config from EEPROM instead of default

#ifdef FIRMATA_SERIAL_FEATURE
  serialFeature.reset();
#endif

  if (isI2CEnabled) {
    disableI2CPins();
  }

  for (byte i = 0; i &lt; TOTAL_PORTS; i++) {
    reportPINs[i] = false;    // by default, reporting off
    portConfigInputs[i] = 0;  // until activated
    previousPINs[i] = 0;
  }

  for (byte i = 0; i &lt; TOTAL_PINS; i++) {
    // pins with analog capability default to analog input
    // otherwise, pins default to digital output
    if (IS_PIN_ANALOG(i)) {
      // turns off pullup, configures everything
      setPinModeCallback(i, PIN_MODE_ANALOG);
    } else if (IS_PIN_DIGITAL(i)) {
      // sets the output to 0, configures portConfigInputs
      setPinModeCallback(i, OUTPUT);
    }

    servoPinMap[i] = 255;
  }
  // by default, do not report any analog inputs
  analogInputsToReport = 0;

  detachedServoCount = 0;
  servoCount = 0;

  /* send digital inputs to set the initial state on the host computer,
   * since once in the loop(), this firmware will only send on change */
  /*
  TODO: this can never execute, since no pins default to digital input
        but it will be needed when/if we support EEPROM stored config
  for (byte i=0; i &lt; TOTAL_PORTS; i++) {
    outputPort(i, readPort(i, portConfigInputs[i]), true);
  }
  */
  isResetting = false;
}

#ifdef ETHERNETCLIENTSTREAM_H
/*
 * Called when a TCP connection is either connected or disconnected.
 * TODO:
 * - report connected or reconnected state to host (to be added to protocol)
 * - report current state to host (to be added to protocol)
 */
void hostConnectionCallback(byte state)
{
  switch (state) {
    case HOST_CONNECTION_CONNECTED:
      DEBUG_PRINTLN( &quot;TCP connection established&quot; );
      break;
    case HOST_CONNECTION_DISCONNECTED:
      DEBUG_PRINTLN( &quot;TCP connection disconnected&quot; );
      break;
  }
}
#endif

void printEthernetStatus()
{
  DEBUG_PRINT(&quot;Local IP Address: &quot;);
  IPAddress ip = Ethernet.localIP();
  DEBUG_PRINTLN(ip);
#ifdef remote_ip
  DEBUG_PRINT(&quot;Connecting to server at: &quot;);
  DEBUG_PRINTLN(remote_ip);
#endif
}

/*
 * StandardFirmataEthernet communicates with Ethernet shields over SPI. Therefore all
 * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication.
 * Additional pins may also need to be ignored depending on the particular board or
 * shield in use.
 */
void ignorePins()
{
#ifdef IS_IGNORE_PIN
  for (byte i = 0; i &lt; TOTAL_PINS; i++) {
    if (IS_IGNORE_PIN(i)) {
      Firmata.setPinMode(i, PIN_MODE_IGNORE);
    }
  }
#endif

#ifdef WIZ5100_ETHERNET
  // Arduino Ethernet and Arduino EthernetShield have SD SS wired to D4
  pinMode(PIN_TO_DIGITAL(4), OUTPUT);    // switch off SD card bypassing Firmata
  digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low;

#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
  pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA
#endif

#endif // WIZ5100_ETHERNET
}

void initTransport()
{
#ifdef ETHERNETCLIENTSTREAM_H
  stream.attach(hostConnectionCallback);
#endif

#ifdef YUN_ETHERNET
  Bridge.begin();
#else
#ifdef local_ip
  Ethernet.begin((uint8_t *)mac, local_ip); //start ethernet
#else
  DEBUG_PRINTLN(&quot;Local IP will be requested from DHCP...&quot;);
  //start ethernet using dhcp
  if (Ethernet.begin((uint8_t *)mac) == 0) {
    DEBUG_PRINTLN(&quot;Failed to configure Ethernet using DHCP&quot;);
  }
#endif
#endif
  printEthernetStatus();
}

void initFirmata()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);
  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);
  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);
  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);
  Firmata.attach(SET_PIN_MODE, setPinModeCallback);
  Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback);
  Firmata.attach(START_SYSEX, sysexCallback);
  Firmata.attach(SYSTEM_RESET, systemResetCallback);

  ignorePins();

  // start up Network Firmata:
  Firmata.begin(stream);
  systemResetCallback();  // Initialize default configuration
}

void setup()
{
  DEBUG_BEGIN(9600);

  initTransport();

  initFirmata();
}

/*==============================================================================
 * LOOP()
 *============================================================================*/
void loop()
{
  byte pin, analogPin;

  /* DIGITALREAD - as fast as possible, check for changes and output them to the
   * Stream buffer using Stream.write()  */
  checkDigitalInputs();

  /* STREAMREAD - processing incoming messagse as soon as possible, while still
   * checking digital inputs.  */
  while (Firmata.available())
    Firmata.processInput();

  // TODO - ensure that Stream buffer doesn't go over 60 bytes

  currentMillis = millis();
  if (currentMillis - previousMillis &gt; samplingInterval) {
    previousMillis += samplingInterval;
    /* ANALOGREAD - do all analogReads() at the configured sampling interval */
    for (pin = 0; pin &lt; TOTAL_PINS; pin++) {
      if (IS_PIN_ANALOG(pin) &amp;&amp; Firmata.getPinMode(pin) == PIN_MODE_ANALOG) {
        analogPin = PIN_TO_ANALOG(pin);
        if (analogInputsToReport &amp; (1 &lt;&lt; analogPin)) {
          Firmata.sendAnalog(analogPin, analogRead(analogPin));
        }
      }
    }
    // report i2c data for all device with read continuous mode enabled
    if (queryIndex &gt; -1) {
      for (byte i = 0; i &lt; queryIndex + 1; i++) {
        readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX);
      }
    }
  }

#ifdef FIRMATA_SERIAL_FEATURE
  serialFeature.update();
#endif

#if !defined local_ip &amp;&amp; !defined YUN_ETHERNET
  // only necessary when using DHCP, ensures local IP is updated appropriately if it changes
  if (Ethernet.maintain()) {
    stream.maintain(Ethernet.localIP());
  }
#endif

}
</code></pre>
<h4 id="fritzing-circuit_36"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_36"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_36">Video Demonstration</h4>
<h3 id="5611-standardfirmataplus">5.6.11 StandardFirmataPlus</h3>
<h4 id="sketch-code_37">Sketch Code</h4>
<pre><code class="language-C">/*
  Firmata is a generic protocol for communicating with microcontrollers
  from software on a host computer. It is intended to work with
  any host computer software package.

  To download a host software package, please click on the following link
  to open the list of Firmata client libraries in your default browser.

  https://github.com/firmata/arduino#firmata-client-libraries

  Copyright (C) 2006-2008 Hans-Christoph Steiner.  All rights reserved.
  Copyright (C) 2010-2011 Paul Stoffregen.  All rights reserved.
  Copyright (C) 2009 Shigeru Kobayashi.  All rights reserved.
  Copyright (C) 2009-2016 Jeff Hoefs.  All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  See file LICENSE.txt for further informations on licensing terms.

  Last updated August 17th, 2017
*/

/*
  README

  StandardFirmataPlus adds additional features that may exceed the Flash and
  RAM sizes of Arduino boards such as ATMega328p (Uno) and ATMega32u4
  (Leonardo, Micro, Yun, etc). It is best to use StandardFirmataPlus with higher
  memory boards such as the Arduino Mega, Arduino Due, Teensy 3.0/3.1/3.2.

  All Firmata examples that are appended with &quot;Plus&quot; add the following features:

  - Ability to interface with serial devices using UART, USART, or SoftwareSerial
    depending on the capatilities of the board.

  NOTE: In order to use SoftwareSerial with the Firmata Serial feature,
  StandardFirmataPlus must be compiled with Arduino v1.6.6 or newer.

  At the time of this writing, StandardFirmataPlus will still compile and run
  on ATMega328p and ATMega32u4-based boards, but future versions of this sketch
  may not as new features are added.
*/

#include &lt;Servo.h&gt;
#include &lt;Wire.h&gt;
#include &lt;Firmata.h&gt;

// In order to use software serial, you will need to compile this sketch with
// Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0.
#include &quot;utility/SerialFirmata.h&quot;

#define I2C_WRITE                   B00000000
#define I2C_READ                    B00001000
#define I2C_READ_CONTINUOUSLY       B00010000
#define I2C_STOP_READING            B00011000
#define I2C_READ_WRITE_MODE_MASK    B00011000
#define I2C_10BIT_ADDRESS_MODE_MASK B00100000
#define I2C_END_TX_MASK             B01000000
#define I2C_STOP_TX                 1
#define I2C_RESTART_TX              0
#define I2C_MAX_QUERIES             8
#define I2C_REGISTER_NOT_SPECIFIED  -1

// the minimum interval for sampling analog input
#define MINIMUM_SAMPLING_INTERVAL   1


/*==============================================================================
 * GLOBAL VARIABLES
 *============================================================================*/

#ifdef FIRMATA_SERIAL_FEATURE
SerialFirmata serialFeature;
#endif

/* analog inputs */
int analogInputsToReport = 0; // bitwise array to store pin reporting

/* digital input ports */
byte reportPINs[TOTAL_PORTS];       // 1 = report this port, 0 = silence
byte previousPINs[TOTAL_PORTS];     // previous 8 bits sent

/* pins configuration */
byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else

/* timer variables */
unsigned long currentMillis;        // store the current value from millis()
unsigned long previousMillis;       // for comparison with currentMillis
unsigned int samplingInterval = 19; // how often to run the main loop (in ms)

/* i2c data */
struct i2c_device_info {
  byte addr;
  int reg;
  byte bytes;
  byte stopTX;
};

/* for i2c read continuous more */
i2c_device_info query[I2C_MAX_QUERIES];

byte i2cRxData[64];
boolean isI2CEnabled = false;
signed char queryIndex = -1;
// default delay time between i2c read request and Wire.requestFrom()
unsigned int i2cReadDelayTime = 0;

Servo servos[MAX_SERVOS];
byte servoPinMap[TOTAL_PINS];
byte detachedServos[MAX_SERVOS];
byte detachedServoCount = 0;
byte servoCount = 0;

boolean isResetting = false;

// Forward declare a few functions to avoid compiler errors with older versions
// of the Arduino IDE.
void setPinModeCallback(byte, int);
void reportAnalogCallback(byte analogPin, int value);
void sysexCallback(byte, byte, byte*);

/* utility functions */
void wireWrite(byte data)
{
#if ARDUINO &gt;= 100
  Wire.write((byte)data);
#else
  Wire.send(data);
#endif
}

byte wireRead(void)
{
#if ARDUINO &gt;= 100
  return Wire.read();
#else
  return Wire.receive();
#endif
}

/*==============================================================================
 * FUNCTIONS
 *============================================================================*/

void attachServo(byte pin, int minPulse, int maxPulse)
{
  if (servoCount &lt; MAX_SERVOS) {
    // reuse indexes of detached servos until all have been reallocated
    if (detachedServoCount &gt; 0) {
      servoPinMap[pin] = detachedServos[detachedServoCount - 1];
      if (detachedServoCount &gt; 0) detachedServoCount--;
    } else {
      servoPinMap[pin] = servoCount;
      servoCount++;
    }
    if (minPulse &gt; 0 &amp;&amp; maxPulse &gt; 0) {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse);
    } else {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin));
    }
  } else {
    Firmata.sendString(&quot;Max servos attached&quot;);
  }
}

void detachServo(byte pin)
{
  servos[servoPinMap[pin]].detach();
  // if we're detaching the last servo, decrement the count
  // otherwise store the index of the detached servo
  if (servoPinMap[pin] == servoCount &amp;&amp; servoCount &gt; 0) {
    servoCount--;
  } else if (servoCount &gt; 0) {
    // keep track of detached servos because we want to reuse their indexes
    // before incrementing the count of attached servos
    detachedServoCount++;
    detachedServos[detachedServoCount - 1] = servoPinMap[pin];
  }

  servoPinMap[pin] = 255;
}

void enableI2CPins()
{
  byte i;
  // is there a faster way to do this? would probaby require importing
  // Arduino.h to get SCL and SDA pins
  for (i = 0; i &lt; TOTAL_PINS; i++) {
    if (IS_PIN_I2C(i)) {
      // mark pins as i2c so they are ignore in non i2c data requests
      setPinModeCallback(i, PIN_MODE_I2C);
    }
  }

  isI2CEnabled = true;

  Wire.begin();
}

/* disable the i2c pins so they can be used for other functions */
void disableI2CPins() {
  isI2CEnabled = false;
  // disable read continuous mode for all devices
  queryIndex = -1;
}

void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) {
  // allow I2C requests that don't require a register read
  // for example, some devices using an interrupt pin to signify new data available
  // do not always require the register read so upon interrupt you call Wire.requestFrom()
  if (theRegister != I2C_REGISTER_NOT_SPECIFIED) {
    Wire.beginTransmission(address);
    wireWrite((byte)theRegister);
    Wire.endTransmission(stopTX); // default = true
    // do not set a value of 0
    if (i2cReadDelayTime &gt; 0) {
      // delay is necessary for some devices such as WiiNunchuck
      delayMicroseconds(i2cReadDelayTime);
    }
  } else {
    theRegister = 0;  // fill the register with a dummy value
  }

  Wire.requestFrom(address, numBytes);  // all bytes are returned in requestFrom

  // check to be sure correct number of bytes were returned by slave
  if (numBytes &lt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too many bytes received&quot;);
  } else if (numBytes &gt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too few bytes received&quot;);
    numBytes = Wire.available();
  }

  i2cRxData[0] = address;
  i2cRxData[1] = theRegister;

  for (int i = 0; i &lt; numBytes &amp;&amp; Wire.available(); i++) {
    i2cRxData[2 + i] = wireRead();
  }

  // send slave address, register and received bytes
  Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData);
}

void outputPort(byte portNumber, byte portValue, byte forceSend)
{
  // pins not configured as INPUT are cleared to zeros
  portValue = portValue &amp; portConfigInputs[portNumber];
  // only send if the value is different than previously sent
  if (forceSend || previousPINs[portNumber] != portValue) {
    Firmata.sendDigitalPort(portNumber, portValue);
    previousPINs[portNumber] = portValue;
  }
}

/* -----------------------------------------------------------------------------
 * check all the active digital inputs for change of state, then add any events
 * to the Serial output queue using Serial.print() */
void checkDigitalInputs(void)
{
  /* Using non-looping code allows constants to be given to readPort().
   * The compiler will apply substantial optimizations if the inputs
   * to readPort() are compile-time constants. */
  if (TOTAL_PORTS &gt; 0 &amp;&amp; reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false);
  if (TOTAL_PORTS &gt; 1 &amp;&amp; reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false);
  if (TOTAL_PORTS &gt; 2 &amp;&amp; reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false);
  if (TOTAL_PORTS &gt; 3 &amp;&amp; reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false);
  if (TOTAL_PORTS &gt; 4 &amp;&amp; reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false);
  if (TOTAL_PORTS &gt; 5 &amp;&amp; reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false);
  if (TOTAL_PORTS &gt; 6 &amp;&amp; reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false);
  if (TOTAL_PORTS &gt; 7 &amp;&amp; reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false);
  if (TOTAL_PORTS &gt; 8 &amp;&amp; reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false);
  if (TOTAL_PORTS &gt; 9 &amp;&amp; reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false);
  if (TOTAL_PORTS &gt; 10 &amp;&amp; reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false);
  if (TOTAL_PORTS &gt; 11 &amp;&amp; reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false);
  if (TOTAL_PORTS &gt; 12 &amp;&amp; reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false);
  if (TOTAL_PORTS &gt; 13 &amp;&amp; reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false);
  if (TOTAL_PORTS &gt; 14 &amp;&amp; reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false);
  if (TOTAL_PORTS &gt; 15 &amp;&amp; reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false);
}

// -----------------------------------------------------------------------------
/* sets the pin mode to the correct state and sets the relevant bits in the
 * two bit-arrays that track Digital I/O and PWM status
 */
void setPinModeCallback(byte pin, int mode)
{
  if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE)
    return;

  if (Firmata.getPinMode(pin) == PIN_MODE_I2C &amp;&amp; isI2CEnabled &amp;&amp; mode != PIN_MODE_I2C) {
    // disable i2c so pins can be used for other functions
    // the following if statements should reconfigure the pins properly
    disableI2CPins();
  }
  if (IS_PIN_DIGITAL(pin) &amp;&amp; mode != PIN_MODE_SERVO) {
    if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
      detachServo(pin);
    }
  }
  if (IS_PIN_ANALOG(pin)) {
    reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting
  }
  if (IS_PIN_DIGITAL(pin)) {
    if (mode == INPUT || mode == PIN_MODE_PULLUP) {
      portConfigInputs[pin / 8] |= (1 &lt;&lt; (pin &amp; 7));
    } else {
      portConfigInputs[pin / 8] &amp;= ~(1 &lt;&lt; (pin &amp; 7));
    }
  }
  Firmata.setPinState(pin, 0);
  switch (mode) {
    case PIN_MODE_ANALOG:
      if (IS_PIN_ANALOG(pin)) {
        if (IS_PIN_DIGITAL(pin)) {
          pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
          // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
          digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        }
        Firmata.setPinMode(pin, PIN_MODE_ANALOG);
      }
      break;
    case INPUT:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
        // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
        digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        Firmata.setPinMode(pin, INPUT);
      }
      break;
    case PIN_MODE_PULLUP:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP);
        Firmata.setPinMode(pin, PIN_MODE_PULLUP);
        Firmata.setPinState(pin, 1);
      }
      break;
    case OUTPUT:
      if (IS_PIN_DIGITAL(pin)) {
        if (Firmata.getPinMode(pin) == PIN_MODE_PWM) {
          // Disable PWM if pin mode was previously set to PWM.
          digitalWrite(PIN_TO_DIGITAL(pin), LOW);
        }
        pinMode(PIN_TO_DIGITAL(pin), OUTPUT);
        Firmata.setPinMode(pin, OUTPUT);
      }
      break;
    case PIN_MODE_PWM:
      if (IS_PIN_PWM(pin)) {
        pinMode(PIN_TO_PWM(pin), OUTPUT);
        analogWrite(PIN_TO_PWM(pin), 0);
        Firmata.setPinMode(pin, PIN_MODE_PWM);
      }
      break;
    case PIN_MODE_SERVO:
      if (IS_PIN_DIGITAL(pin)) {
        Firmata.setPinMode(pin, PIN_MODE_SERVO);
        if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) {
          // pass -1 for min and max pulse values to use default values set
          // by Servo library
          attachServo(pin, -1, -1);
        }
      }
      break;
    case PIN_MODE_I2C:
      if (IS_PIN_I2C(pin)) {
        // mark the pin as i2c
        // the user must call I2C_CONFIG to enable I2C for a device
        Firmata.setPinMode(pin, PIN_MODE_I2C);
      }
      break;
    case PIN_MODE_SERIAL:
#ifdef FIRMATA_SERIAL_FEATURE
      serialFeature.handlePinMode(pin, PIN_MODE_SERIAL);
#endif
      break;
    default:
      Firmata.sendString(&quot;Unknown pin mode&quot;); // TODO: put error msgs in EEPROM
  }
  // TODO: save status to EEPROM here, if changed
}

/*
 * Sets the value of an individual pin. Useful if you want to set a pin value but
 * are not tracking the digital port state.
 * Can only be used on pins configured as OUTPUT.
 * Cannot be used to enable pull-ups on Digital INPUT pins.
 */
void setPinValueCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS &amp;&amp; IS_PIN_DIGITAL(pin)) {
    if (Firmata.getPinMode(pin) == OUTPUT) {
      Firmata.setPinState(pin, value);
      digitalWrite(PIN_TO_DIGITAL(pin), value);
    }
  }
}

void analogWriteCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS) {
    switch (Firmata.getPinMode(pin)) {
      case PIN_MODE_SERVO:
        if (IS_PIN_DIGITAL(pin))
          servos[servoPinMap[pin]].write(value);
        Firmata.setPinState(pin, value);
        break;
      case PIN_MODE_PWM:
        if (IS_PIN_PWM(pin))
          analogWrite(PIN_TO_PWM(pin), value);
        Firmata.setPinState(pin, value);
        break;
    }
  }
}

void digitalWriteCallback(byte port, int value)
{
  byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0;

  if (port &lt; TOTAL_PORTS) {
    // create a mask of the pins on this port that are writable.
    lastPin = port * 8 + 8;
    if (lastPin &gt; TOTAL_PINS) lastPin = TOTAL_PINS;
    for (pin = port * 8; pin &lt; lastPin; pin++) {
      // do not disturb non-digital pins (eg, Rx &amp; Tx)
      if (IS_PIN_DIGITAL(pin)) {
        // do not touch pins in PWM, ANALOG, SERVO or other modes
        if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) {
          pinValue = ((byte)value &amp; mask) ? 1 : 0;
          if (Firmata.getPinMode(pin) == OUTPUT) {
            pinWriteMask |= mask;
          } else if (Firmata.getPinMode(pin) == INPUT &amp;&amp; pinValue == 1 &amp;&amp; Firmata.getPinState(pin) != 1) {
            // only handle INPUT here for backwards compatibility
#if ARDUINO &gt; 100
            pinMode(pin, INPUT_PULLUP);
#else
            // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier
            pinWriteMask |= mask;
#endif
          }
          Firmata.setPinState(pin, pinValue);
        }
      }
      mask = mask &lt;&lt; 1;
    }
    writePort(port, (byte)value, pinWriteMask);
  }
}


// -----------------------------------------------------------------------------
/* sets bits in a bit array (int) to toggle the reporting of the analogIns
 */
//void FirmataClass::setAnalogPinReporting(byte pin, byte state) {
//}
void reportAnalogCallback(byte analogPin, int value)
{
  if (analogPin &lt; TOTAL_ANALOG_PINS) {
    if (value == 0) {
      analogInputsToReport = analogInputsToReport &amp; ~ (1 &lt;&lt; analogPin);
    } else {
      analogInputsToReport = analogInputsToReport | (1 &lt;&lt; analogPin);
      // prevent during system reset or all analog pin values will be reported
      // which may report noise for unconnected analog pins
      if (!isResetting) {
        // Send pin value immediately. This is helpful when connected via
        // ethernet, wi-fi or bluetooth so pin states can be known upon
        // reconnecting.
        Firmata.sendAnalog(analogPin, analogRead(analogPin));
      }
    }
  }
  // TODO: save status to EEPROM here, if changed
}

void reportDigitalCallback(byte port, int value)
{
  if (port &lt; TOTAL_PORTS) {
    reportPINs[port] = (byte)value;
    // Send port value immediately. This is helpful when connected via
    // ethernet, wi-fi or bluetooth so pin states can be known upon
    // reconnecting.
    if (value) outputPort(port, readPort(port, portConfigInputs[port]), true);
  }
  // do not disable analog reporting on these 8 pins, to allow some
  // pins used for digital, others analog.  Instead, allow both types
  // of reporting to be enabled, but check if the pin is configured
  // as analog when sampling the analog inputs.  Likewise, while
  // scanning digital pins, portConfigInputs will mask off values from any
  // pins configured as analog
}

/*==============================================================================
 * SYSEX-BASED commands
 *============================================================================*/

void sysexCallback(byte command, byte argc, byte *argv)
{
  byte mode;
  byte stopTX;
  byte slaveAddress;
  byte data;
  int slaveRegister;
  unsigned int delayTime;

  switch (command) {
    case I2C_REQUEST:
      mode = argv[1] &amp; I2C_READ_WRITE_MODE_MASK;
      if (argv[1] &amp; I2C_10BIT_ADDRESS_MODE_MASK) {
        Firmata.sendString(&quot;10-bit addressing not supported&quot;);
        return;
      }
      else {
        slaveAddress = argv[0];
      }

      // need to invert the logic here since 0 will be default for client
      // libraries that have not updated to add support for restart tx
      if (argv[1] &amp; I2C_END_TX_MASK) {
        stopTX = I2C_RESTART_TX;
      }
      else {
        stopTX = I2C_STOP_TX; // default
      }

      switch (mode) {
        case I2C_WRITE:
          Wire.beginTransmission(slaveAddress);
          for (byte i = 2; i &lt; argc; i += 2) {
            data = argv[i] + (argv[i + 1] &lt;&lt; 7);
            wireWrite(data);
          }
          Wire.endTransmission();
          delayMicroseconds(70);
          break;
        case I2C_READ:
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX);
          break;
        case I2C_READ_CONTINUOUSLY:
          if ((queryIndex + 1) &gt;= I2C_MAX_QUERIES) {
            // too many queries, just ignore
            Firmata.sendString(&quot;too many queries&quot;);
            break;
          }
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          queryIndex++;
          query[queryIndex].addr = slaveAddress;
          query[queryIndex].reg = slaveRegister;
          query[queryIndex].bytes = data;
          query[queryIndex].stopTX = stopTX;
          break;
        case I2C_STOP_READING:
          byte queryIndexToSkip;
          // if read continuous mode is enabled for only 1 i2c device, disable
          // read continuous reporting for that device
          if (queryIndex &lt;= 0) {
            queryIndex = -1;
          } else {
            queryIndexToSkip = 0;
            // if read continuous mode is enabled for multiple devices,
            // determine which device to stop reading and remove it's data from
            // the array, shifiting other array data to fill the space
            for (byte i = 0; i &lt; queryIndex + 1; i++) {
              if (query[i].addr == slaveAddress) {
                queryIndexToSkip = i;
                break;
              }
            }

            for (byte i = queryIndexToSkip; i &lt; queryIndex + 1; i++) {
              if (i &lt; I2C_MAX_QUERIES) {
                query[i].addr = query[i + 1].addr;
                query[i].reg = query[i + 1].reg;
                query[i].bytes = query[i + 1].bytes;
                query[i].stopTX = query[i + 1].stopTX;
              }
            }
            queryIndex--;
          }
          break;
        default:
          break;
      }
      break;
    case I2C_CONFIG:
      delayTime = (argv[0] + (argv[1] &lt;&lt; 7));

      if (argc &gt; 1 &amp;&amp; delayTime &gt; 0) {
        i2cReadDelayTime = delayTime;
      }

      if (!isI2CEnabled) {
        enableI2CPins();
      }

      break;
    case SERVO_CONFIG:
      if (argc &gt; 4) {
        // these vars are here for clarity, they'll optimized away by the compiler
        byte pin = argv[0];
        int minPulse = argv[1] + (argv[2] &lt;&lt; 7);
        int maxPulse = argv[3] + (argv[4] &lt;&lt; 7);

        if (IS_PIN_DIGITAL(pin)) {
          if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
            detachServo(pin);
          }
          attachServo(pin, minPulse, maxPulse);
          setPinModeCallback(pin, PIN_MODE_SERVO);
        }
      }
      break;
    case SAMPLING_INTERVAL:
      if (argc &gt; 1) {
        samplingInterval = argv[0] + (argv[1] &lt;&lt; 7);
        if (samplingInterval &lt; MINIMUM_SAMPLING_INTERVAL) {
          samplingInterval = MINIMUM_SAMPLING_INTERVAL;
        }
      } else {
        //Firmata.sendString(&quot;Not enough data&quot;);
      }
      break;
    case EXTENDED_ANALOG:
      if (argc &gt; 1) {
        int val = argv[1];
        if (argc &gt; 2) val |= (argv[2] &lt;&lt; 7);
        if (argc &gt; 3) val |= (argv[3] &lt;&lt; 14);
        analogWriteCallback(argv[0], val);
      }
      break;
    case CAPABILITY_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(CAPABILITY_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write((byte)INPUT);
          Firmata.write(1);
          Firmata.write((byte)PIN_MODE_PULLUP);
          Firmata.write(1);
          Firmata.write((byte)OUTPUT);
          Firmata.write(1);
        }
        if (IS_PIN_ANALOG(pin)) {
          Firmata.write(PIN_MODE_ANALOG);
          Firmata.write(10); // 10 = 10-bit resolution
        }
        if (IS_PIN_PWM(pin)) {
          Firmata.write(PIN_MODE_PWM);
          Firmata.write(DEFAULT_PWM_RESOLUTION);
        }
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write(PIN_MODE_SERVO);
          Firmata.write(14);
        }
        if (IS_PIN_I2C(pin)) {
          Firmata.write(PIN_MODE_I2C);
          Firmata.write(1);  // TODO: could assign a number to map to SCL or SDA
        }
#ifdef FIRMATA_SERIAL_FEATURE
        serialFeature.handleCapability(pin);
#endif
        Firmata.write(127);
      }
      Firmata.write(END_SYSEX);
      break;
    case PIN_STATE_QUERY:
      if (argc &gt; 0) {
        byte pin = argv[0];
        Firmata.write(START_SYSEX);
        Firmata.write(PIN_STATE_RESPONSE);
        Firmata.write(pin);
        if (pin &lt; TOTAL_PINS) {
          Firmata.write(Firmata.getPinMode(pin));
          Firmata.write((byte)Firmata.getPinState(pin) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 7) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 14) &amp; 0x7F);
        }
        Firmata.write(END_SYSEX);
      }
      break;
    case ANALOG_MAPPING_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(ANALOG_MAPPING_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127);
      }
      Firmata.write(END_SYSEX);
      break;

    case SERIAL_MESSAGE:
#ifdef FIRMATA_SERIAL_FEATURE
      serialFeature.handleSysex(command, argc, argv);
#endif
      break;
  }
}

/*==============================================================================
 * SETUP()
 *============================================================================*/

void systemResetCallback()
{
  isResetting = true;

  // initialize a defalt state
  // TODO: option to load config from EEPROM instead of default

#ifdef FIRMATA_SERIAL_FEATURE
  serialFeature.reset();
#endif

  if (isI2CEnabled) {
    disableI2CPins();
  }

  for (byte i = 0; i &lt; TOTAL_PORTS; i++) {
    reportPINs[i] = false;    // by default, reporting off
    portConfigInputs[i] = 0;  // until activated
    previousPINs[i] = 0;
  }

  for (byte i = 0; i &lt; TOTAL_PINS; i++) {
    // pins with analog capability default to analog input
    // otherwise, pins default to digital output
    if (IS_PIN_ANALOG(i)) {
      // turns off pullup, configures everything
      setPinModeCallback(i, PIN_MODE_ANALOG);
    } else if (IS_PIN_DIGITAL(i)) {
      // sets the output to 0, configures portConfigInputs
      setPinModeCallback(i, OUTPUT);
    }

    servoPinMap[i] = 255;
  }
  // by default, do not report any analog inputs
  analogInputsToReport = 0;

  detachedServoCount = 0;
  servoCount = 0;

  /* send digital inputs to set the initial state on the host computer,
   * since once in the loop(), this firmware will only send on change */
  /*
  TODO: this can never execute, since no pins default to digital input
        but it will be needed when/if we support EEPROM stored config
  for (byte i=0; i &lt; TOTAL_PORTS; i++) {
    outputPort(i, readPort(i, portConfigInputs[i]), true);
  }
  */
  isResetting = false;
}

void setup()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);

  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);
  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);
  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);
  Firmata.attach(SET_PIN_MODE, setPinModeCallback);
  Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback);
  Firmata.attach(START_SYSEX, sysexCallback);
  Firmata.attach(SYSTEM_RESET, systemResetCallback);

  // Save a couple of seconds by disabling the startup blink sequence.
  Firmata.disableBlinkVersion();

  // to use a port other than Serial, such as Serial1 on an Arduino Leonardo or Mega,
  // Call begin(baud) on the alternate serial port and pass it to Firmata to begin like this:
  // Serial1.begin(57600);
  // Firmata.begin(Serial1);
  // However do not do this if you are using SERIAL_MESSAGE

  Firmata.begin(57600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for ATmega32u4-based boards and Arduino 101
  }

  systemResetCallback();  // reset to default config
}

/*==============================================================================
 * LOOP()
 *============================================================================*/
void loop()
{
  byte pin, analogPin;

  /* DIGITALREAD - as fast as possible, check for changes and output them to the
   * FTDI buffer using Serial.print()  */
  checkDigitalInputs();

  /* STREAMREAD - processing incoming messagse as soon as possible, while still
   * checking digital inputs.  */
  while (Firmata.available())
    Firmata.processInput();

  // TODO - ensure that Stream buffer doesn't go over 60 bytes

  currentMillis = millis();
  if (currentMillis - previousMillis &gt; samplingInterval) {
    previousMillis += samplingInterval;
    /* ANALOGREAD - do all analogReads() at the configured sampling interval */
    for (pin = 0; pin &lt; TOTAL_PINS; pin++) {
      if (IS_PIN_ANALOG(pin) &amp;&amp; Firmata.getPinMode(pin) == PIN_MODE_ANALOG) {
        analogPin = PIN_TO_ANALOG(pin);
        if (analogInputsToReport &amp; (1 &lt;&lt; analogPin)) {
          Firmata.sendAnalog(analogPin, analogRead(analogPin));
        }
      }
    }
    // report i2c data for all device with read continuous mode enabled
    if (queryIndex &gt; -1) {
      for (byte i = 0; i &lt; queryIndex + 1; i++) {
        readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX);
      }
    }
  }

#ifdef FIRMATA_SERIAL_FEATURE
  serialFeature.update();
#endif
}
</code></pre>
<h4 id="fritzing-circuit_37"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_37"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_37">Video Demonstration</h4>
<h3 id="5612-standardfirmatawifi">5.6.12 StandardFirmataWiFi</h3>
<h4 id="sketch-code_38">Sketch Code</h4>
<pre><code class="language-C">/*
  Firmata is a generic protocol for communicating with microcontrollers
  from software on a host computer. It is intended to work with
  any host computer software package.

  To download a host software package, please click on the following link
  to open the list of Firmata client libraries in your default browser.

  https://github.com/firmata/arduino#firmata-client-libraries

  Copyright (C) 2006-2008 Hans-Christoph Steiner.  All rights reserved.
  Copyright (C) 2010-2011 Paul Stoffregen.  All rights reserved.
  Copyright (C) 2009 Shigeru Kobayashi.  All rights reserved.
  Copyright (C) 2009-2016 Jeff Hoefs.  All rights reserved.
  Copyright (C) 2015-2016 Jesse Frush. All rights reserved.
  Copyright (C) 2016 Jens B. All rights reserved.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  See file LICENSE.txt for further informations on licensing terms.

  Last updated August 17th, 2017
*/

/*
  README

  StandardFirmataWiFi enables the use of Firmata over a TCP connection. It can be configured as
  either a TCP server or TCP client.

  To use StandardFirmataWiFi you will need to have one of the following
  boards or shields:

  - Arduino WiFi Shield (or clone)
  - Arduino WiFi Shield 101
  - Arduino MKR1000 board
  - Arduino MKRWIFI1010 board
  - ESP8266 WiFi board compatible with ESP8266 Arduino core

  Follow the instructions in the wifiConfig.h file (wifiConfig.h tab in Arduino IDE) to
  configure your particular hardware.

  Dependencies:
  - WiFi Shield 101 requires version 0.7.0 or higher of the WiFi101 library (available in Arduino
    1.6.8 or higher, or update the library via the Arduino Library Manager or clone from source:
    https://github.com/arduino-libraries/WiFi101)
  - ESP8266 requires the Arduino ESP8266 core v2.1.0 or higher which can be obtained here:
    https://github.com/esp8266/Arduino

  In order to use the WiFi Shield 101 with Firmata you will need a board with at least 35k of Flash
  memory. This means you cannot use the WiFi Shield 101 with an Arduino Uno or any other
  ATmega328p-based microcontroller or with an Arduino Leonardo or other ATmega32u4-based
  microcontroller. Some boards that will work are:

  - Arduino Zero
  - Arduino Due
  - Arduino 101
  - Arduino Mega

  NOTE: If you are using an Arduino WiFi (legacy) shield you cannot use the following pins on
  the following boards. Firmata will ignore any requests to use these pins:

  - Arduino Uno or other ATMega328 boards: (D4, D7, D10, D11, D12, D13)
  - Arduino Mega: (D4, D7, D10, D50, D51, D52, D53)
  - Arduino Due, Zero or Leonardo: (D4, D7, D10)

  If you are using an Arduino WiFi 101 shield you cannot use the following pins on the following
  boards:

  - Arduino Due or Zero: (D5, D7, D10)
  - Arduino Mega: (D5, D7, D10, D50, D52, D53)
*/

#include &lt;Servo.h&gt;
#include &lt;Wire.h&gt;
#include &lt;Firmata.h&gt;

/*
 * Uncomment the #define SERIAL_DEBUG line below to receive serial output messages relating to your
 * connection that may help in the event of connection issues. If defined, some boards may not begin
 * executing this sketch until the Serial console is opened.
 */
//#define SERIAL_DEBUG
#include &quot;utility/firmataDebug.h&quot;

/*
 * Uncomment the following include to enable interfacing with Serial devices via hardware or
 * software serial.
 */
// In order to use software serial, you will need to compile this sketch with
// Arduino IDE v1.6.6 or higher. Hardware serial should work back to Arduino 1.0.
//#include &quot;utility/SerialFirmata.h&quot;

// follow the instructions in wifiConfig.h to configure your particular hardware
#include &quot;wifiConfig.h&quot;

#define I2C_WRITE                   B00000000
#define I2C_READ                    B00001000
#define I2C_READ_CONTINUOUSLY       B00010000
#define I2C_STOP_READING            B00011000
#define I2C_READ_WRITE_MODE_MASK    B00011000
#define I2C_10BIT_ADDRESS_MODE_MASK B00100000
#define I2C_END_TX_MASK             B01000000
#define I2C_STOP_TX                 1
#define I2C_RESTART_TX              0
#define I2C_MAX_QUERIES             8
#define I2C_REGISTER_NOT_SPECIFIED  -1

// the minimum interval for sampling analog input
#define MINIMUM_SAMPLING_INTERVAL   1

#define MAX_CONN_ATTEMPTS           20  // [500 ms] -&gt; 10 s

/*==============================================================================
 * GLOBAL VARIABLES
 *============================================================================*/

#ifdef FIRMATA_SERIAL_FEATURE
SerialFirmata serialFeature;
#endif

#ifdef STATIC_IP_ADDRESS
IPAddress local_ip(STATIC_IP_ADDRESS);
#endif
#ifdef SUBNET_MASK
IPAddress subnet(SUBNET_MASK);
#endif
#ifdef GATEWAY_IP_ADDRESS
IPAddress gateway(GATEWAY_IP_ADDRESS);
#endif

int connectionAttempts = 0;
bool streamConnected = false;

/* analog inputs */
int analogInputsToReport = 0;      // bitwise array to store pin reporting

/* digital input ports */
byte reportPINs[TOTAL_PORTS];       // 1 = report this port, 0 = silence
byte previousPINs[TOTAL_PORTS];     // previous 8 bits sent

/* pins configuration */
byte portConfigInputs[TOTAL_PORTS]; // each bit: 1 = pin in INPUT, 0 = anything else

/* timer variables */
unsigned long currentMillis;        // store the current value from millis()
unsigned long previousMillis;       // for comparison with currentMillis
unsigned int samplingInterval = 19; // how often to sample analog inputs (in ms)

/* i2c data */
struct i2c_device_info {
  byte addr;
  int reg;
  byte bytes;
  byte stopTX;
};

/* for i2c read continuous mode */
i2c_device_info query[I2C_MAX_QUERIES];

byte i2cRxData[64];
boolean isI2CEnabled = false;
signed char queryIndex = -1;
// default delay time between i2c read request and Wire.requestFrom()
unsigned int i2cReadDelayTime = 0;

Servo servos[MAX_SERVOS];
byte servoPinMap[TOTAL_PINS];
byte detachedServos[MAX_SERVOS];
byte detachedServoCount = 0;
byte servoCount = 0;

boolean isResetting = false;

// Forward declare a few functions to avoid compiler errors with older versions
// of the Arduino IDE.
void setPinModeCallback(byte, int);
void reportAnalogCallback(byte analogPin, int value);
void sysexCallback(byte, byte, byte*);

/* utility functions */
void wireWrite(byte data)
{
#if ARDUINO &gt;= 100
  Wire.write((byte)data);
#else
  Wire.send(data);
#endif
}

byte wireRead(void)
{
#if ARDUINO &gt;= 100
  return Wire.read();
#else
  return Wire.receive();
#endif
}

/*==============================================================================
 * FUNCTIONS
 *============================================================================*/

void attachServo(byte pin, int minPulse, int maxPulse)
{
  if (servoCount &lt; MAX_SERVOS) {
    // reuse indexes of detached servos until all have been reallocated
    if (detachedServoCount &gt; 0) {
      servoPinMap[pin] = detachedServos[detachedServoCount - 1];
      if (detachedServoCount &gt; 0) detachedServoCount--;
    } else {
      servoPinMap[pin] = servoCount;
      servoCount++;
    }
    if (minPulse &gt; 0 &amp;&amp; maxPulse &gt; 0) {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin), minPulse, maxPulse);
    } else {
      servos[servoPinMap[pin]].attach(PIN_TO_DIGITAL(pin));
    }
  } else {
    Firmata.sendString(&quot;Max servos attached&quot;);
  }
}

void detachServo(byte pin)
{
  servos[servoPinMap[pin]].detach();
  // if we're detaching the last servo, decrement the count
  // otherwise store the index of the detached servo
  if (servoPinMap[pin] == servoCount &amp;&amp; servoCount &gt; 0) {
    servoCount--;
  } else if (servoCount &gt; 0) {
    // keep track of detached servos because we want to reuse their indexes
    // before incrementing the count of attached servos
    detachedServoCount++;
    detachedServos[detachedServoCount - 1] = servoPinMap[pin];
  }

  servoPinMap[pin] = 255;
}

void enableI2CPins()
{
  byte i;
  // is there a faster way to do this? would probaby require importing
  // Arduino.h to get SCL and SDA pins
  for (i = 0; i &lt; TOTAL_PINS; i++) {
    if (IS_PIN_I2C(i)) {
      // mark pins as i2c so they are ignore in non i2c data requests
      setPinModeCallback(i, PIN_MODE_I2C);
    }
  }

  isI2CEnabled = true;

  Wire.begin();
}

/* disable the i2c pins so they can be used for other functions */
void disableI2CPins() {
  isI2CEnabled = false;
  // disable read continuous mode for all devices
  queryIndex = -1;
}

void readAndReportData(byte address, int theRegister, byte numBytes, byte stopTX) {
  // allow I2C requests that don't require a register read
  // for example, some devices using an interrupt pin to signify new data available
  // do not always require the register read so upon interrupt you call Wire.requestFrom()
  if (theRegister != I2C_REGISTER_NOT_SPECIFIED) {
    Wire.beginTransmission(address);
    wireWrite((byte)theRegister);
    Wire.endTransmission(stopTX); // default = true
    // do not set a value of 0
    if (i2cReadDelayTime &gt; 0) {
      // delay is necessary for some devices such as WiiNunchuck
      delayMicroseconds(i2cReadDelayTime);
    }
  } else {
    theRegister = 0;  // fill the register with a dummy value
  }

  Wire.requestFrom(address, numBytes);  // all bytes are returned in requestFrom

  // check to be sure correct number of bytes were returned by slave
  if (numBytes &lt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too many bytes received&quot;);
  } else if (numBytes &gt; Wire.available()) {
    Firmata.sendString(&quot;I2C: Too few bytes received&quot;);
    numBytes = Wire.available();
  }

  i2cRxData[0] = address;
  i2cRxData[1] = theRegister;

  for (int i = 0; i &lt; numBytes &amp;&amp; Wire.available(); i++) {
    i2cRxData[2 + i] = wireRead();
  }

  // send slave address, register and received bytes
  Firmata.sendSysex(SYSEX_I2C_REPLY, numBytes + 2, i2cRxData);
}

void outputPort(byte portNumber, byte portValue, byte forceSend)
{
  // pins not configured as INPUT are cleared to zeros
  portValue = portValue &amp; portConfigInputs[portNumber];
  // only send if the value is different than previously sent
  if (forceSend || previousPINs[portNumber] != portValue) {
    Firmata.sendDigitalPort(portNumber, portValue);
    previousPINs[portNumber] = portValue;
  }
}

/* -----------------------------------------------------------------------------
 * check all the active digital inputs for change of state, then add any events
 * to the Stream output queue using Stream.write() */
void checkDigitalInputs(void)
{
  /* Using non-looping code allows constants to be given to readPort().
   * The compiler will apply substantial optimizations if the inputs
   * to readPort() are compile-time constants. */
  if (TOTAL_PORTS &gt; 0 &amp;&amp; reportPINs[0]) outputPort(0, readPort(0, portConfigInputs[0]), false);
  if (TOTAL_PORTS &gt; 1 &amp;&amp; reportPINs[1]) outputPort(1, readPort(1, portConfigInputs[1]), false);
  if (TOTAL_PORTS &gt; 2 &amp;&amp; reportPINs[2]) outputPort(2, readPort(2, portConfigInputs[2]), false);
  if (TOTAL_PORTS &gt; 3 &amp;&amp; reportPINs[3]) outputPort(3, readPort(3, portConfigInputs[3]), false);
  if (TOTAL_PORTS &gt; 4 &amp;&amp; reportPINs[4]) outputPort(4, readPort(4, portConfigInputs[4]), false);
  if (TOTAL_PORTS &gt; 5 &amp;&amp; reportPINs[5]) outputPort(5, readPort(5, portConfigInputs[5]), false);
  if (TOTAL_PORTS &gt; 6 &amp;&amp; reportPINs[6]) outputPort(6, readPort(6, portConfigInputs[6]), false);
  if (TOTAL_PORTS &gt; 7 &amp;&amp; reportPINs[7]) outputPort(7, readPort(7, portConfigInputs[7]), false);
  if (TOTAL_PORTS &gt; 8 &amp;&amp; reportPINs[8]) outputPort(8, readPort(8, portConfigInputs[8]), false);
  if (TOTAL_PORTS &gt; 9 &amp;&amp; reportPINs[9]) outputPort(9, readPort(9, portConfigInputs[9]), false);
  if (TOTAL_PORTS &gt; 10 &amp;&amp; reportPINs[10]) outputPort(10, readPort(10, portConfigInputs[10]), false);
  if (TOTAL_PORTS &gt; 11 &amp;&amp; reportPINs[11]) outputPort(11, readPort(11, portConfigInputs[11]), false);
  if (TOTAL_PORTS &gt; 12 &amp;&amp; reportPINs[12]) outputPort(12, readPort(12, portConfigInputs[12]), false);
  if (TOTAL_PORTS &gt; 13 &amp;&amp; reportPINs[13]) outputPort(13, readPort(13, portConfigInputs[13]), false);
  if (TOTAL_PORTS &gt; 14 &amp;&amp; reportPINs[14]) outputPort(14, readPort(14, portConfigInputs[14]), false);
  if (TOTAL_PORTS &gt; 15 &amp;&amp; reportPINs[15]) outputPort(15, readPort(15, portConfigInputs[15]), false);
}

// -----------------------------------------------------------------------------
// function forward declarations for xtensa compiler (ESP8266)
void enableI2CPins();
void disableI2CPins();
void reportAnalogCallback(byte analogPin, int value);

// -----------------------------------------------------------------------------
/* sets the pin mode to the correct state and sets the relevant bits in the
 * two bit-arrays that track Digital I/O and PWM status
 */
void setPinModeCallback(byte pin, int mode)
{
  if (Firmata.getPinMode(pin) == PIN_MODE_IGNORE)
    return;

  if (Firmata.getPinMode(pin) == PIN_MODE_I2C &amp;&amp; isI2CEnabled &amp;&amp; mode != PIN_MODE_I2C) {
    // disable i2c so pins can be used for other functions
    // the following if statements should reconfigure the pins properly
    disableI2CPins();
  }
  if (IS_PIN_DIGITAL(pin) &amp;&amp; mode != PIN_MODE_SERVO) {
    if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
      detachServo(pin);
    }
  }
  if (IS_PIN_ANALOG(pin)) {
    reportAnalogCallback(PIN_TO_ANALOG(pin), mode == PIN_MODE_ANALOG ? 1 : 0); // turn on/off reporting
  }
  if (IS_PIN_DIGITAL(pin)) {
    if (mode == INPUT || mode == PIN_MODE_PULLUP) {
      portConfigInputs[pin / 8] |= (1 &lt;&lt; (pin &amp; 7));
    } else {
      portConfigInputs[pin / 8] &amp;= ~(1 &lt;&lt; (pin &amp; 7));
    }
  }
  Firmata.setPinState(pin, 0);
  switch (mode) {
    case PIN_MODE_ANALOG:
      if (IS_PIN_ANALOG(pin)) {
        if (IS_PIN_DIGITAL(pin)) {
          pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
          // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
          digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        }
        Firmata.setPinMode(pin, PIN_MODE_ANALOG);
      }
      break;
    case INPUT:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT);    // disable output driver
#if ARDUINO &lt;= 100
        // deprecated since Arduino 1.0.1 - TODO: drop support in Firmata 2.6
        digitalWrite(PIN_TO_DIGITAL(pin), LOW); // disable internal pull-ups
#endif
        Firmata.setPinMode(pin, INPUT);
      }
      break;
    case PIN_MODE_PULLUP:
      if (IS_PIN_DIGITAL(pin)) {
        pinMode(PIN_TO_DIGITAL(pin), INPUT_PULLUP);
        Firmata.setPinMode(pin, PIN_MODE_PULLUP);
        Firmata.setPinState(pin, 1);
      }
      break;
    case OUTPUT:
      if (IS_PIN_DIGITAL(pin)) {
        if (Firmata.getPinMode(pin) == PIN_MODE_PWM) {
          // Disable PWM if pin mode was previously set to PWM.
          digitalWrite(PIN_TO_DIGITAL(pin), LOW);
        }
        pinMode(PIN_TO_DIGITAL(pin), OUTPUT);
        Firmata.setPinMode(pin, OUTPUT);
      }
      break;
    case PIN_MODE_PWM:
      if (IS_PIN_PWM(pin)) {
        pinMode(PIN_TO_PWM(pin), OUTPUT);
        analogWrite(PIN_TO_PWM(pin), 0);
        Firmata.setPinMode(pin, PIN_MODE_PWM);
      }
      break;
    case PIN_MODE_SERVO:
      if (IS_PIN_DIGITAL(pin)) {
        Firmata.setPinMode(pin, PIN_MODE_SERVO);
        if (servoPinMap[pin] == 255 || !servos[servoPinMap[pin]].attached()) {
          // pass -1 for min and max pulse values to use default values set
          // by Servo library
          attachServo(pin, -1, -1);
        }
      }
      break;
    case PIN_MODE_I2C:
      if (IS_PIN_I2C(pin)) {
        // mark the pin as i2c
        // the user must call I2C_CONFIG to enable I2C for a device
        Firmata.setPinMode(pin, PIN_MODE_I2C);
      }
      break;
    case PIN_MODE_SERIAL:
#ifdef FIRMATA_SERIAL_FEATURE
      serialFeature.handlePinMode(pin, PIN_MODE_SERIAL);
#endif
      break;
    default:
      Firmata.sendString(&quot;Unknown pin mode&quot;); // TODO: put error msgs in EEPROM
  }
  // TODO: save status to EEPROM here, if changed
}

/*
 * Sets the value of an individual pin. Useful if you want to set a pin value but
 * are not tracking the digital port state.
 * Can only be used on pins configured as OUTPUT.
 * Cannot be used to enable pull-ups on Digital INPUT pins.
 */
void setPinValueCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS &amp;&amp; IS_PIN_DIGITAL(pin)) {
    if (Firmata.getPinMode(pin) == OUTPUT) {
      Firmata.setPinState(pin, value);
      digitalWrite(PIN_TO_DIGITAL(pin), value);
    }
  }
}

void analogWriteCallback(byte pin, int value)
{
  if (pin &lt; TOTAL_PINS) {
    switch (Firmata.getPinMode(pin)) {
      case PIN_MODE_SERVO:
        if (IS_PIN_DIGITAL(pin))
          servos[servoPinMap[pin]].write(value);
        Firmata.setPinState(pin, value);
        break;
      case PIN_MODE_PWM:
        if (IS_PIN_PWM(pin))
          analogWrite(PIN_TO_PWM(pin), value);
        Firmata.setPinState(pin, value);
        break;
    }
  }
}

void digitalWriteCallback(byte port, int value)
{
  byte pin, lastPin, pinValue, mask = 1, pinWriteMask = 0;

  if (port &lt; TOTAL_PORTS) {
    // create a mask of the pins on this port that are writable.
    lastPin = port * 8 + 8;
    if (lastPin &gt; TOTAL_PINS) lastPin = TOTAL_PINS;
    for (pin = port * 8; pin &lt; lastPin; pin++) {
      // do not disturb non-digital pins (eg, Rx &amp; Tx)
      if (IS_PIN_DIGITAL(pin)) {
        // do not touch pins in PWM, ANALOG, SERVO or other modes
        if (Firmata.getPinMode(pin) == OUTPUT || Firmata.getPinMode(pin) == INPUT) {
          pinValue = ((byte)value &amp; mask) ? 1 : 0;
          if (Firmata.getPinMode(pin) == OUTPUT) {
            pinWriteMask |= mask;
          } else if (Firmata.getPinMode(pin) == INPUT &amp;&amp; pinValue == 1 &amp;&amp; Firmata.getPinState(pin) != 1) {
            // only handle INPUT here for backwards compatibility
#if ARDUINO &gt; 100
            pinMode(pin, INPUT_PULLUP);
#else
            // only write to the INPUT pin to enable pullups if Arduino v1.0.0 or earlier
            pinWriteMask |= mask;
#endif
          }
          Firmata.setPinState(pin, pinValue);
        }
      }
      mask = mask &lt;&lt; 1;
    }
    writePort(port, (byte)value, pinWriteMask);
  }
}


// -----------------------------------------------------------------------------
/* sets bits in a bit array (int) to toggle the reporting of the analogIns
 */
//void FirmataClass::setAnalogPinReporting(byte pin, byte state) {
//}
void reportAnalogCallback(byte analogPin, int value)
{
  if (analogPin &lt; TOTAL_ANALOG_PINS) {
    if (value == 0) {
      analogInputsToReport = analogInputsToReport &amp; ~ (1 &lt;&lt; analogPin);
    } else {
      analogInputsToReport = analogInputsToReport | (1 &lt;&lt; analogPin);
      // prevent during system reset or all analog pin values will be reported
      // which may report noise for unconnected analog pins
      if (!isResetting) {
        // Send pin value immediately. This is helpful when connected via
        // ethernet, wi-fi or bluetooth so pin states can be known upon
        // reconnecting.
        Firmata.sendAnalog(analogPin, analogRead(analogPin));
      }
    }
  }
  // TODO: save status to EEPROM here, if changed
}

void reportDigitalCallback(byte port, int value)
{
  if (port &lt; TOTAL_PORTS) {
    reportPINs[port] = (byte)value;
    // Send port value immediately. This is helpful when connected via
    // ethernet, wi-fi or bluetooth so pin states can be known upon
    // reconnecting.
    if (value) outputPort(port, readPort(port, portConfigInputs[port]), true);
  }
  // do not disable analog reporting on these 8 pins, to allow some
  // pins used for digital, others analog.  Instead, allow both types
  // of reporting to be enabled, but check if the pin is configured
  // as analog when sampling the analog inputs.  Likewise, while
  // scanning digital pins, portConfigInputs will mask off values from any
  // pins configured as analog
}

/*==============================================================================
 * SYSEX-BASED commands
 *============================================================================*/

void sysexCallback(byte command, byte argc, byte *argv)
{
  byte mode;
  byte stopTX;
  byte slaveAddress;
  byte data;
  int slaveRegister;
  unsigned int delayTime;

  switch (command) {
    case I2C_REQUEST:
      mode = argv[1] &amp; I2C_READ_WRITE_MODE_MASK;
      if (argv[1] &amp; I2C_10BIT_ADDRESS_MODE_MASK) {
        Firmata.sendString(&quot;10-bit addressing not supported&quot;);
        return;
      }
      else {
        slaveAddress = argv[0];
      }

      // need to invert the logic here since 0 will be default for client
      // libraries that have not updated to add support for restart tx
      if (argv[1] &amp; I2C_END_TX_MASK) {
        stopTX = I2C_RESTART_TX;
      }
      else {
        stopTX = I2C_STOP_TX; // default
      }

      switch (mode) {
        case I2C_WRITE:
          Wire.beginTransmission(slaveAddress);
          for (byte i = 2; i &lt; argc; i += 2) {
            data = argv[i] + (argv[i + 1] &lt;&lt; 7);
            wireWrite(data);
          }
          Wire.endTransmission();
          delayMicroseconds(70);
          break;
        case I2C_READ:
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          readAndReportData(slaveAddress, (int)slaveRegister, data, stopTX);
          break;
        case I2C_READ_CONTINUOUSLY:
          if ((queryIndex + 1) &gt;= I2C_MAX_QUERIES) {
            // too many queries, just ignore
            Firmata.sendString(&quot;too many queries&quot;);
            break;
          }
          if (argc == 6) {
            // a slave register is specified
            slaveRegister = argv[2] + (argv[3] &lt;&lt; 7);
            data = argv[4] + (argv[5] &lt;&lt; 7);  // bytes to read
          }
          else {
            // a slave register is NOT specified
            slaveRegister = (int)I2C_REGISTER_NOT_SPECIFIED;
            data = argv[2] + (argv[3] &lt;&lt; 7);  // bytes to read
          }
          queryIndex++;
          query[queryIndex].addr = slaveAddress;
          query[queryIndex].reg = slaveRegister;
          query[queryIndex].bytes = data;
          query[queryIndex].stopTX = stopTX;
          break;
        case I2C_STOP_READING:
          byte queryIndexToSkip;
          // if read continuous mode is enabled for only 1 i2c device, disable
          // read continuous reporting for that device
          if (queryIndex &lt;= 0) {
            queryIndex = -1;
          } else {
            queryIndexToSkip = 0;
            // if read continuous mode is enabled for multiple devices,
            // determine which device to stop reading and remove it's data from
            // the array, shifiting other array data to fill the space
            for (byte i = 0; i &lt; queryIndex + 1; i++) {
              if (query[i].addr == slaveAddress) {
                queryIndexToSkip = i;
                break;
              }
            }

            for (byte i = queryIndexToSkip; i &lt; queryIndex + 1; i++) {
              if (i &lt; I2C_MAX_QUERIES) {
                query[i].addr = query[i + 1].addr;
                query[i].reg = query[i + 1].reg;
                query[i].bytes = query[i + 1].bytes;
                query[i].stopTX = query[i + 1].stopTX;
              }
            }
            queryIndex--;
          }
          break;
        default:
          break;
      }
      break;
    case I2C_CONFIG:
      delayTime = (argv[0] + (argv[1] &lt;&lt; 7));

      if (argc &gt; 1 &amp;&amp; delayTime &gt; 0) {
        i2cReadDelayTime = delayTime;
      }

      if (!isI2CEnabled) {
        enableI2CPins();
      }

      break;
    case SERVO_CONFIG:
      if (argc &gt; 4) {
        // these vars are here for clarity, they'll optimized away by the compiler
        byte pin = argv[0];
        int minPulse = argv[1] + (argv[2] &lt;&lt; 7);
        int maxPulse = argv[3] + (argv[4] &lt;&lt; 7);

        if (IS_PIN_DIGITAL(pin)) {
          if (servoPinMap[pin] &lt; MAX_SERVOS &amp;&amp; servos[servoPinMap[pin]].attached()) {
            detachServo(pin);
          }
          attachServo(pin, minPulse, maxPulse);
          setPinModeCallback(pin, PIN_MODE_SERVO);
        }
      }
      break;
    case SAMPLING_INTERVAL:
      if (argc &gt; 1) {
        samplingInterval = argv[0] + (argv[1] &lt;&lt; 7);
        if (samplingInterval &lt; MINIMUM_SAMPLING_INTERVAL) {
          samplingInterval = MINIMUM_SAMPLING_INTERVAL;
        }
      } else {
        //Firmata.sendString(&quot;Not enough data&quot;);
      }
      break;
    case EXTENDED_ANALOG:
      if (argc &gt; 1) {
        int val = argv[1];
        if (argc &gt; 2) val |= (argv[2] &lt;&lt; 7);
        if (argc &gt; 3) val |= (argv[3] &lt;&lt; 14);
        analogWriteCallback(argv[0], val);
      }
      break;
    case CAPABILITY_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(CAPABILITY_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write((byte)INPUT);
          Firmata.write(1);
          Firmata.write((byte)PIN_MODE_PULLUP);
          Firmata.write(1);
          Firmata.write((byte)OUTPUT);
          Firmata.write(1);
        }
        if (IS_PIN_ANALOG(pin)) {
          Firmata.write(PIN_MODE_ANALOG);
          Firmata.write(10); // 10 = 10-bit resolution
        }
        if (IS_PIN_PWM(pin)) {
          Firmata.write(PIN_MODE_PWM);
          Firmata.write(DEFAULT_PWM_RESOLUTION);
        }
        if (IS_PIN_DIGITAL(pin)) {
          Firmata.write(PIN_MODE_SERVO);
          Firmata.write(14);
        }
        if (IS_PIN_I2C(pin)) {
          Firmata.write(PIN_MODE_I2C);
          Firmata.write(1);  // TODO: could assign a number to map to SCL or SDA
        }
#ifdef FIRMATA_SERIAL_FEATURE
        serialFeature.handleCapability(pin);
#endif
        Firmata.write(127);
      }
      Firmata.write(END_SYSEX);
      break;
    case PIN_STATE_QUERY:
      if (argc &gt; 0) {
        byte pin = argv[0];
        Firmata.write(START_SYSEX);
        Firmata.write(PIN_STATE_RESPONSE);
        Firmata.write(pin);
        if (pin &lt; TOTAL_PINS) {
          Firmata.write(Firmata.getPinMode(pin));
          Firmata.write((byte)Firmata.getPinState(pin) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xFF80) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 7) &amp; 0x7F);
          if (Firmata.getPinState(pin) &amp; 0xC000) Firmata.write((byte)(Firmata.getPinState(pin) &gt;&gt; 14) &amp; 0x7F);
        }
        Firmata.write(END_SYSEX);
      }
      break;
    case ANALOG_MAPPING_QUERY:
      Firmata.write(START_SYSEX);
      Firmata.write(ANALOG_MAPPING_RESPONSE);
      for (byte pin = 0; pin &lt; TOTAL_PINS; pin++) {
        Firmata.write(IS_PIN_ANALOG(pin) ? PIN_TO_ANALOG(pin) : 127);
      }
      Firmata.write(END_SYSEX);
      break;

    case SERIAL_MESSAGE:
#ifdef FIRMATA_SERIAL_FEATURE
      serialFeature.handleSysex(command, argc, argv);
#endif
      break;
  }
}

/*==============================================================================
 * SETUP()
 *============================================================================*/

void systemResetCallback()
{
  isResetting = true;

  // initialize a defalt state
  // TODO: option to load config from EEPROM instead of default

#ifdef FIRMATA_SERIAL_FEATURE
  serialFeature.reset();
#endif

  if (isI2CEnabled) {
    disableI2CPins();
  }

  for (byte i = 0; i &lt; TOTAL_PORTS; i++) {
    reportPINs[i] = false;    // by default, reporting off
    portConfigInputs[i] = 0;  // until activated
    previousPINs[i] = 0;
  }

  for (byte i = 0; i &lt; TOTAL_PINS; i++) {
    // pins with analog capability default to analog input
    // otherwise, pins default to digital output
    if (IS_PIN_ANALOG(i)) {
      // turns off pullup, configures everything
      setPinModeCallback(i, PIN_MODE_ANALOG);
    } else if (IS_PIN_DIGITAL(i)) {
      // sets the output to 0, configures portConfigInputs
      setPinModeCallback(i, OUTPUT);
    }

    servoPinMap[i] = 255;
  }
  // by default, do not report any analog inputs
  analogInputsToReport = 0;

  detachedServoCount = 0;
  servoCount = 0;

  /* send digital inputs to set the initial state on the host computer,
   * since once in the loop(), this firmware will only send on change */
  /*
  TODO: this can never execute, since no pins default to digital input
        but it will be needed when/if we support EEPROM stored config
  for (byte i=0; i &lt; TOTAL_PORTS; i++) {
    outputPort(i, readPort(i, portConfigInputs[i]), true);
  }
  */
  isResetting = false;
}

/*
 * Called when a TCP connection is either connected or disconnected.
 * TODO:
 * - report connected or reconnected state to host (to be added to protocol)
 * - report current state to host (to be added to protocol)
 */
void hostConnectionCallback(byte state)
{
  switch (state) {
    case HOST_CONNECTION_CONNECTED:
      DEBUG_PRINTLN( &quot;TCP connection established&quot; );
      break;
    case HOST_CONNECTION_DISCONNECTED:
      DEBUG_PRINTLN( &quot;TCP connection disconnected&quot; );
      break;
  }
}

/*
 * Print the status of the WiFi connection. This is the connection to the access point rather
 * than the TCP connection.
 */
void printWifiStatus() {
  if ( WiFi.status() != WL_CONNECTED )
  {
    DEBUG_PRINT( &quot;WiFi connection failed. Status value: &quot; );
    DEBUG_PRINTLN( WiFi.status() );
  }
  else
  {
    // print the SSID of the network you're attached to:
    DEBUG_PRINT( &quot;SSID: &quot; );
    DEBUG_PRINTLN( WiFi.SSID() );

    // print your WiFi shield's IP address:
    DEBUG_PRINT( &quot;IP Address: &quot; );
    IPAddress ip = WiFi.localIP();
    DEBUG_PRINTLN( ip );

    // print the received signal strength:
    DEBUG_PRINT( &quot;signal strength (RSSI): &quot; );
    long rssi = WiFi.RSSI();
    DEBUG_PRINT( rssi );
    DEBUG_PRINTLN( &quot; dBm&quot; );
  }
}

/*
 * StandardFirmataWiFi communicates with WiFi shields over SPI. Therefore all
 * SPI pins must be set to IGNORE. Otherwise Firmata would break SPI communication.
 * Additional pins may also need to be ignored depending on the particular board or
 * shield in use.
 */
void ignorePins()
{
#ifdef IS_IGNORE_PIN
  for (byte i = 0; i &lt; TOTAL_PINS; i++) {
    if (IS_IGNORE_PIN(i)) {
      Firmata.setPinMode(i, PIN_MODE_IGNORE);
    }
  }
#endif

  //Set up controls for the Arduino WiFi Shield SS for the SD Card
#ifdef ARDUINO_WIFI_SHIELD
  // Arduino WiFi Shield has SD SS wired to D4
  pinMode(PIN_TO_DIGITAL(4), OUTPUT);    // switch off SD card bypassing Firmata
  digitalWrite(PIN_TO_DIGITAL(4), HIGH); // SS is active low;

#if defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)
  pinMode(PIN_TO_DIGITAL(53), OUTPUT); // configure hardware SS as output on MEGA
#endif //defined(__AVR_ATmega1280__) || defined(__AVR_ATmega2560__)

#endif //ARDUINO_WIFI_SHIELD
}

void initTransport()
{
  // This statement will clarify how a connection is being made
  DEBUG_PRINT( &quot;StandardFirmataWiFi will attempt a WiFi connection &quot; );
#if defined(WIFI_101)
  DEBUG_PRINTLN( &quot;using the WiFi 101 library.&quot; );
#elif defined(ARDUINO_WIFI_SHIELD)
  DEBUG_PRINTLN( &quot;using the legacy WiFi library.&quot; );
#elif defined(ESP8266_WIFI)
  DEBUG_PRINTLN( &quot;using the ESP8266 WiFi library.&quot; );
#elif defined(HUZZAH_WIFI)
  DEBUG_PRINTLN( &quot;using the HUZZAH WiFi library.&quot; );
#elif defined(WIFI_NINA)
  DEBUG_PRINTLN( &quot;using the WiFi NINA library.&quot; );
  //else should never happen here as error-checking in wifiConfig.h will catch this
#endif  //defined(WIFI_101)

  // Configure WiFi IP Address
#ifdef STATIC_IP_ADDRESS
  DEBUG_PRINT( &quot;Using static IP: &quot; );
  DEBUG_PRINTLN( local_ip );
#if defined(ESP8266_WIFI) || (defined(SUBNET_MASK) &amp;&amp; defined(GATEWAY_IP_ADDRESS))
  stream.config( local_ip , gateway, subnet );
#else
  // you can also provide a static IP in the begin() functions, but this simplifies
  // ifdef logic in this sketch due to support for all different encryption types.
  stream.config( local_ip );
#endif
#else
  DEBUG_PRINTLN( &quot;IP will be requested from DHCP ...&quot; );
#endif

  stream.attach(hostConnectionCallback);

  // Configure WiFi security and initiate WiFi connection
#if defined(WIFI_WEP_SECURITY)
  DEBUG_PRINT( &quot;Attempting to connect to WEP SSID: &quot; );
  DEBUG_PRINTLN(ssid);
  stream.begin(ssid, wep_index, wep_key);
#elif defined(WIFI_WPA_SECURITY)
  DEBUG_PRINT( &quot;Attempting to connect to WPA SSID: &quot; );
  DEBUG_PRINTLN(ssid);
  stream.begin(ssid, wpa_passphrase);
#else                          //OPEN network
  DEBUG_PRINTLN( &quot;Attempting to connect to open SSID: &quot; );
  DEBUG_PRINTLN(ssid);
  stream.begin(ssid);
#endif //defined(WIFI_WEP_SECURITY)
  DEBUG_PRINTLN( &quot;WiFi setup done&quot; );

  // Wait for connection to access point to be established.
  while (WiFi.status() != WL_CONNECTED &amp;&amp; ++connectionAttempts &lt;= MAX_CONN_ATTEMPTS) {
    delay(500);
    DEBUG_PRINT(&quot;.&quot;);
  }
  printWifiStatus();
}

void initFirmata()
{
  Firmata.setFirmwareVersion(FIRMATA_FIRMWARE_MAJOR_VERSION, FIRMATA_FIRMWARE_MINOR_VERSION);
  Firmata.attach(ANALOG_MESSAGE, analogWriteCallback);
  Firmata.attach(DIGITAL_MESSAGE, digitalWriteCallback);
  Firmata.attach(REPORT_ANALOG, reportAnalogCallback);
  Firmata.attach(REPORT_DIGITAL, reportDigitalCallback);
  Firmata.attach(SET_PIN_MODE, setPinModeCallback);
  Firmata.attach(SET_DIGITAL_PIN_VALUE, setPinValueCallback);
  Firmata.attach(START_SYSEX, sysexCallback);
  Firmata.attach(SYSTEM_RESET, systemResetCallback);

  ignorePins();

  // Initialize Firmata to use the WiFi stream object as the transport.
  Firmata.begin(stream);
  systemResetCallback();  // reset to default config
}

void setup()
{
  DEBUG_BEGIN(9600);

  initTransport();

  initFirmata();
}

/*==============================================================================
 * LOOP()
 *============================================================================*/
void loop()
{
  byte pin, analogPin;

  /* DIGITALREAD - as fast as possible, check for changes and output them to the
   * Stream buffer using Stream.write()  */
  checkDigitalInputs();

  /* STREAMREAD - processing incoming messagse as soon as possible, while still
   * checking digital inputs.  */
  while (Firmata.available()) {
    Firmata.processInput();
  }

  // TODO - ensure that Stream buffer doesn't go over 60 bytes

  currentMillis = millis();
  if (currentMillis - previousMillis &gt; samplingInterval) {
    previousMillis += samplingInterval;
    /* ANALOGREAD - do all analogReads() at the configured sampling interval */
    for (pin = 0; pin &lt; TOTAL_PINS; pin++) {
      if (IS_PIN_ANALOG(pin) &amp;&amp; Firmata.getPinMode(pin) == PIN_MODE_ANALOG) {
        analogPin = PIN_TO_ANALOG(pin);
        if (analogInputsToReport &amp; (1 &lt;&lt; analogPin)) {
          Firmata.sendAnalog(analogPin, analogRead(analogPin));
        }
      }
    }
    // report i2c data for all device with read continuous mode enabled
    if (queryIndex &gt; -1) {
      for (byte i = 0; i &lt; queryIndex + 1; i++) {
        readAndReportData(query[i].addr, query[i].reg, query[i].bytes, query[i].stopTX);
      }
    }
  }

#ifdef FIRMATA_SERIAL_FEATURE
  serialFeature.update();
#endif

  stream.maintain();
}
</code></pre>
<h4 id="fritzing-circuit_38"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_38"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_38">Video Demonstration</h4>
<h2 id="section-57-keyboard">Section 5.7: Keyboard</h2>
<h3 id="571-serial">5.7.1 Serial</h3>
<h4 id="sketch-code_39">Sketch Code</h4>
<pre><code class="language-C">/*
  Keyboard test

  For the Arduino Leonardo, Micro or Due

  Reads a byte from the serial port, sends a keystroke back.
  The sent keystroke is one higher than what's received, e.g. if you send a,
  you get b, send A you get B, and so forth.

  The circuit:
  - none

  created 21 Oct 2011
  modified 27 Mar 2012
  by Tom Igoe

  This example code is in the public domain.

  https://www.arduino.cc/en/Tutorial/BuiltInExamples/KeyboardSerial
*/

#include &quot;Keyboard.h&quot;

void setup() {
  // open the serial port:
  Serial.begin(9600);
  // initialize control over the keyboard:
  Keyboard.begin();
}

void loop() {
  // check for incoming serial data:
  if (Serial.available() &gt; 0) {
    // read incoming serial data:
    char inChar = Serial.read();
    // Type the next ASCII value from what you received:
    Keyboard.write(inChar + 1);
  }
}
</code></pre>
<h4 id="fritzing-circuit_39"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<p>N/A</p>
<h4 id="kicad-schematic_39"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<p>N/A</p>
<h4 id="video-demonstration_39">Video Demonstration</h4>
<h2 id="section-58-led_matrix">Section 5.8: LED_Matrix</h2>
<h3 id="581-displaysingleframe">5.8.1 DisplaySingleFrame</h3>
<h4 id="sketch-code_40">Sketch Code</h4>
<pre><code class="language-C">/*
  Single Frame

  Displays single frames using matrix.loadFrame

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix
*/

#include &quot;Arduino_LED_Matrix.h&quot;   // Include the LED_Matrix library
#include &quot;frames.h&quot;               // Include a header file containing frame data

ArduinoLEDMatrix matrix;          // Create an instance of the ArduinoLEDMatrix class

void setup() {
  Serial.begin(115200);           // Initialize serial communication at a baud rate of 115200
  matrix.begin();                 // Initialize the LED matrix
}

void loop() {
  // Load and display the &quot;chip&quot; frame on the LED matrix
  matrix.loadFrame(chip);
  delay(500);  // Pause for 500 milliseconds (half a second)

  // Load and display the &quot;danger&quot; frame on the LED matrix
  matrix.loadFrame(danger);
  delay(500);

  // Load and display the &quot;happy&quot; frame on the LED matrix
  matrix.loadFrame(happy);
  delay(500);

  // Load and display the &quot;heart&quot; frame on the LED matrix
  matrix.loadFrame(heart);
  delay(500);

  // Print the current value of millis() to the serial monitor
  Serial.println(millis());
}
</code></pre>
<h4 id="fritzing-circuit_40"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_40"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_40">Video Demonstration</h4>
<h3 id="582-gameoflife">5.8.2 GameOfLife</h3>
<h4 id="sketch-code_41">Sketch Code</h4>
<pre><code class="language-C">/*
  Game Of Life

  The Game of Life, also known simply as Life, is a cellular automaton devised 
  by the British mathematician John Horton Conway in 1970. It is a zero-player game, 
  meaning that its evolution is determined by its initial state, requiring no further 
  input.

  Example developed starting from Toby Oxborrow's sketch
  https://github.com/tobyoxborrow/gameoflife-arduino/blob/master/GameOfLife.ino

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix
*/

#include &quot;Arduino_LED_Matrix.h&quot; // Include the LED_Matrix library

// grid dimensions. should not be larger than 8x8
#define MAX_Y 8
#define MAX_X 12

// time to wait between turns
#define TURN_DELAY 200

// how many turns per game before starting a new game
// you can also use the reset button on the board
#define TURNS_MAX 60

// number of patterns in predefined list
#define MAX_PATTERNS 4

// how many turns to wait if there are no changes before starting a new game
#define NO_CHANGES_RESET 4

int turns = 0;       // counter for turns
int noChanges = 0;  // counter for turns without changes

// game state. 0 is dead cell, 1 is live cell
uint8_t grid[MAX_Y][MAX_X] = {
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
};

int currentPattern = 0;

String patternNames[] = {
  &quot;Glider&quot;,
  &quot;Light-weight spaceship&quot;,
  &quot;R-Pentomino&quot;,
  &quot;Diehard&quot;
};

// custom starting grid patterns
boolean cGrids[][MAX_Y][MAX_X] = {
    { /* Glider */
        {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    { /* Light-weight spaceship */
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0},
        {0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0},
        {0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    { /* R-Pentomino */
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    },
    { /* Die hard */
        {0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0},
        {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
        {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
    }
};


ArduinoLEDMatrix matrix;

void setup() {
  Serial.begin(9600);
  delay(1000);

  Serial.println(&quot;Conway's game of life on Arduino LED Matrix&quot;);
  matrix.begin();

  resetGrid();
  displayGrid();

}

void loop() {
  delay(TURN_DELAY);

  playGoL();

  turns++;

  // reset the grid if no changes have occured recently
  // for when the game enters a static stable state
  if (noChanges &gt; NO_CHANGES_RESET) {
    resetGrid();

  }
  // reset the grid if the loop has been running a long time
  // for when the game cycles between a few stable states
  if (turns &gt; TURNS_MAX) {
    resetGrid();
  }

  displayGrid();
}

// play game of life
void playGoL() {
  /*
    1. Any live cell with fewer than two neighbours dies, as if by loneliness.
    2. Any live cell with more than three neighbours dies, as if by
    overcrowding.
    3. Any live cell with two or three neighbours lives, unchanged, to the next
    generation.
    4. Any dead cell with exactly three neighbours comes to life.
    */

  boolean newGrid[MAX_Y][MAX_X] = {
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}, 
      {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  };

  for (int y = 0; y &lt; MAX_Y; y++) {
    for (int x = 0; x &lt; MAX_X; x++) {
      int neighboughs = countNeighbours(y, x);
      if (grid[y][x] == 1) {
        if ((neighboughs == 2) || (neighboughs == 3)) {
          newGrid[y][x] = 1;
        } else {
          newGrid[y][x] = 0;
        }
      } else {
        if (neighboughs == 3) {
          newGrid[y][x] = 1;
        } else {
          newGrid[y][x] = 0;
        }
      }
    }
  }

  // update the current grid from the new grid and count how many changes
  // occured
  int changes = 0;
  for (int y = 0; y &lt; MAX_Y; y++) {
    for (int x = 0; x &lt; MAX_X; x++) {
      if (newGrid[y][x] != grid[y][x]) {
        changes++;
      }
      grid[y][x] = newGrid[y][x];
    }
  }

  // update global counter when no changes occured
  if (changes == 0) {
    noChanges++;
  }
}

// count the number of neighbour live cells for a given cell
int countNeighbours(int y, int x) {
  int count = 0;

  // -- Row above us ---
  if (y &gt; 0) {
    // above left
    if (x &gt; 0) {
      count += grid[y - 1][x - 1];
    }
    // above
    count += grid[y - 1][x];
    // above right
    if ((x + 1) &lt; 8) {
      count += grid[y - 1][x + 1];
    }
  }

  // -- Same row -------
  // left
  if (x &gt; 0) {
    count += grid[y][x - 1];
  }
  // right
  if ((x + 1) &lt; 8) {
    count += grid[y][x + 1];
  }

  // -- Row below us ---
  if ((y + 1) &lt; 8) {
    // below left
    if (x &gt; 0) {
      count += grid[y + 1][x - 1];
    }
    // below
    count += grid[y + 1][x];
    // below right
    if ((x + 1) &lt; 8) {
      count += grid[y + 1][x + 1];
    }
  }

  return count;
}

// reset the grid
void resetGrid() {
  Serial.print(&quot;Current pattern: &quot;);
  Serial.println(patternNames[currentPattern]);
  noChanges = 0;
  turns = 0;

  for (int y = 0; y &lt; MAX_Y; y++) {
    for (int x = 0; x &lt; MAX_X; x++) {
      grid[y][x] = cGrids[currentPattern][y][x];
    }
  }
  currentPattern++;
  if(currentPattern &gt;= MAX_PATTERNS){
    currentPattern = 0;
  }
}

// display the current grid to the LED matrix
void displayGrid() {
  matrix.renderBitmap(grid, 8, 12);
}
</code></pre>
<h4 id="fritzing-circuit_41"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_41"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_41">Video Demonstration</h4>
<h3 id="583-livepreview">5.8.3 LivePreview</h3>
<h4 id="sketch-code_42">Sketch Code</h4>
<pre><code class="language-C">/*
  This sketch allows live editing of the matrix pixels using WebSerial
  To test, head to https://ledmatrix-editor.arduino.cc

  The LED Matrix editor is part of Arduino Labs (https://labs.arduino.cc/), and is therefore considered experimental software.

  Don't forget to close any serial monitor already opened.

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix  
*/

#include &quot;Arduino_LED_Matrix.h&quot; // Include the LED_Matrix library

ArduinoLEDMatrix matrix;        // Create an instance of the ArduinoLEDMatrix class

void setup() {
  Serial.begin(115200);         // Initialize serial communication at a baud rate of 115200
  matrix.begin();               // Initialize the LED matrix
}

// Define an array to hold pixel data for a single frame (4 pixels)
uint32_t frame[] = {
  0, 0, 0, 0xFFFF
};

void loop() {
  // Check if there are at least 12 bytes available in the serial buffer
  if(Serial.available() &gt;= 12){
    // Read 4 bytes from the serial buffer and compose them into a 32-bit value for each element in the frame
    frame[0] = Serial.read() | Serial.read() &lt;&lt; 8 | Serial.read() &lt;&lt; 16 | Serial.read() &lt;&lt; 24;
    frame[1] = Serial.read() | Serial.read() &lt;&lt; 8 | Serial.read() &lt;&lt; 16 | Serial.read() &lt;&lt; 24;
    frame[2] = Serial.read() | Serial.read() &lt;&lt; 8 | Serial.read() &lt;&lt; 16 | Serial.read() &lt;&lt; 24;

     // Load and display the received frame data on the LED matrix
    matrix.loadFrame(frame);
  }
}
</code></pre>
<h4 id="fritzing-circuit_42"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_42"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_42">Video Demonstration</h4>
<h3 id="584-matrixframebuffer">5.8.4 MatrixFrameBuffer</h3>
<h4 id="sketch-code_43">Sketch Code</h4>
<pre><code class="language-C">/*
  Matrix Frame Buffer

  This Arduino sketch demonstrates the creation and manipulation of 
  a frame buffer for the LED matrix. The frame buffer is used to control 
  the lighting of individual LEDs on the matrix, turning them randomly on and off.

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix
*/

// Include the LED_Matrix library
#include &quot;Arduino_LED_Matrix.h&quot;  

// Create an instance of the ArduinoLEDMatrix class
ArduinoLEDMatrix matrix;        

// Define the frame array for the LED matrix with pixel values
uint8_t frame[8][12] = {
  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }, 
  { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 },
  { 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0 },
  { 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 }
};

// Set up time intervals and dimensions for the matrix
unsigned long lastTickTime, lastGameTickTime;
#define UPDATE_INTERVAL 100
#define GAME_UPDATE_INTERVAL 66

#define ROWS 8
#define COLUMNS 12

// Variables to track the current positions
uint8_t pointX = 0, pointY = 0;

void setup() {
  // Initialize serial communication and delaying for setup
  Serial.begin(115200);
  delay(1500);

  // Initialize the LED matrix
  matrix.begin();

  // Initialize time tracking variables
  lastGameTickTime = lastTickTime = millis();
}

void loop() {
  // Track the current time
  unsigned long msNow = millis();

  // Update the game logic with a fixed interval
  if (msNow - lastGameTickTime &gt; GAME_UPDATE_INTERVAL) {
    // Increment pointX and handling wraparound
    pointX++;
    if (pointX &gt;= COLUMNS) {
      pointX = 0;
      pointY++;
      if (pointY &gt;= ROWS) {
        pointY = 0;
      }
    }

    // Generate random positions and pixel value
    pointX = random(COLUMNS);
    pointY = random(ROWS);
    uint8_t pixelValue = random(2);

    // Update the frame with the new pixel value
    frame[pointY][pointX] = pixelValue;

    // Update the last game tick time
    lastGameTickTime = msNow;
  }

  // Render the LED matrix with the current frame at a fixed interval
  if (msNow - lastTickTime &gt; UPDATE_INTERVAL) {
    matrix.renderBitmap(frame, 8, 12);

    // Update the last rendering tick time
    lastTickTime = msNow;
  }
}
</code></pre>
<h4 id="fritzing-circuit_43"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_43"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_43">Video Demonstration</h4>
<h3 id="585-matrixintro">5.8.5 MatrixIntro</h3>
<h4 id="sketch-code_44">Sketch Code</h4>
<pre><code class="language-C">/*
  Heart Animation Sketch

  This is the default sketch that comes
  shipped with every UNO R4 WiFi board.

  After the animation (a heart) is complete,
  the built-in LED blinks infinitely.

  No additional circuit required.

  created 26 Jun 2023
  by Martino Facchin

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix
*/


// include the LED Matrix library from the Uno R4 core:
#include &quot;Arduino_LED_Matrix.h&quot;
// make an instance of the library:
ArduinoLEDMatrix matrix;
//include the &quot;animation.h&quot; header file that stores the frames for the animation 
#include &quot;animation.h&quot;

void setup() {
  Serial.begin(115200);
  //load frames from the animation.h file
  matrix.loadSequence(frames);
  // start the matrix
  matrix.begin();

  // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds
  // matrix.autoscroll(300);

  //play the animation on the matrix
  matrix.play(true);

  //define LED_BUILTIN as an output
  pinMode(LED_BUILTIN, OUTPUT);
}

void loop() {
  //blinks the built-in LED every second
  digitalWrite(LED_BUILTIN, HIGH);
  delay(1000);
  digitalWrite(LED_BUILTIN, LOW);
  delay(1000);
}
</code></pre>
<h4 id="fritzing-circuit_44"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_44"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_44">Video Demonstration</h4>
<h3 id="586-playanimation">5.8.6 PlayAnimation</h3>
<h4 id="sketch-code_45">Sketch Code</h4>
<pre><code class="language-C">/*
  Play Animation

  Sketch shows animation defined in animation.h

  See the full documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/led-matrix
*/



#include &quot;Arduino_LED_Matrix.h&quot;   //Include the LED_Matrix library
#include &quot;animation.h&quot;            //Include animation.h header file

// Create an instance of the ArduinoLEDMatrix class
ArduinoLEDMatrix matrix;  

void setup() {
  Serial.begin(115200);
  // you can also load frames at runtime, without stopping the refresh
  matrix.loadSequence(animation);
  matrix.begin();
  // turn on autoscroll to avoid calling next() to show the next frame; the paramenter is in milliseconds
  // matrix.autoscroll(300);
  matrix.play(true);
}

void loop() {
  delay(500);
  Serial.println(millis());
}
</code></pre>
<h4 id="fritzing-circuit_45"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_45"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_45">Video Demonstration</h4>
<h3 id="587-textwitharduinographics">5.8.7 TextWithArduinoGraphics</h3>
<h4 id="sketch-code_46">Sketch Code</h4>
<pre><code class="language-C">// To use ArduinoGraphics APIs, please include BEFORE Arduino_LED_Matrix
#include &quot;ArduinoGraphics.h&quot;
#include &quot;Arduino_LED_Matrix.h&quot;

ArduinoLEDMatrix matrix;

void setup() {
  Serial.begin(115200);
  matrix.begin();

  matrix.beginDraw();
  matrix.stroke(0xFFFFFFFF);
  // add some static text
  // will only show &quot;UNO&quot; (not enough space on the display)
  const char text[] = &quot;UNO r4&quot;;
  matrix.textFont(Font_4x6);
  matrix.beginText(0, 1, 0xFFFFFF);
  matrix.println(text);
  matrix.endText();

  matrix.endDraw();

  delay(2000);
}

void loop() {

  // Make it scroll!
  matrix.beginDraw();

  matrix.stroke(0xFFFFFFFF);
  matrix.textScrollSpeed(50);

  // add the text
  const char text[] = &quot;    Scrolling text!    &quot;;
  matrix.textFont(Font_5x7);
  matrix.beginText(0, 1, 0xFFFFFF);
  matrix.println(text);
  matrix.endText(SCROLL_LEFT);

  matrix.endDraw();
}```


#### [Fritzing] Circuit



#### [KiCad] Schematic




#### Video Demonstration




[Fritzing]: https://fritzing.org/
[KiCad]: https://www.kicad.org/
[Arduino]: https://arduino.cc
[Microcontroller]: https://en.wikipedia.org/wiki/Microcontroller


## Section 5.9: LiquidCrystal

### 5.9.1 Autoscroll

#### Sketch Code

```C
/*
  LiquidCrystal Library - Autoscroll

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch demonstrates the use of the autoscroll()
 and noAutoscroll() functions to make new text scroll or not.

 The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe
 modified 7 Nov 2016
 by Arturo Guadalupi

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystalAutoscroll

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
}

void loop() {
  // set the cursor to (0,0):
  lcd.setCursor(0, 0);
  // print from 0 to 9:
  for (int thisChar = 0; thisChar &lt; 10; thisChar++) {
    lcd.print(thisChar);
    delay(500);
  }

  // set the cursor to (16,1):
  lcd.setCursor(16, 1);
  // set the display to automatically scroll:
  lcd.autoscroll();
  // print from 0 to 9:
  for (int thisChar = 0; thisChar &lt; 10; thisChar++) {
    lcd.print(thisChar);
    delay(500);
  }
  // turn off automatic scrolling
  lcd.noAutoscroll();

  // clear screen for the next loop:
  lcd.clear();
}
</code></pre>
<h4 id="fritzing-circuit_46"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_46"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_46">Video Demonstration</h4>
<h3 id="592-blink">5.9.2 Blink</h3>
<h4 id="sketch-code_47">Sketch Code</h4>
<pre><code class="language-C">/*
  LiquidCrystal Library - Blink

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch prints &quot;Hello World!&quot; to the LCD and makes the
 cursor block blink.

 The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * 10K resistor:
   * ends to +5V and ground
   * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe
 modified 7 Nov 2016
 by Arturo Guadalupi

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystalBlink

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // Print a message to the LCD.
  lcd.print(&quot;hello, world!&quot;);
}

void loop() {
  // Turn off the blinking cursor:
  lcd.noBlink();
  delay(3000);
  // Turn on the blinking cursor:
  lcd.blink();
  delay(3000);
}
</code></pre>
<h4 id="fritzing-circuit_47"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_47"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_47">Video Demonstration</h4>
<h3 id="593-cursor">5.9.3 Cursor</h3>
<h4 id="sketch-code_48">Sketch Code</h4>
<pre><code class="language-C">/*
  LiquidCrystal Library - Cursor

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch prints &quot;Hello World!&quot; to the LCD and
 uses the cursor()  and noCursor() methods to turn
 on and off the cursor.

 The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe
 modified 7 Nov 2016
 by Arturo Guadalupi

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystalCursor

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // Print a message to the LCD.
  lcd.print(&quot;hello, world!&quot;);
}

void loop() {
  // Turn off the cursor:
  lcd.noCursor();
  delay(500);
  // Turn on the cursor:
  lcd.cursor();
  delay(500);
}
``


#### [Fritzing] Circuit



#### [KiCad] Schematic




#### Video Demonstration




[Fritzing]: https://fritzing.org/
[KiCad]: https://www.kicad.org/
[Arduino]: https://arduino.cc
[Microcontroller]: https://en.wikipedia.org/wiki/Microcontroller

### 5.9.4 CustomCharacter

#### Sketch Code

```C
/*
  LiquidCrystal Library - Custom Characters

 Demonstrates how to add custom characters on an LCD  display.
 The LiquidCrystal library works with all LCD displays that are
 compatible with the  Hitachi HD44780 driver. There are many of
 them out there, and you can usually tell them by the 16-pin interface.

 This sketch prints &quot;I &lt;heart&gt; Arduino!&quot; and a little dancing man
 to the LCD.

  The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * 10K potentiometer:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)
 * 10K poterntiometer on pin A0

 created 21 Mar 2011
 by Tom Igoe
 modified 11 Nov 2013
 by Scott Fitzgerald
 modified 7 Nov 2016
 by Arturo Guadalupi

 Based on Adafruit's example at
 https://github.com/adafruit/SPI_VFD/blob/master/examples/createChar/createChar.pde

 This example code is in the public domain.
 http://www.arduino.cc/en/Tutorial/LiquidCrystalCustomCharacter

 Also useful:
 http://icontexto.com/charactercreator/

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

// make some custom characters:
byte heart[8] = {
  0b00000,
  0b01010,
  0b11111,
  0b11111,
  0b11111,
  0b01110,
  0b00100,
  0b00000
};

byte smiley[8] = {
  0b00000,
  0b00000,
  0b01010,
  0b00000,
  0b00000,
  0b10001,
  0b01110,
  0b00000
};

byte frownie[8] = {
  0b00000,
  0b00000,
  0b01010,
  0b00000,
  0b00000,
  0b00000,
  0b01110,
  0b10001
};

byte armsDown[8] = {
  0b00100,
  0b01010,
  0b00100,
  0b00100,
  0b01110,
  0b10101,
  0b00100,
  0b01010
};

byte armsUp[8] = {
  0b00100,
  0b01010,
  0b00100,
  0b10101,
  0b01110,
  0b00100,
  0b00100,
  0b01010
};

void setup() {
  // initialize LCD and set up the number of columns and rows:
  lcd.begin(16, 2);

  // create a new character
  lcd.createChar(0, heart);
  // create a new character
  lcd.createChar(1, smiley);
  // create a new character
  lcd.createChar(2, frownie);
  // create a new character
  lcd.createChar(3, armsDown);
  // create a new character
  lcd.createChar(4, armsUp);

  // set the cursor to the top left
  lcd.setCursor(0, 0);

  // Print a message to the lcd.
  lcd.print(&quot;I &quot;);
  lcd.write(byte(0)); // when calling lcd.write() '0' must be cast as a byte
  lcd.print(&quot; Arduino! &quot;);
  lcd.write((byte)1);

}

void loop() {
  // read the potentiometer on A0:
  int sensorReading = analogRead(A0);
  // map the result to 200 - 1000:
  int delayTime = map(sensorReading, 0, 1023, 200, 1000);
  // set the cursor to the bottom row, 5th position:
  lcd.setCursor(4, 1);
  // draw the little man, arms down:
  lcd.write(3);
  delay(delayTime);
  lcd.setCursor(4, 1);
  // draw him arms up:
  lcd.write(4);
  delay(delayTime);
}
</code></pre>
<h4 id="fritzing-circuit_48"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_48"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_48">Video Demonstration</h4>
<h3 id="595-display">5.9.5 Display</h3>
<h4 id="sketch-code_49">Sketch Code</h4>
<pre><code class="language-C">/*
  LiquidCrystal Library - display() and noDisplay()

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch prints &quot;Hello World!&quot; to the LCD and uses the
 display() and noDisplay() functions to turn on and off
 the display.

 The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe
 modified 7 Nov 2016
 by Arturo Guadalupi

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystalDisplay

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // Print a message to the LCD.
  lcd.print(&quot;hello, world!&quot;);
}

void loop() {
  // Turn off the display:
  lcd.noDisplay();
  delay(500);
  // Turn on the display:
  lcd.display();
  delay(500);
}
</code></pre>
<h4 id="fritzing-circuit_49"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_49"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_49">Video Demonstration</h4>
<h3 id="596-helloworld">5.9.6 HelloWorld</h3>
<h4 id="sketch-code_50">Sketch Code</h4>
<pre><code class="language-C">/*
  LiquidCrystal Library - Hello World

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch prints &quot;Hello World!&quot; to the LCD
 and shows the time.

  The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * LCD VSS pin to ground
 * LCD VCC pin to 5V
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe
 modified 7 Nov 2016
 by Arturo Guadalupi

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystalHelloWorld

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // Print a message to the LCD.
  lcd.print(&quot;hello, world!&quot;);
}

void loop() {
  // set the cursor to column 0, line 1
  // (note: line 1 is the second row, since counting begins with 0):
  lcd.setCursor(0, 1);
  // print the number of seconds since reset:
  lcd.print(millis() / 1000);
}
</code></pre>
<h4 id="fritzing-circuit_50"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_50"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_50">Video Demonstration</h4>
<h3 id="597-scroll">5.9.7 Scroll</h3>
<h4 id="sketch-code_51">Sketch Code</h4>
<pre><code class="language-C">/*
  LiquidCrystal Library - scrollDisplayLeft() and scrollDisplayRight()

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch prints &quot;Hello World!&quot; to the LCD and uses the
 scrollDisplayLeft() and scrollDisplayRight() methods to scroll
 the text.

  The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe
 modified 7 Nov 2016
 by Arturo Guadalupi

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystalScroll

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // Print a message to the LCD.
  lcd.print(&quot;hello, world!&quot;);
  delay(1000);
}

void loop() {
  // scroll 13 positions (string length) to the left
  // to move it offscreen left:
  for (int positionCounter = 0; positionCounter &lt; 13; positionCounter++) {
    // scroll one position left:
    lcd.scrollDisplayLeft();
    // wait a bit:
    delay(150);
  }

  // scroll 29 positions (string length + display length) to the right
  // to move it offscreen right:
  for (int positionCounter = 0; positionCounter &lt; 29; positionCounter++) {
    // scroll one position right:
    lcd.scrollDisplayRight();
    // wait a bit:
    delay(150);
  }

  // scroll 16 positions (display length + string length) to the left
  // to move it back to center:
  for (int positionCounter = 0; positionCounter &lt; 16; positionCounter++) {
    // scroll one position left:
    lcd.scrollDisplayLeft();
    // wait a bit:
    delay(150);
  }

  // delay at the end of the full loop:
  delay(1000);

}
</code></pre>
<h4 id="fritzing-circuit_51"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_51"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_51">Video Demonstration</h4>
<h3 id="598-serialdisplay">5.9.8 SerialDisplay</h3>
<h4 id="sketch-code_52">Sketch Code</h4>
<pre><code class="language-C">/*
  LiquidCrystal Library - Serial Input

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch displays text sent over the serial port
 (e.g. from the Serial Monitor) on an attached LCD.

 The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe
 modified 7 Nov 2016
 by Arturo Guadalupi

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystalSerialDisplay

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // initialize the serial communications:
  Serial.begin(9600);
}

void loop() {
  // when characters arrive over the serial port...
  if (Serial.available()) {
    // wait a bit for the entire message to arrive
    delay(100);
    // clear the screen
    lcd.clear();
    // read all the available characters
    while (Serial.available() &gt; 0) {
      // display each character to the LCD
      lcd.write(Serial.read());
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_52"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_52"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_52">Video Demonstration</h4>
<h3 id="599-setcursor">5.9.9 setCursor</h3>
<h4 id="sketch-code_53">Sketch Code</h4>
<pre><code class="language-C">/*
  LiquidCrystal Library - setCursor

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch prints to all the positions of the LCD using the
 setCursor() method:

  The circuit:
 * LCD RS pin to digital pin 12
 * LCD Enable pin to digital pin 11
 * LCD D4 pin to digital pin 5
 * LCD D5 pin to digital pin 4
 * LCD D6 pin to digital pin 3
 * LCD D7 pin to digital pin 2
 * LCD R/W pin to ground
 * 10K resistor:
 * ends to +5V and ground
 * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe
 modified 7 Nov 2016
 by Arturo Guadalupi

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystalSetCursor

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

// these constants won't change.  But you can change the size of
// your LCD using them:
const int numRows = 2;
const int numCols = 16;

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(numCols, numRows);
}

void loop() {
  // loop from ASCII 'a' to ASCII 'z':
  for (int thisLetter = 'a'; thisLetter &lt;= 'z'; thisLetter++) {
    // loop over the columns:
    for (int  thisRow = 0; thisRow &lt; numRows; thisRow++) {
      // loop over the rows:
      for (int thisCol = 0; thisCol &lt; numCols; thisCol++) {
        // set the cursor position:
        lcd.setCursor(thisCol, thisRow);
        // print the letter:
        lcd.write(thisLetter);
        delay(200);
      }
    }
  }
}
</code></pre>
<h4 id="fritzing-circuit_53"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_53"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_53">Video Demonstration</h4>
<h3 id="5910-textdirection">5.9.10 TextDirection</h3>
<h4 id="sketch-code_54">Sketch Code</h4>
<pre><code class="language-C">/*
 LiquidCrystal Library - TextDirection

 Demonstrates the use a 16x2 LCD display.  The LiquidCrystal
 library works with all LCD displays that are compatible with the
 Hitachi HD44780 driver. There are many of them out there, and you
 can usually tell them by the 16-pin interface.

 This sketch demonstrates how to use leftToRight() and rightToLeft()
 to move the cursor.

 The circuit:
  * LCD RS pin to digital pin 12
  * LCD Enable pin to digital pin 11
  * LCD D4 pin to digital pin 5
  * LCD D5 pin to digital pin 4
  * LCD D6 pin to digital pin 3
  * LCD D7 pin to digital pin 2
  * LCD R/W pin to ground
  * 10K resistor:
  * ends to +5V and ground
  * wiper to LCD VO pin (pin 3)

 Library originally added 18 Apr 2008
 by David A. Mellis
 library modified 5 Jul 2009
 by Limor Fried (http://www.ladyada.net)
 example added 9 Jul 2009
 by Tom Igoe
 modified 22 Nov 2010
 by Tom Igoe
 modified 7 Nov 2016
 by Arturo Guadalupi

 This example code is in the public domain.

 http://www.arduino.cc/en/Tutorial/LiquidCrystalTextDirection

*/

// include the library code:
#include &lt;LiquidCrystal.h&gt;

// initialize the library by associating any needed LCD interface pin
// with the arduino pin number it is connected to
const int rs = 12, en = 11, d4 = 5, d5 = 4, d6 = 3, d7 = 2;
LiquidCrystal lcd(rs, en, d4, d5, d6, d7);

int thisChar = 'a';

void setup() {
  // set up the LCD's number of columns and rows:
  lcd.begin(16, 2);
  // turn on the cursor:
  lcd.cursor();
}

void loop() {
  // reverse directions at 'm':
  if (thisChar == 'm') {
    // go right for the next letter
    lcd.rightToLeft();
  }
  // reverse again at 's':
  if (thisChar == 's') {
    // go left for the next letter
    lcd.leftToRight();
  }
  // reset at 'z':
  if (thisChar &gt; 'z') {
    // go to (0,0):
    lcd.home();
    // start again at 0
    thisChar = 'a';
  }
  // print the character
  lcd.write(thisChar);
  // wait a second:
  delay(1000);
  // increment the letter:
  thisChar++;
}
</code></pre>
<h4 id="fritzing-circuit_54"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_54"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_54">Video Demonstration</h4>
<h2 id="section-510-opamp">Section 5.10: OPAMP</h2>
<h3 id="5101-start_opamp">5.10.1 start_opamp</h3>
<h4 id="sketch-code_55">Sketch Code</h4>
<pre><code class="language-C">#include &lt;OPAMP.h&gt;

void setup () {
  Serial.begin(9600);
  delay(2000); // serial monitor delay
  // activate OPAMP, default channel 0
  // Plus: Analog A1
  // Minus: Analog A2 
  // Output: Analog A3
  if (!OPAMP.begin(OPAMP_SPEED_HIGHSPEED)) {
    Serial.println(&quot;Failed to start OPAMP!&quot;);
  }
  bool const isRunning = OPAMP.isRunning(0);
  if (isRunning) {
    Serial.println(&quot;OPAMP running on channel 0!&quot;);
  } else {
    Serial.println(&quot;OPAMP channel 0 is not running!&quot;);
  }
}

void loop() {
  delay(1000); // do nothing
}
</code></pre>
<h4 id="fritzing-circuit_55"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_55"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_55">Video Demonstration</h4>
<h2 id="section-511-otaupdate">Section 5.11: OTAUpdate</h2>
<h3 id="5111-ota">5.11.1 OTA</h3>
<h4 id="sketch-code_56">Sketch Code</h4>
<pre><code class="language-C">/*
  OTA

  This sketch demonstrates how to make an OTA Update on the UNO R4 WiFi.
  Upload the sketch and wait for the invasion!

*/


#include &quot;WiFiS3.h&quot;
#include &quot;OTAUpdate.h&quot;
#include &quot;root_ca.h&quot;
#include &quot;arduino_secrets.h&quot;

char ssid[] = SECRET_SSID;    // your network SSID (name)
char pass[] = SECRET_PASS;    // your network password (use for WPA, or use as key for WEP)

int status = WL_IDLE_STATUS;

OTAUpdate ota;
static char const OTA_FILE_LOCATION[] = &quot;https://downloads.arduino.cc/ota/UNOR4WIFI_Animation.ota&quot;;

/* -------------------------------------------------------------------------- */
void setup() {
/* -------------------------------------------------------------------------- */
  //Initialize serial and wait for port to open:
  Serial.begin(115200);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // check for the Wi-Fi module:
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println(&quot;Communication with Wi-Fi module failed!&quot;);
    // don't continue
    while (true);
  }

  String fv = WiFi.firmwareVersion();
  if (fv &lt; WIFI_FIRMWARE_LATEST_VERSION) {
    Serial.println(&quot;Please upgrade the firmware&quot;);
  }

  // attempt to connect to Wi-Fi network:
  while (status != WL_CONNECTED) {
    Serial.print(&quot;Attempting to connect to SSID: &quot;);
    Serial.println(ssid);
    // Connect to WPA/WPA2 network. Change this line if using open or WEP network:
    status = WiFi.begin(ssid, pass);

    // wait 1 seconds for connection:
    delay(1000);
  }

  printWiFiStatus();

  OTAUpdate::Error ret = OTAUpdate::Error::None;
  ret = ota.begin(&quot;/update.bin&quot;);
  if(ret != OTAUpdate::Error::None) {
    Serial.println(&quot;ota.begin() error: &quot;);
    Serial.println((int)ret);
    return;
  }
  ret = ota.setCACert(root_ca);
  if(ret != OTAUpdate::Error::None) {
    Serial.println(&quot;ota.setCACert() error: &quot;);
    Serial.println((int)ret);
    return;
  }
  int ota_size = ota.download(OTA_FILE_LOCATION, &quot;/update.bin&quot;);
  if(ota_size &lt;= 0) {
    Serial.println(&quot;ota.download() error: &quot;);
    Serial.println(ota_size);
    return;
  }
  ret = ota.verify();
  if(ret != OTAUpdate::Error::None) {
    Serial.println(&quot;ota.verify() error: &quot;);
    Serial.println((int)ret);
    return;
  }

  ret = ota.update(&quot;/update.bin&quot;);
  if(ret != OTAUpdate::Error::None) {
    Serial.println(&quot;ota.update() error: &quot;);
    Serial.println((int)ret);
    return;
  }
}

/* -------------------------------------------------------------------------- */
void loop() {
/* -------------------------------------------------------------------------- */
  delay(1000);
}

/* -------------------------------------------------------------------------- */
void printWiFiStatus() {
/* -------------------------------------------------------------------------- */
  // print the SSID of the network you're attached to:
  Serial.print(&quot;SSID: &quot;);
  Serial.println(WiFi.SSID());

  // print your board's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print(&quot;IP Address: &quot;);
  Serial.println(ip);

  // print the received signal strength:
  long rssi = WiFi.RSSI();
  Serial.print(&quot;signal strength (RSSI):&quot;);
  Serial.print(rssi);
  Serial.println(&quot; dBm&quot;);
}
</code></pre>
<h4 id="fritzing-circuit_56"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_56"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_56">Video Demonstration</h4>
<h3 id="5112-wififirmwareota">5.11.2 WiFiFirmwareOTA</h3>
<h4 id="sketch-code_57">Sketch Code</h4>
<pre><code class="language-C">/*
  OTA

  This sketch demonstrates how to make the UNO R4 WiFi self-update its Wi-Fi module
  firmware via OTA. Upload the Sketch and wait for Serial detach. After the update
  the new Wi-Fi firmware version will be 98.98.98

  WARNING: running this sketch will load a test Wi-Fi firmware version on the UNO R4
  WiFi module. To restore a production firmware use the Arduino Firmware Uploader or
  the update packages available here:

  https://github.com/arduino/uno-r4-wifi-usb-bridge/releases

*/


#include &quot;WiFiS3.h&quot;
#include &quot;OTAUpdate.h&quot;
#include &quot;root_ca.h&quot;
#include &quot;arduino_secrets.h&quot;

char ssid[] = SECRET_SSID;    // your network SSID (name)
char pass[] = SECRET_PASS;    // your network password (use for WPA, or use as key for WEP)

int status = WL_IDLE_STATUS;

OTAUpdate ota;
static char const OTA_FILE_LOCATION[] = &quot;https://downloads.arduino.cc/ota/UNOR4USBBridge.ino.ota&quot;;

/* -------------------------------------------------------------------------- */
void setup() {
/* -------------------------------------------------------------------------- */
  //Initialize serial and wait for port to open:
  Serial.begin(115200);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }

  // check for the Wi-Fi module:
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println(&quot;Communication with Wi-Fi module failed!&quot;);
    // don't continue
    while (true);
  }

  String fv = WiFi.firmwareVersion();
  if (fv &lt; WIFI_FIRMWARE_LATEST_VERSION) {
    Serial.println(&quot;Please upgrade the firmware&quot;);
  }

  Serial.print(&quot;Current Wi-Fi firmware version: &quot;);
  Serial.println(fv);

  // attempt to connect to Wi-Fi network:
  while (status != WL_CONNECTED) {
    Serial.print(&quot;Attempting to connect to SSID: &quot;);
    Serial.println(ssid);
    // Connect to WPA/WPA2 network. Change this line if using open or WEP network:
    status = WiFi.begin(ssid, pass);

    // wait 1 seconds for connection:
    delay(1000);
  }

  printWiFiStatus();

  OTAUpdate::Error ret = OTAUpdate::Error::None;
  ret = ota.begin();
  if(ret != OTAUpdate::Error::None) {
    Serial.println(&quot;ota.begin() error: &quot;);
    Serial.println((int)ret);
    return;
  }
  ret = ota.setCACert(root_ca);
  if(ret != OTAUpdate::Error::None) {
    Serial.println(&quot;ota.setCACert() error: &quot;);
    Serial.println((int)ret);
    return;
  }
  int ota_size = ota.download(OTA_FILE_LOCATION);
  if(ota_size &lt;= 0) {
    Serial.println(&quot;ota.download() error: &quot;);
    Serial.println(ota_size);
    return;
  }
  ret = ota.verify();
  if(ret != OTAUpdate::Error::None) {
    Serial.println(&quot;ota.verify() error: &quot;);
    Serial.println((int)ret);
    return;
  }
  ret = ota.update();
  if(ret != OTAUpdate::Error::None) {
    Serial.println(&quot;ota.update() error: &quot;);
    Serial.println((int)ret);
    return;
  }
  ret = ota.reset();
  if(ret != OTAUpdate::Error::None) {
    Serial.println(&quot;ota.reset() error: &quot;);
    Serial.println((int)ret);
    return;
  }
}


/* -------------------------------------------------------------------------- */
void loop() {
/* -------------------------------------------------------------------------- */

  String fv = WiFi.firmwareVersion();
  Serial.print(&quot;Updated Wi-Fi firmware version: &quot;);
  Serial.println(fv);
  delay(1000);
}

/* -------------------------------------------------------------------------- */
void printWiFiStatus() {
/* -------------------------------------------------------------------------- */
  // print the SSID of the network you're attached to:
  Serial.print(&quot;SSID: &quot;);
  Serial.println(WiFi.SSID());

  // print your board's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print(&quot;IP Address: &quot;);
  Serial.println(ip);

  // print the received signal strength:
  long rssi = WiFi.RSSI();
  Serial.print(&quot;signal strength (RSSI):&quot;);
  Serial.print(rssi);
  Serial.println(&quot; dBm&quot;);
}
</code></pre>
<h4 id="fritzing-circuit_57"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_57"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_57">Video Demonstration</h4>
<h2 id="section-512-rtc">Section 5.12: RTC</h2>
<h3 id="5121-rtc_alarm">5.12.1 RTC_Alarm</h3>
<h4 id="sketch-code_58">Sketch Code</h4>
<pre><code class="language-C">/*
 * RTC_Alarm
 *
 * This example demonstrates how to use the alarm functionality of the RTC
 * (Real Time Clock) on the Portenta C33 and UNO R4 Minima / WiFi.
 *
 * It turns on the built-in LED when the alarm
 * is triggered, which is once every minute in this example.
 * In addition, inside the loop, we print the state of the alarm
 * continuously, which is either 0 (LOW) or 1 (HIGH).
 *
 * Note that the Portenta C33's LED is inverted and will be lit when
 * the state is 0 (LOW).
 * 
 * Find the full UNO R4 WiFi RTC documentation here:
 * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc
 */

unsigned long previousMillis = 0;
const long interval = 1000;
bool ledState = false;

// Include the RTC library
#include &quot;RTC.h&quot;

void setup() {
  //initialize Serial Communication
  Serial.begin(9600);

  //define LED as output
  pinMode(LED_BUILTIN, OUTPUT);

  // Initialize the RTC
  RTC.begin();

  // RTC.setTime() must be called for RTC.setAlarmCallback to work, but it doesn't matter
  // what date and time it's set to in this example
  RTCTime initialTime(7, Month::JUNE, 2023, 13, 03, 00, DayOfWeek::WEDNESDAY, SaveLight::SAVING_TIME_ACTIVE);
  RTC.setTime(initialTime);

  // Trigger the alarm every time the seconds are zero
  RTCTime alarmTime;
  alarmTime.setSecond(0);

  // Make sure to only match on the seconds in this example - not on any other parts of the date/time
  AlarmMatch matchTime;
  matchTime.addMatchSecond();

  //sets the alarm callback
  RTC.setAlarmCallback(alarmCallback, alarmTime, matchTime);
}

void loop() {

  // in the loop, we continuously print the alarm's current state
  // this is for debugging only and has no effect on the alarm whatsoever
  unsigned long currentMillis = millis();
  if (currentMillis - previousMillis &gt;= interval) {
    // save the last time you blinked the LED
    previousMillis = currentMillis;
    Serial.print(&quot;Alarm state: &quot;);
    Serial.println(ledState);
  }
}

// this function activates every minute
// and changes the ledState boolean
void alarmCallback() {
  if (!ledState) {
    digitalWrite(LED_BUILTIN, HIGH);
  } else {
    digitalWrite(LED_BUILTIN, LOW);
  }
  ledState = !ledState;
}
</code></pre>
<h4 id="fritzing-circuit_58"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_58"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_58">Video Demonstration</h4>
<h3 id="5122-rtc_automaticexample">5.12.2 RTC_AutomaticExample</h3>
<h4 id="sketch-code_59">Sketch Code</h4>
<pre><code class="language-C">/*
 * RTC_AutomaticExample
 *
 * This example sets the RTC (Real Time Clock) on the Portenta C33 automatically by
 * retrieving the date and time from the computer you upload the sketch from, at the
 * point when you start the upload.
 *
 * Next, it gets the current time from the RTC and prints it to the Serial Monitor.
 * It then sets an RTC alarm to fire every time the seconds value of the time is zero.
 * The alarm, which now goes off once a minute, triggers a callback that prints the
 * current time to the Serial Monitor.
 *
 * Find the full UNO R4 WiFi RTC documentation here:
 * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc
 */

// Include the RTC library
#include &quot;RTC.h&quot;

DayOfWeek convertDayOfWeek(String s)
{
  if (s == String(&quot;Mon&quot;))
  {
    return DayOfWeek::MONDAY;
  }
  if (s == String(&quot;Tue&quot;))
  {
    return DayOfWeek::TUESDAY;
  }
  if (s == String(&quot;Wed&quot;))
  {
    return DayOfWeek::WEDNESDAY;
  }  
  if (s == String(&quot;Thu&quot;))
  {
    return DayOfWeek::THURSDAY;
  }  
  if (s == String(&quot;Fri&quot;))
  {
    return DayOfWeek::FRIDAY;
  }  
  if (s == String(&quot;Sat&quot;))
  {
    return DayOfWeek::SATURDAY;
  }  
  if (s == String(&quot;Sun&quot;))
  {
    return DayOfWeek::SUNDAY;
  }  
}

Month convertMonth(String s)
{
  if (s == String(&quot;Jan&quot;))
  {
    return Month::JANUARY;
  }
  if (s == String(&quot;Feb&quot;))
  {
    return Month::FEBRUARY;
  }
  if (s == String(&quot;Mar&quot;))
  {
    return Month::MARCH;
  }
  if (s == String(&quot;Apr&quot;))
  {
    return Month::APRIL;
  }
  if (s == String(&quot;May&quot;))
  {
    return Month::MAY;
  }
  if (s == String(&quot;Jun&quot;))
  {
    return Month::JUNE;
  }
  if (s == String(&quot;Jul&quot;))
  {
    return Month::JULY;
  }
  if (s == String(&quot;Aug&quot;))
  {
    return Month::AUGUST;
  }
  if (s == String(&quot;Sep&quot;))
  {
    return Month::SEPTEMBER;
  }
  if (s == String(&quot;Oct&quot;))
  {
    return Month::OCTOBER;
  }  
  if (s == String(&quot;Nov&quot;))
  {
    return Month::NOVEMBER;
  }
  if (s == String(&quot;Dec&quot;))
  {
    return Month::DECEMBER;
  }  
}

RTCTime currentRTCTime()
{
  // Get a compilation timestamp of the format: Wed May 10 08:54:31 2023
  // __TIMESTAMP__ is a GNU C extension macro
  // We can't use the standard macros __DATE__ and __TIME__ because they don't provide the day of the week
  String timeStamp = __TIMESTAMP__;
  // Extract the day of the week
  int pos1 = timeStamp.indexOf(&quot; &quot;);
  DayOfWeek dayOfWeek = convertDayOfWeek(timeStamp.substring(0, pos1));
  // Extract the month
  ++pos1;
  int pos2 = timeStamp.indexOf(&quot; &quot;, pos1);
  Month month = convertMonth(timeStamp.substring(pos1, pos2));
  // Extract the day
  pos1 = ++pos2;
  pos2 = timeStamp.indexOf(&quot; &quot;, pos1);
  int day = timeStamp.substring(pos1, pos2).toInt();
  // Extract the hour
  pos1 = ++pos2;
  pos2 = timeStamp.indexOf(&quot;:&quot;, pos1);
  int hour = timeStamp.substring(pos1, pos2).toInt();
  // Extract the minute
  pos1 = ++pos2;
  pos2 = timeStamp.indexOf(&quot;:&quot;, pos1);
  int minute = timeStamp.substring(pos1, pos2).toInt();
  // Extract the second
  pos1 = ++pos2;
  pos2 = timeStamp.indexOf(&quot; &quot;, pos1);
  int second = timeStamp.substring(pos1, pos2).toInt();
  // Extract the year
  pos1 = ++pos2;
  pos2 = timeStamp.indexOf(&quot; &quot;, pos1);
  int year = timeStamp.substring(pos1, pos2).toInt();

  return RTCTime(day, month, year, hour, minute, second, dayOfWeek, SaveLight::SAVING_TIME_INACTIVE);
}

void alarmCallback() {
  Serial.println(&quot;An alarm was triggered at:&quot;);
  RTCTime currentTime;
  RTC.getTime(currentTime); 
  Serial.print(currentTime.getYear());
  Serial.print(&quot;-&quot;);
  Serial.print(Month2int(currentTime.getMonth()));
  Serial.print(&quot;-&quot;);
  Serial.print(currentTime.getDayOfMonth());
  Serial.print(&quot; &quot;);
  Serial.print(currentTime.getHour());
  Serial.print(&quot;:&quot;);
  Serial.print(currentTime.getMinutes());
  Serial.print(&quot;:&quot;);
  Serial.println(currentTime.getSeconds());
}

void setup()
{
  Serial.begin(9600);
  while (!Serial) ;

  // Initialize the RTC
  RTC.begin();

  // Get the current date and time when the sketch is uploaded and set the RTC
  RTCTime timeToSet = currentRTCTime();
  RTC.setTime(timeToSet);

  // Retrieve the date and time from the RTC and print them
  Serial.println(&quot;The RTC was just set to: &quot;);
  RTCTime currentTime;
  RTC.getTime(currentTime); 
  Serial.print(currentTime.getYear());
  Serial.print(&quot;-&quot;);
  Serial.print(Month2int(currentTime.getMonth()));
  Serial.print(&quot;-&quot;);
  Serial.print(currentTime.getDayOfMonth());
  Serial.print(&quot; &quot;);
  Serial.print(currentTime.getHour());
  Serial.print(&quot;:&quot;);
  Serial.print(currentTime.getMinutes());
  Serial.print(&quot;:&quot;);
  Serial.println(currentTime.getSeconds());

  // Create an alarm time with the seconds value set to zero
  RTCTime alarmTime;
  alarmTime.setSecond(0);
  // Tell the RTC to only match on the seconds value
  AlarmMatch alarmMatch;
  alarmMatch.addMatchSecond();
  // Set the alarm callback function
  RTC.setAlarmCallback(alarmCallback, alarmTime, alarmMatch);
}

void loop()
{
}
</code></pre>
<h4 id="fritzing-circuit_59"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_59"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_59">Video Demonstration</h4>
<h3 id="5123-rtc_ntpsync">5.12.3 RTC_NTPSync</h3>
<h4 id="sketch-code_60">Sketch Code</h4>
<pre><code class="language-C">/**
 * RTC_NTPSync
 * 
 * This example shows how to set the RTC (Real Time Clock) on the Portenta C33 / UNO R4 WiFi
 * to the current date and time retrieved from an NTP server on the Internet (pool.ntp.org).
 * Then the current time from the RTC is printed to the Serial port.
 * 
 * Instructions:
 * 1. Download the NTPClient library (https://github.com/arduino-libraries/NTPClient) through the Library Manager
 * 2. Change the WiFi credentials in the arduino_secrets.h file to match your WiFi network.
 * 3. Upload this sketch to Portenta C33 / UNO R4 WiFi.
 * 4. Open the Serial Monitor.
 * 
 * Initial author: Sebastian Romero @sebromero
 * 
 * Find the full UNO R4 WiFi RTC documentation here:
 * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc
 */

// Include the RTC library
#include &quot;RTC.h&quot;

//Include the NTP library
#include &lt;NTPClient.h&gt;

#if defined(ARDUINO_PORTENTA_C33)
#include &lt;WiFiC3.h&gt;
#elif defined(ARDUINO_UNOWIFIR4)
#include &lt;WiFiS3.h&gt;
#endif

#include &lt;WiFiUdp.h&gt;
#include &quot;arduino_secrets.h&quot; 

///////please enter your sensitive data in the Secret tab/arduino_secrets.h
char ssid[] = SECRET_SSID;        // your network SSID (name)
char pass[] = SECRET_PASS;    // your network password (use for WPA, or use as key for WEP)

int wifiStatus = WL_IDLE_STATUS;
WiFiUDP Udp; // A UDP instance to let us send and receive packets over UDP
NTPClient timeClient(Udp);

void printWifiStatus() {
  // print the SSID of the network you're attached to:
  Serial.print(&quot;SSID: &quot;);
  Serial.println(WiFi.SSID());

  // print your board's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print(&quot;IP Address: &quot;);
  Serial.println(ip);

  // print the received signal strength:
  long rssi = WiFi.RSSI();
  Serial.print(&quot;signal strength (RSSI):&quot;);
  Serial.print(rssi);
  Serial.println(&quot; dBm&quot;);
}

void connectToWiFi(){
  // check for the WiFi module:
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println(&quot;Communication with WiFi module failed!&quot;);
    // don't continue
    while (true);
  }

  String fv = WiFi.firmwareVersion();
  if (fv &lt; WIFI_FIRMWARE_LATEST_VERSION) {
    Serial.println(&quot;Please upgrade the firmware&quot;);
  }

  // attempt to connect to WiFi network:
  while (wifiStatus != WL_CONNECTED) {
    Serial.print(&quot;Attempting to connect to SSID: &quot;);
    Serial.println(ssid);
    // Connect to WPA/WPA2 network. Change this line if using open or WEP network:
    wifiStatus = WiFi.begin(ssid, pass);

    // wait 10 seconds for connection:
    delay(10000);
  }

  Serial.println(&quot;Connected to WiFi&quot;);
  printWifiStatus();
}

void setup(){
  Serial.begin(9600);
  while (!Serial);

  connectToWiFi();
  RTC.begin();
  Serial.println(&quot;\nStarting connection to server...&quot;);
  timeClient.begin();
  timeClient.update();

  // Get the current date and time from an NTP server and convert
  // it to UTC +2 by passing the time zone offset in hours.
  // You may change the time zone offset to your local one.
  auto timeZoneOffsetHours = 2;
  auto unixTime = timeClient.getEpochTime() + (timeZoneOffsetHours * 3600);
  Serial.print(&quot;Unix time = &quot;);
  Serial.println(unixTime);
  RTCTime timeToSet = RTCTime(unixTime);
  RTC.setTime(timeToSet);

  // Retrieve the date and time from the RTC and print them
  RTCTime currentTime;
  RTC.getTime(currentTime); 
  Serial.println(&quot;The RTC was just set to: &quot; + String(currentTime));
}

void loop(){}
</code></pre>
<h4 id="fritzing-circuit_60"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_60"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_60">Video Demonstration</h4>
<h3 id="5124-rtc_periodicexample">5.12.4 RTC_PeriodicExample</h3>
<h4 id="sketch-code_61">Sketch Code</h4>
<pre><code class="language-C">/*
 * RTC_PeriodicExample
 *
 * This example demonstrates how to use the periodic callback functionality of the RTC
 * (Real Time Clock) on the Portenta C33.
 *
 * It blinks the built-in LED at progressively faster and slower rates repeatedly.
 *
 * Find the full UNO R4 WiFi RTC documentation here:
 * https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc
 */

// Include the RTC library
#include &quot;RTC.h&quot;

#define BLINK_DELAY 2000

// This is the callback function to be passed to RTC.setPeriodicCallback()
void periodicCallback()
{
  static bool ledState = false;
  if (ledState == true) {
    digitalWrite(LED_BUILTIN, HIGH);
  }
  else {
    digitalWrite(LED_BUILTIN, LOW);
  }
  ledState = !ledState;
}

void setup() {
  pinMode(LED_BUILTIN, OUTPUT);

  // Initialize the RTC
  RTC.begin();

  // RTC.setTime() must be called for RTC.setPeriodicCallback to work, but it doesn't matter
  // what date and time it's set to
  RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE);
  RTC.setTime(mytime);
}

void loop() {
  RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::N32_TIMES_EVERY_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::N16_TIMES_EVERY_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::N8_TIMES_EVERY_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::N4_TIMES_EVERY_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::N2_TIMES_EVERY_SEC);
  delay(BLINK_DELAY);
  RTC.setPeriodicCallback(periodicCallback, Period::ONCE_EVERY_1_SEC);
  delay(BLINK_DELAY);
}
</code></pre>
<h4 id="fritzing-circuit_61"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_61"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_61">Video Demonstration</h4>
<h3 id="5125-test_rtc">5.12.5 Test_RTC</h3>
<h4 id="sketch-code_62">Sketch Code</h4>
<pre><code class="language-C">/*
  Test RTC

  A test sketch showcasing all RTC showcasing various functionalities related to the RTC module,
  including setting the time, handling interrupts, and reading time values.

  Find the full UNO R4 WiFi RTC documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/rtc
*/

// Include the RTC library
#include &quot;RTC.h&quot;

// Define the interrupt pin for LED control during interrupts
const int LED_ON_INTERRUPT  = 22;

// Callback function for periodic interrupt
void periodic_cbk() {
  static bool clb_st = false;

  // Toggle the LED based on callback state
  if (clb_st) {
    digitalWrite(LED_ON_INTERRUPT, HIGH);
  }
  else {
    digitalWrite(LED_ON_INTERRUPT, LOW);
  }

  clb_st = !clb_st;  // Toggle callback state

  // Print message indicating periodic interrupt
  Serial.println(&quot;PERIODIC INTERRUPT&quot;);
}

void alarm_cbk() {
  Serial.println(&quot;ALARM INTERRUPT&quot;);
}

// Callback function for alarm interrupt
void setup() {
  // Initialize serial communication
  Serial.begin(9600);
  // Wait for serial connection
  while (!Serial) {

  }

  // Set LED pins as outputs
  pinMode(LED_BUILTIN, OUTPUT);
  pinMode(LED_ON_INTERRUPT, OUTPUT);

  // Initialize the RTC
  RTC.begin();

  // Set a specific initial time (August 25, 2022, 14:37:00 Thursday)
  RTCTime mytime(25, Month::AUGUST, 2022, 14, 37, 00, DayOfWeek::THURSDAY, SaveLight::SAVING_TIME_ACTIVE);

  RTCTime savedTime;
  RTC.getTime(savedTime);

  // Set the initial time if RTC is not running
  if (!RTC.isRunning()) {
    if (savedTime.getYear() != 2000) {
      RTC.setTime(mytime);
    } else {
      RTC.setTime(savedTime);
    }
  }

  // Create an alarm time set to 35 seconds
  RTCTime alarmtime;
  alarmtime.setSecond(35);

  // Create an AlarmMatch object to match seconds
  AlarmMatch am;
  am.addMatchSecond();

  // Set the periodic callback function to run once every 2 seconds
  if (!RTC.setPeriodicCallback(periodic_cbk, Period::ONCE_EVERY_2_SEC)) {
    Serial.println(&quot;ERROR: periodic callback not set&quot;);
  }

  // Set the alarm callback function with the alarm time and matching condition
  if (!RTC.setAlarmCallback(alarm_cbk, alarmtime, am)) {
    Serial.println(&quot;ERROR: alarm callback not set&quot;);
  }
}

void loop() {
  static bool status = false;

  RTCTime currenttime;

  // Check if RTC is running and print status
  if (status) {

    // Toggle LED and display RTC status if 'status' is true
    if (RTC.isRunning()) {
      Serial.println(&quot;RTC is running&quot;);
    }
    else {
      Serial.println(&quot;RTC is not running&quot;);
    }

    /* GET CURRENT TIME FROM RTC */
    RTC.getTime(currenttime);

    /* PRINT CURRENT TIME on Serial */
    Serial.print(&quot;Current time: &quot;);
    /* DATE */
    Serial.print(currenttime.getDayOfMonth());
    Serial.print(&quot;/&quot;);
    Serial.print(Month2int(currenttime.getMonth()));
    Serial.print(&quot;/&quot;);
    Serial.print(currenttime.getYear());
    Serial.print(&quot; - &quot;);

    /* ORE:MINUTI:SECONDI */
    Serial.print(currenttime.getHour());
    Serial.print(&quot;:&quot;);
    Serial.print(currenttime.getMinutes());
    Serial.print(&quot;:&quot;);
    Serial.println(currenttime.getSeconds());

    digitalWrite(LED_BUILTIN, HIGH);
  }
  else {
    digitalWrite(LED_BUILTIN, LOW);
  }

  status = !status;
  delay(1000);
}```


#### [Fritzing] Circuit



#### [KiCad] Schematic




#### Video Demonstration




[Fritzing]: https://fritzing.org/
[KiCad]: https://www.kicad.org/
[Arduino]: https://arduino.cc
[Microcontroller]: https://en.wikipedia.org/wiki/Microcontroller


## Section 5.13: SD

### 5.13.1 CardInfo

#### Sketch Code

```C
/*
  SD card test

  This example shows how use the utility libraries on which the'
  SD library is based in order to get info about your SD card.
  Very useful for testing a card when you're not sure whether its working or not.

  The circuit:
    SD card attached to SPI bus as follows:
 ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila
 ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila
 ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila
 ** CS - depends on your SD card shield or module.
        Pin 4 used here for consistency with other Arduino examples


  created  28 Mar 2011
  by Limor Fried
  modified 9 Apr 2012
  by Tom Igoe
*/
// include the SD library:
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;

// set up variables using the SD utility library functions:
Sd2Card card;
SdVolume volume;
SdFile root;

// change this to match your SD shield or module;
// Arduino Ethernet shield: pin 4
// Adafruit SD shields and modules: pin 10
// Sparkfun SD shield: pin 8
// MKRZero SD: SDCARD_SS_PIN
const int chipSelect = 4;

void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  Serial.print(&quot;\nInitializing SD card...&quot;);

  // we'll use the initialization code from the utility libraries
  // since we're just testing if the card is working!
  if (!card.init(SPI_HALF_SPEED, chipSelect)) {
    Serial.println(&quot;initialization failed. Things to check:&quot;);
    Serial.println(&quot;* is a card inserted?&quot;);
    Serial.println(&quot;* is your wiring correct?&quot;);
    Serial.println(&quot;* did you change the chipSelect pin to match your shield or module?&quot;);
    while (1);
  } else {
    Serial.println(&quot;Wiring is correct and a card is present.&quot;);
  }

  // print the type of card
  Serial.println();
  Serial.print(&quot;Card type:         &quot;);
  switch (card.type()) {
    case SD_CARD_TYPE_SD1:
      Serial.println(&quot;SD1&quot;);
      break;
    case SD_CARD_TYPE_SD2:
      Serial.println(&quot;SD2&quot;);
      break;
    case SD_CARD_TYPE_SDHC:
      Serial.println(&quot;SDHC&quot;);
      break;
    default:
      Serial.println(&quot;Unknown&quot;);
  }

  // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32
  if (!volume.init(card)) {
    Serial.println(&quot;Could not find FAT16/FAT32 partition.\nMake sure you've formatted the card&quot;);
    while (1);
  }

  Serial.print(&quot;Clusters:          &quot;);
  Serial.println(volume.clusterCount());
  Serial.print(&quot;Blocks x Cluster:  &quot;);
  Serial.println(volume.blocksPerCluster());

  Serial.print(&quot;Total Blocks:      &quot;);
  Serial.println(volume.blocksPerCluster() * volume.clusterCount());
  Serial.println();

  // print the type and size of the first FAT-type volume
  uint32_t volumesize;
  Serial.print(&quot;Volume type is:    FAT&quot;);
  Serial.println(volume.fatType(), DEC);

  volumesize = volume.blocksPerCluster();    // clusters are collections of blocks
  volumesize *= volume.clusterCount();       // we'll have a lot of clusters
  volumesize /= 2;                           // SD card blocks are always 512 bytes (2 blocks are 1KB)
  Serial.print(&quot;Volume size (Kb):  &quot;);
  Serial.println(volumesize);
  Serial.print(&quot;Volume size (Mb):  &quot;);
  volumesize /= 1024;
  Serial.println(volumesize);
  Serial.print(&quot;Volume size (Gb):  &quot;);
  Serial.println((float)volumesize / 1024.0);

  Serial.println(&quot;\nFiles found on the card (name, date and size in bytes): &quot;);
  root.openRoot(volume);

  // list all files in the card with date and size
  root.ls(LS_R | LS_DATE | LS_SIZE);
}

void loop(void) {
}
</code></pre>
<h4 id="fritzing-circuit_62"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_62"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_62">Video Demonstration</h4>
<h3 id="5132-cardinfo">5.13.2 CardInfo</h3>
<h4 id="sketch-code_63">Sketch Code</h4>
<pre><code class="language-C">/*
  SD card test

  This example shows how use the utility libraries on which the'
  SD library is based in order to get info about your SD card.
  Very useful for testing a card when you're not sure whether its working or not.

  The circuit:
    SD card attached to SPI bus as follows:
 ** MOSI - pin 11 on Arduino Uno/Duemilanove/Diecimila
 ** MISO - pin 12 on Arduino Uno/Duemilanove/Diecimila
 ** CLK - pin 13 on Arduino Uno/Duemilanove/Diecimila
 ** CS - depends on your SD card shield or module.
        Pin 4 used here for consistency with other Arduino examples


  created  28 Mar 2011
  by Limor Fried
  modified 9 Apr 2012
  by Tom Igoe
*/
// include the SD library:
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;

// set up variables using the SD utility library functions:
Sd2Card card;
SdVolume volume;
SdFile root;

// change this to match your SD shield or module;
// Arduino Ethernet shield: pin 4
// Adafruit SD shields and modules: pin 10
// Sparkfun SD shield: pin 8
// MKRZero SD: SDCARD_SS_PIN
const int chipSelect = 4;

void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  Serial.print(&quot;\nInitializing SD card...&quot;);

  // we'll use the initialization code from the utility libraries
  // since we're just testing if the card is working!
  if (!card.init(SPI_HALF_SPEED, chipSelect)) {
    Serial.println(&quot;initialization failed. Things to check:&quot;);
    Serial.println(&quot;* is a card inserted?&quot;);
    Serial.println(&quot;* is your wiring correct?&quot;);
    Serial.println(&quot;* did you change the chipSelect pin to match your shield or module?&quot;);
    while (1);
  } else {
    Serial.println(&quot;Wiring is correct and a card is present.&quot;);
  }

  // print the type of card
  Serial.println();
  Serial.print(&quot;Card type:         &quot;);
  switch (card.type()) {
    case SD_CARD_TYPE_SD1:
      Serial.println(&quot;SD1&quot;);
      break;
    case SD_CARD_TYPE_SD2:
      Serial.println(&quot;SD2&quot;);
      break;
    case SD_CARD_TYPE_SDHC:
      Serial.println(&quot;SDHC&quot;);
      break;
    default:
      Serial.println(&quot;Unknown&quot;);
  }

  // Now we will try to open the 'volume'/'partition' - it should be FAT16 or FAT32
  if (!volume.init(card)) {
    Serial.println(&quot;Could not find FAT16/FAT32 partition.\nMake sure you've formatted the card&quot;);
    while (1);
  }

  Serial.print(&quot;Clusters:          &quot;);
  Serial.println(volume.clusterCount());
  Serial.print(&quot;Blocks x Cluster:  &quot;);
  Serial.println(volume.blocksPerCluster());

  Serial.print(&quot;Total Blocks:      &quot;);
  Serial.println(volume.blocksPerCluster() * volume.clusterCount());
  Serial.println();

  // print the type and size of the first FAT-type volume
  uint32_t volumesize;
  Serial.print(&quot;Volume type is:    FAT&quot;);
  Serial.println(volume.fatType(), DEC);

  volumesize = volume.blocksPerCluster();    // clusters are collections of blocks
  volumesize *= volume.clusterCount();       // we'll have a lot of clusters
  volumesize /= 2;                           // SD card blocks are always 512 bytes (2 blocks are 1KB)
  Serial.print(&quot;Volume size (Kb):  &quot;);
  Serial.println(volumesize);
  Serial.print(&quot;Volume size (Mb):  &quot;);
  volumesize /= 1024;
  Serial.println(volumesize);
  Serial.print(&quot;Volume size (Gb):  &quot;);
  Serial.println((float)volumesize / 1024.0);

  Serial.println(&quot;\nFiles found on the card (name, date and size in bytes): &quot;);
  root.openRoot(volume);

  // list all files in the card with date and size
  root.ls(LS_R | LS_DATE | LS_SIZE);
}

void loop(void) {
}
</code></pre>
<h4 id="fritzing-circuit_63"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_63"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_63">Video Demonstration</h4>
<h3 id="5133-datalogger">5.13.3 Datalogger</h3>
<h4 id="sketch-code_64">Sketch Code</h4>
<pre><code class="language-C">/*
  SD card datalogger

  This example shows how to log data from three analog sensors
  to an SD card using the SD library.

  The circuit:
   analog sensors on analog ins 0, 1, and 2
   SD card attached to SPI bus as follows:
 ** MOSI - pin 11
 ** MISO - pin 12
 ** CLK - pin 13
 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN)

  created  24 Nov 2010
  modified 9 Apr 2012
  by Tom Igoe

  This example code is in the public domain.

*/

#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;

const int chipSelect = 4;

void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  Serial.print(&quot;Initializing SD card...&quot;);

  // see if the card is present and can be initialized:
  if (!SD.begin(chipSelect)) {
    Serial.println(&quot;Card failed, or not present&quot;);
    // don't do anything more:
    while (1);
  }
  Serial.println(&quot;card initialized.&quot;);
}

void loop() {
  // make a string for assembling the data to log:
  String dataString = &quot;&quot;;

  // read three sensors and append to the string:
  for (int analogPin = 0; analogPin &lt; 3; analogPin++) {
    int sensor = analogRead(analogPin);
    dataString += String(sensor);
    if (analogPin &lt; 2) {
      dataString += &quot;,&quot;;
    }
  }

  // open the file. note that only one file can be open at a time,
  // so you have to close this one before opening another.
  File dataFile = SD.open(&quot;datalog.txt&quot;, FILE_WRITE);

  // if the file is available, write to it:
  if (dataFile) {
    dataFile.println(dataString);
    dataFile.close();
    // print to the serial port too:
    Serial.println(dataString);
  }
  // if the file isn't open, pop up an error:
  else {
    Serial.println(&quot;error opening datalog.txt&quot;);
  }
}
</code></pre>
<h4 id="fritzing-circuit_64"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_64"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_64">Video Demonstration</h4>
<h3 id="5134-dumpfile">5.13.4 DumpFile</h3>
<h4 id="sketch-code_65">Sketch Code</h4>
<pre><code class="language-C">/*
  SD card file dump

  This example shows how to read a file from the SD card using the
  SD library and send it over the serial port.

  The circuit:
   SD card attached to SPI bus as follows:
 ** MOSI - pin 11
 ** MISO - pin 12
 ** CLK - pin 13
 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN)

  created  22 December 2010
  by Limor Fried
  modified 9 Apr 2012
  by Tom Igoe

  This example code is in the public domain.

*/

#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;

const int chipSelect = 4;

void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  Serial.print(&quot;Initializing SD card...&quot;);

  // see if the card is present and can be initialized:
  if (!SD.begin(chipSelect)) {
    Serial.println(&quot;Card failed, or not present&quot;);
    // don't do anything more:
    while (1);
  }
  Serial.println(&quot;card initialized.&quot;);

  // open the file. note that only one file can be open at a time,
  // so you have to close this one before opening another.
  File dataFile = SD.open(&quot;datalog.txt&quot;);

  // if the file is available, write to it:
  if (dataFile) {
    while (dataFile.available()) {
      Serial.write(dataFile.read());
    }
    dataFile.close();
  }
  // if the file isn't open, pop up an error:
  else {
    Serial.println(&quot;error opening datalog.txt&quot;);
  }
}

void loop() {
}
</code></pre>
<h4 id="fritzing-circuit_65"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_65"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_65">Video Demonstration</h4>
<h3 id="5135-files">5.13.5 Files</h3>
<h4 id="sketch-code_66">Sketch Code</h4>
<pre><code class="language-C">/*
  SD card basic file example

  This example shows how to create and destroy an SD card file
  The circuit:
   SD card attached to SPI bus as follows:
 ** MOSI - pin 11
 ** MISO - pin 12
 ** CLK - pin 13
 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN)

  created   Nov 2010
  by David A. Mellis
  modified 9 Apr 2012
  by Tom Igoe

  This example code is in the public domain.

*/
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;

File myFile;

void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  Serial.print(&quot;Initializing SD card...&quot;);

  if (!SD.begin(4)) {
    Serial.println(&quot;initialization failed!&quot;);
    while (1);
  }
  Serial.println(&quot;initialization done.&quot;);

  if (SD.exists(&quot;example.txt&quot;)) {
    Serial.println(&quot;example.txt exists.&quot;);
  } else {
    Serial.println(&quot;example.txt doesn't exist.&quot;);
  }

  // open a new file and immediately close it:
  Serial.println(&quot;Creating example.txt...&quot;);
  myFile = SD.open(&quot;example.txt&quot;, FILE_WRITE);
  myFile.close();

  // Check to see if the file exists:
  if (SD.exists(&quot;example.txt&quot;)) {
    Serial.println(&quot;example.txt exists.&quot;);
  } else {
    Serial.println(&quot;example.txt doesn't exist.&quot;);
  }

  // delete the file:
  Serial.println(&quot;Removing example.txt...&quot;);
  SD.remove(&quot;example.txt&quot;);

  if (SD.exists(&quot;example.txt&quot;)) {
    Serial.println(&quot;example.txt exists.&quot;);
  } else {
    Serial.println(&quot;example.txt doesn't exist.&quot;);
  }
}

void loop() {
  // nothing happens after setup finishes.
}
</code></pre>
<h4 id="fritzing-circuit_66"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_66"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_66">Video Demonstration</h4>
<h3 id="5136-nonblockingwrite">5.13.6 NonBlockingWrite</h3>
<h4 id="sketch-code_67">Sketch Code</h4>
<pre><code class="language-C">/*
  Non-blocking Write

  This example demonstrates how to perform non-blocking writes
  to a file on a SD card. The file will contain the current millis()
  value every 10ms. If the SD card is busy, the data will be buffered
  in order to not block the sketch.

  NOTE: myFile.availableForWrite() will automatically sync the
        file contents as needed. You may lose some unsynced data
        still if myFile.sync() or myFile.close() is not called.

  The circuit:
  - Arduino MKR Zero board
  - micro SD card attached

  This example code is in the public domain.
*/

#include &lt;SD.h&gt;

// file name to use for writing
const char filename[] = &quot;demo.txt&quot;;

// File object to represent file
File txtFile;

// string to buffer output
String buffer;

unsigned long lastMillis = 0;

void setup() {
  Serial.begin(9600);
  while (!Serial);

  // reserve 1kB for String used as a buffer
  buffer.reserve(1024);

  // set LED pin to output, used to blink when writing
  pinMode(LED_BUILTIN, OUTPUT);

  // init the SD card
  if (!SD.begin()) {
    Serial.println(&quot;Card failed, or not present&quot;);
    // don't do anything more:
    while (1);
  }

  // If you want to start from an empty file,
  // uncomment the next line:
  // SD.remove(filename);

  // try to open the file for writing
  txtFile = SD.open(filename, FILE_WRITE);
  if (!txtFile) {
    Serial.print(&quot;error opening &quot;);
    Serial.println(filename);
    while (1);
  }

  // add some new lines to start
  txtFile.println();
  txtFile.println(&quot;Hello World!&quot;);
}

void loop() {
  // check if it's been over 10 ms since the last line added
  unsigned long now = millis();
  if ((now - lastMillis) &gt;= 10) {
    // add a new line to the buffer
    buffer += &quot;Hello &quot;;
    buffer += now;
    buffer += &quot;\r\n&quot;;

    lastMillis = now;
  }

  // check if the SD card is available to write data without blocking
  // and if the buffered data is enough for the full chunk size
  unsigned int chunkSize = txtFile.availableForWrite();
  if (chunkSize &amp;&amp; buffer.length() &gt;= chunkSize) {
    // write to file and blink LED
    digitalWrite(LED_BUILTIN, HIGH);
    txtFile.write(buffer.c_str(), chunkSize);
    digitalWrite(LED_BUILTIN, LOW);

    // remove written data from buffer
    buffer.remove(0, chunkSize);
  }
}
</code></pre>
<h4 id="fritzing-circuit_67"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_67"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_67">Video Demonstration</h4>
<h3 id="5137-readwrite">5.13.7 ReadWrite</h3>
<h4 id="sketch-code_68">Sketch Code</h4>
<pre><code class="language-C">/*
  SD card read/write

  This example shows how to read and write data to and from an SD card file
  The circuit:
   SD card attached to SPI bus as follows:
 ** MOSI - pin 11
 ** MISO - pin 12
 ** CLK - pin 13
 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN)

  created   Nov 2010
  by David A. Mellis
  modified 9 Apr 2012
  by Tom Igoe

  This example code is in the public domain.

*/

#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;

File myFile;

void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  Serial.print(&quot;Initializing SD card...&quot;);

  if (!SD.begin(4)) {
    Serial.println(&quot;initialization failed!&quot;);
    while (1);
  }
  Serial.println(&quot;initialization done.&quot;);

  // open the file. note that only one file can be open at a time,
  // so you have to close this one before opening another.
  myFile = SD.open(&quot;test.txt&quot;, FILE_WRITE);

  // if the file opened okay, write to it:
  if (myFile) {
    Serial.print(&quot;Writing to test.txt...&quot;);
    myFile.println(&quot;testing 1, 2, 3.&quot;);
    // close the file:
    myFile.close();
    Serial.println(&quot;done.&quot;);
  } else {
    // if the file didn't open, print an error:
    Serial.println(&quot;error opening test.txt&quot;);
  }

  // re-open the file for reading:
  myFile = SD.open(&quot;test.txt&quot;);
  if (myFile) {
    Serial.println(&quot;test.txt:&quot;);

    // read from the file until there's nothing else in it:
    while (myFile.available()) {
      Serial.write(myFile.read());
    }
    // close the file:
    myFile.close();
  } else {
    // if the file didn't open, print an error:
    Serial.println(&quot;error opening test.txt&quot;);
  }
}

void loop() {
  // nothing happens after setup
}


/*
  SD card read/write

  This example shows how to read and write data to and from an SD card file
  The circuit:
   SD card attached to SPI bus as follows:
 ** MOSI - pin 11
 ** MISO - pin 12
 ** CLK - pin 13
 ** CS - pin 4 (for MKRZero SD: SDCARD_SS_PIN)

  created   Nov 2010
  by David A. Mellis
  modified 9 Apr 2012
  by Tom Igoe

  This example code is in the public domain.

*/

#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;

File myFile;

void setup() {
  // Open serial communications and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }


  Serial.print(&quot;Initializing SD card...&quot;);

  if (!SD.begin(4)) {
    Serial.println(&quot;initialization failed!&quot;);
    while (1);
  }
  Serial.println(&quot;initialization done.&quot;);

  // open the file. note that only one file can be open at a time,
  // so you have to close this one before opening another.
  myFile = SD.open(&quot;test.txt&quot;, FILE_WRITE);

  // if the file opened okay, write to it:
  if (myFile) {
    Serial.print(&quot;Writing to test.txt...&quot;);
    myFile.println(&quot;testing 1, 2, 3.&quot;);
    // close the file:
    myFile.close();
    Serial.println(&quot;done.&quot;);
  } else {
    // if the file didn't open, print an error:
    Serial.println(&quot;error opening test.txt&quot;);
  }

  // re-open the file for reading:
  myFile = SD.open(&quot;test.txt&quot;);
  if (myFile) {
    Serial.println(&quot;test.txt:&quot;);

    // read from the file until there's nothing else in it:
    while (myFile.available()) {
      Serial.write(myFile.read());
    }
    // close the file:
    myFile.close();
  } else {
    // if the file didn't open, print an error:
    Serial.println(&quot;error opening test.txt&quot;);
  }
}

void loop() {
  // nothing happens after setup
}
</code></pre>
<h4 id="fritzing-circuit_68"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_68"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_68">Video Demonstration</h4>
<h2 id="section-514-sdu">Section 5.14: SDU</h2>
<h3 id="5141-usage">5.14.1 Usage</h3>
<h4 id="sketch-code_69">Sketch Code</h4>
<pre><code class="language-C">/*
 Usage
 This example demonstrates how to use the UNO R4 SDU library to update a
 sketch on an Arduino UNO R4 (WiFi, Minima) board using an
 SD card. It prints out the date and time the sketch was compiled at 
 to both Serial and Serial1.

 Circuit:
 * Arduino UNO R4 Minima or WiFi board
 * SD shield or breakout connected with CS pin of 4
 * SD card

 Non-Arduino UNO R4 board are NOT supported.
 Steps to update sketch via SD card:

 1) Upload this sketch or another sketch that includes the SDU library
    via #include &lt;SDU.h&gt;

 2) Update the sketch as desired. For this example the sketch prints out
    the compiled date and time so no updates are needed.

 3) In the IDE select: Sketch -&gt; Export Compiled Binary

 4) Copy the .bin file from the sketch's folder to the SD card and rename
    the file to UPDATE.bin. Eject the SD card from your PC.

 5) Insert the SD card into the board, shield or breakout and press the
    reset button or power cycle the board. The SDU library will then update
    the sketch on the board with the contents of UPDATE.bin

 created 23 March 2017
 by Sandeep Mistry
*/

/*
 Include the SDU library 

 This will add some code to the sketch before setup() is called
 to check if an SD card is present and UPDATE.bin exists on the
 SD card.

 If UPDATE.bin is present, the file is used to update the sketch
 running on the board. After this UPDATE.bin is deleted from the
 SD card.
*/
#include &lt;SDU.h&gt;

String message;

void setup() {
  Serial.begin(115200);

  // Wait for Serial Monitor connection
  while (!Serial.available()) {
    Serial.println(&quot;Send any key.&quot;);
    delay(1000);
  }

  message += &quot;Sketch compile date and time: &quot;;
  message += __DATE__;
  message += &quot; &quot;;
  message += __TIME__;

  // print out the sketch compile date and time on the serial port
  Serial.println(message);
}

void loop() {
  // add you own code here
}

</code></pre>
<h4 id="fritzing-circuit_69"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_69"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_69">Video Demonstration</h4>
<h2 id="section-515-servo">Section 5.15: Servo</h2>
<h3 id="5151-knob">5.15.1 Knob</h3>
<h4 id="sketch-code_70">Sketch Code</h4>
<pre><code class="language-C">/*
 Controlling a servo position using a potentiometer (variable resistor)
 by Michal Rinott &lt;http://people.interaction-ivrea.it/m.rinott&gt;

 modified on 8 Nov 2013
 by Scott Fitzgerald
 http://www.arduino.cc/en/Tutorial/Knob
*/

#include &lt;Servo.h&gt;

Servo myservo;  // create servo object to control a servo

int potpin = A0;  // analog pin used to connect the potentiometer
int val;    // variable to read the value from the analog pin

void setup() {
  myservo.attach(9);  // attaches the servo on pin 9 to the servo object
}

void loop() {
  val = analogRead(potpin);            // reads the value of the potentiometer (value between 0 and 1023)
  val = map(val, 0, 1023, 0, 180);     // scale it for use with the servo (value between 0 and 180)
  myservo.write(val);                  // sets the servo position according to the scaled value
  delay(15);                           // waits for the servo to get there
}
</code></pre>
<h4 id="fritzing-circuit_70"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_70"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_70">Video Demonstration</h4>
<h3 id="5152-sweep">5.15.2 Sweep</h3>
<h4 id="sketch-code_71">Sketch Code</h4>
<pre><code class="language-C">/* Sweep
 by BARRAGAN &lt;http://barraganstudio.com&gt;
 This example code is in the public domain.

 modified 8 Nov 2013
 by Scott Fitzgerald
 https://www.arduino.cc/en/Tutorial/LibraryExamples/Sweep
*/

#include &lt;Servo.h&gt;

Servo myservo;  // create servo object to control a servo
// twelve servo objects can be created on most boards

int pos = 0;    // variable to store the servo position

void setup() {
  myservo.attach(9);  // attaches the servo on pin 9 to the servo object
}

void loop() {
  for (pos = 0; pos &lt;= 180; pos += 1) { // goes from 0 degrees to 180 degrees
    // in steps of 1 degree
    myservo.write(pos);              // tell servo to go to position in variable 'pos'
    delay(15);                       // waits 15 ms for the servo to reach the position
  }
  for (pos = 180; pos &gt;= 0; pos -= 1) { // goes from 180 degrees to 0 degrees
    myservo.write(pos);              // tell servo to go to position in variable 'pos'
    delay(15);                       // waits 15 ms for the servo to reach the position
  }
}
</code></pre>
<h4 id="fritzing-circuit_71"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_71"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_71">Video Demonstration</h4>
<h2 id="section-516-softwareserial">Section 5.16: SoftwareSerial</h2>
<h3 id="5161-serialecho">5.16.1 SerialEcho</h3>
<h4 id="sketch-code_72">Sketch Code</h4>
<pre><code class="language-C">#include &lt;SoftwareSerial.h&gt;

// Note any pin can be used for TX, but only the following pins
// can be used for RX:
// D0, D1, D2, D3, D8, D14, D15, A1, A2, A3, A4, A5

SoftwareSerial SoftSerial(2, 7); // Rx, Tx

void setup() {
    Serial.begin(9600);

    while (!Serial) {

    }

    if (!SoftSerial.begin(115200, SERIAL_8E2)) {
        Serial.println(&quot;Failed to init soft serial&quot;);
        while (1);
    }

    Serial.println(SoftSerial);
}

void loop() { // run over and over
    while (SoftSerial.available()) {
        SoftSerial.write(SoftSerial.read());
    }
}
</code></pre>
<h4 id="fritzing-circuit_72"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_72"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_72">Video Demonstration</h4>
<h2 id="section-517-stepper">Section 5.17: Stepper</h2>
<h3 id="5171-motorknob">5.17.1 MotorKnob</h3>
<h4 id="sketch-code_73">Sketch Code</h4>
<pre><code class="language-C">/*
 * MotorKnob
 *
 * A stepper motor follows the turns of a potentiometer
 * (or other sensor) on analog input 0.
 *
 * http://www.arduino.cc/en/Reference/Stepper
 * This example code is in the public domain.
 */

#include &lt;Stepper.h&gt;

// change this to the number of steps on your motor
#define STEPS 100

// create an instance of the stepper class, specifying
// the number of steps of the motor and the pins it's
// attached to
Stepper stepper(STEPS, 8, 9, 10, 11);

// the previous reading from the analog input
int previous = 0;

void setup() {
  // set the speed of the motor to 30 RPMs
  stepper.setSpeed(30);
}

void loop() {
  // get the sensor value
  int val = analogRead(0);

  // move a number of steps equal to the change in the
  // sensor reading
  stepper.step(val - previous);

  // remember the previous value of the sensor
  previous = val;
}```


#### [Fritzing] Circuit



#### [KiCad] Schematic




#### Video Demonstration




[Fritzing]: https://fritzing.org/
[KiCad]: https://www.kicad.org/
[Arduino]: https://arduino.cc
[Microcontroller]: https://en.wikipedia.org/wiki/Microcontroller

### 5.17.2 stepper_oneRevolution

#### Sketch Code

```C

/*
 Stepper Motor Control - one revolution

 This program drives a unipolar or bipolar stepper motor.
 The motor is attached to digital pins 8 - 11 of the Arduino.

 The motor should revolve one revolution in one direction, then
 one revolution in the other direction.


 Created 11 Mar. 2007
 Modified 30 Nov. 2009
 by Tom Igoe

 */

#include &lt;Stepper.h&gt;

const int stepsPerRevolution = 200;  // change this to fit the number of steps per revolution
// for your motor

// initialize the stepper library on pins 8 through 11:
Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11);

void setup() {
  // set the speed at 60 rpm:
  myStepper.setSpeed(60);
  // initialize the serial port:
  Serial.begin(9600);
}

void loop() {
  // step one revolution  in one direction:
  Serial.println(&quot;clockwise&quot;);
  myStepper.step(stepsPerRevolution);
  delay(500);

  // step one revolution in the other direction:
  Serial.println(&quot;counterclockwise&quot;);
  myStepper.step(-stepsPerRevolution);
  delay(500);
}

</code></pre>
<h4 id="fritzing-circuit_73"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_73"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_73">Video Demonstration</h4>
<h3 id="5173-stepper_onestepatatime">5.17.3 stepper_oneStepAtATime</h3>
<h4 id="sketch-code_74">Sketch Code</h4>
<pre><code class="language-C">
/*
 Stepper Motor Control - one step at a time

 This program drives a unipolar or bipolar stepper motor.
 The motor is attached to digital pins 8 - 11 of the Arduino.

 The motor will step one step at a time, very slowly.  You can use this to
 test that you've got the four wires of your stepper wired to the correct
 pins. If wired correctly, all steps should be in the same direction.

 Use this also to count the number of steps per revolution of your motor,
 if you don't know it.  Then plug that number into the oneRevolution
 example to see if you got it right.

 Created 30 Nov. 2009
 by Tom Igoe

 */

#include &lt;Stepper.h&gt;

const int stepsPerRevolution = 200;  // change this to fit the number of steps per revolution
// for your motor

// initialize the stepper library on pins 8 through 11:
Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11);

int stepCount = 0;         // number of steps the motor has taken

void setup() {
  // initialize the serial port:
  Serial.begin(9600);
}

void loop() {
  // step one step:
  myStepper.step(1);
  Serial.print(&quot;steps:&quot;);
  Serial.println(stepCount);
  stepCount++;
  delay(500);
}
</code></pre>
<h4 id="fritzing-circuit_74"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_74"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_74">Video Demonstration</h4>
<h3 id="5174-stepper_speedcontrol">5.17.4 stepper_speedControl</h3>
<h4 id="sketch-code_75">Sketch Code</h4>
<pre><code class="language-C">
/*
 Stepper Motor Control - speed control

 This program drives a unipolar or bipolar stepper motor.
 The motor is attached to digital pins 8 - 11 of the Arduino.
 A potentiometer is connected to analog input 0.

 The motor will rotate in a clockwise direction. The higher the potentiometer value,
 the faster the motor speed. Because setSpeed() sets the delay between steps,
 you may notice the motor is less responsive to changes in the sensor value at
 low speeds.

 Created 30 Nov. 2009
 Modified 28 Oct 2010
 by Tom Igoe

 */

#include &lt;Stepper.h&gt;

const int stepsPerRevolution = 200;  // change this to fit the number of steps per revolution
// for your motor


// initialize the stepper library on pins 8 through 11:
Stepper myStepper(stepsPerRevolution, 8, 9, 10, 11);

int stepCount = 0;  // number of steps the motor has taken

void setup() {
  // nothing to do inside the setup
}

void loop() {
  // read the sensor value:
  int sensorReading = analogRead(A0);
  // map it to a range from 0 to 100:
  int motorSpeed = map(sensorReading, 0, 1023, 0, 100);
  // set the motor speed:
  if (motorSpeed &gt; 0) {
    myStepper.setSpeed(motorSpeed);
    // step 1/100 of a revolution:
    myStepper.step(stepsPerRevolution / 100);
  }
}
</code></pre>
<h4 id="fritzing-circuit_75"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_75"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_75">Video Demonstration</h4>
<h2 id="section-518-tft">Section 5.18: TFT</h2>
<h3 id="5181-tftbitmaplogo">5.18.1 TFTBitmapLogo</h3>
<h4 id="sketch-code_76">Sketch Code</h4>
<pre><code class="language-C">/*

 Arduino TFT Bitmap Logo example

 This example reads an image file from a micro-SD card
 and draws it on the screen, at random locations.

 In this sketch, the Arduino logo is read from a micro-SD card.
 There is a .bmp file included with this sketch.
 - open the sketch folder (Ctrl-K or Cmd-K)
 - copy the &quot;arduino.bmp&quot; file to a micro-SD
 - put the SD into the SD slot of the Arduino TFT module.

 This example code is in the public domain.

 Created 19 April 2013 by Enrico Gueli

 http://www.arduino.cc/en/Tutorial/TFTBitmapLogo

 */

// include the necessary libraries
#include &lt;SPI.h&gt;
#include &lt;SD.h&gt;
#include &lt;TFT.h&gt;  // Arduino LCD library

// pin definition for the Uno
#define sd_cs  4
#define lcd_cs 10
#define dc     9
#define rst    8

// pin definition for the Leonardo
//#define sd_cs  8
//#define lcd_cs 7
//#define dc     0
//#define rst    1

TFT TFTscreen = TFT(lcd_cs, dc, rst);

// this variable represents the image to be drawn on screen
PImage logo;


void setup() {
  // initialize the GLCD and show a message
  // asking the user to open the serial line
  TFTscreen.begin();
  TFTscreen.background(255, 255, 255);

  TFTscreen.stroke(0, 0, 255);
  TFTscreen.println();
  TFTscreen.println(F(&quot;Arduino TFT Bitmap Example&quot;));
  TFTscreen.stroke(0, 0, 0);
  TFTscreen.println(F(&quot;Open serial monitor&quot;));
  TFTscreen.println(F(&quot;to run the sketch&quot;));

  // initialize the serial port: it will be used to
  // print some diagnostic info
  Serial.begin(9600);
  while (!Serial) {
    // wait for serial port to connect. Needed for native USB port only
  }

  // clear the GLCD screen before starting
  TFTscreen.background(255, 255, 255);

  // try to access the SD card. If that fails (e.g.
  // no card present), the setup process will stop.
  Serial.print(F(&quot;Initializing SD card...&quot;));
  if (!SD.begin(sd_cs)) {
    Serial.println(F(&quot;failed!&quot;));
    return;
  }
  Serial.println(F(&quot;OK!&quot;));

  // initialize and clear the GLCD screen
  TFTscreen.begin();
  TFTscreen.background(255, 255, 255);

  // now that the SD card can be access, try to load the
  // image file.
  logo = TFTscreen.loadImage(&quot;arduino.bmp&quot;);
  if (!logo.isValid()) {
    Serial.println(F(&quot;error while loading arduino.bmp&quot;));
  }
}

void loop() {
  // don't do anything if the image wasn't loaded correctly.
  if (logo.isValid() == false) {
    return;
  }

  Serial.println(F(&quot;drawing image&quot;));

  // get a random location where to draw the image.
  // To avoid the image to be draw outside the screen,
  // take into account the image size.
  int x = random(TFTscreen.width() - logo.width());
  int y = random(TFTscreen.height() - logo.height());

  // draw the image to the screen
  TFTscreen.image(logo, x, y);

  // wait a little bit before drawing again
  delay(1500);
}
</code></pre>
<h4 id="fritzing-circuit_76"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_76"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_76">Video Demonstration</h4>
<h3 id="5182-tftcolorpicker">5.18.2 TFTColorPicker</h3>
<h4 id="sketch-code_77">Sketch Code</h4>
<pre><code class="language-C">/*

 TFT Color Picker

 This example for the Arduino screen reads the input of
 potentiometers or analog sensors attached to A0, A1,
 and A2 and uses the values to change the screen's color.

 This example code is in the public domain.

 Created 15 April 2013 by Scott Fitzgerald

 http://www.arduino.cc/en/Tutorial/TFTColorPicker

 */

// pin definition for the Uno
#define cs   10
#define dc   9
#define rst  8

// pin definition for the Leonardo
// #define cs   7
// #define dc   0
// #define rst  1

#include &lt;TFT.h&gt;  // Arduino LCD library
#include &lt;SPI.h&gt;

TFT TFTscreen = TFT(cs, dc, rst);

void setup() {
  // begin serial communication
  Serial.begin(9600);

  // initialize the display
  TFTscreen.begin();

  // set the background to white
  TFTscreen.background(255, 255, 255);

}

void loop() {

  // read the values from your sensors and scale them to 0-255
  int redVal = map(analogRead(A0), 0, 1023, 0, 255);
  int greenVal = map(analogRead(A1), 0, 1023, 0, 255);
  int blueVal = map(analogRead(A2), 0, 1023, 0, 255);

  // draw the background based on the mapped values
  TFTscreen.background(redVal, greenVal, blueVal);

  // send the values to the serial monitor
  Serial.print(&quot;background(&quot;);
  Serial.print(redVal);
  Serial.print(&quot; , &quot;);
  Serial.print(greenVal);
  Serial.print(&quot; , &quot;);
  Serial.print(blueVal);
  Serial.println(&quot;)&quot;);

  // wait for a moment
  delay(33);

}
</code></pre>
<h4 id="fritzing-circuit_77"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_77"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_77">Video Demonstration</h4>
<h3 id="5183-tftdisplaytext">5.18.3 TFTDisplayText</h3>
<h4 id="sketch-code_78">Sketch Code</h4>
<pre><code class="language-C">/*
  Arduino TFT text example

  This example demonstrates how to draw text on the
  TFT with an Arduino. The Arduino reads the value
  of an analog sensor attached to pin A0, and writes
  the value to the LCD screen, updating every
  quarter second.

  This example code is in the public domain

  Created 15 April 2013 by Scott Fitzgerald

  http://www.arduino.cc/en/Tutorial/TFTDisplayText

 */

#include &lt;TFT.h&gt;  // Arduino LCD library
#include &lt;SPI.h&gt;

// pin definition for the Uno
#define cs   10
#define dc   9
#define rst  8

// pin definition for the Leonardo
// #define cs   7
// #define dc   0
// #define rst  1

// create an instance of the library
TFT TFTscreen = TFT(cs, dc, rst);

// char array to print to the screen
char sensorPrintout[4];

void setup() {

  // Put this line at the beginning of every sketch that uses the GLCD:
  TFTscreen.begin();

  // clear the screen with a black background
  TFTscreen.background(0, 0, 0);

  // write the static text to the screen
  // set the font color to white
  TFTscreen.stroke(255, 255, 255);
  // set the font size
  TFTscreen.setTextSize(2);
  // write the text to the top left corner of the screen
  TFTscreen.text(&quot;Sensor Value :\n &quot;, 0, 0);
  // ste the font size very large for the loop
  TFTscreen.setTextSize(5);
}

void loop() {

  // Read the value of the sensor on A0
  String sensorVal = String(analogRead(A0));

  // convert the reading to a char array
  sensorVal.toCharArray(sensorPrintout, 4);

  // set the font color
  TFTscreen.stroke(255, 255, 255);
  // print the sensor value
  TFTscreen.text(sensorPrintout, 0, 20);
  // wait for a moment
  delay(250);
  // erase the text you just wrote
  TFTscreen.stroke(0, 0, 0);
  TFTscreen.text(sensorPrintout, 0, 20);
}
</code></pre>
<h4 id="fritzing-circuit_78"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_78"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_78">Video Demonstration</h4>
<h3 id="5184-tftetchasketch">5.18.4 TFTEtchAsketch</h3>
<h4 id="sketch-code_79">Sketch Code</h4>
<pre><code class="language-C">/*

 TFT EtchASketch

 This example for the Arduino screen draws a white point
 on the GLCD based on the values of 2 potentiometers.
 To clear the screen, press a button attached to pin 2.

 This example code is in the public domain.

 Created 15 April 2013 by Scott Fitzgerald

 http://www.arduino.cc/en/Tutorial/TFTEtchASketch

 */

#include &lt;TFT.h&gt;  // Arduino LCD library
#include &lt;SPI.h&gt;

// pin definition for the Uno
#define cs   10
#define dc   9
#define rst  8

// pin definition for the Leonardo
// #define cs   7
// #define dc   0
// #define rst  1

TFT TFTscreen = TFT(cs, dc, rst);

// initial position of the cursor
int xPos = TFTscreen.width() / 2;
int yPos = TFTscreen.height() / 2;

// pin the erase switch is connected to
int erasePin = 2;

void setup() {
  // declare inputs
  pinMode(erasePin, INPUT);
  // initialize the screen
  TFTscreen.begin();
  // make the background black
  TFTscreen.background(0, 0, 0);
}

void loop() {
  // read the potentiometers on A0 and A1
  int xValue = analogRead(A0);
  int yValue = analogRead(A1);

  // map the values and update the position
  xPos = xPos + (map(xValue, 0, 1023, 2, -2));
  yPos = yPos + (map(yValue, 0, 1023, -2, 2));

  // don't let the point go past the screen edges
  if (xPos &gt; 159) {
    (xPos = 159);
  }

  if (xPos &lt; 0) {
    (xPos = 0);
  }
  if (yPos &gt; 127) {
    (yPos = 127);
  }

  if (yPos &lt; 0) {
    (yPos = 0);
  }

  // draw the point
  TFTscreen.stroke(255, 255, 255);
  TFTscreen.point(xPos, yPos);

  // read the value of the pin, and erase the screen if pressed
  if (digitalRead(erasePin) == HIGH) {
    TFTscreen.background(0, 0, 0);
  }

  delay(33);
}
</code></pre>
<h4 id="fritzing-circuit_79"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_79"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_79">Video Demonstration</h4>
<h3 id="5185-tftgraph">5.18.5 TFTGraph</h3>
<h4 id="sketch-code_80">Sketch Code</h4>
<pre><code class="language-C">/*

 TFT Graph

 This example for an Arduino screen reads
 the value of an analog sensor on A0, and
 graphs the values on the screen.

 This example code is in the public domain.

 Created 15 April 2013 by Scott Fitzgerald

 http://www.arduino.cc/en/Tutorial/TFTGraph

 */

#include &lt;TFT.h&gt;  // Arduino LCD library
#include &lt;SPI.h&gt;

// pin definition for the Uno
#define cs   10
#define dc   9
#define rst  8

// pin definition for the Leonardo
// #define cs   7
// #define dc   0
// #define rst  1

TFT TFTscreen = TFT(cs, dc, rst);

// position of the line on screen
int xPos = 0;

void setup() {
  // initialize the serial port
  Serial.begin(9600);

  // initialize the display
  TFTscreen.begin();

  // clear the screen with a pretty color
  TFTscreen.background(250, 16, 200);
}

void loop() {
  // read the sensor and map it to the screen height
  int sensor = analogRead(A0);
  int drawHeight = map(sensor, 0, 1023, 0, TFTscreen.height());

  // print out the height to the serial monitor
  Serial.println(drawHeight);

  // draw a line in a nice color
  TFTscreen.stroke(250, 180, 10);
  TFTscreen.line(xPos, TFTscreen.height() - drawHeight, xPos, TFTscreen.height());

  // if the graph has reached the screen edge
  // erase the screen and start again
  if (xPos &gt;= 160) {
    xPos = 0;
    TFTscreen.background(250, 16, 200);
  } else {
    // increment the horizontal position:
    xPos++;
  }

  delay(16);
}
</code></pre>
<h4 id="fritzing-circuit_80"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_80"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_80">Video Demonstration</h4>
<h3 id="5186-tftpong">5.18.6 TFTPong</h3>
<h4 id="sketch-code_81">Sketch Code</h4>
<pre><code class="language-C">/*

 TFT Pong

 This example for the Arduino screen reads the values
 of 2 potentiometers to move a rectangular platform
 on the x and y axes. The platform can intersect
 with a ball causing it to bounce.

 This example code is in the public domain.

 Created by Tom Igoe December 2012
 Modified 15 April 2013 by Scott Fitzgerald

 http://www.arduino.cc/en/Tutorial/TFTPong

 */

#include &lt;TFT.h&gt;  // Arduino LCD library
#include &lt;SPI.h&gt;

// pin definition for the Uno
#define cs   10
#define dc   9
#define rst  8

// pin definition for the Leonardo
// #define cs   7
// #define dc   0
// #define rst  1

TFT TFTscreen = TFT(cs, dc, rst);

// variables for the position of the ball and paddle
int paddleX = 0;
int paddleY = 0;
int oldPaddleX, oldPaddleY;
int ballDirectionX = 1;
int ballDirectionY = 1;

int ballSpeed = 10; // lower numbers are faster

int ballX, ballY, oldBallX, oldBallY;

void setup() {
  // initialize the display
  TFTscreen.begin();
  // black background
  TFTscreen.background(0, 0, 0);
}

void loop() {

  // save the width and height of the screen
  int myWidth = TFTscreen.width();
  int myHeight = TFTscreen.height();

  // map the paddle's location to the position of the potentiometers
  paddleX = map(analogRead(A0), 512, -512, 0, myWidth) - 20 / 2;
  paddleY = map(analogRead(A1), 512, -512, 0, myHeight) - 5 / 2;

  // set the fill color to black and erase the previous
  // position of the paddle if different from present
  TFTscreen.fill(0, 0, 0);

  if (oldPaddleX != paddleX || oldPaddleY != paddleY) {
    TFTscreen.rect(oldPaddleX, oldPaddleY, 20, 5);
  }

  // draw the paddle on screen, save the current position
  // as the previous.
  TFTscreen.fill(255, 255, 255);

  TFTscreen.rect(paddleX, paddleY, 20, 5);
  oldPaddleX = paddleX;
  oldPaddleY = paddleY;

  // update the ball's position and draw it on screen
  if (millis() % ballSpeed &lt; 2) {
    moveBall();
  }
}

// this function determines the ball's position on screen
void moveBall() {
  // if the ball goes offscreen, reverse the direction:
  if (ballX &gt; TFTscreen.width() || ballX &lt; 0) {
    ballDirectionX = -ballDirectionX;
  }

  if (ballY &gt; TFTscreen.height() || ballY &lt; 0) {
    ballDirectionY = -ballDirectionY;
  }

  // check if the ball and the paddle occupy the same space on screen
  if (inPaddle(ballX, ballY, paddleX, paddleY, 20, 5)) {
    ballDirectionX = -ballDirectionX;
    ballDirectionY = -ballDirectionY;
  }

  // update the ball's position
  ballX += ballDirectionX;
  ballY += ballDirectionY;

  // erase the ball's previous position
  TFTscreen.fill(0, 0, 0);

  if (oldBallX != ballX || oldBallY != ballY) {
    TFTscreen.rect(oldBallX, oldBallY, 5, 5);
  }


  // draw the ball's current position
  TFTscreen.fill(255, 255, 255);
  TFTscreen.rect(ballX, ballY, 5, 5);

  oldBallX = ballX;
  oldBallY = ballY;

}

// this function checks the position of the ball
// to see if it intersects with the paddle
boolean inPaddle(int x, int y, int rectX, int rectY, int rectWidth, int rectHeight) {
  boolean result = false;

  if ((x &gt;= rectX &amp;&amp; x &lt;= (rectX + rectWidth)) &amp;&amp;
      (y &gt;= rectY &amp;&amp; y &lt;= (rectY + rectHeight))) {
    result = true;
  }

  return result;
}
</code></pre>
<h4 id="fritzing-circuit_81"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_81"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_81">Video Demonstration</h4>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p><a href="https://docs.arduino.cc/retired/boards/arduino-esplora">Esplora</a> is <strong>ALREADY retired</strong>.</p>
</div>
<h2 id="section-519-wdt">Section 5.19: WDT</h2>
<h3 id="5191-watchdogrefresh">5.19.1 WatchdogRefresh</h3>
<h4 id="sketch-code_82">Sketch Code</h4>
<pre><code class="language-C">/*
  Watchdog Refresh

  This sketch shows how to enable the watchdog and
  refresh the timer to avoid resets

  Watchdog intervals are limited to 7 timeout periods
  the library will select the best clock divisor and timeout
  according to the selected wdtInterval.

  UNO R4 min wdtInterval 1ms / max wdtInterval 5592ms
  Comment out Serial.print() in the setup to make it work with
  small intervals

  Portenta C33 min wdtInterval 1ms / max wdtInterval 2684ms

  Circuit:
   - Portenta C33
   - UNO R4
*/

#include &lt;WDT.h&gt;

const long ledInterval = 1000;
unsigned long ledMillis = 0;
bool ledState = true;
const long wdtInterval = 2684;
unsigned long wdtMillis = 0;

void setup() {
  Serial.begin(9600);
  while (!Serial);

  pinMode(LED_BUILTIN, OUTPUT);

  if(wdtInterval &lt; 1) {
    Serial.println(&quot;Invalid watchdog interval&quot;);
    while(1){}
  }

  if(WDT.begin(wdtInterval)) {
    Serial.print(&quot;WDT interval: &quot;);
    WDT.refresh();
    Serial.print(WDT.getTimeout());
    WDT.refresh();
    Serial.println(&quot; ms&quot;);
    WDT.refresh();
  } else {
    Serial.println(&quot;Error initializing watchdog&quot;);
    while(1){}
  }
}

void loop() {
  if(millis() - ledMillis &gt;= ledInterval) {
    digitalWrite(LED_BUILTIN, ledState);
    ledState = !ledState;
    ledMillis = millis();
  }

  if(millis() - wdtMillis &gt;= wdtInterval - 1) {
    WDT.refresh(); // Comment this line to stop refreshing the watchdog
    wdtMillis = millis();
  }

}
</code></pre>
<h4 id="fritzing-circuit_82"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_82"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_82">Video Demonstration</h4>
<h2 id="section-520-wifis3">Section 5.20: WiFiS3</h2>
<h3 id="5201-ap_simplewebserver">5.20.1 AP_SimpleWebServer</h3>
<h4 id="sketch-code_83">Sketch Code</h4>
<pre><code class="language-C">/*
  WiFi Web Server LED Blink

  A simple web server that lets you blink an LED via the web.
  This sketch will create a new access point (with no password).
  It will then launch a new server and print out the IP address
  to the Serial Monitor. From there, you can open that address in a web browser
  to turn on and off the LED on pin 13.

  If the IP address of your board is yourAddress:
    http://yourAddress/H turns the LED on
    http://yourAddress/L turns it off

  created 25 Nov 2012
  by Tom Igoe
  adapted to WiFi AP by Adafruit

  Find the full UNO R4 WiFi Network documentation here:
  https://docs.arduino.cc/tutorials/uno-r4-wifi/wifi-examples#access-point
 */

#include &quot;WiFiS3.h&quot;

#include &quot;arduino_secrets.h&quot; 

///////please enter your sensitive data in the Secret tab/arduino_secrets.h
char ssid[] = SECRET_SSID;        // your network SSID (name)
char pass[] = SECRET_PASS;        // your network password (use for WPA, or use as key for WEP)
int keyIndex = 0;                 // your network key index number (needed only for WEP)

int led =  LED_BUILTIN;
int status = WL_IDLE_STATUS;
WiFiServer server(80);

void setup() {
  //Initialize serial and wait for port to open:
  Serial.begin(9600);
  while (!Serial) {
    ; // wait for serial port to connect. Needed for native USB port only
  }
  Serial.println(&quot;Access Point Web Server&quot;);

  pinMode(led, OUTPUT);      // set the LED pin mode

  // check for the WiFi module:
  if (WiFi.status() == WL_NO_MODULE) {
    Serial.println(&quot;Communication with WiFi module failed!&quot;);
    // don't continue
    while (true);
  }

  String fv = WiFi.firmwareVersion();
  if (fv &lt; WIFI_FIRMWARE_LATEST_VERSION) {
    Serial.println(&quot;Please upgrade the firmware&quot;);
  }

  // by default the local IP address will be 192.168.4.1
  // you can override it with the following:
  WiFi.config(IPAddress(192,48,56,2));

  // print the network name (SSID);
  Serial.print(&quot;Creating access point named: &quot;);
  Serial.println(ssid);

  // Create open network. Change this line if you want to create an WEP network:
  status = WiFi.beginAP(ssid, pass);
  if (status != WL_AP_LISTENING) {
    Serial.println(&quot;Creating access point failed&quot;);
    // don't continue
    while (true);
  }

  // wait 10 seconds for connection:
  delay(10000);

  // start the web server on port 80
  server.begin();

  // you're connected now, so print out the status
  printWiFiStatus();
}


void loop() {

  // compare the previous status to the current status
  if (status != WiFi.status()) {
    // it has changed update the variable
    status = WiFi.status();

    if (status == WL_AP_CONNECTED) {
      // a device has connected to the AP
      Serial.println(&quot;Device connected to AP&quot;);
    } else {
      // a device has disconnected from the AP, and we are back in listening mode
      Serial.println(&quot;Device disconnected from AP&quot;);
    }
  }

  WiFiClient client = server.available();   // listen for incoming clients

  if (client) {                             // if you get a client,
    Serial.println(&quot;new client&quot;);           // print a message out the serial port
    String currentLine = &quot;&quot;;                // make a String to hold incoming data from the client
    while (client.connected()) {            // loop while the client's connected
      delayMicroseconds(10);                // This is required for the Arduino Nano RP2040 Connect - otherwise it will loop so fast that SPI will never be served.
      if (client.available()) {             // if there's bytes to read from the client,
        char c = client.read();             // read a byte, then
        Serial.write(c);                    // print it out to the serial monitor
        if (c == '\n') {                    // if the byte is a newline character

          // if the current line is blank, you got two newline characters in a row.
          // that's the end of the client HTTP request, so send a response:
          if (currentLine.length() == 0) {
            // HTTP headers always start with a response code (e.g. HTTP/1.1 200 OK)
            // and a content-type so the client knows what's coming, then a blank line:
            client.println(&quot;HTTP/1.1 200 OK&quot;);
            client.println(&quot;Content-type:text/html&quot;);
            client.println();

            // the content of the HTTP response follows the header:
            client.print(&quot;&lt;p style=\&quot;font-size:7vw;\&quot;&gt;Click &lt;a href=\&quot;/H\&quot;&gt;here&lt;/a&gt; turn the LED on&lt;br&gt;&lt;/p&gt;&quot;);
            client.print(&quot;&lt;p style=\&quot;font-size:7vw;\&quot;&gt;Click &lt;a href=\&quot;/L\&quot;&gt;here&lt;/a&gt; turn the LED off&lt;br&gt;&lt;/p&gt;&quot;);

            // The HTTP response ends with another blank line:
            client.println();
            // break out of the while loop:
            break;
          }
          else {      // if you got a newline, then clear currentLine:
            currentLine = &quot;&quot;;
          }
        }
        else if (c != '\r') {    // if you got anything else but a carriage return character,
          currentLine += c;      // add it to the end of the currentLine
        }

        // Check to see if the client request was &quot;GET /H&quot; or &quot;GET /L&quot;:
        if (currentLine.endsWith(&quot;GET /H&quot;)) {
          digitalWrite(led, HIGH);               // GET /H turns the LED on
        }
        if (currentLine.endsWith(&quot;GET /L&quot;)) {
          digitalWrite(led, LOW);                // GET /L turns the LED off
        }
      }
    }
    // close the connection:
    client.stop();
    Serial.println(&quot;client disconnected&quot;);
  }
}

void printWiFiStatus() {
  // print the SSID of the network you're attached to:
  Serial.print(&quot;SSID: &quot;);
  Serial.println(WiFi.SSID());

  // print your WiFi shield's IP address:
  IPAddress ip = WiFi.localIP();
  Serial.print(&quot;IP Address: &quot;);
  Serial.println(ip);

  // print where to go in a browser:
  Serial.print(&quot;To see this page in action, open a browser to http://&quot;);
  Serial.println(ip);

}
</code></pre>
<h4 id="fritzing-circuit_83"><a href="https://fritzing.org/">Fritzing</a> Circuit</h4>
<h4 id="kicad-schematic_83"><a href="https://www.kicad.org/">KiCad</a> Schematic</h4>
<h4 id="video-demonstration_83">Video Demonstration</h4>
              
            </div>
          </div><footer>

  <hr/>

  <div role="contentinfo">
    <!-- Copyright etc -->
  </div>

  Built with <a href="https://www.mkdocs.org/">MkDocs</a> using a <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.
</footer>
          
        </div>
      </div>

    </section>

  </div>

  <div class="rst-versions" role="note" aria-label="Versions">
  <span class="rst-current-version" data-toggle="rst-current-version">
    
    
    
  </span>
</div>
    <script src="../js/jquery-3.6.0.min.js"></script>
    <script>var base_url = "..";</script>
    <script src="../js/theme_extra.js"></script>
    <script src="../js/theme.js"></script>
      <script src="../search/main.js"></script>
    <script>
        jQuery(function () {
            SphinxRtdTheme.Navigation.enable(true);
        });
    </script>

</body>
</html>
